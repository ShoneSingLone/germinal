var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
const p = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p();
const scriptRel$1 = "modulepreload";
const seen$1 = {};
const base$1 = "./";
const __vitePreload = function preload(baseModule, deps) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  return Promise.all(deps.map((dep) => {
    dep = `${base$1}${dep}`;
    if (dep in seen$1)
      return;
    seen$1[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel$1;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
var _default = "";
var index$C = "";
function _defineProperty$T(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key2) {
      _defineProperty$T(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
var LoadingOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "0 0 1024 1024",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z"
      }
    }]
  },
  "name": "loading",
  "theme": "outlined"
};
var LoadingOutlinedSvg = LoadingOutlined$2;
function bound01(n2, max) {
  if (isOnePointZero(n2)) {
    n2 = "100%";
  }
  var isPercent = isPercentage(n2);
  n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
  if (isPercent) {
    n2 = parseInt(String(n2 * max), 10) / 100;
  }
  if (Math.abs(n2 - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
  } else {
    n2 = n2 % max / parseFloat(String(max));
  }
  return n2;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n2) {
  return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") !== -1;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    return "".concat(Number(n2) * 100, "%");
  }
  return n2;
}
function pad2(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}
function rgbToRgb(r2, g2, b2) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function rgbToHsl(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var s2 = 0;
  var l2 = (max + min) / 2;
  if (max === min) {
    s2 = 0;
    h2 = 0;
  } else {
    var d2 = max - min;
    s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s: s2,
    l: l2
  };
}
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  }
  return p2;
}
function hslToRgb(h2, s2, l2) {
  var r2;
  var g2;
  var b2;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  if (s2 === 0) {
    g2 = l2;
    b2 = l2;
    r2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb(p2, q2, h2);
    b2 = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return {
    r: r2 * 255,
    g: g2 * 255,
    b: b2 * 255
  };
}
function rgbToHsv(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var v2 = max;
  var d2 = max - min;
  var s2 = max === 0 ? 0 : d2 / max;
  if (max === min) {
    h2 = 0;
  } else {
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s: s2,
    v: v2
  };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i2 = Math.floor(h2);
  var f2 = h2 - i2;
  var p2 = v2 * (1 - s2);
  var q2 = v2 * (1 - f2 * s2);
  var t2 = v2 * (1 - (1 - f2) * s2);
  var mod = i2 % 6;
  var r2 = [v2, q2, p2, p2, t2, v2][mod];
  var g2 = [t2, v2, v2, q2, p2, p2][mod];
  var b2 = [p2, p2, t2, v2, v2, q2][mod];
  return {
    r: r2 * 255,
    g: g2 * 255,
    b: b2 * 255
  };
}
function rgbToHex(r2, g2, b2, allow3Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16))];
  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r2, g2, b2, a2, allow4Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16)), pad2(convertDecimalToHex(a2))];
  if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a2 = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok = false;
  var format2 = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s2 = convertToPercentage(color.s);
      v2 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s2, v2);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s2 = convertToPercentage(color.s);
      l2 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s2, l2);
      ok = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a2 = color.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok,
    format: color.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a2
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match2 = matchers.rgb.exec(color);
  if (match2) {
    return {
      r: match2[1],
      g: match2[2],
      b: match2[3]
    };
  }
  match2 = matchers.rgba.exec(color);
  if (match2) {
    return {
      r: match2[1],
      g: match2[2],
      b: match2[3],
      a: match2[4]
    };
  }
  match2 = matchers.hsl.exec(color);
  if (match2) {
    return {
      h: match2[1],
      s: match2[2],
      l: match2[3]
    };
  }
  match2 = matchers.hsla.exec(color);
  if (match2) {
    return {
      h: match2[1],
      s: match2[2],
      l: match2[3],
      a: match2[4]
    };
  }
  match2 = matchers.hsv.exec(color);
  if (match2) {
    return {
      h: match2[1],
      s: match2[2],
      v: match2[3]
    };
  }
  match2 = matchers.hsva.exec(color);
  if (match2) {
    return {
      h: match2[1],
      s: match2[2],
      v: match2[3],
      a: match2[4]
    };
  }
  match2 = matchers.hex8.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      a: convertHexToDecimal(match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex6.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      format: named ? "name" : "hex"
    };
  }
  match2 = matchers.hex4.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      a: convertHexToDecimal(match2[4] + match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex3.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}
var TinyColor = function() {
  function TinyColor2(color, opts2) {
    if (color === void 0) {
      color = "";
    }
    if (opts2 === void 0) {
      opts2 = {};
    }
    var _a;
    if (color instanceof TinyColor2) {
      return color;
    }
    if (typeof color === "number") {
      color = numberInputToObject(color);
    }
    this.originalInput = color;
    var rgb = inputToRGB(color);
    this.originalInput = color;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = (_a = opts2.format) !== null && _a !== void 0 ? _a : rgb.format;
    this.gradientType = opts2.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  TinyColor2.prototype.isDark = function() {
    return this.getBrightness() < 128;
  };
  TinyColor2.prototype.isLight = function() {
    return !this.isDark();
  };
  TinyColor2.prototype.getBrightness = function() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  };
  TinyColor2.prototype.getLuminance = function() {
    var rgb = this.toRgb();
    var R2;
    var G;
    var B2;
    var RsRGB = rgb.r / 255;
    var GsRGB = rgb.g / 255;
    var BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R2 = RsRGB / 12.92;
    } else {
      R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G = GsRGB / 12.92;
    } else {
      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B2 = BsRGB / 12.92;
    } else {
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R2 + 0.7152 * G + 0.0722 * B2;
  };
  TinyColor2.prototype.getAlpha = function() {
    return this.a;
  };
  TinyColor2.prototype.setAlpha = function(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  };
  TinyColor2.prototype.toHsv = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this.a
    };
  };
  TinyColor2.prototype.toHsvString = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    var h2 = Math.round(hsv.h * 360);
    var s2 = Math.round(hsv.s * 100);
    var v2 = Math.round(hsv.v * 100);
    return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHsl = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this.a
    };
  };
  TinyColor2.prototype.toHslString = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    var h2 = Math.round(hsl.h * 360);
    var s2 = Math.round(hsl.s * 100);
    var l2 = Math.round(hsl.l * 100);
    return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHex = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  };
  TinyColor2.prototype.toHexString = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return "#" + this.toHex(allow3Char);
  };
  TinyColor2.prototype.toHex8 = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  };
  TinyColor2.prototype.toHex8String = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return "#" + this.toHex8(allow4Char);
  };
  TinyColor2.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toRgbString = function() {
    var r2 = Math.round(this.r);
    var g2 = Math.round(this.g);
    var b2 = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toPercentageRgb = function() {
    var fmt = function(x2) {
      return "".concat(Math.round(bound01(x2, 255) * 100), "%");
    };
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toPercentageRgbString = function() {
    var rnd = function(x2) {
      return Math.round(bound01(x2, 255) * 100);
    };
    return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toName = function() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
      var _b = _a[_i], key2 = _b[0], value = _b[1];
      if (hex === value) {
        return key2;
      }
    }
    return false;
  };
  TinyColor2.prototype.toString = function(format2) {
    var formatSet = Boolean(format2);
    format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
    var formattedString = false;
    var hasAlpha = this.a < 1 && this.a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  };
  TinyColor2.prototype.toNumber = function() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  };
  TinyColor2.prototype.clone = function() {
    return new TinyColor2(this.toString());
  };
  TinyColor2.prototype.lighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.brighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new TinyColor2(rgb);
  };
  TinyColor2.prototype.darken = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.tint = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("white", amount);
  };
  TinyColor2.prototype.shade = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("black", amount);
  };
  TinyColor2.prototype.desaturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.saturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.greyscale = function() {
    return this.desaturate(100);
  };
  TinyColor2.prototype.spin = function(amount) {
    var hsl = this.toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.mix = function(color, amount) {
    if (amount === void 0) {
      amount = 50;
    }
    var rgb1 = this.toRgb();
    var rgb2 = new TinyColor2(color).toRgb();
    var p2 = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p2 + rgb1.a
    };
    return new TinyColor2(rgba);
  };
  TinyColor2.prototype.analogous = function(results, slices) {
    if (results === void 0) {
      results = 6;
    }
    if (slices === void 0) {
      slices = 30;
    }
    var hsl = this.toHsl();
    var part = 360 / slices;
    var ret = [this];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor2(hsl));
    }
    return ret;
  };
  TinyColor2.prototype.complement = function() {
    var hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.monochromatic = function(results) {
    if (results === void 0) {
      results = 6;
    }
    var hsv = this.toHsv();
    var h2 = hsv.h;
    var s2 = hsv.s;
    var v2 = hsv.v;
    var res = [];
    var modification = 1 / results;
    while (results--) {
      res.push(new TinyColor2({
        h: h2,
        s: s2,
        v: v2
      }));
      v2 = (v2 + modification) % 1;
    }
    return res;
  };
  TinyColor2.prototype.splitcomplement = function() {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    return [this, new TinyColor2({
      h: (h2 + 72) % 360,
      s: hsl.s,
      l: hsl.l
    }), new TinyColor2({
      h: (h2 + 216) % 360,
      s: hsl.s,
      l: hsl.l
    })];
  };
  TinyColor2.prototype.onBackground = function(background) {
    var fg = this.toRgb();
    var bg = new TinyColor2(background).toRgb();
    return new TinyColor2({
      r: bg.r + (fg.r - bg.r) * fg.a,
      g: bg.g + (fg.g - bg.g) * fg.a,
      b: bg.b + (fg.b - bg.b) * fg.a
    });
  };
  TinyColor2.prototype.triad = function() {
    return this.polyad(3);
  };
  TinyColor2.prototype.tetrad = function() {
    return this.polyad(4);
  };
  TinyColor2.prototype.polyad = function(n2) {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    var result = [this];
    var increment = 360 / n2;
    for (var i2 = 1; i2 < n2; i2++) {
      result.push(new TinyColor2({
        h: (h2 + i2 * increment) % 360,
        s: hsl.s,
        l: hsl.l
      }));
    }
    return result;
  };
  TinyColor2.prototype.equals = function(color) {
    return this.toRgbString() === new TinyColor2(color).toRgbString();
  };
  return TinyColor2;
}();
var hueStep = 2;
var saturationStep = 0.16;
var saturationStep2 = 0.05;
var brightnessStep1 = 0.05;
var brightnessStep2 = 0.15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function toHsv(_ref) {
  var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
  var hsv = rgbToHsv(r2, g2, b2);
  return {
    h: hsv.h * 360,
    s: hsv.s,
    v: hsv.v
  };
}
function toHex(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
  return "#".concat(rgbToHex(r2, g2, b2, false));
}
function mix$1(rgb1, rgb2, amount) {
  var p2 = amount / 100;
  var rgb = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b
  };
  return rgb;
}
function getHue(hsv, i2, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation(hsv, i2, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i2;
  } else if (i2 === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i2;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i2 === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue$2(hsv, i2, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1 * i2;
  } else {
    value = hsv.v - brightnessStep2 * i2;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate$1(color) {
  var opts2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = inputToRGB(color);
  for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
    var hsv = toHsv(pColor);
    var colorString = toHex(inputToRGB({
      h: getHue(hsv, i2, true),
      s: getSaturation(hsv, i2, true),
      v: getValue$2(hsv, i2, true)
    }));
    patterns.push(colorString);
  }
  patterns.push(toHex(pColor));
  for (var _i = 1; _i <= darkColorCount; _i += 1) {
    var _hsv = toHsv(pColor);
    var _colorString = toHex(inputToRGB({
      h: getHue(_hsv, _i),
      s: getSaturation(_hsv, _i),
      v: getValue$2(_hsv, _i)
    }));
    patterns.push(_colorString);
  }
  if (opts2.theme === "dark") {
    return darkColorMap.map(function(_ref3) {
      var index2 = _ref3.index, opacity = _ref3.opacity;
      var darkColorString = toHex(mix$1(inputToRGB(opts2.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key2) {
  presetPalettes[key2] = generate$1(presetPrimaryColors[key2]);
  presetPalettes[key2].primary = presetPalettes[key2][5];
  presetDarkPalettes[key2] = generate$1(presetPrimaryColors[key2], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes[key2].primary = presetDarkPalettes[key2][5];
});
presetPalettes.red;
presetPalettes.volcano;
presetPalettes.gold;
presetPalettes.orange;
presetPalettes.yellow;
presetPalettes.lime;
presetPalettes.green;
presetPalettes.cyan;
presetPalettes.blue;
presetPalettes.geekblue;
presetPalettes.purple;
presetPalettes.magenta;
presetPalettes.grey;
var containers = [];
var styleElements = [];
var usage = "insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).";
function createStyleElement() {
  var styleElement = document.createElement("style");
  styleElement.setAttribute("type", "text/css");
  return styleElement;
}
function insertCss(css2, options) {
  options = options || {};
  if (css2 === void 0) {
    throw new Error(usage);
  }
  var position = options.prepend === true ? "prepend" : "append";
  var container = options.container !== void 0 ? options.container : document.querySelector("head");
  var containerId = containers.indexOf(container);
  if (containerId === -1) {
    containerId = containers.push(container) - 1;
    styleElements[containerId] = {};
  }
  var styleElement;
  if (styleElements[containerId] !== void 0 && styleElements[containerId][position] !== void 0) {
    styleElement = styleElements[containerId][position];
  } else {
    styleElement = styleElements[containerId][position] = createStyleElement();
    if (position === "prepend") {
      container.insertBefore(styleElement, container.childNodes[0]);
    } else {
      container.appendChild(styleElement);
    }
  }
  if (css2.charCodeAt(0) === 65279) {
    css2 = css2.substr(1, css2.length);
  }
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText += css2;
  } else {
    styleElement.textContent += css2;
  }
  return styleElement;
}
function _objectSpread$R(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$S(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$S(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function warning$2(valid, message) {
}
function isIconDefinition(target) {
  return typeof target === "object" && typeof target.name === "string" && typeof target.theme === "string" && (typeof target.icon === "object" || typeof target.icon === "function");
}
function generate(node, key2, rootProps) {
  if (!rootProps) {
    return Vue.h(node.tag, _objectSpread$R({
      key: key2
    }, node.attrs), (node.children || []).map(function(child, index2) {
      return generate(child, "".concat(key2, "-").concat(node.tag, "-").concat(index2));
    }));
  }
  return Vue.h(node.tag, _objectSpread$R({
    key: key2
  }, rootProps, node.attrs), (node.children || []).map(function(child, index2) {
    return generate(child, "".concat(key2, "-").concat(node.tag, "-").concat(index2));
  }));
}
function getSecondaryColor(primaryColor) {
  return generate$1(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var cssInjectedFlag = false;
var useInsertStyles = function useInsertStyles2() {
  var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;
  Vue.nextTick(function() {
    if (!cssInjectedFlag) {
      if (typeof window !== "undefined" && window.document && window.document.documentElement) {
        insertCss(styleStr, {
          prepend: true
        });
      }
      cssInjectedFlag = true;
    }
  });
};
var _excluded$1 = ["icon", "primaryColor", "secondaryColor"];
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key2, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key2 = sourceSymbolKeys[i2];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key2 = sourceKeys[i2];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function _objectSpread$Q(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$R(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$R(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var twoToneColorPalette = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: false
};
function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
  return _objectSpread$Q({}, twoToneColorPalette);
}
var IconBase = function IconBase2(props2, context) {
  var _props$context$attrs = _objectSpread$Q({}, props2, context.attrs), icon = _props$context$attrs.icon, primaryColor = _props$context$attrs.primaryColor, secondaryColor = _props$context$attrs.secondaryColor, restProps = _objectWithoutProperties$1(_props$context$attrs, _excluded$1);
  var colors = twoToneColorPalette;
  if (primaryColor) {
    colors = {
      primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
    };
  }
  useInsertStyles();
  warning$2(isIconDefinition(icon));
  if (!isIconDefinition(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === "function") {
    target = _objectSpread$Q({}, target, {
      icon: target.icon(colors.primaryColor, colors.secondaryColor)
    });
  }
  return generate(target.icon, "svg-".concat(target.name), _objectSpread$Q({}, restProps, {
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }));
};
IconBase.props = {
  icon: Object,
  primaryColor: String,
  secondaryColor: String,
  focusable: String
};
IconBase.inheritAttrs = false;
IconBase.displayName = "IconBase";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
var VueIcon = IconBase;
function _slicedToArray$2(arr, i2) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i2) || _unsupportedIterableToArray$2(arr, i2) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o2, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit$2(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$2(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return VueIcon.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
function getTwoToneColor() {
  var colors = VueIcon.getTwoToneColors();
  if (!colors.calculated) {
    return colors.primaryColor;
  }
  return [colors.primaryColor, colors.secondaryColor];
}
var _excluded = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
function _slicedToArray$1(arr, i2) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$1(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o2, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit$1(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _objectSpread$P(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$Q(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$Q(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key2, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key2 = sourceSymbolKeys[i2];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key2 = sourceKeys[i2];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
setTwoToneColor("#1890ff");
var Icon = function Icon2(props2, context) {
  var _classObj;
  var _props$context$attrs = _objectSpread$P({}, props2, context.attrs), cls = _props$context$attrs["class"], icon = _props$context$attrs.icon, spin = _props$context$attrs.spin, rotate = _props$context$attrs.rotate, tabindex = _props$context$attrs.tabindex, twoToneColor = _props$context$attrs.twoToneColor, onClick2 = _props$context$attrs.onClick, restProps = _objectWithoutProperties(_props$context$attrs, _excluded);
  var classObj = (_classObj = {
    anticon: true
  }, _defineProperty$Q(_classObj, "anticon-".concat(icon.name), Boolean(icon.name)), _defineProperty$Q(_classObj, cls, cls), _classObj);
  var svgClassString = spin === "" || !!spin || icon.name === "loading" ? "anticon-spin" : "";
  var iconTabIndex = tabindex;
  if (iconTabIndex === void 0 && onClick2) {
    iconTabIndex = -1;
    restProps.tabindex = iconTabIndex;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : void 0;
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$1(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return Vue.createVNode("span", _objectSpread$P({
    "role": "img",
    "aria-label": icon.name
  }, restProps, {
    "onClick": onClick2,
    "class": classObj
  }), [Vue.createVNode(VueIcon, {
    "class": svgClassString,
    "icon": icon,
    "primaryColor": primaryColor,
    "secondaryColor": secondaryColor,
    "style": svgStyle
  }, null)]);
};
Icon.props = {
  spin: Boolean,
  rotate: Number,
  icon: Object,
  twoToneColor: String
};
Icon.displayName = "AntdIcon";
Icon.inheritAttrs = false;
Icon.getTwoToneColor = getTwoToneColor;
Icon.setTwoToneColor = setTwoToneColor;
var AntdIcon = Icon;
function _objectSpread$O(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$P(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$P(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var LoadingOutlined = function LoadingOutlined2(props2, context) {
  var p2 = _objectSpread$O({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$O({}, p2, {
    "icon": LoadingOutlinedSvg
  }), null);
};
LoadingOutlined.displayName = "LoadingOutlined";
LoadingOutlined.inheritAttrs = false;
var LoadingOutlined$1 = LoadingOutlined;
function e(e2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var r2 = t2[n2];
    r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);
  }
}
function t(t2, n2, r2) {
  return n2 && e(t2.prototype, n2), r2 && e(t2, r2), t2;
}
function n() {
  return (n = Object.assign || function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }).apply(this, arguments);
}
function r(e2, t2) {
  e2.prototype = Object.create(t2.prototype), e2.prototype.constructor = e2, e2.__proto__ = t2;
}
function i(e2, t2) {
  if (e2 == null)
    return {};
  var n2, r2, i2 = {}, o2 = Object.keys(e2);
  for (r2 = 0; r2 < o2.length; r2++)
    t2.indexOf(n2 = o2[r2]) >= 0 || (i2[n2] = e2[n2]);
  return i2;
}
function o(e2) {
  return ((t2 = e2) != null && typeof t2 == "object" && Array.isArray(t2) === false) == 1 && Object.prototype.toString.call(e2) === "[object Object]";
  var t2;
}
var u = Object.prototype, a = u.toString, f = u.hasOwnProperty, c = /^\s*function (\w+)/;
function l(e2) {
  var t2, n2 = (t2 = e2 == null ? void 0 : e2.type) !== null && t2 !== void 0 ? t2 : e2;
  if (n2) {
    var r2 = n2.toString().match(c);
    return r2 ? r2[1] : "";
  }
  return "";
}
var s = function(e2) {
  var t2, n2;
  return o(e2) !== false && typeof (t2 = e2.constructor) == "function" && o(n2 = t2.prototype) !== false && n2.hasOwnProperty("isPrototypeOf") !== false;
}, v = function(e2) {
  return e2;
}, y = v;
var d = function(e2, t2) {
  return f.call(e2, t2);
}, h = Number.isInteger || function(e2) {
  return typeof e2 == "number" && isFinite(e2) && Math.floor(e2) === e2;
}, b = Array.isArray || function(e2) {
  return a.call(e2) === "[object Array]";
}, O = function(e2) {
  return a.call(e2) === "[object Function]";
}, g = function(e2) {
  return s(e2) && d(e2, "_vueTypes_name");
}, m = function(e2) {
  return s(e2) && (d(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function(t2) {
    return d(e2, t2);
  }));
};
function j(e2, t2) {
  return Object.defineProperty(e2.bind(t2), "__original", {
    value: e2
  });
}
function _$1(e2, t2, n2) {
  var r2;
  n2 === void 0 && (n2 = false);
  var i2 = true, o2 = "";
  r2 = s(e2) ? e2 : {
    type: e2
  };
  var u2 = g(r2) ? r2._vueTypes_name + " - " : "";
  if (m(r2) && r2.type !== null) {
    if (r2.type === void 0 || r2.type === true)
      return i2;
    if (!r2.required && t2 === void 0)
      return i2;
    b(r2.type) ? (i2 = r2.type.some(function(e3) {
      return _$1(e3, t2, true) === true;
    }), o2 = r2.type.map(function(e3) {
      return l(e3);
    }).join(" or ")) : i2 = (o2 = l(r2)) === "Array" ? b(t2) : o2 === "Object" ? s(t2) : o2 === "String" || o2 === "Number" || o2 === "Boolean" || o2 === "Function" ? function(e3) {
      if (e3 == null)
        return "";
      var t3 = e3.constructor.toString().match(c);
      return t3 ? t3[1] : "";
    }(t2) === o2 : t2 instanceof r2.type;
  }
  if (!i2) {
    var a2 = u2 + 'value "' + t2 + '" should be of type "' + o2 + '"';
    return n2 === false ? (y(a2), false) : a2;
  }
  if (d(r2, "validator") && O(r2.validator)) {
    var f2 = y, v2 = [];
    if (y = function(e3) {
      v2.push(e3);
    }, i2 = r2.validator(t2), y = f2, !i2) {
      var p2 = (v2.length > 1 ? "* " : "") + v2.join("\n* ");
      return v2.length = 0, n2 === false ? (y(p2), i2) : p2;
    }
  }
  return i2;
}
function T(e2, t2) {
  var n2 = Object.defineProperties(t2, {
    _vueTypes_name: {
      value: e2,
      writable: true
    },
    isRequired: {
      get: function() {
        return this.required = true, this;
      }
    },
    def: {
      value: function(e3) {
        return e3 !== void 0 || this.default ? O(e3) || _$1(this, e3, true) === true ? (this.default = b(e3) ? function() {
          return [].concat(e3);
        } : s(e3) ? function() {
          return Object.assign({}, e3);
        } : e3, this) : (y(this._vueTypes_name + ' - invalid default value: "' + e3 + '"'), this) : this;
      }
    }
  }), r2 = n2.validator;
  return O(r2) && (n2.validator = j(r2, n2)), n2;
}
function w(e2, t2) {
  var n2 = T(e2, t2);
  return Object.defineProperty(n2, "validate", {
    value: function(e3) {
      return O(this.validator) && y(this._vueTypes_name + " - calling .validate() will overwrite the current custom validator function. Validator info:\n" + JSON.stringify(this)), this.validator = j(e3, this), this;
    }
  });
}
function k(e2, t2, n2) {
  var r2, o2, u2 = (r2 = t2, o2 = {}, Object.getOwnPropertyNames(r2).forEach(function(e3) {
    o2[e3] = Object.getOwnPropertyDescriptor(r2, e3);
  }), Object.defineProperties({}, o2));
  if (u2._vueTypes_name = e2, !s(n2))
    return u2;
  var a2, f2, c2 = n2.validator, l2 = i(n2, ["validator"]);
  if (O(c2)) {
    var v2 = u2.validator;
    v2 && (v2 = (f2 = (a2 = v2).__original) !== null && f2 !== void 0 ? f2 : a2), u2.validator = j(v2 ? function(e3) {
      return v2.call(this, e3) && c2.call(this, e3);
    } : c2, u2);
  }
  return Object.assign(u2, l2);
}
function P(e2) {
  return e2.replace(/^(?!\s*$)/gm, "  ");
}
var x = function() {
  return w("any", {});
}, A = function() {
  return w("function", {
    type: Function
  });
}, E = function() {
  return w("boolean", {
    type: Boolean
  });
}, N = function() {
  return w("string", {
    type: String
  });
}, q = function() {
  return w("number", {
    type: Number
  });
}, S = function() {
  return w("array", {
    type: Array
  });
}, V = function() {
  return w("object", {
    type: Object
  });
}, F = function() {
  return T("integer", {
    type: Number,
    validator: function(e2) {
      return h(e2);
    }
  });
}, D = function() {
  return T("symbol", {
    validator: function(e2) {
      return typeof e2 == "symbol";
    }
  });
};
function L(e2, t2) {
  if (t2 === void 0 && (t2 = "custom validation failed"), typeof e2 != "function")
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return T(e2.name || "<<anonymous function>>", {
    validator: function(n2) {
      var r2 = e2(n2);
      return r2 || y(this._vueTypes_name + " - " + t2), r2;
    }
  });
}
function Y(e2) {
  if (!b(e2))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  var t2 = 'oneOf - value should be one of "' + e2.join('", "') + '".', n2 = e2.reduce(function(e3, t3) {
    if (t3 != null) {
      var n3 = t3.constructor;
      e3.indexOf(n3) === -1 && e3.push(n3);
    }
    return e3;
  }, []);
  return T("oneOf", {
    type: n2.length > 0 ? n2 : void 0,
    validator: function(n3) {
      var r2 = e2.indexOf(n3) !== -1;
      return r2 || y(t2), r2;
    }
  });
}
function B(e2) {
  if (!b(e2))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  for (var t2 = false, n2 = [], r2 = 0; r2 < e2.length; r2 += 1) {
    var i2 = e2[r2];
    if (m(i2)) {
      if (g(i2) && i2._vueTypes_name === "oneOf") {
        n2 = n2.concat(i2.type);
        continue;
      }
      if (O(i2.validator) && (t2 = true), i2.type !== true && i2.type) {
        n2 = n2.concat(i2.type);
        continue;
      }
    }
    n2.push(i2);
  }
  return n2 = n2.filter(function(e3, t3) {
    return n2.indexOf(e3) === t3;
  }), T("oneOfType", t2 ? {
    type: n2,
    validator: function(t3) {
      var n3 = [], r3 = e2.some(function(e3) {
        var r4 = _$1(g(e3) && e3._vueTypes_name === "oneOf" ? e3.type || null : e3, t3, true);
        return typeof r4 == "string" && n3.push(r4), r4 === true;
      });
      return r3 || y("oneOfType - provided value does not match any of the " + n3.length + " passed-in validators:\n" + P(n3.join("\n"))), r3;
    }
  } : {
    type: n2
  });
}
function I(e2) {
  return T("arrayOf", {
    type: Array,
    validator: function(t2) {
      var n2, r2 = t2.every(function(t3) {
        return (n2 = _$1(e2, t3, true)) === true;
      });
      return r2 || y("arrayOf - value validation error:\n" + P(n2)), r2;
    }
  });
}
function J(e2) {
  return T("instanceOf", {
    type: e2
  });
}
function M(e2) {
  return T("objectOf", {
    type: Object,
    validator: function(t2) {
      var n2, r2 = Object.keys(t2).every(function(r3) {
        return (n2 = _$1(e2, t2[r3], true)) === true;
      });
      return r2 || y("objectOf - value validation error:\n" + P(n2)), r2;
    }
  });
}
function R(e2) {
  var t2 = Object.keys(e2), n2 = t2.filter(function(t3) {
    var n3;
    return !!((n3 = e2[t3]) === null || n3 === void 0 ? void 0 : n3.required);
  }), r2 = T("shape", {
    type: Object,
    validator: function(r3) {
      var i2 = this;
      if (!s(r3))
        return false;
      var o2 = Object.keys(r3);
      if (n2.length > 0 && n2.some(function(e3) {
        return o2.indexOf(e3) === -1;
      })) {
        var u2 = n2.filter(function(e3) {
          return o2.indexOf(e3) === -1;
        });
        return y(u2.length === 1 ? 'shape - required property "' + u2[0] + '" is not defined.' : 'shape - required properties "' + u2.join('", "') + '" are not defined.'), false;
      }
      return o2.every(function(n3) {
        if (t2.indexOf(n3) === -1)
          return i2._vueTypes_isLoose === true || (y('shape - shape definition does not include a "' + n3 + '" property. Allowed keys: "' + t2.join('", "') + '".'), false);
        var o3 = _$1(e2[n3], r3[n3], true);
        return typeof o3 == "string" && y('shape - "' + n3 + '" property validation error:\n ' + P(o3)), o3 === true;
      });
    }
  });
  return Object.defineProperty(r2, "_vueTypes_isLoose", {
    writable: true,
    value: false
  }), Object.defineProperty(r2, "loose", {
    get: function() {
      return this._vueTypes_isLoose = true, this;
    }
  }), r2;
}
var $$1 = function() {
  function e2() {
  }
  return e2.extend = function(e3) {
    var t2 = this;
    if (b(e3))
      return e3.forEach(function(e4) {
        return t2.extend(e4);
      }), this;
    var n2 = e3.name, r2 = e3.validate, o2 = r2 !== void 0 && r2, u2 = e3.getter, a2 = u2 !== void 0 && u2, f2 = i(e3, ["name", "validate", "getter"]);
    if (d(this, n2))
      throw new TypeError('[VueTypes error]: Type "' + n2 + '" already defined');
    var c2, l2 = f2.type;
    return g(l2) ? (delete f2.type, Object.defineProperty(this, n2, a2 ? {
      get: function() {
        return k(n2, l2, f2);
      }
    } : {
      value: function() {
        var e4, t3 = k(n2, l2, f2);
        return t3.validator && (t3.validator = (e4 = t3.validator).bind.apply(e4, [t3].concat([].slice.call(arguments)))), t3;
      }
    })) : (c2 = a2 ? {
      get: function() {
        var e4 = Object.assign({}, f2);
        return o2 ? w(n2, e4) : T(n2, e4);
      },
      enumerable: true
    } : {
      value: function() {
        var e4, t3, r3 = Object.assign({}, f2);
        return e4 = o2 ? w(n2, r3) : T(n2, r3), r3.validator && (e4.validator = (t3 = r3.validator).bind.apply(t3, [e4].concat([].slice.call(arguments)))), e4;
      },
      enumerable: true
    }, Object.defineProperty(this, n2, c2));
  }, t(e2, null, [{
    key: "any",
    get: function() {
      return x();
    }
  }, {
    key: "func",
    get: function() {
      return A().def(this.defaults.func);
    }
  }, {
    key: "bool",
    get: function() {
      return E().def(this.defaults.bool);
    }
  }, {
    key: "string",
    get: function() {
      return N().def(this.defaults.string);
    }
  }, {
    key: "number",
    get: function() {
      return q().def(this.defaults.number);
    }
  }, {
    key: "array",
    get: function() {
      return S().def(this.defaults.array);
    }
  }, {
    key: "object",
    get: function() {
      return V().def(this.defaults.object);
    }
  }, {
    key: "integer",
    get: function() {
      return F().def(this.defaults.integer);
    }
  }, {
    key: "symbol",
    get: function() {
      return D();
    }
  }]), e2;
}();
function z(e2) {
  var i2;
  return e2 === void 0 && (e2 = {
    func: function() {
    },
    bool: true,
    string: "",
    number: 0,
    array: function() {
      return [];
    },
    object: function() {
      return {};
    },
    integer: 0
  }), (i2 = function(i3) {
    function o2() {
      return i3.apply(this, arguments) || this;
    }
    return r(o2, i3), t(o2, null, [{
      key: "sensibleDefaults",
      get: function() {
        return n({}, this.defaults);
      },
      set: function(t2) {
        this.defaults = t2 !== false ? n({}, t2 !== true ? t2 : e2) : {};
      }
    }]), o2;
  }($$1)).defaults = n({}, e2), i2;
}
$$1.defaults = {}, $$1.custom = L, $$1.oneOf = Y, $$1.instanceOf = J, $$1.oneOfType = B, $$1.arrayOf = I, $$1.objectOf = M, $$1.shape = R, $$1.utils = {
  validate: function(e2, t2) {
    return _$1(t2, e2, true) === true;
  },
  toType: function(e2, t2, n2) {
    return n2 === void 0 && (n2 = false), n2 ? w(e2, t2) : T(e2, t2);
  }
};
(function(e2) {
  function t2() {
    return e2.apply(this, arguments) || this;
  }
  return r(t2, e2), t2;
})(z());
var PropTypes = z({
  func: void 0,
  bool: void 0,
  string: void 0,
  number: void 0,
  array: void 0,
  object: void 0,
  integer: void 0
});
PropTypes.extend([{
  name: "looseBool",
  getter: true,
  type: Boolean,
  default: void 0
}, {
  name: "style",
  getter: true,
  type: [String, Object],
  default: void 0
}, {
  name: "VueNode",
  getter: true,
  type: null
}]);
var PropTypes$1 = PropTypes;
var KeyCode = {
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PRINT_SCREEN: 44,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  QUESTION_MARK: 63,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SEMICOLON: 186,
  DASH: 189,
  EQUALS: 187,
  COMMA: 188,
  PERIOD: 190,
  SLASH: 191,
  APOSTROPHE: 192,
  SINGLE_QUOTE: 222,
  OPEN_SQUARE_BRACKET: 219,
  BACKSLASH: 220,
  CLOSE_SQUARE_BRACKET: 221,
  WIN_KEY: 224,
  MAC_FF_META: 224,
  WIN_IME: 229,
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
    var keyCode = e2.keyCode;
    if (e2.altKey && !e2.ctrlKey || e2.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
var KeyCode$1 = KeyCode;
var START_EVENT_NAME_MAP = {
  transitionstart: {
    transition: "transitionstart",
    WebkitTransition: "webkitTransitionStart",
    MozTransition: "mozTransitionStart",
    OTransition: "oTransitionStart",
    msTransition: "MSTransitionStart"
  },
  animationstart: {
    animation: "animationstart",
    WebkitAnimation: "webkitAnimationStart",
    MozAnimation: "mozAnimationStart",
    OAnimation: "oAnimationStart",
    msAnimation: "MSAnimationStart"
  }
};
var END_EVENT_NAME_MAP = {
  transitionend: {
    transition: "transitionend",
    WebkitTransition: "webkitTransitionEnd",
    MozTransition: "mozTransitionEnd",
    OTransition: "oTransitionEnd",
    msTransition: "MSTransitionEnd"
  },
  animationend: {
    animation: "animationend",
    WebkitAnimation: "webkitAnimationEnd",
    MozAnimation: "mozAnimationEnd",
    OAnimation: "oAnimationEnd",
    msAnimation: "MSAnimationEnd"
  }
};
var startEvents = [];
var endEvents = [];
function detectEvents() {
  var testEl = document.createElement("div");
  var style = testEl.style;
  if (!("AnimationEvent" in window)) {
    delete START_EVENT_NAME_MAP.animationstart.animation;
    delete END_EVENT_NAME_MAP.animationend.animation;
  }
  if (!("TransitionEvent" in window)) {
    delete START_EVENT_NAME_MAP.transitionstart.transition;
    delete END_EVENT_NAME_MAP.transitionend.transition;
  }
  function process(EVENT_NAME_MAP, events2) {
    for (var baseEventName in EVENT_NAME_MAP) {
      if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
        var baseEvents = EVENT_NAME_MAP[baseEventName];
        for (var styleName in baseEvents) {
          if (styleName in style) {
            events2.push(baseEvents[styleName]);
            break;
          }
        }
      }
    }
  }
  process(START_EVENT_NAME_MAP, startEvents);
  process(END_EVENT_NAME_MAP, endEvents);
}
if (typeof window !== "undefined" && typeof document !== "undefined") {
  detectEvents();
}
function addEventListener$1(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}
function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}
var TransitionEvents = {
  startEvents,
  addStartEventListener: function addStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      setTimeout(eventListener, 0);
      return;
    }
    startEvents.forEach(function(startEvent) {
      addEventListener$1(node, startEvent, eventListener);
    });
  },
  removeStartEventListener: function removeStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      return;
    }
    startEvents.forEach(function(startEvent) {
      removeEventListener(node, startEvent, eventListener);
    });
  },
  endEvents,
  addEndEventListener: function addEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function(endEvent) {
      addEventListener$1(node, endEvent, eventListener);
    });
  },
  removeEndEventListener: function removeEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function(endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};
var TransitionEvents$1 = TransitionEvents;
var raf$1 = function raf2(callback) {
  return setTimeout(callback, 16);
};
var caf = function caf2(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf$1 = function raf3(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf = function caf3(handle) {
    return window.cancelAnimationFrame(handle);
  };
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
  rafIds.delete(id);
}
function wrapperRaf(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID += 1;
  var id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id);
      callback();
    } else {
      var realId = raf$1(function() {
        callRef(leftTimes - 1);
      });
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
}
wrapperRaf.cancel = function(id) {
  var realId = rafIds.get(id);
  cleanup(realId);
  return caf(realId);
};
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
var freeGlobal$2 = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$3 = freeGlobal$2;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal$3 || freeSelf$1 || Function("return this")();
var root$3 = root$2;
var Symbol$4 = root$3.Symbol;
var Symbol$5 = Symbol$4;
var objectProto$j = Object.prototype;
var hasOwnProperty$f = objectProto$j.hasOwnProperty;
var nativeObjectToString$3 = objectProto$j.toString;
var symToStringTag$3 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$2(value) {
  var isOwn = hasOwnProperty$f.call(value, symToStringTag$3), tag = value[symToStringTag$3];
  try {
    value[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}
var objectProto$i = Object.prototype;
var nativeObjectToString$2 = objectProto$i.toString;
function objectToString$2(value) {
  return nativeObjectToString$2.call(value);
}
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$4(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$2(value) : objectToString$2(value);
}
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var getPrototype = overArg$2(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
function isObjectLike$4(value) {
  return value != null && typeof value == "object";
}
var objectTag$4 = "[object Object]";
var funcProto$2 = Function.prototype, objectProto$h = Object.prototype;
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$e = objectProto$h.hasOwnProperty;
var objectCtorString = funcToString$2.call(Object);
function isPlainObject(value) {
  if (!isObjectLike$4(value) || baseGetTag$4(value) != objectTag$4) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$e.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}
var isFunction$3 = function isFunction2(val) {
  return typeof val === "function";
};
var isArray$5 = Array.isArray;
var isString = function isString2(val) {
  return typeof val === "string";
};
var isObject$3 = function isObject2(val) {
  return val !== null && _typeof$1(val) === "object";
};
var onRE$1 = /^on[^a-z]/;
var isOn = function isOn2(key2) {
  return onRE$1.test(key2);
};
var cacheStringFunction = function cacheStringFunction2(fn) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(str) {
    var hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction(function(str) {
  return str.replace(camelizeRE, function(_2, c2) {
    return c2 ? c2.toUpperCase() : "";
  });
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction(function(str) {
  return str.replace(hyphenateRE, "-$1").toLowerCase();
});
var hasOwnProperty$d = Object.prototype.hasOwnProperty;
var hasOwn = function hasOwn2(val, key2) {
  return hasOwnProperty$d.call(val, key2);
};
function resolvePropValue(options, props2, key2, value) {
  var opt = options[key2];
  if (opt != null) {
    var hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      var defaultValue = opt.default;
      value = opt.type !== Function && isFunction$3(defaultValue) ? defaultValue() : defaultValue;
    }
    if (opt.type === Boolean) {
      if (!hasOwn(props2, key2) && !hasDefault) {
        value = false;
      } else if (value === "") {
        value = true;
      }
    }
  }
  return value;
}
function toPx(val) {
  if (typeof val === "number")
    return "".concat(val, "px");
  return val;
}
function renderHelper(v2) {
  var props2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var defaultV = arguments.length > 2 ? arguments[2] : void 0;
  if (typeof v2 === "function") {
    return v2(props2);
  }
  return v2 !== null && v2 !== void 0 ? v2 : defaultV;
}
function classNames() {
  var classes = [];
  for (var i2 = 0; i2 < arguments.length; i2++) {
    var value = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
    if (!value)
      continue;
    if (isString(value)) {
      classes.push(value);
    } else if (isArray$5(value)) {
      for (var _i = 0; _i < value.length; _i++) {
        var inner = classNames(value[_i]);
        if (inner) {
          classes.push(inner);
        }
      }
    } else if (isObject$3(value)) {
      for (var name in value) {
        if (value[name]) {
          classes.push(name);
        }
      }
    }
  }
  return classes.join(" ");
}
var isValid$1 = function isValid2(value) {
  return value !== void 0 && value !== null && value !== "";
};
var isValid$2 = isValid$1;
var initDefaultProps = function initDefaultProps2(types, defaultProps2) {
  var propTypes2 = _extends({}, types);
  Object.keys(defaultProps2).forEach(function(k2) {
    var prop = propTypes2[k2];
    if (prop) {
      if (prop.type || prop.default) {
        prop.default = defaultProps2[k2];
      } else if (prop.def) {
        prop.def(defaultProps2[k2]);
      } else {
        propTypes2[k2] = {
          type: prop,
          default: defaultProps2[k2]
        };
      }
    } else {
      throw new Error("not have ".concat(k2, " prop"));
    }
  });
  return propTypes2;
};
var initDefaultProps$1 = initDefaultProps;
var splitAttrs = function splitAttrs2(attrs) {
  var allAttrs = Object.keys(attrs);
  var eventAttrs = {};
  var onEvents = {};
  var extraAttrs = {};
  for (var i2 = 0, l2 = allAttrs.length; i2 < l2; i2++) {
    var key2 = allAttrs[i2];
    if (isOn(key2)) {
      eventAttrs[key2[2].toLowerCase() + key2.slice(3)] = attrs[key2];
      onEvents[key2] = attrs[key2];
    } else {
      extraAttrs[key2] = attrs[key2];
    }
  }
  return {
    onEvents,
    events: eventAttrs,
    extraAttrs
  };
};
var parseStyleText = function parseStyleText2() {
  var cssText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var camel = arguments.length > 1 ? arguments[1] : void 0;
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  if (_typeof$1(cssText) === "object")
    return cssText;
  cssText.split(listDelimiter).forEach(function(item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      if (tmp.length > 1) {
        var k2 = camel ? camelize(tmp[0].trim()) : tmp[0].trim();
        res[k2] = tmp[1].trim();
      }
    }
  });
  return res;
};
var hasProp = function hasProp2(instance, prop) {
  return instance[prop] !== void 0;
};
var flattenChildren = function flattenChildren2() {
  var children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var filterEmpty2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var temp = Array.isArray(children) ? children : [children];
  var res = [];
  temp.forEach(function(child) {
    if (Array.isArray(child)) {
      res.push.apply(res, _toConsumableArray(flattenChildren2(child, filterEmpty2)));
    } else if (child && child.type === Vue.Fragment) {
      res.push.apply(res, _toConsumableArray(flattenChildren2(child.children, filterEmpty2)));
    } else if (child && Vue.isVNode(child)) {
      if (filterEmpty2 && !isEmptyElement(child)) {
        res.push(child);
      } else if (!filterEmpty2) {
        res.push(child);
      }
    } else if (isValid$2(child)) {
      res.push(child);
    }
  });
  return res;
};
var getSlot = function getSlot2(self2) {
  var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (Vue.isVNode(self2)) {
    if (self2.type === Vue.Fragment) {
      return name === "default" ? flattenChildren(self2.children) : [];
    } else if (self2.children && self2.children[name]) {
      return flattenChildren(self2.children[name](options));
    } else {
      return [];
    }
  } else {
    var res = self2.$slots[name] && self2.$slots[name](options);
    return flattenChildren(res);
  }
};
var findDOMNode = function findDOMNode2(instance) {
  var _a;
  var node = ((_a = instance === null || instance === void 0 ? void 0 : instance.vnode) === null || _a === void 0 ? void 0 : _a.el) || instance && (instance.$el || instance);
  while (node && !node.tagName) {
    node = node.nextSibling;
  }
  return node;
};
var getOptionProps = function getOptionProps2(instance) {
  var res = {};
  if (instance.$ && instance.$.vnode) {
    var props2 = instance.$.vnode.props || {};
    Object.keys(instance.$props).forEach(function(k2) {
      var v2 = instance.$props[k2];
      var hyphenateKey = hyphenate(k2);
      if (v2 !== void 0 || hyphenateKey in props2) {
        res[k2] = v2;
      }
    });
  } else if (Vue.isVNode(instance) && _typeof$1(instance.type) === "object") {
    var originProps = instance.props || {};
    var _props = {};
    Object.keys(originProps).forEach(function(key2) {
      _props[camelize(key2)] = originProps[key2];
    });
    var options = instance.type.props || {};
    Object.keys(options).forEach(function(k2) {
      var v2 = resolvePropValue(options, _props, k2, _props[k2]);
      if (v2 !== void 0 || k2 in _props) {
        res[k2] = v2;
      }
    });
  }
  return res;
};
var getComponent = function getComponent2(instance) {
  var prop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : instance;
  var execute = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var com = void 0;
  if (instance.$) {
    var temp = instance[prop];
    if (temp !== void 0) {
      return typeof temp === "function" && execute ? temp(options) : temp;
    } else {
      com = instance.$slots[prop];
      com = execute && com ? com(options) : com;
    }
  } else if (Vue.isVNode(instance)) {
    var _temp = instance.props && instance.props[prop];
    if (_temp !== void 0 && instance.props !== null) {
      return typeof _temp === "function" && execute ? _temp(options) : _temp;
    } else if (instance.type === Vue.Fragment) {
      com = instance.children;
    } else if (instance.children && instance.children[prop]) {
      com = instance.children[prop];
      com = execute && com ? com(options) : com;
    }
  }
  if (Array.isArray(com)) {
    com = flattenChildren(com);
    com = com.length === 1 ? com[0] : com;
    com = com.length === 0 ? void 0 : com;
  }
  return com;
};
function getEvents() {
  var ele = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var on = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var props2 = {};
  if (ele.$) {
    props2 = _extends(_extends({}, props2), ele.$attrs);
  } else {
    props2 = _extends(_extends({}, props2), ele.props);
  }
  return splitAttrs(props2)[on ? "onEvents" : "events"];
}
function getClass(ele) {
  var props2 = (Vue.isVNode(ele) ? ele.props : ele.$attrs) || {};
  var tempCls = props2.class || {};
  var cls = {};
  if (typeof tempCls === "string") {
    tempCls.split(" ").forEach(function(c2) {
      cls[c2.trim()] = true;
    });
  } else if (Array.isArray(tempCls)) {
    classNames(tempCls).split(" ").forEach(function(c2) {
      cls[c2.trim()] = true;
    });
  } else {
    cls = _extends(_extends({}, cls), tempCls);
  }
  return cls;
}
function getStyle(ele, camel) {
  var props2 = (Vue.isVNode(ele) ? ele.props : ele.$attrs) || {};
  var style = props2.style || {};
  if (typeof style === "string") {
    style = parseStyleText(style, camel);
  } else if (camel && style) {
    var res = {};
    Object.keys(style).forEach(function(k2) {
      return res[camelize(k2)] = style[k2];
    });
    return res;
  }
  return style;
}
function isEmptyContent(c2) {
  return c2 === void 0 || c2 === null || c2 === "" || Array.isArray(c2) && c2.length === 0;
}
function isEmptyElement(c2) {
  return c2 && (c2.type === Vue.Comment || c2.type === Vue.Fragment && c2.children.length === 0 || c2.type === Vue.Text && c2.children.trim() === "");
}
function isStringElement(c2) {
  return c2 && c2.type === Vue.Text;
}
function filterEmpty() {
  var children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var res = [];
  children.forEach(function(child) {
    if (Array.isArray(child)) {
      res.push.apply(res, _toConsumableArray(child));
    } else if (child.type === Vue.Fragment) {
      res.push.apply(res, _toConsumableArray(child.children));
    } else {
      res.push(child);
    }
  });
  return res.filter(function(c2) {
    return !isEmptyElement(c2);
  });
}
function filterEmptyWithUndefined(children) {
  if (children) {
    var coms = filterEmpty(children);
    return coms.length ? coms : void 0;
  } else {
    return children;
  }
}
function isValidElement(element) {
  if (Array.isArray(element) && element.length === 1) {
    element = element[0];
  }
  return element && element.__v_isVNode && _typeof$1(element.type) !== "symbol";
}
function getPropsSlot(slots, props2) {
  var prop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
  var _a, _b;
  return (_a = props2[prop]) !== null && _a !== void 0 ? _a : (_b = slots[prop]) === null || _b === void 0 ? void 0 : _b.call(slots);
}
var enUS$1 = {
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "",
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages"
};
var locale$5 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "Ok",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: true,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
var CalendarLocale$1 = locale$5;
var locale$4 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
var TimePicker$2 = locale$4;
var locale$3 = {
  lang: _extends({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, CalendarLocale$1),
  timePickerLocale: _extends({}, TimePicker$2)
};
var enUS = locale$3;
var typeTemplate$1 = "${label} is not a valid ${type}";
var localeValues$1 = {
  locale: "en",
  Pagination: enUS$1,
  DatePicker: enUS,
  TimePicker: TimePicker$2,
  Calendar: enUS,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No Data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate$1,
        method: typeTemplate$1,
        array: typeTemplate$1,
        object: typeTemplate$1,
        number: typeTemplate$1,
        date: typeTemplate$1,
        boolean: typeTemplate$1,
        integer: typeTemplate$1,
        float: typeTemplate$1,
        regexp: typeTemplate$1,
        email: typeTemplate$1,
        url: typeTemplate$1,
        hex: typeTemplate$1
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  }
};
var defaultLocale = localeValues$1;
var LocaleReceiver = Vue.defineComponent({
  name: "LocaleReceiver",
  props: {
    componentName: String,
    defaultLocale: {
      type: [Object, Function]
    },
    children: {
      type: Function
    }
  },
  setup: function setup(props2, _ref) {
    var slots = _ref.slots;
    var localeData2 = Vue.inject("localeData", {});
    var locale2 = Vue.computed(function() {
      var _props$componentName = props2.componentName, componentName = _props$componentName === void 0 ? "global" : _props$componentName, defaultLocale$1 = props2.defaultLocale;
      var locale3 = defaultLocale$1 || defaultLocale[componentName || "global"];
      var antLocale = localeData2.antLocale;
      var localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
      return _extends(_extends({}, typeof locale3 === "function" ? locale3() : locale3), localeFromContext || {});
    });
    var localeCode = Vue.computed(function() {
      var antLocale = localeData2.antLocale;
      var localeCode2 = antLocale && antLocale.locale;
      if (antLocale && antLocale.exist && !localeCode2) {
        return defaultLocale.locale;
      }
      return localeCode2;
    });
    return function() {
      var children = props2.children || slots.default;
      var antLocale = localeData2.antLocale;
      return children === null || children === void 0 ? void 0 : children(locale2.value, localeCode.value, antLocale);
    };
  }
});
function useLocaleReceiver(componentName, defaultLocale$1, propsLocale) {
  var localeData2 = Vue.inject("localeData", {});
  var componentLocale = Vue.computed(function() {
    var antLocale = localeData2.antLocale;
    var locale2 = Vue.unref(defaultLocale$1) || defaultLocale[componentName || "global"];
    var localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
    return _extends(_extends(_extends({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {}), Vue.unref(propsLocale) || {});
  });
  return [componentLocale];
}
var Empty$2 = function Empty2() {
  var _useConfigInject = useConfigInject("empty", {}), getPrefixCls2 = _useConfigInject.getPrefixCls;
  var prefixCls = getPrefixCls2("empty-img-default");
  return Vue.createVNode("svg", {
    "class": prefixCls,
    "width": "184",
    "height": "152",
    "viewBox": "0 0 184 152"
  }, [Vue.createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [Vue.createVNode("g", {
    "transform": "translate(24 31.67)"
  }, [Vue.createVNode("ellipse", {
    "class": "".concat(prefixCls, "-ellipse"),
    "cx": "67.797",
    "cy": "106.89",
    "rx": "67.797",
    "ry": "12.668"
  }, null), Vue.createVNode("path", {
    "class": "".concat(prefixCls, "-path-1"),
    "d": "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z"
  }, null), Vue.createVNode("path", {
    "class": "".concat(prefixCls, "-path-2"),
    "d": "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    "transform": "translate(13.56)"
  }, null), Vue.createVNode("path", {
    "class": "".concat(prefixCls, "-path-3"),
    "d": "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z"
  }, null), Vue.createVNode("path", {
    "class": "".concat(prefixCls, "-path-4"),
    "d": "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z"
  }, null)]), Vue.createVNode("path", {
    "class": "".concat(prefixCls, "-path-5"),
    "d": "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z"
  }, null), Vue.createVNode("g", {
    "class": "".concat(prefixCls, "-g"),
    "transform": "translate(149.65 15.383)"
  }, [Vue.createVNode("ellipse", {
    "cx": "20.654",
    "cy": "3.167",
    "rx": "2.849",
    "ry": "2.815"
  }, null), Vue.createVNode("path", {
    "d": "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }, null)])])]);
};
Empty$2.PRESENTED_IMAGE_DEFAULT = true;
var DefaultEmptyImg = Empty$2;
var Simple = function Simple2() {
  var _useConfigInject = useConfigInject("empty", {}), getPrefixCls2 = _useConfigInject.getPrefixCls;
  var prefixCls = getPrefixCls2("empty-img-simple");
  return Vue.createVNode("svg", {
    "class": prefixCls,
    "width": "64",
    "height": "41",
    "viewBox": "0 0 64 41"
  }, [Vue.createVNode("g", {
    "transform": "translate(0 1)",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [Vue.createVNode("ellipse", {
    "class": "".concat(prefixCls, "-ellipse"),
    "fill": "#F5F5F5",
    "cx": "32",
    "cy": "33",
    "rx": "32",
    "ry": "7"
  }, null), Vue.createVNode("g", {
    "class": "".concat(prefixCls, "-g"),
    "fill-rule": "nonzero",
    "stroke": "#D9D9D9"
  }, [Vue.createVNode("path", {
    "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }, null), Vue.createVNode("path", {
    "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    "fill": "#FAFAFA",
    "class": "".concat(prefixCls, "-path")
  }, null)])])]);
};
Simple.PRESENTED_IMAGE_SIMPLE = true;
var SimpleEmptyImg = Simple;
var tuple$1 = function tuple2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args;
};
var withInstall = function withInstall2(comp) {
  var c2 = comp;
  c2.install = function(app) {
    app.component(c2.displayName || c2.name, comp);
  };
  return comp;
};
var __rest$H = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var defaultEmptyImg = Vue.createVNode(DefaultEmptyImg, null, null);
var simpleEmptyImg = Vue.createVNode(SimpleEmptyImg, null, null);
var Empty = function Empty3(props2, _ref) {
  var _ref$slots = _ref.slots, slots = _ref$slots === void 0 ? {} : _ref$slots, attrs = _ref.attrs;
  var _a;
  var _useConfigInject = useConfigInject("empty", props2), direction = _useConfigInject.direction, prefixClsRef = _useConfigInject.prefixCls;
  var prefixCls = prefixClsRef.value;
  var _b = _extends(_extends({}, props2), attrs), _b$image = _b.image, image = _b$image === void 0 ? defaultEmptyImg : _b$image, _b$description = _b.description, description = _b$description === void 0 ? ((_a = slots.description) === null || _a === void 0 ? void 0 : _a.call(slots)) || void 0 : _b$description, imageStyle = _b.imageStyle, _b$class = _b.class, className = _b$class === void 0 ? "" : _b$class, restProps = __rest$H(_b, ["image", "description", "imageStyle", "class"]);
  return Vue.createVNode(LocaleReceiver, {
    "componentName": "Empty",
    "children": function children(locale2) {
      var _classNames;
      var des = typeof description !== "undefined" ? description : locale2.description;
      var alt = typeof des === "string" ? des : "empty";
      var imageNode = null;
      if (typeof image === "string") {
        imageNode = Vue.createVNode("img", {
          "alt": alt,
          "src": image
        }, null);
      } else {
        imageNode = image;
      }
      return Vue.createVNode("div", _objectSpread2$1({
        "class": classNames(prefixCls, className, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls, "-normal"), image === simpleEmptyImg), _defineProperty$T(_classNames, "".concat(prefixCls, "-rtl"), direction.value === "rtl"), _classNames))
      }, restProps), [Vue.createVNode("div", {
        "class": "".concat(prefixCls, "-image"),
        "style": imageStyle
      }, [imageNode]), des && Vue.createVNode("p", {
        "class": "".concat(prefixCls, "-description")
      }, [des]), slots.default && Vue.createVNode("div", {
        "class": "".concat(prefixCls, "-footer")
      }, [filterEmpty(slots.default())])]);
    }
  }, null);
};
Empty.displayName = "AEmpty";
Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
Empty.inheritAttrs = false;
Empty.props = {
  prefixCls: String,
  image: PropTypes$1.any,
  description: PropTypes$1.any,
  imageStyle: {
    type: Object,
    default: void 0
  }
};
var Empty$1 = withInstall(Empty);
var RenderEmpty = function RenderEmpty2(props2) {
  var _useConfigInject = useConfigInject("empty", props2), prefixCls = _useConfigInject.prefixCls;
  var renderHtml = function renderHtml2(componentName) {
    switch (componentName) {
      case "Table":
      case "List":
        return Vue.createVNode(Empty$1, {
          "image": Empty$1.PRESENTED_IMAGE_SIMPLE
        }, null);
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return Vue.createVNode(Empty$1, {
          "image": Empty$1.PRESENTED_IMAGE_SIMPLE,
          "class": "".concat(prefixCls.value, "-small")
        }, null);
      default:
        return Vue.createVNode(Empty$1, null, null);
    }
  };
  return renderHtml(props2.componentName);
};
function renderEmpty(componentName) {
  return Vue.createVNode(RenderEmpty, {
    "componentName": componentName
  }, null);
}
var warned = {};
function warning$1(valid, message) {
}
function note(valid, message) {
}
function call(method, valid, message) {
  if (!valid && !warned[message]) {
    method(false, message);
    warned[message] = true;
  }
}
function warningOnce(valid, message) {
  call(warning$1, valid, message);
}
function noteOnce(valid, message) {
  call(note, valid, message);
}
var warning = function(valid, component) {
  var message = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  warningOnce(valid, "[antdv: ".concat(component, "] ").concat(message));
};
var ANT_MARK = "internalMark";
var LocaleProvider = Vue.defineComponent({
  name: "ALocaleProvider",
  props: {
    locale: {
      type: Object
    },
    ANT_MARK__: String
  },
  setup: function setup2(props2, _ref) {
    var slots = _ref.slots;
    warning(props2.ANT_MARK__ === ANT_MARK, "LocaleProvider", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead");
    var state = Vue.reactive({
      antLocale: _extends(_extends({}, props2.locale), {
        exist: true
      }),
      ANT_MARK__: ANT_MARK
    });
    Vue.provide("localeData", state);
    Vue.watch(function() {
      return props2.locale;
    }, function() {
      state.antLocale = _extends(_extends({}, props2.locale), {
        exist: true
      });
    }, {
      immediate: true
    });
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
  }
});
LocaleProvider.install = function(app) {
  app.component(LocaleProvider.name, LocaleProvider);
  return app;
};
var LocaleProvider$1 = withInstall(LocaleProvider);
globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
tuple$1("bottomLeft", "bottomRight", "topLeft", "topRight");
var getTransitionProps = function getTransitionProps2(transitionName2) {
  var opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var transitionProps = transitionName2 ? _extends({
    name: transitionName2,
    appear: true,
    enterFromClass: "".concat(transitionName2, "-enter ").concat(transitionName2, "-enter-prepare"),
    enterActiveClass: "".concat(transitionName2, "-enter ").concat(transitionName2, "-enter-prepare"),
    enterToClass: "".concat(transitionName2, "-enter ").concat(transitionName2, "-enter-active"),
    leaveFromClass: " ".concat(transitionName2, "-leave"),
    leaveActiveClass: "".concat(transitionName2, "-leave"),
    leaveToClass: "".concat(transitionName2, "-leave ").concat(transitionName2, "-leave-active")
  }, opt) : _extends({
    css: false
  }, opt);
  return transitionProps;
};
var getTransitionGroupProps = function getTransitionGroupProps2(transitionName2) {
  var opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var transitionProps = transitionName2 ? _extends({
    name: transitionName2,
    appear: true,
    appearActiveClass: "".concat(transitionName2),
    appearToClass: "".concat(transitionName2, "-appear ").concat(transitionName2, "-appear-active"),
    enterFromClass: "".concat(transitionName2, "-appear ").concat(transitionName2, "-enter ").concat(transitionName2, "-appear-prepare ").concat(transitionName2, "-enter-prepare"),
    enterActiveClass: "".concat(transitionName2),
    enterToClass: "".concat(transitionName2, "-enter ").concat(transitionName2, "-appear ").concat(transitionName2, "-appear-active ").concat(transitionName2, "-enter-active"),
    leaveActiveClass: "".concat(transitionName2, " ").concat(transitionName2, "-leave"),
    leaveToClass: "".concat(transitionName2, "-leave-active")
  }, opt) : _extends({
    css: false
  }, opt);
  return transitionProps;
};
var Transition = Vue.Transition;
var TransitionGroup = Vue.TransitionGroup;
var getTransitionName$1 = function getTransitionName2(rootPrefixCls, motion, transitionName2) {
  if (transitionName2 !== void 0) {
    return transitionName2;
  }
  return "".concat(rootPrefixCls, "-").concat(motion);
};
var Transition$1 = Transition;
var Notice = Vue.defineComponent({
  name: "Notice",
  inheritAttrs: false,
  props: ["prefixCls", "duration", "updateMark", "noticeKey", "closeIcon", "closable", "props", "onClick", "onClose", "holder", "visible"],
  setup: function setup3(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var closeTimer;
    var duration = Vue.computed(function() {
      return props2.duration === void 0 ? 1.5 : props2.duration;
    });
    var startCloseTimer = function startCloseTimer2() {
      if (duration.value) {
        closeTimer = setTimeout(function() {
          close3();
        }, duration.value * 1e3);
      }
    };
    var clearCloseTimer = function clearCloseTimer2() {
      if (closeTimer) {
        clearTimeout(closeTimer);
        closeTimer = null;
      }
    };
    var close3 = function close4(e2) {
      if (e2) {
        e2.stopPropagation();
      }
      clearCloseTimer();
      var onClose = props2.onClose, noticeKey = props2.noticeKey;
      if (onClose) {
        onClose(noticeKey);
      }
    };
    var restartCloseTimer = function restartCloseTimer2() {
      clearCloseTimer();
      startCloseTimer();
    };
    Vue.onMounted(function() {
      startCloseTimer();
    });
    Vue.onUnmounted(function() {
      clearCloseTimer();
    });
    Vue.watch([duration, function() {
      return props2.updateMark;
    }, function() {
      return props2.visible;
    }], function(_ref2, _ref3) {
      var _ref4 = _slicedToArray(_ref2, 3), preDuration = _ref4[0], preUpdateMark = _ref4[1], preVisible = _ref4[2];
      var _ref5 = _slicedToArray(_ref3, 3), newDuration = _ref5[0], newUpdateMark = _ref5[1], newVisible = _ref5[2];
      if (preDuration !== newDuration || preUpdateMark !== newUpdateMark || preVisible !== newVisible && newVisible) {
        restartCloseTimer();
      }
    }, {
      flush: "post"
    });
    return function() {
      var _a, _b;
      var prefixCls = props2.prefixCls, closable = props2.closable, _props$closeIcon = props2.closeIcon, closeIcon = _props$closeIcon === void 0 ? (_a = slots.closeIcon) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$closeIcon, onClick2 = props2.onClick, holder = props2.holder;
      var className = attrs.class, style = attrs.style;
      var componentClass = "".concat(prefixCls, "-notice");
      var dataOrAriaAttributeProps = Object.keys(attrs).reduce(function(acc, key2) {
        if (key2.substr(0, 5) === "data-" || key2.substr(0, 5) === "aria-" || key2 === "role") {
          acc[key2] = attrs[key2];
        }
        return acc;
      }, {});
      var node = Vue.createVNode("div", _objectSpread2$1({
        "class": classNames(componentClass, className, _defineProperty$T({}, "".concat(componentClass, "-closable"), closable)),
        "style": style,
        "onMouseenter": clearCloseTimer,
        "onMouseleave": startCloseTimer,
        "onClick": onClick2
      }, dataOrAriaAttributeProps), [Vue.createVNode("div", {
        "class": "".concat(componentClass, "-content")
      }, [(_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots)]), closable ? Vue.createVNode("a", {
        "tabindex": 0,
        "onClick": close3,
        "class": "".concat(componentClass, "-close")
      }, [closeIcon || Vue.createVNode("span", {
        "class": "".concat(componentClass, "-close-x")
      }, null)]) : null]);
      if (holder) {
        return Vue.createVNode(Vue.Teleport, {
          "to": holder
        }, {
          default: function _default5() {
            return node;
          }
        });
      }
      return node;
    };
  }
});
var __rest$G = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var seed = 0;
var now$3 = Date.now();
function getUuid() {
  var id = seed;
  seed += 1;
  return "rcNotification_".concat(now$3, "_").concat(id);
}
var Notification = Vue.defineComponent({
  name: "Notification",
  inheritAttrs: false,
  props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon"],
  setup: function setup4(props2, _ref) {
    var attrs = _ref.attrs, expose = _ref.expose, slots = _ref.slots;
    var hookRefs = /* @__PURE__ */ new Map();
    var notices = Vue.ref([]);
    var transitionProps = Vue.computed(function() {
      var prefixCls = props2.prefixCls, _props$animation = props2.animation, animation = _props$animation === void 0 ? "fade" : _props$animation;
      var name = props2.transitionName;
      if (!name && animation) {
        name = "".concat(prefixCls, "-").concat(animation);
      }
      return getTransitionGroupProps(name);
    });
    var add = function add2(originNotice, holderCallback) {
      var key2 = originNotice.key || getUuid();
      var notice2 = _extends(_extends({}, originNotice), {
        key: key2
      });
      var maxCount2 = props2.maxCount;
      var noticeIndex = notices.value.map(function(v2) {
        return v2.notice.key;
      }).indexOf(key2);
      var updatedNotices = notices.value.concat();
      if (noticeIndex !== -1) {
        updatedNotices.splice(noticeIndex, 1, {
          notice: notice2,
          holderCallback
        });
      } else {
        if (maxCount2 && notices.value.length >= maxCount2) {
          notice2.key = updatedNotices[0].notice.key;
          notice2.updateMark = getUuid();
          notice2.userPassKey = key2;
          updatedNotices.shift();
        }
        updatedNotices.push({
          notice: notice2,
          holderCallback
        });
      }
      notices.value = updatedNotices;
    };
    var remove = function remove2(removeKey) {
      notices.value = notices.value.filter(function(_ref2) {
        var _ref2$notice = _ref2.notice, key2 = _ref2$notice.key, userPassKey = _ref2$notice.userPassKey;
        var mergedKey = userPassKey || key2;
        return mergedKey !== removeKey;
      });
    };
    expose({
      add,
      remove,
      notices
    });
    return function() {
      var _className;
      var _a;
      var prefixCls = props2.prefixCls, _props$closeIcon = props2.closeIcon, closeIcon = _props$closeIcon === void 0 ? (_a = slots.closeIcon) === null || _a === void 0 ? void 0 : _a.call(slots, {
        prefixCls
      }) : _props$closeIcon;
      var noticeNodes = notices.value.map(function(_ref3, index2) {
        var notice2 = _ref3.notice, holderCallback = _ref3.holderCallback;
        var updateMark = index2 === notices.value.length - 1 ? notice2.updateMark : void 0;
        var key2 = notice2.key, userPassKey = notice2.userPassKey;
        var content = notice2.content;
        var noticeProps = _extends(_extends(_extends({
          prefixCls,
          closeIcon: typeof closeIcon === "function" ? closeIcon({
            prefixCls
          }) : closeIcon
        }, notice2), notice2.props), {
          key: key2,
          noticeKey: userPassKey || key2,
          updateMark,
          onClose: function onClose(noticeKey) {
            var _a2;
            remove(noticeKey);
            (_a2 = notice2.onClose) === null || _a2 === void 0 ? void 0 : _a2.call(notice2);
          },
          onClick: notice2.onClick
        });
        if (holderCallback) {
          return Vue.createVNode("div", {
            "key": key2,
            "class": "".concat(prefixCls, "-hook-holder"),
            "ref": function ref(div) {
              if (typeof key2 === "undefined") {
                return;
              }
              if (div) {
                hookRefs.set(key2, div);
                holderCallback(div, noticeProps);
              } else {
                hookRefs.delete(key2);
              }
            }
          }, null);
        }
        return Vue.createVNode(Notice, noticeProps, {
          default: function _default5() {
            return [typeof content === "function" ? content({
              prefixCls
            }) : content];
          }
        });
      });
      var className = (_className = {}, _defineProperty$T(_className, prefixCls, 1), _defineProperty$T(_className, attrs.class, !!attrs.class), _className);
      return Vue.createVNode("div", {
        "class": className,
        "style": attrs.style || {
          top: "65px",
          left: "50%"
        }
      }, [Vue.createVNode(Vue.TransitionGroup, _objectSpread2$1({
        "tag": "div"
      }, transitionProps.value), {
        default: function _default5() {
          return [noticeNodes];
        }
      })]);
    };
  }
});
Notification.newInstance = function newNotificationInstance(properties, callback) {
  var _a = properties || {}, _a$name = _a.name, name = _a$name === void 0 ? "notification" : _a$name, getContainer4 = _a.getContainer, appContext = _a.appContext, customizePrefixCls = _a.prefixCls, customRootPrefixCls = _a.rootPrefixCls, customTransitionName = _a.transitionName, hasTransitionName2 = _a.hasTransitionName, props2 = __rest$G(_a, ["name", "getContainer", "appContext", "prefixCls", "rootPrefixCls", "transitionName", "hasTransitionName"]);
  var div = document.createElement("div");
  if (getContainer4) {
    var root2 = getContainer4();
    root2.appendChild(div);
  } else {
    document.body.appendChild(div);
  }
  var Wrapper = Vue.defineComponent({
    name: "NotificationWrapper",
    setup: function setup153(_props, _ref4) {
      var attrs = _ref4.attrs;
      var notiRef = Vue.ref();
      Vue.onMounted(function() {
        callback({
          notice: function notice2(noticeProps) {
            var _a2;
            (_a2 = notiRef.value) === null || _a2 === void 0 ? void 0 : _a2.add(noticeProps);
          },
          removeNotice: function removeNotice(key2) {
            var _a2;
            (_a2 = notiRef.value) === null || _a2 === void 0 ? void 0 : _a2.remove(key2);
          },
          destroy: function destroy3() {
            Vue.render(null, div);
            if (div.parentNode) {
              div.parentNode.removeChild(div);
            }
          },
          component: notiRef
        });
      });
      return function() {
        var global2 = globalConfigForApi;
        var prefixCls = global2.getPrefixCls(name, customizePrefixCls);
        var rootPrefixCls = global2.getRootPrefixCls(customRootPrefixCls, prefixCls);
        var transitionName2 = hasTransitionName2 ? customTransitionName : "".concat(rootPrefixCls, "-").concat(customTransitionName);
        return Vue.createVNode(ConfigProvider, _objectSpread2$1(_objectSpread2$1({}, global2), {}, {
          "notUpdateGlobalConfig": true,
          "prefixCls": rootPrefixCls
        }), {
          default: function _default5() {
            return [Vue.createVNode(Notification, _objectSpread2$1(_objectSpread2$1({
              "ref": notiRef
            }, attrs), {}, {
              "prefixCls": prefixCls,
              "transitionName": transitionName2
            }), null)];
          }
        });
      };
    }
  });
  var vm = Vue.createVNode(Wrapper, props2);
  vm.appContext = appContext || vm.appContext;
  Vue.render(vm, div);
};
var Notification$1 = Notification;
var ExclamationCircleFilled$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
      }
    }]
  },
  "name": "exclamation-circle",
  "theme": "filled"
};
var ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
function _objectSpread$N(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$O(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$O(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ExclamationCircleFilled = function ExclamationCircleFilled2(props2, context) {
  var p2 = _objectSpread$N({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$N({}, p2, {
    "icon": ExclamationCircleFilledSvg
  }), null);
};
ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
ExclamationCircleFilled.inheritAttrs = false;
var ExclamationCircleFilled$1 = ExclamationCircleFilled;
var CloseCircleFilled$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z"
      }
    }]
  },
  "name": "close-circle",
  "theme": "filled"
};
var CloseCircleFilledSvg = CloseCircleFilled$2;
function _objectSpread$M(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$N(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$N(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CloseCircleFilled = function CloseCircleFilled2(props2, context) {
  var p2 = _objectSpread$M({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$M({}, p2, {
    "icon": CloseCircleFilledSvg
  }), null);
};
CloseCircleFilled.displayName = "CloseCircleFilled";
CloseCircleFilled.inheritAttrs = false;
var CloseCircleFilled$1 = CloseCircleFilled;
var CheckCircleFilled$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z"
      }
    }]
  },
  "name": "check-circle",
  "theme": "filled"
};
var CheckCircleFilledSvg = CheckCircleFilled$2;
function _objectSpread$L(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$M(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$M(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CheckCircleFilled = function CheckCircleFilled2(props2, context) {
  var p2 = _objectSpread$L({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$L({}, p2, {
    "icon": CheckCircleFilledSvg
  }), null);
};
CheckCircleFilled.displayName = "CheckCircleFilled";
CheckCircleFilled.inheritAttrs = false;
var CheckCircleFilled$1 = CheckCircleFilled;
var InfoCircleFilled$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
      }
    }]
  },
  "name": "info-circle",
  "theme": "filled"
};
var InfoCircleFilledSvg = InfoCircleFilled$2;
function _objectSpread$K(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$L(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$L(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var InfoCircleFilled = function InfoCircleFilled2(props2, context) {
  var p2 = _objectSpread$K({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$K({}, p2, {
    "icon": InfoCircleFilledSvg
  }), null);
};
InfoCircleFilled.displayName = "InfoCircleFilled";
InfoCircleFilled.inheritAttrs = false;
var InfoCircleFilled$1 = InfoCircleFilled;
var defaultDuration$1 = 3;
var defaultTop$1;
var messageInstance;
var key = 1;
var localPrefixCls = "";
var transitionName = "move-up";
var hasTransitionName = false;
var getContainer$1 = function getContainer2() {
  return document.body;
};
var maxCount$1;
var rtl$1 = false;
function getKeyThenIncreaseKey() {
  return key++;
}
function setMessageConfig(options) {
  if (options.top !== void 0) {
    defaultTop$1 = options.top;
    messageInstance = null;
  }
  if (options.duration !== void 0) {
    defaultDuration$1 = options.duration;
  }
  if (options.prefixCls !== void 0) {
    localPrefixCls = options.prefixCls;
  }
  if (options.getContainer !== void 0) {
    getContainer$1 = options.getContainer;
    messageInstance = null;
  }
  if (options.transitionName !== void 0) {
    transitionName = options.transitionName;
    messageInstance = null;
    hasTransitionName = true;
  }
  if (options.maxCount !== void 0) {
    maxCount$1 = options.maxCount;
    messageInstance = null;
  }
  if (options.rtl !== void 0) {
    rtl$1 = options.rtl;
  }
}
function getMessageInstance(args, callback) {
  if (messageInstance) {
    callback(messageInstance);
    return;
  }
  Notification$1.newInstance({
    appContext: args.appContext,
    prefixCls: args.prefixCls || localPrefixCls,
    rootPrefixCls: args.rootPrefixCls,
    transitionName,
    hasTransitionName,
    style: {
      top: defaultTop$1
    },
    getContainer: getContainer$1 || args.getPopupContainer,
    maxCount: maxCount$1,
    name: "message"
  }, function(instance) {
    if (messageInstance) {
      callback(messageInstance);
      return;
    }
    messageInstance = instance;
    callback(instance);
  });
}
var typeToIcon$1 = {
  info: InfoCircleFilled$1,
  success: CheckCircleFilled$1,
  error: CloseCircleFilled$1,
  warning: ExclamationCircleFilled$1,
  loading: LoadingOutlined$1
};
function notice$1(args) {
  var duration = args.duration !== void 0 ? args.duration : defaultDuration$1;
  var target = args.key || getKeyThenIncreaseKey();
  var closePromise = new Promise(function(resolve) {
    var callback = function callback2() {
      if (typeof args.onClose === "function") {
        args.onClose();
      }
      return resolve(true);
    };
    getMessageInstance(args, function(instance) {
      instance.notice({
        key: target,
        duration,
        style: args.style || {},
        class: args.class,
        content: function content(_ref) {
          var _classNames;
          var prefixCls = _ref.prefixCls;
          var Icon3 = typeToIcon$1[args.type];
          var iconNode = Icon3 ? Vue.createVNode(Icon3, null, null) : "";
          var messageClass = classNames("".concat(prefixCls, "-custom-content"), (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls, "-").concat(args.type), args.type), _defineProperty$T(_classNames, "".concat(prefixCls, "-rtl"), rtl$1 === true), _classNames));
          return Vue.createVNode("div", {
            "class": messageClass
          }, [typeof args.icon === "function" ? args.icon() : args.icon || iconNode, Vue.createVNode("span", null, [typeof args.content === "function" ? args.content() : args.content])]);
        },
        onClose: callback,
        onClick: args.onClick
      });
    });
  });
  var result = function result2() {
    if (messageInstance) {
      messageInstance.removeNotice(target);
    }
  };
  result.then = function(filled, rejected) {
    return closePromise.then(filled, rejected);
  };
  result.promise = closePromise;
  return result;
}
function isArgsProps(content) {
  return Object.prototype.toString.call(content) === "[object Object]" && !!content.content;
}
var api$1 = {
  open: notice$1,
  config: setMessageConfig,
  destroy: function destroy(messageKey) {
    if (messageInstance) {
      if (messageKey) {
        var _messageInstance = messageInstance, removeNotice = _messageInstance.removeNotice;
        removeNotice(messageKey);
      } else {
        var _messageInstance2 = messageInstance, destroy3 = _messageInstance2.destroy;
        destroy3();
        messageInstance = null;
      }
    }
  }
};
function attachTypeApi(originalApi, type2) {
  originalApi[type2] = function(content, duration, onClose) {
    if (isArgsProps(content)) {
      return originalApi.open(_extends(_extends({}, content), {
        type: type2
      }));
    }
    if (typeof duration === "function") {
      onClose = duration;
      duration = void 0;
    }
    return originalApi.open({
      content,
      duration,
      type: type2,
      onClose
    });
  };
}
["success", "info", "warning", "error", "loading"].forEach(function(type2) {
  return attachTypeApi(api$1, type2);
});
api$1.warn = api$1.warning;
var _message = api$1;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var runtime = { exports: {} };
(function(module2) {
  var runtime2 = function(exports2) {
    var Op = Object.prototype;
    var hasOwn3 = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key2, value) {
      Object.defineProperty(obj, key2, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key2];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function(obj, key2, value) {
        return obj[key2] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator2 = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator2._invoke = makeInvokeMethod(innerFn, self2, context);
      return generator2;
    }
    exports2.wrap = wrap;
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn3.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports2.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports2.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports2.awrap = function(arg) {
      return {
        __await: arg
      };
    };
    function AsyncIterator(generator2, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator2[method], generator2, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn3.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
      this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    });
    exports2.AsyncIterator = AsyncIterator;
    exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0)
        PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self2, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context.method = method;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self2, context);
          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        context.delegate = null;
        if (context.method === "throw") {
          if (delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }
      context.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    define(Gp, iteratorSymbol, function() {
      return this;
    });
    define(Gp, "toString", function() {
      return "[object Generator]";
    });
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports2.keys = function(object) {
      var keys2 = [];
      for (var key2 in object) {
        keys2.push(key2);
      }
      keys2.reverse();
      return function next2() {
        while (keys2.length) {
          var key3 = keys2.pop();
          if (key3 in object) {
            next2.value = key3;
            next2.done = false;
            return next2;
          }
        }
        next2.done = true;
        return next2;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i2 = -1, next2 = function next3() {
            while (++i2 < iterable.length) {
              if (hasOwn3.call(iterable, i2)) {
                next3.value = iterable[i2];
                next3.done = false;
                return next3;
              }
            }
            next3.value = undefined$1;
            next3.done = true;
            return next3;
          };
          return next2.next = next2;
        }
      }
      return {
        next: doneResult
      };
    }
    exports2.values = values;
    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }
    Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn3.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }
          return !!caught;
        }
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn3.call(entry, "catchLoc");
            var hasFinally = hasOwn3.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type2, arg) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc <= this.prev && hasOwn3.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type2 === "break" || type2 === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type2;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function(tryLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };
    return exports2;
  }(module2.exports);
  try {
    regeneratorRuntime = runtime2;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime2;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime2);
    }
  }
})(runtime);
var regenerator = runtime.exports;
var CheckCircleOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
      }
    }]
  },
  "name": "check-circle",
  "theme": "outlined"
};
var CheckCircleOutlinedSvg = CheckCircleOutlined$2;
function _objectSpread$J(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$K(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$K(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CheckCircleOutlined = function CheckCircleOutlined2(props2, context) {
  var p2 = _objectSpread$J({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$J({}, p2, {
    "icon": CheckCircleOutlinedSvg
  }), null);
};
CheckCircleOutlined.displayName = "CheckCircleOutlined";
CheckCircleOutlined.inheritAttrs = false;
var CheckCircleOutlined$1 = CheckCircleOutlined;
var InfoCircleOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z"
      }
    }]
  },
  "name": "info-circle",
  "theme": "outlined"
};
var InfoCircleOutlinedSvg = InfoCircleOutlined$2;
function _objectSpread$I(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$J(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$J(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var InfoCircleOutlined = function InfoCircleOutlined2(props2, context) {
  var p2 = _objectSpread$I({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$I({}, p2, {
    "icon": InfoCircleOutlinedSvg
  }), null);
};
InfoCircleOutlined.displayName = "InfoCircleOutlined";
InfoCircleOutlined.inheritAttrs = false;
var InfoCircleOutlined$1 = InfoCircleOutlined;
var CloseCircleOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M685.4 354.8c0-4.4-3.6-8-8-8l-66 .3L512 465.6l-99.3-118.4-66.1-.3c-4.4 0-8 3.5-8 8 0 1.9.7 3.7 1.9 5.2l130.1 155L340.5 670a8.32 8.32 0 00-1.9 5.2c0 4.4 3.6 8 8 8l66.1-.3L512 564.4l99.3 118.4 66 .3c4.4 0 8-3.5 8-8 0-1.9-.7-3.7-1.9-5.2L553.5 515l130.1-155c1.2-1.4 1.8-3.3 1.8-5.2z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M512 65C264.6 65 64 265.6 64 513s200.6 448 448 448 448-200.6 448-448S759.4 65 512 65zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
      }
    }]
  },
  "name": "close-circle",
  "theme": "outlined"
};
var CloseCircleOutlinedSvg = CloseCircleOutlined$2;
function _objectSpread$H(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$I(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$I(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CloseCircleOutlined = function CloseCircleOutlined2(props2, context) {
  var p2 = _objectSpread$H({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$H({}, p2, {
    "icon": CloseCircleOutlinedSvg
  }), null);
};
CloseCircleOutlined.displayName = "CloseCircleOutlined";
CloseCircleOutlined.inheritAttrs = false;
var CloseCircleOutlined$1 = CloseCircleOutlined;
var ExclamationCircleOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z"
      }
    }]
  },
  "name": "exclamation-circle",
  "theme": "outlined"
};
var ExclamationCircleOutlinedSvg = ExclamationCircleOutlined$2;
function _objectSpread$G(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$H(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$H(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ExclamationCircleOutlined = function ExclamationCircleOutlined2(props2, context) {
  var p2 = _objectSpread$G({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$G({}, p2, {
    "icon": ExclamationCircleOutlinedSvg
  }), null);
};
ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined";
ExclamationCircleOutlined.inheritAttrs = false;
var ExclamationCircleOutlined$1 = ExclamationCircleOutlined;
var CloseOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z"
      }
    }]
  },
  "name": "close",
  "theme": "outlined"
};
var CloseOutlinedSvg = CloseOutlined$2;
function _objectSpread$F(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$G(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$G(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CloseOutlined = function CloseOutlined2(props2, context) {
  var p2 = _objectSpread$F({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$F({}, p2, {
    "icon": CloseOutlinedSvg
  }), null);
};
CloseOutlined.displayName = "CloseOutlined";
CloseOutlined.inheritAttrs = false;
var CloseOutlined$1 = CloseOutlined;
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator2) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator2["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
var notificationInstance = {};
var defaultDuration = 4.5;
var defaultTop = "24px";
var defaultBottom = "24px";
var defaultPrefixCls$1 = "";
var defaultPlacement = "topRight";
var defaultGetContainer = function defaultGetContainer2() {
  return document.body;
};
var defaultCloseIcon = null;
var rtl = false;
var maxCount;
function setNotificationConfig(options) {
  var duration = options.duration, placement = options.placement, bottom = options.bottom, top = options.top, getContainer4 = options.getContainer, closeIcon = options.closeIcon, prefixCls = options.prefixCls;
  if (prefixCls !== void 0) {
    defaultPrefixCls$1 = prefixCls;
  }
  if (duration !== void 0) {
    defaultDuration = duration;
  }
  if (placement !== void 0) {
    defaultPlacement = placement;
  }
  if (bottom !== void 0) {
    defaultBottom = typeof bottom === "number" ? "".concat(bottom, "px") : bottom;
  }
  if (top !== void 0) {
    defaultTop = typeof top === "number" ? "".concat(top, "px") : top;
  }
  if (getContainer4 !== void 0) {
    defaultGetContainer = getContainer4;
  }
  if (closeIcon !== void 0) {
    defaultCloseIcon = closeIcon;
  }
  if (options.rtl !== void 0) {
    rtl = options.rtl;
  }
  if (options.maxCount !== void 0) {
    maxCount = options.maxCount;
  }
}
function getPlacementStyle(placement) {
  var top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultTop;
  var bottom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultBottom;
  var style;
  switch (placement) {
    case "topLeft":
      style = {
        left: "0px",
        top,
        bottom: "auto"
      };
      break;
    case "topRight":
      style = {
        right: "0px",
        top,
        bottom: "auto"
      };
      break;
    case "bottomLeft":
      style = {
        left: "0px",
        top: "auto",
        bottom
      };
      break;
    default:
      style = {
        right: "0px",
        top: "auto",
        bottom
      };
      break;
  }
  return style;
}
function getNotificationInstance(_ref, callback) {
  var customizePrefixCls = _ref.prefixCls, _ref$placement = _ref.placement, placement = _ref$placement === void 0 ? defaultPlacement : _ref$placement, _ref$getContainer = _ref.getContainer, getContainer4 = _ref$getContainer === void 0 ? defaultGetContainer : _ref$getContainer, top = _ref.top, bottom = _ref.bottom, _ref$closeIcon = _ref.closeIcon, _closeIcon = _ref$closeIcon === void 0 ? defaultCloseIcon : _ref$closeIcon, appContext = _ref.appContext;
  var _globalConfig = globalConfig(), getPrefixCls2 = _globalConfig.getPrefixCls;
  var prefixCls = getPrefixCls2("notification", customizePrefixCls || defaultPrefixCls$1);
  var cacheKey = "".concat(prefixCls, "-").concat(placement, "-").concat(rtl);
  var cacheInstance = notificationInstance[cacheKey];
  if (cacheInstance) {
    Promise.resolve(cacheInstance).then(function(instance) {
      callback(instance);
    });
    return;
  }
  var notificationClass = classNames("".concat(prefixCls, "-").concat(placement), _defineProperty$T({}, "".concat(prefixCls, "-rtl"), rtl === true));
  Notification$1.newInstance({
    name: "notification",
    prefixCls: customizePrefixCls || defaultPrefixCls$1,
    class: notificationClass,
    style: getPlacementStyle(placement, top, bottom),
    appContext,
    getContainer: getContainer4,
    closeIcon: function closeIcon(_ref2) {
      var prefixCls2 = _ref2.prefixCls;
      var closeIconToRender = Vue.createVNode("span", {
        "class": "".concat(prefixCls2, "-close-x")
      }, [renderHelper(_closeIcon, {}, Vue.createVNode(CloseOutlined$1, {
        "class": "".concat(prefixCls2, "-close-icon")
      }, null))]);
      return closeIconToRender;
    },
    maxCount,
    hasTransitionName: true
  }, function(notification) {
    notificationInstance[cacheKey] = notification;
    callback(notification);
  });
}
var typeToIcon = {
  success: CheckCircleOutlined$1,
  info: InfoCircleOutlined$1,
  error: CloseCircleOutlined$1,
  warning: ExclamationCircleOutlined$1
};
function notice(args) {
  var icon = args.icon, type2 = args.type, description = args.description, message = args.message, btn = args.btn;
  var duration = args.duration === void 0 ? defaultDuration : args.duration;
  getNotificationInstance(args, function(notification) {
    notification.notice({
      content: function content(_ref3) {
        var outerPrefixCls = _ref3.prefixCls;
        var prefixCls = "".concat(outerPrefixCls, "-notice");
        var iconNode = null;
        if (icon) {
          iconNode = function iconNode2() {
            return Vue.createVNode("span", {
              "class": "".concat(prefixCls, "-icon")
            }, [renderHelper(icon)]);
          };
        } else if (type2) {
          var Icon3 = typeToIcon[type2];
          iconNode = function iconNode2() {
            return Vue.createVNode(Icon3, {
              "class": "".concat(prefixCls, "-icon ").concat(prefixCls, "-icon-").concat(type2)
            }, null);
          };
        }
        return Vue.createVNode("div", {
          "class": iconNode ? "".concat(prefixCls, "-with-icon") : ""
        }, [iconNode && iconNode(), Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-message")
        }, [!description && iconNode ? Vue.createVNode("span", {
          "class": "".concat(prefixCls, "-message-single-line-auto-margin")
        }, null) : null, renderHelper(message)]), Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-description")
        }, [renderHelper(description)]), btn ? Vue.createVNode("span", {
          "class": "".concat(prefixCls, "-btn")
        }, [renderHelper(btn)]) : null]);
      },
      duration,
      closable: true,
      onClose: args.onClose,
      onClick: args.onClick,
      key: args.key,
      style: args.style || {},
      class: args.class
    });
  });
}
var api = {
  open: notice,
  close: function close(key2) {
    Object.keys(notificationInstance).forEach(function(cacheKey) {
      return Promise.resolve(notificationInstance[cacheKey]).then(function(instance) {
        instance.removeNotice(key2);
      });
    });
  },
  config: setNotificationConfig,
  destroy: function destroy2() {
    Object.keys(notificationInstance).forEach(function(cacheKey) {
      Promise.resolve(notificationInstance[cacheKey]).then(function(instance) {
        instance.destroy();
      });
      delete notificationInstance[cacheKey];
    });
  }
};
var iconTypes = ["success", "info", "warning", "error"];
iconTypes.forEach(function(type2) {
  api[type2] = function(args) {
    return api.open(_extends(_extends({}, args), {
      type: type2
    }));
  };
});
api.warn = api.warning;
var _notification = api;
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var MARK_KEY = "vc-util-key";
function getMark() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
  if (mark) {
    return mark.startsWith("data-") ? mark : "data-".concat(mark);
  }
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function injectCSS(css2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _a, _b;
  if (!canUseDom()) {
    return null;
  }
  var styleNode = document.createElement("style");
  if ((_a = option.csp) === null || _a === void 0 ? void 0 : _a.nonce) {
    styleNode.nonce = (_b = option.csp) === null || _b === void 0 ? void 0 : _b.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer(option);
  var firstChild = container.firstChild;
  if (option.prepend && container.prepend) {
    container.prepend(styleNode);
  } else if (option.prepend && firstChild) {
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
var containerCache = /* @__PURE__ */ new Map();
function findExistNode(key2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer(option);
  return Array.from(containerCache.get(container).children).find(function(node) {
    return node.tagName === "STYLE" && node.getAttribute(getMark(option)) === key2;
  });
}
function updateCSS(css2, key2) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _a, _b, _c;
  var container = getContainer(option);
  if (!containerCache.has(container)) {
    var placeholderStyle = injectCSS("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache.set(container, parentNode);
    parentNode.removeChild(placeholderStyle);
  }
  var existNode = findExistNode(key2, option);
  if (existNode) {
    if (((_a = option.csp) === null || _a === void 0 ? void 0 : _a.nonce) && existNode.nonce !== ((_b = option.csp) === null || _b === void 0 ? void 0 : _b.nonce)) {
      existNode.nonce = (_c = option.csp) === null || _c === void 0 ? void 0 : _c.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS(css2, option);
  newNode.setAttribute(getMark(option), key2);
  return newNode;
}
var devWarning = function(valid, component, message) {
  warningOnce(valid, "[ant-design-vue: ".concat(component, "] ").concat(message));
};
var dynamicStyleMark = "-ant-".concat(Date.now(), "-").concat(Math.random());
function registerTheme(globalPrefixCls, theme) {
  var variables = {};
  var formatColor = function formatColor2(color, updater) {
    var clone2 = color.clone();
    clone2 = (updater === null || updater === void 0 ? void 0 : updater(clone2)) || clone2;
    return clone2.toRgbString();
  };
  var fillColor = function fillColor2(colorVal, type2) {
    var baseColor = new TinyColor(colorVal);
    var colorPalettes = generate$1(baseColor.toRgbString());
    variables["".concat(type2, "-color")] = formatColor(baseColor);
    variables["".concat(type2, "-color-disabled")] = colorPalettes[1];
    variables["".concat(type2, "-color-hover")] = colorPalettes[4];
    variables["".concat(type2, "-color-active")] = colorPalettes[7];
    variables["".concat(type2, "-color-outline")] = baseColor.clone().setAlpha(0.2).toRgbString();
    variables["".concat(type2, "-color-deprecated-bg")] = colorPalettes[1];
    variables["".concat(type2, "-color-deprecated-border")] = colorPalettes[3];
  };
  if (theme.primaryColor) {
    fillColor(theme.primaryColor, "primary");
    var primaryColor = new TinyColor(theme.primaryColor);
    var primaryColors = generate$1(primaryColor.toRgbString());
    primaryColors.forEach(function(color, index2) {
      variables["primary-".concat(index2 + 1)] = color;
    });
    variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, function(c2) {
      return c2.lighten(35);
    });
    variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, function(c2) {
      return c2.lighten(20);
    });
    variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, function(c2) {
      return c2.tint(20);
    });
    variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, function(c2) {
      return c2.tint(50);
    });
    variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, function(c2) {
      return c2.setAlpha(c2.getAlpha() * 0.12);
    });
    var primaryActiveColor = new TinyColor(primaryColors[0]);
    variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, function(c2) {
      return c2.setAlpha(c2.getAlpha() * 0.3);
    });
    variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, function(c2) {
      return c2.darken(2);
    });
  }
  if (theme.successColor) {
    fillColor(theme.successColor, "success");
  }
  if (theme.warningColor) {
    fillColor(theme.warningColor, "warning");
  }
  if (theme.errorColor) {
    fillColor(theme.errorColor, "error");
  }
  if (theme.infoColor) {
    fillColor(theme.infoColor, "info");
  }
  var cssList = Object.keys(variables).map(function(key2) {
    return "--".concat(globalPrefixCls, "-").concat(key2, ": ").concat(variables[key2], ";");
  });
  if (canUseDom()) {
    updateCSS("\n  :root {\n    ".concat(cssList.join("\n"), "\n  }\n  "), "".concat(dynamicStyleMark, "-dynamic-theme"));
  } else {
    devWarning(false, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
  }
}
var GlobalFormContextKey = Symbol("GlobalFormContextKey");
var useProvideGlobalForm = function useProvideGlobalForm2(state) {
  Vue.provide(GlobalFormContextKey, state);
};
var configProviderProps = function configProviderProps2() {
  return {
    getTargetContainer: {
      type: Function
    },
    getPopupContainer: {
      type: Function
    },
    prefixCls: String,
    getPrefixCls: {
      type: Function
    },
    renderEmpty: {
      type: Function
    },
    transformCellText: {
      type: Function
    },
    csp: {
      type: Object,
      default: void 0
    },
    input: {
      type: Object
    },
    autoInsertSpaceInButton: {
      type: Boolean,
      default: void 0
    },
    locale: {
      type: Object,
      default: void 0
    },
    pageHeader: {
      type: Object
    },
    componentSize: {
      type: String
    },
    direction: {
      type: String
    },
    space: {
      type: Object
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    dropdownMatchSelectWidth: {
      type: [Number, Boolean],
      default: true
    },
    form: {
      type: Object,
      default: void 0
    },
    notUpdateGlobalConfig: Boolean
  };
};
var defaultPrefixCls = "ant";
function getGlobalPrefixCls() {
  return globalConfigForApi.prefixCls || defaultPrefixCls;
}
var globalConfigByCom = Vue.reactive({});
var globalConfigBySet = Vue.reactive({});
var globalConfigForApi = Vue.reactive({});
Vue.watchEffect(function() {
  _extends(globalConfigForApi, globalConfigByCom, globalConfigBySet);
  globalConfigForApi.prefixCls = getGlobalPrefixCls();
  globalConfigForApi.getPrefixCls = function(suffixCls, customizePrefixCls) {
    if (customizePrefixCls)
      return customizePrefixCls;
    return suffixCls ? "".concat(globalConfigForApi.prefixCls, "-").concat(suffixCls) : globalConfigForApi.prefixCls;
  };
  globalConfigForApi.getRootPrefixCls = function(rootPrefixCls, customizePrefixCls) {
    if (rootPrefixCls) {
      return rootPrefixCls;
    }
    if (globalConfigForApi.prefixCls) {
      return globalConfigForApi.prefixCls;
    }
    if (customizePrefixCls && customizePrefixCls.includes("-")) {
      return customizePrefixCls.replace(/^(.*)-[^-]*$/, "$1");
    }
    return getGlobalPrefixCls();
  };
});
var stopWatchEffect;
var setGlobalConfig = function setGlobalConfig2(params) {
  if (stopWatchEffect) {
    stopWatchEffect();
  }
  stopWatchEffect = Vue.watchEffect(function() {
    _extends(globalConfigBySet, Vue.reactive(params));
  });
  if (params.theme) {
    registerTheme(getGlobalPrefixCls(), params.theme);
  }
};
var globalConfig = function globalConfig2() {
  return {
    getPrefixCls: function getPrefixCls2(suffixCls, customizePrefixCls) {
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? "".concat(getGlobalPrefixCls(), "-").concat(suffixCls) : getGlobalPrefixCls();
    },
    getRootPrefixCls: function getRootPrefixCls(rootPrefixCls, customizePrefixCls) {
      if (rootPrefixCls) {
        return rootPrefixCls;
      }
      if (globalConfigForApi.prefixCls) {
        return globalConfigForApi.prefixCls;
      }
      if (customizePrefixCls && customizePrefixCls.includes("-")) {
        return customizePrefixCls.replace(/^(.*)-[^-]*$/, "$1");
      }
      return getGlobalPrefixCls();
    }
  };
};
var ConfigProvider = Vue.defineComponent({
  name: "AConfigProvider",
  inheritAttrs: false,
  props: configProviderProps(),
  setup: function setup5(props2, _ref) {
    var slots = _ref.slots;
    var getPrefixCls2 = function getPrefixCls3(suffixCls, customizePrefixCls) {
      var _props$prefixCls = props2.prefixCls, prefixCls = _props$prefixCls === void 0 ? "ant" : _props$prefixCls;
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? "".concat(prefixCls, "-").concat(suffixCls) : prefixCls;
    };
    var renderEmptyComponent = function renderEmptyComponent2(name) {
      var renderEmpty$1 = props2.renderEmpty || slots.renderEmpty || renderEmpty;
      return renderEmpty$1(name);
    };
    var getPrefixClsWrapper = function getPrefixClsWrapper2(suffixCls, customizePrefixCls) {
      var prefixCls = props2.prefixCls;
      if (customizePrefixCls)
        return customizePrefixCls;
      var mergedPrefixCls = prefixCls || getPrefixCls2("");
      return suffixCls ? "".concat(mergedPrefixCls, "-").concat(suffixCls) : mergedPrefixCls;
    };
    var configProvider = Vue.reactive(_extends(_extends({}, props2), {
      getPrefixCls: getPrefixClsWrapper,
      renderEmpty: renderEmptyComponent
    }));
    Object.keys(props2).forEach(function(key2) {
      Vue.watch(function() {
        return props2[key2];
      }, function() {
        configProvider[key2] = props2[key2];
      });
    });
    if (!props2.notUpdateGlobalConfig) {
      _extends(globalConfigByCom, configProvider);
      Vue.watch(configProvider, function() {
        _extends(globalConfigByCom, configProvider);
      });
    }
    var validateMessagesRef = Vue.computed(function() {
      var _a, _b;
      var validateMessages = {};
      if (props2.locale) {
        validateMessages = ((_a = props2.locale.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || ((_b = defaultLocale.Form) === null || _b === void 0 ? void 0 : _b.defaultValidateMessages) || {};
      }
      if (props2.form && props2.form.validateMessages) {
        validateMessages = _extends(_extends({}, validateMessages), props2.form.validateMessages);
      }
      return validateMessages;
    });
    useProvideGlobalForm({
      validateMessages: validateMessagesRef
    });
    Vue.provide("configProvider", configProvider);
    var renderProvider = function renderProvider2(legacyLocale) {
      var _a;
      return Vue.createVNode(LocaleProvider$1, {
        "locale": props2.locale || legacyLocale,
        "ANT_MARK__": ANT_MARK
      }, {
        default: function _default5() {
          return [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)];
        }
      });
    };
    Vue.watchEffect(function() {
      if (props2.direction) {
        _message.config({
          rtl: props2.direction === "rtl"
        });
        _notification.config({
          rtl: props2.direction === "rtl"
        });
      }
    });
    return function() {
      return Vue.createVNode(LocaleReceiver, {
        "children": function children(_2, __, legacyLocale) {
          return renderProvider(legacyLocale);
        }
      }, null);
    };
  }
});
var defaultConfigProvider = Vue.reactive({
  getPrefixCls: function getPrefixCls(suffixCls, customizePrefixCls) {
    if (customizePrefixCls)
      return customizePrefixCls;
    return suffixCls ? "ant-".concat(suffixCls) : "ant";
  },
  renderEmpty,
  direction: "ltr"
});
ConfigProvider.config = setGlobalConfig;
ConfigProvider.install = function(app) {
  app.component(ConfigProvider.name, ConfigProvider);
};
var useConfigInject = function(name, props2) {
  var configProvider = Vue.inject("configProvider", defaultConfigProvider);
  var prefixCls = Vue.computed(function() {
    return configProvider.getPrefixCls(name, props2.prefixCls);
  });
  var direction = Vue.computed(function() {
    var _a;
    return (_a = props2.direction) !== null && _a !== void 0 ? _a : configProvider.direction;
  });
  var rootPrefixCls = Vue.computed(function() {
    return configProvider.getPrefixCls();
  });
  var autoInsertSpaceInButton = Vue.computed(function() {
    return configProvider.autoInsertSpaceInButton;
  });
  var renderEmpty2 = Vue.computed(function() {
    return configProvider.renderEmpty;
  });
  var space = Vue.computed(function() {
    return configProvider.space;
  });
  var pageHeader = Vue.computed(function() {
    return configProvider.pageHeader;
  });
  var form = Vue.computed(function() {
    return configProvider.form;
  });
  var getTargetContainer = Vue.computed(function() {
    return props2.getTargetContainer || configProvider.getTargetContainer;
  });
  var getPopupContainer = Vue.computed(function() {
    return props2.getPopupContainer || configProvider.getPopupContainer;
  });
  var dropdownMatchSelectWidth = Vue.computed(function() {
    var _a;
    return (_a = props2.dropdownMatchSelectWidth) !== null && _a !== void 0 ? _a : configProvider.dropdownMatchSelectWidth;
  });
  var virtual = Vue.computed(function() {
    return (props2.virtual === void 0 ? configProvider.virtual !== false : props2.virtual !== false) && dropdownMatchSelectWidth.value !== false;
  });
  var size = Vue.computed(function() {
    return props2.size || configProvider.componentSize;
  });
  var autocomplete = Vue.computed(function() {
    var _a;
    return props2.autocomplete || ((_a = configProvider.input) === null || _a === void 0 ? void 0 : _a.autocomplete);
  });
  var csp = Vue.computed(function() {
    return configProvider.csp;
  });
  return {
    configProvider,
    prefixCls,
    direction,
    size,
    getTargetContainer,
    getPopupContainer,
    space,
    pageHeader,
    form,
    autoInsertSpaceInButton,
    renderEmpty: renderEmpty2,
    virtual,
    dropdownMatchSelectWidth,
    rootPrefixCls,
    getPrefixCls: configProvider.getPrefixCls,
    autocomplete,
    csp
  };
};
var styleForPesudo;
function isHidden(element) {
  return !element || element.offsetParent === null;
}
function isNotGrey(color) {
  var match2 = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\.\d]*)?\)/);
  if (match2 && match2[1] && match2[2] && match2[3]) {
    return !(match2[1] === match2[2] && match2[2] === match2[3]);
  }
  return true;
}
var Wave = Vue.defineComponent({
  name: "Wave",
  props: {
    insertExtraNode: Boolean,
    disabled: Boolean
  },
  setup: function setup6(props2, _ref) {
    var slots = _ref.slots, expose = _ref.expose;
    var instance = Vue.getCurrentInstance();
    var _useConfigInject = useConfigInject("", props2), csp = _useConfigInject.csp, prefixCls = _useConfigInject.prefixCls;
    expose({
      csp
    });
    var eventIns = null;
    var clickWaveTimeoutId = null;
    var animationStartId = null;
    var animationStart = false;
    var extraNode = null;
    var isUnmounted = false;
    var onTransitionStart = function onTransitionStart2(e2) {
      if (isUnmounted)
        return;
      var node = findDOMNode(instance);
      if (!e2 || e2.target !== node) {
        return;
      }
      if (!animationStart) {
        resetEffect(node);
      }
    };
    var onTransitionEnd = function onTransitionEnd2(e2) {
      if (!e2 || e2.animationName !== "fadeEffect") {
        return;
      }
      resetEffect(e2.target);
    };
    var getAttributeName = function getAttributeName2() {
      var insertExtraNode = props2.insertExtraNode;
      return insertExtraNode ? "".concat(prefixCls.value, "-click-animating") : "".concat(prefixCls.value, "-click-animating-without-extra-node");
    };
    var onClick2 = function onClick3(node, waveColor) {
      var _a;
      var insertExtraNode = props2.insertExtraNode, disabled = props2.disabled;
      if (disabled || !node || isHidden(node) || node.className.indexOf("-leave") >= 0) {
        return;
      }
      extraNode = document.createElement("div");
      extraNode.className = "".concat(prefixCls.value, "-click-animating-node");
      var attributeName = getAttributeName();
      node.removeAttribute(attributeName);
      node.setAttribute(attributeName, "true");
      styleForPesudo = styleForPesudo || document.createElement("style");
      if (waveColor && waveColor !== "#ffffff" && waveColor !== "rgb(255, 255, 255)" && isNotGrey(waveColor) && !/rgba\(\d*, \d*, \d*, 0\)/.test(waveColor) && waveColor !== "transparent") {
        if ((_a = csp.value) === null || _a === void 0 ? void 0 : _a.nonce) {
          styleForPesudo.nonce = csp.value.nonce;
        }
        extraNode.style.borderColor = waveColor;
        styleForPesudo.innerHTML = "\n        [".concat(prefixCls.value, "-click-animating-without-extra-node='true']::after, .").concat(prefixCls.value, "-click-animating-node {\n          --antd-wave-shadow-color: ").concat(waveColor, ";\n        }");
        if (!document.body.contains(styleForPesudo)) {
          document.body.appendChild(styleForPesudo);
        }
      }
      if (insertExtraNode) {
        node.appendChild(extraNode);
      }
      TransitionEvents$1.addStartEventListener(node, onTransitionStart);
      TransitionEvents$1.addEndEventListener(node, onTransitionEnd);
    };
    var resetEffect = function resetEffect2(node) {
      if (!node || node === extraNode || !(node instanceof Element)) {
        return;
      }
      var insertExtraNode = props2.insertExtraNode;
      var attributeName = getAttributeName();
      node.setAttribute(attributeName, "false");
      if (styleForPesudo) {
        styleForPesudo.innerHTML = "";
      }
      if (insertExtraNode && extraNode && node.contains(extraNode)) {
        node.removeChild(extraNode);
      }
      TransitionEvents$1.removeStartEventListener(node, onTransitionStart);
      TransitionEvents$1.removeEndEventListener(node, onTransitionEnd);
    };
    var bindAnimationEvent = function bindAnimationEvent2(node) {
      if (!node || !node.getAttribute || node.getAttribute("disabled") || node.className.indexOf("disabled") >= 0) {
        return;
      }
      var newClick = function newClick2(e2) {
        if (e2.target.tagName === "INPUT" || isHidden(e2.target)) {
          return;
        }
        resetEffect(node);
        var waveColor = getComputedStyle(node).getPropertyValue("border-top-color") || getComputedStyle(node).getPropertyValue("border-color") || getComputedStyle(node).getPropertyValue("background-color");
        clickWaveTimeoutId = setTimeout(function() {
          return onClick2(node, waveColor);
        }, 0);
        wrapperRaf.cancel(animationStartId);
        animationStart = true;
        animationStartId = wrapperRaf(function() {
          animationStart = false;
        }, 10);
      };
      node.addEventListener("click", newClick, true);
      return {
        cancel: function cancel() {
          node.removeEventListener("click", newClick, true);
        }
      };
    };
    Vue.onMounted(function() {
      Vue.nextTick(function() {
        var node = findDOMNode(instance);
        if (node.nodeType !== 1) {
          return;
        }
        eventIns = bindAnimationEvent(node);
      });
    });
    Vue.onBeforeUnmount(function() {
      if (eventIns) {
        eventIns.cancel();
      }
      clearTimeout(clickWaveTimeoutId);
      isUnmounted = true;
    });
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)[0];
    };
  }
});
var ContextKey$1 = Symbol("ContextProps");
var InternalContextKey = Symbol("InternalContextProps");
var defaultContext = {
  id: Vue.computed(function() {
    return void 0;
  }),
  onFieldBlur: function onFieldBlur() {
  },
  onFieldChange: function onFieldChange() {
  },
  clearValidate: function clearValidate() {
  }
};
var defaultInternalContext = {
  addFormItemField: function addFormItemField() {
  },
  removeFormItemField: function removeFormItemField() {
  }
};
var useInjectFormItemContext = function useInjectFormItemContext2() {
  var internalContext = Vue.inject(InternalContextKey, defaultInternalContext);
  var formItemFieldKey = Symbol("FormItemFieldKey");
  var instance = Vue.getCurrentInstance();
  internalContext.addFormItemField(formItemFieldKey, instance.type);
  Vue.onBeforeUnmount(function() {
    internalContext.removeFormItemField(formItemFieldKey);
  });
  Vue.provide(InternalContextKey, defaultInternalContext);
  Vue.provide(ContextKey$1, defaultContext);
  return Vue.inject(ContextKey$1, defaultContext);
};
Vue.defineComponent({
  name: "AFormItemRest",
  setup: function setup7(_2, _ref) {
    var slots = _ref.slots;
    Vue.provide(InternalContextKey, defaultInternalContext);
    Vue.provide(ContextKey$1, defaultContext);
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
  }
});
function omit(obj, fields) {
  var shallowCopy = _extends({}, obj);
  for (var i2 = 0; i2 < fields.length; i2 += 1) {
    var key2 = fields[i2];
    delete shallowCopy[key2];
  }
  return shallowCopy;
}
var SwitchSizes = tuple$1("small", "default");
var switchProps = function switchProps2() {
  return {
    id: String,
    prefixCls: String,
    size: PropTypes$1.oneOf(SwitchSizes),
    disabled: {
      type: Boolean,
      default: void 0
    },
    checkedChildren: PropTypes$1.any,
    unCheckedChildren: PropTypes$1.any,
    tabindex: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
    autofocus: {
      type: Boolean,
      default: void 0
    },
    loading: {
      type: Boolean,
      default: void 0
    },
    checked: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number, PropTypes$1.looseBool]),
    checkedValue: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number, PropTypes$1.looseBool]).def(true),
    unCheckedValue: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number, PropTypes$1.looseBool]).def(false),
    onChange: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onMouseup: {
      type: Function
    },
    "onUpdate:checked": {
      type: Function
    },
    onBlur: Function,
    onFocus: Function
  };
};
var Switch$1 = Vue.defineComponent({
  name: "ASwitch",
  __ANT_SWITCH: true,
  inheritAttrs: false,
  props: switchProps(),
  slots: ["checkedChildren", "unCheckedChildren"],
  setup: function setup8(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose, emit = _ref.emit;
    var formItemContext = useInjectFormItemContext();
    Vue.onBeforeMount(function() {
      warning(!("defaultChecked" in attrs), "Switch", "'defaultChecked' is deprecated, please use 'v-model:checked'");
      warning(!("value" in attrs), "Switch", "`value` is not validate prop, do you mean `checked`?");
    });
    var checked = Vue.ref(props2.checked !== void 0 ? props2.checked : attrs.defaultChecked);
    var checkedStatus = Vue.computed(function() {
      return checked.value === props2.checkedValue;
    });
    Vue.watch(function() {
      return props2.checked;
    }, function() {
      checked.value = props2.checked;
    });
    var _useConfigInject = useConfigInject("switch", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, size = _useConfigInject.size;
    var refSwitchNode = Vue.ref();
    var focus = function focus2() {
      var _a;
      (_a = refSwitchNode.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    var blur = function blur2() {
      var _a;
      (_a = refSwitchNode.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    expose({
      focus,
      blur
    });
    Vue.onMounted(function() {
      Vue.nextTick(function() {
        if (props2.autofocus && !props2.disabled) {
          refSwitchNode.value.focus();
        }
      });
    });
    var setChecked = function setChecked2(check, e2) {
      if (props2.disabled) {
        return;
      }
      emit("update:checked", check);
      emit("change", check, e2);
      formItemContext.onFieldChange();
    };
    var handleBlur = function handleBlur2(e2) {
      emit("blur", e2);
    };
    var handleClick = function handleClick2(e2) {
      focus();
      var newChecked = checkedStatus.value ? props2.unCheckedValue : props2.checkedValue;
      setChecked(newChecked, e2);
      emit("click", newChecked, e2);
    };
    var handleKeyDown2 = function handleKeyDown3(e2) {
      if (e2.keyCode === KeyCode$1.LEFT) {
        setChecked(props2.unCheckedValue, e2);
      } else if (e2.keyCode === KeyCode$1.RIGHT) {
        setChecked(props2.checkedValue, e2);
      }
      emit("keydown", e2);
    };
    var handleMouseUp = function handleMouseUp2(e2) {
      var _a;
      (_a = refSwitchNode.value) === null || _a === void 0 ? void 0 : _a.blur();
      emit("mouseup", e2);
    };
    var classNames2 = Vue.computed(function() {
      var _ref2;
      return _ref2 = {}, _defineProperty$T(_ref2, "".concat(prefixCls.value, "-small"), size.value === "small"), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-loading"), props2.loading), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-checked"), checkedStatus.value), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-disabled"), props2.disabled), _defineProperty$T(_ref2, prefixCls.value, true), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _ref2;
    });
    return function() {
      var _a;
      return Vue.createVNode(Wave, {
        "insertExtraNode": true
      }, {
        default: function _default5() {
          return [Vue.createVNode("button", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit(props2, ["prefixCls", "checkedChildren", "unCheckedChildren", "checked", "autofocus", "checkedValue", "unCheckedValue", "id", "onChange", "onUpdate:checked"])), attrs), {}, {
            "id": (_a = props2.id) !== null && _a !== void 0 ? _a : formItemContext.id.value,
            "onKeydown": handleKeyDown2,
            "onClick": handleClick,
            "onBlur": handleBlur,
            "onMouseup": handleMouseUp,
            "type": "button",
            "role": "switch",
            "aria-checked": checked.value,
            "disabled": props2.disabled || props2.loading,
            "class": [attrs.class, classNames2.value],
            "ref": refSwitchNode
          }), [Vue.createVNode("div", {
            "class": "".concat(prefixCls.value, "-handle")
          }, [props2.loading ? Vue.createVNode(LoadingOutlined$1, {
            "class": "".concat(prefixCls.value, "-loading-icon")
          }, null) : null]), Vue.createVNode("span", {
            "class": "".concat(prefixCls.value, "-inner")
          }, [checkedStatus.value ? getPropsSlot(slots, props2, "checkedChildren") : getPropsSlot(slots, props2, "unCheckedChildren")])])];
        }
      });
    };
  }
});
var _Switch = withInstall(Switch$1);
var index$B = "";
var index$A = "";
var index$z = "";
var index$y = "";
function getError(option, xhr) {
  var msg = "cannot ".concat(option.method, " ").concat(option.action, " ").concat(xhr.status, "'");
  var err = new Error(msg);
  err.status = xhr.status;
  err.method = option.method;
  err.url = option.action;
  return err;
}
function getBody(xhr) {
  var text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e2) {
    return text;
  }
}
function upload(option) {
  var xhr = new XMLHttpRequest();
  if (option.onProgress && xhr.upload) {
    xhr.upload.onprogress = function progress(e2) {
      if (e2.total > 0) {
        e2.percent = e2.loaded / e2.total * 100;
      }
      option.onProgress(e2);
    };
  }
  var formData = new FormData();
  if (option.data) {
    Object.keys(option.data).forEach(function(key2) {
      var value = option.data[key2];
      if (Array.isArray(value)) {
        value.forEach(function(item) {
          formData.append("".concat(key2, "[]"), item);
        });
        return;
      }
      formData.append(key2, value);
    });
  }
  if (option.file instanceof Blob) {
    formData.append(option.filename, option.file, option.file.name);
  } else {
    formData.append(option.filename, option.file);
  }
  xhr.onerror = function error(e2) {
    option.onError(e2);
  };
  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(option, xhr), getBody(xhr));
    }
    return option.onSuccess(getBody(xhr), xhr);
  };
  xhr.open(option.method, option.action, true);
  if (option.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  var headers = option.headers || {};
  if (headers["X-Requested-With"] !== null) {
    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
  }
  Object.keys(headers).forEach(function(h2) {
    if (headers[h2] !== null) {
      xhr.setRequestHeader(h2, headers[h2]);
    }
  });
  xhr.send(formData);
  return {
    abort: function abort() {
      xhr.abort();
    }
  };
}
var now$2 = +new Date();
var index$x = 0;
function uid() {
  return "vc-upload-".concat(now$2, "-").concat(++index$x);
}
var attrAccept = function(file, acceptedFiles) {
  if (file && acceptedFiles) {
    var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
    var fileName = file.name || "";
    var mimeType = file.type || "";
    var baseMimeType = mimeType.replace(/\/.*$/, "");
    return acceptedFilesArray.some(function(type2) {
      var validType = type2.trim();
      if (/^\*(\/\*)?$/.test(type2)) {
        return true;
      }
      if (validType.charAt(0) === ".") {
        var lowerFileName = fileName.toLowerCase();
        var lowerType = validType.toLowerCase();
        var affixList = [lowerType];
        if (lowerType === ".jpg" || lowerType === ".jpeg") {
          affixList = [".jpg", ".jpeg"];
        }
        return affixList.some(function(affix) {
          return lowerFileName.endsWith(affix);
        });
      }
      if (/\/\*$/.test(validType)) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      if (mimeType === validType) {
        return true;
      }
      if (/^\w+$/.test(validType)) {
        return true;
      }
      return false;
    });
  }
  return true;
};
function loopFiles(item, callback) {
  var dirReader = item.createReader();
  var fileList = [];
  function sequence() {
    dirReader.readEntries(function(entries) {
      var entryList = Array.prototype.slice.apply(entries);
      fileList = fileList.concat(entryList);
      var isFinished = !entryList.length;
      if (isFinished) {
        callback(fileList);
      } else {
        sequence();
      }
    });
  }
  sequence();
}
var traverseFileTree = function traverseFileTree2(files, callback, isAccepted) {
  var _traverseFileTree = function _traverseFileTree2(item, path) {
    item.path = path || "";
    if (item.isFile) {
      item.file(function(file) {
        if (isAccepted(file)) {
          if (item.fullPath && !file.webkitRelativePath) {
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: true
              }
            });
            file.webkitRelativePath = item.fullPath.replace(/^\//, "");
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: false
              }
            });
          }
          callback([file]);
        }
      });
    } else if (item.isDirectory) {
      loopFiles(item, function(entries) {
        entries.forEach(function(entryItem) {
          _traverseFileTree2(entryItem, "".concat(path).concat(item.name, "/"));
        });
      });
    }
  };
  files.forEach(function(file) {
    _traverseFileTree(file.webkitGetAsEntry());
  });
};
var traverseFileTree$1 = traverseFileTree;
var uploadProps$1 = function uploadProps2() {
  return {
    capture: [Boolean, String],
    multipart: {
      type: Boolean,
      default: void 0
    },
    name: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    componentTag: String,
    action: [String, Function],
    method: String,
    directory: {
      type: Boolean,
      default: void 0
    },
    data: [Object, Function],
    headers: Object,
    accept: String,
    multiple: {
      type: Boolean,
      default: void 0
    },
    onBatchStart: Function,
    onReject: Function,
    onStart: Function,
    onError: Function,
    onSuccess: Function,
    onProgress: Function,
    beforeUpload: Function,
    customRequest: Function,
    withCredentials: {
      type: Boolean,
      default: void 0
    },
    openFileDialogOnClick: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    id: String,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function
  };
};
var attributes = "accept acceptcharset accesskey action allowfullscreen allowtransparency\nalt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge\ncharset checked classid classname colspan cols content contenteditable contextmenu\ncontrols coords crossorigin data datetime default defer dir disabled download draggable\nenctype form formaction formenctype formmethod formnovalidate formtarget frameborder\nheaders height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity\nis keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media\nmediagroup method min minlength multiple muted name novalidate nonce open\noptimum pattern placeholder poster preload radiogroup readonly rel required\nreversed role rowspan rows sandbox scope scoped scrolling seamless selected\nshape size sizes span spellcheck src srcdoc srclang srcset start step style\nsummary tabindex target title type usemap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown\n    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick\n    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown\n    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel\n    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough\n    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata\n    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match$1(key2, prefix) {
  return key2.indexOf(prefix) === 0;
}
function pickAttrs(props2) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _extends({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props2).forEach(function(key2) {
    if (mergedConfig.aria && (key2 === "role" || match$1(key2, ariaPrefix)) || mergedConfig.data && match$1(key2, dataPrefix) || mergedConfig.attr && (propList.includes(key2) || propList.includes(key2.toLowerCase()))) {
      attrs[key2] = props2[key2];
    }
  });
  return attrs;
}
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    var value = array[index2];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}
function createBaseFor$2(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props2 = keysFunc(object), length = props2.length;
    while (length--) {
      var key2 = props2[fromRight ? length : ++index2];
      if (iteratee(iterable[key2], key2, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor$2 = createBaseFor$2();
var baseFor$3 = baseFor$2;
function baseTimes$2(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$4 = "[object Arguments]";
function baseIsArguments$2(value) {
  return isObjectLike$4(value) && baseGetTag$4(value) == argsTag$4;
}
var objectProto$g = Object.prototype;
var hasOwnProperty$c = objectProto$g.hasOwnProperty;
var propertyIsEnumerable$2 = objectProto$g.propertyIsEnumerable;
var isArguments$2 = baseIsArguments$2(function() {
  return arguments;
}()) ? baseIsArguments$2 : function(value) {
  return isObjectLike$4(value) && hasOwnProperty$c.call(value, "callee") && !propertyIsEnumerable$2.call(value, "callee");
};
var isArguments$3 = isArguments$2;
var isArray$3 = Array.isArray;
var isArray$4 = isArray$3;
function stubFalse$1() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer = moduleExports$1 ? root$3.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer$3 = nativeIsBuffer || stubFalse$1;
var isBuffer$4 = isBuffer$3;
var MAX_SAFE_INTEGER$3 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$2(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$3 : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint$1.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
}
var argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$2 = "[object Error]", funcTag$3 = "[object Function]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
var typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$1] = typedArrayTags$1[float64Tag$1] = typedArrayTags$1[int8Tag$1] = typedArrayTags$1[int16Tag$1] = typedArrayTags$1[int32Tag$1] = typedArrayTags$1[uint8Tag$1] = typedArrayTags$1[uint8ClampedTag$1] = typedArrayTags$1[uint16Tag$1] = typedArrayTags$1[uint32Tag$1] = true;
typedArrayTags$1[argsTag$3] = typedArrayTags$1[arrayTag$2] = typedArrayTags$1[arrayBufferTag$2] = typedArrayTags$1[boolTag$2] = typedArrayTags$1[dataViewTag$3] = typedArrayTags$1[dateTag$2] = typedArrayTags$1[errorTag$2] = typedArrayTags$1[funcTag$3] = typedArrayTags$1[mapTag$3] = typedArrayTags$1[numberTag$2] = typedArrayTags$1[objectTag$3] = typedArrayTags$1[regexpTag$2] = typedArrayTags$1[setTag$3] = typedArrayTags$1[stringTag$2] = typedArrayTags$1[weakMapTag$2] = false;
function baseIsTypedArray$2(value) {
  return isObjectLike$4(value) && isLength$3(value.length) && !!typedArrayTags$1[baseGetTag$4(value)];
}
function baseUnary$2(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$3.process;
var nodeUtil$1 = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
var nodeUtil$2 = nodeUtil$1;
var nodeIsTypedArray$1 = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray$1 ? baseUnary$2(nodeIsTypedArray$1) : baseIsTypedArray$2;
var isTypedArray$3 = isTypedArray$2;
var objectProto$f = Object.prototype;
var hasOwnProperty$b = objectProto$f.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$4(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$4(value), isType = !isArr && !isArg && !isBuff && isTypedArray$3(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes$2(value.length, String) : [], length = result.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$b.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex$2(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
var objectProto$e = Object.prototype;
function isPrototype$2(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$e;
  return value === proto;
}
var nativeKeys$2 = overArg$2(Object.keys, Object);
var nativeKeys$3 = nativeKeys$2;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
function baseKeys$2(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys$3(object);
  }
  var result = [];
  for (var key2 in Object(object)) {
    if (hasOwnProperty$a.call(object, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
function isObject$2(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var asyncTag$1 = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$2(value) {
  if (!isObject$2(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag$1 || tag == proxyTag$1;
}
function isArrayLike$3(value) {
  return value != null && isLength$3(value.length) && !isFunction$2(value);
}
function keys$2(object) {
  return isArrayLike$3(object) ? arrayLikeKeys$2(object) : baseKeys$2(object);
}
function baseForOwn$2(object, iteratee) {
  return object && baseFor$3(object, iteratee, keys$2);
}
function createBaseEach$2(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$3(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach$2 = createBaseEach$2(baseForOwn$2);
var baseEach$3 = baseEach$2;
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach$3(collection, function(value, key2, collection2) {
    setter(accumulator, value, iteratee(value), collection2);
  });
  return accumulator;
}
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array, key2) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key2) {
  var data4 = this.__data__, index2 = assocIndexOf(data4, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data4.length - 1;
  if (index2 == lastIndex) {
    data4.pop();
  } else {
    splice.call(data4, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key2) {
  var data4 = this.__data__, index2 = assocIndexOf(data4, key2);
  return index2 < 0 ? void 0 : data4[index2][1];
}
function listCacheHas(key2) {
  return assocIndexOf(this.__data__, key2) > -1;
}
function listCacheSet(key2, value) {
  var data4 = this.__data__, index2 = assocIndexOf(data4, key2);
  if (index2 < 0) {
    ++this.size;
    data4.push([key2, value]);
  } else {
    data4[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key2) {
  var data4 = this.__data__, result = data4["delete"](key2);
  this.size = data4.size;
  return result;
}
function stackGet(key2) {
  return this.__data__.get(key2);
}
function stackHas(key2) {
  return this.__data__.has(key2);
}
var coreJsData = root$3["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$c = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject$2(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue$1(object, key2) {
  return object == null ? void 0 : object[key2];
}
function getNative(object, key2) {
  var value = getValue$1(object, key2);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root$3, "Map");
var Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
function hashGet(key2) {
  var data4 = this.__data__;
  if (nativeCreate$1) {
    var result = data4[key2];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data4, key2) ? data4[key2] : void 0;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$7 = objectProto$a.hasOwnProperty;
function hashHas(key2) {
  var data4 = this.__data__;
  return nativeCreate$1 ? data4[key2] !== void 0 : hasOwnProperty$7.call(data4, key2);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key2, value) {
  var data4 = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data4[key2] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map, key2) {
  var data4 = map.__data__;
  return isKeyable(key2) ? data4[typeof key2 == "string" ? "string" : "hash"] : data4.map;
}
function mapCacheDelete(key2) {
  var result = getMapData(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key2) {
  return getMapData(this, key2).get(key2);
}
function mapCacheHas(key2) {
  return getMapData(this, key2).has(key2);
}
function mapCacheSet(key2, value) {
  var data4 = getMapData(this, key2), size = data4.size;
  data4.set(key2, value);
  this.size += data4.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet(key2, value) {
  var data4 = this.__data__;
  if (data4 instanceof ListCache) {
    var pairs = data4.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key2, value]);
      this.size = ++data4.size;
      return this;
    }
    data4 = this.__data__ = new MapCache(pairs);
  }
  data4.set(key2, value);
  this.size = data4.size;
  return this;
}
function Stack(entries) {
  var data4 = this.__data__ = new ListCache(entries);
  this.size = data4.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache2, key2) {
  return cache2.has(key2);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen2) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen2.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var Uint8Array$1 = root$3.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
function mapToArray(map) {
  var index2 = -1, result = Array(map.size);
  map.forEach(function(value, key2) {
    result[++index2] = [key2, value];
  });
  return result;
}
function setToArray(set) {
  var index2 = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
var symbolProto$1 = Symbol$5 ? Symbol$5.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      return eq(+object, +other);
    case errorTag$1:
      return object.name == other.name && object.message == other.message;
    case regexpTag$1:
    case stringTag$1:
      return object == other + "";
    case mapTag$2:
      var convert = mapToArray;
    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
function arrayPush(array, values) {
  var index2 = -1, length = values.length, offset3 = array.length;
  while (++index2 < length) {
    array[offset3 + index2] = values[index2];
  }
  return array;
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$4(object) ? result : arrayPush(result, symbolsFunc(object));
}
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$9 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
function getAllKeys(object) {
  return baseGetAllKeys(object, keys$2, getSymbols$1);
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key2 = objProps[index2];
    if (!(isPartial ? key2 in other : hasOwnProperty$6.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key2 = objProps[index2];
    var objValue = object[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var DataView = getNative(root$3, "DataView");
var DataView$1 = DataView;
var Promise$1 = getNative(root$3, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$3, "Set");
var Set$2 = Set$1;
var WeakMap$1 = getNative(root$3, "WeakMap");
var WeakMap$2 = WeakMap$1;
var mapTag$1 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$1 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag$4;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1 || Map$2 && getTag(new Map$2()) != mapTag$1 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$1 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
  getTag = function(value) {
    var result = baseGetTag$4(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;
        case mapCtorString:
          return mapTag$1;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$1;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag$2 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$1 = "[object Object]";
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$4(object), othIsArr = isArray$4(other), objTag = objIsArr ? arrayTag$1 : getTag$1(object), othTag = othIsArr ? arrayTag$1 : getTag$1(other);
  objTag = objTag == argsTag$2 ? objectTag$1 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$1 : othTag;
  var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$4(object)) {
    if (!isBuffer$4(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$3(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$5.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$5.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$4(value) && !isObjectLike$4(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data4 = matchData[index2];
    if (noCustomizer && data4[2] ? data4[1] !== object[data4[0]] : !(data4[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data4 = matchData[index2];
    var key2 = data4[0], objValue = object[key2], srcValue = data4[1];
    if (noCustomizer && data4[2]) {
      if (objValue === void 0 && !(key2 in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key2, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject$2(value);
}
function getMatchData(object) {
  var result = keys$2(object), length = result.length;
  while (length--) {
    var key2 = result[length], value = object[key2];
    result[length] = [key2, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key2, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike$4(value) && baseGetTag$4(value) == symbolTag;
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray$4(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key2)) {
      return cache2.get(key2);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key2, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key2) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key2;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
  });
  return result;
});
var stringToPath$1 = stringToPath;
function arrayMap(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var INFINITY$2 = 1 / 0;
var symbolProto = Symbol$5 ? Symbol$5.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$4(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}
var INFINITY$1 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function baseHasIn(object, key2) {
  return object != null && key2 in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key2 = toKey(path[index2]);
    if (!(result = object != null && hasFunc(object, key2))) {
      break;
    }
    object = object[key2];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength$3(length) && isIndex$2(key2, length) && (isArray$4(object) || isArguments$3(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function identity$2(value) {
  return value;
}
function baseProperty(key2) {
  return function(object) {
    return object == null ? void 0 : object[key2];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$2;
  }
  if (typeof value == "object") {
    return isArray$4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray$4(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee(iteratee), accumulator);
  };
}
var partition = createAggregator(function(result, value, key2) {
  result[key2 ? 0 : 1].push(value);
}, function() {
  return [[], []];
});
var partition$1 = partition;
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator2) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator2["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$F = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var AjaxUpload = Vue.defineComponent({
  name: "AjaxUploader",
  inheritAttrs: false,
  props: uploadProps$1(),
  setup: function setup9(props2, _ref) {
    var _this = this;
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var uid$1 = Vue.ref(uid());
    var reqs = {};
    var fileInput = Vue.ref();
    var isMounted = false;
    var processFile = function processFile2(file, fileList) {
      return __awaiter$2(_this, void 0, void 0, /* @__PURE__ */ regenerator.mark(function _callee() {
        var beforeUpload, transformedFile, action, mergedAction, data4, mergedData, parsedData, parsedFile, mergedParsedFile;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                beforeUpload = props2.beforeUpload;
                transformedFile = file;
                if (!beforeUpload) {
                  _context.next = 14;
                  break;
                }
                _context.prev = 3;
                _context.next = 6;
                return beforeUpload(file, fileList);
              case 6:
                transformedFile = _context.sent;
                _context.next = 12;
                break;
              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](3);
                transformedFile = false;
              case 12:
                if (!(transformedFile === false)) {
                  _context.next = 14;
                  break;
                }
                return _context.abrupt("return", {
                  origin: file,
                  parsedFile: null,
                  action: null,
                  data: null
                });
              case 14:
                action = props2.action;
                if (!(typeof action === "function")) {
                  _context.next = 21;
                  break;
                }
                _context.next = 18;
                return action(file);
              case 18:
                mergedAction = _context.sent;
                _context.next = 22;
                break;
              case 21:
                mergedAction = action;
              case 22:
                data4 = props2.data;
                if (!(typeof data4 === "function")) {
                  _context.next = 29;
                  break;
                }
                _context.next = 26;
                return data4(file);
              case 26:
                mergedData = _context.sent;
                _context.next = 30;
                break;
              case 29:
                mergedData = data4;
              case 30:
                parsedData = (_typeof$1(transformedFile) === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file;
                if (parsedData instanceof File) {
                  parsedFile = parsedData;
                } else {
                  parsedFile = new File([parsedData], file.name, {
                    type: file.type
                  });
                }
                mergedParsedFile = parsedFile;
                mergedParsedFile.uid = file.uid;
                return _context.abrupt("return", {
                  origin: file,
                  data: mergedData,
                  parsedFile: mergedParsedFile,
                  action: mergedAction
                });
              case 35:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[3, 9]]);
      }));
    };
    var post = function post2(_ref2) {
      var data4 = _ref2.data, origin = _ref2.origin, action = _ref2.action, parsedFile = _ref2.parsedFile;
      if (!isMounted) {
        return;
      }
      var onStart = props2.onStart, customRequest = props2.customRequest, name = props2.name, headers = props2.headers, withCredentials = props2.withCredentials, method = props2.method;
      var uid2 = origin.uid;
      var request = customRequest || upload;
      var requestOption = {
        action,
        filename: name,
        data: data4,
        file: parsedFile,
        headers,
        withCredentials,
        method: method || "post",
        onProgress: function onProgress(e2) {
          var onProgress2 = props2.onProgress;
          onProgress2 === null || onProgress2 === void 0 ? void 0 : onProgress2(e2, parsedFile);
        },
        onSuccess: function onSuccess(ret, xhr) {
          var onSuccess2 = props2.onSuccess;
          onSuccess2 === null || onSuccess2 === void 0 ? void 0 : onSuccess2(ret, parsedFile, xhr);
          delete reqs[uid2];
        },
        onError: function onError(err, ret) {
          var onError2 = props2.onError;
          onError2 === null || onError2 === void 0 ? void 0 : onError2(err, ret, parsedFile);
          delete reqs[uid2];
        }
      };
      onStart(origin);
      reqs[uid2] = request(requestOption);
    };
    var reset = function reset2() {
      uid$1.value = uid();
    };
    var abort = function abort2(file) {
      if (file) {
        var _uid = file.uid ? file.uid : file;
        if (reqs[_uid] && reqs[_uid].abort) {
          reqs[_uid].abort();
        }
        delete reqs[_uid];
      } else {
        Object.keys(reqs).forEach(function(uid2) {
          if (reqs[uid2] && reqs[uid2].abort) {
            reqs[uid2].abort();
          }
          delete reqs[uid2];
        });
      }
    };
    Vue.onMounted(function() {
      isMounted = true;
    });
    Vue.onBeforeUnmount(function() {
      isMounted = false;
      abort();
    });
    var uploadFiles = function uploadFiles2(files) {
      var originFiles = _toConsumableArray(files);
      var postFiles = originFiles.map(function(file) {
        file.uid = uid();
        return processFile(file, originFiles);
      });
      Promise.all(postFiles).then(function(fileList) {
        var onBatchStart = props2.onBatchStart;
        onBatchStart === null || onBatchStart === void 0 ? void 0 : onBatchStart(fileList.map(function(_ref3) {
          var origin = _ref3.origin, parsedFile = _ref3.parsedFile;
          return {
            file: origin,
            parsedFile
          };
        }));
        fileList.filter(function(file) {
          return file.parsedFile !== null;
        }).forEach(function(file) {
          post(file);
        });
      });
    };
    var onChange = function onChange2(e2) {
      var accept = props2.accept, directory = props2.directory;
      var files = e2.target.files;
      var acceptedFiles = _toConsumableArray(files).filter(function(file) {
        return !directory || attrAccept(file, accept);
      });
      uploadFiles(acceptedFiles);
      reset();
    };
    var onClick2 = function onClick3(e2) {
      var el = fileInput.value;
      if (!el) {
        return;
      }
      var onClick4 = props2.onClick;
      el.click();
      if (onClick4) {
        onClick4(e2);
      }
    };
    var onKeyDown = function onKeyDown2(e2) {
      if (e2.key === "Enter") {
        onClick2(e2);
      }
    };
    var onFileDrop = function onFileDrop2(e2) {
      var multiple = props2.multiple;
      e2.preventDefault();
      if (e2.type === "dragover") {
        return;
      }
      if (props2.directory) {
        traverseFileTree$1(Array.prototype.slice.call(e2.dataTransfer.items), uploadFiles, function(_file) {
          return attrAccept(_file, props2.accept);
        });
      } else {
        var files = partition$1(Array.prototype.slice.call(e2.dataTransfer.files), function(file) {
          return attrAccept(file, props2.accept);
        });
        var successFiles = files[0];
        var errorFiles = files[1];
        if (multiple === false) {
          successFiles = successFiles.slice(0, 1);
        }
        uploadFiles(successFiles);
        if (errorFiles.length && props2.onReject)
          props2.onReject(errorFiles);
      }
    };
    expose({
      abort
    });
    return function() {
      var _cls;
      var _a;
      var Tag2 = props2.componentTag, prefixCls = props2.prefixCls, disabled = props2.disabled, id = props2.id, multiple = props2.multiple, accept = props2.accept, capture = props2.capture, directory = props2.directory, openFileDialogOnClick = props2.openFileDialogOnClick, onMouseenter2 = props2.onMouseenter, onMouseleave2 = props2.onMouseleave, otherProps = __rest$F(props2, ["componentTag", "prefixCls", "disabled", "id", "multiple", "accept", "capture", "directory", "openFileDialogOnClick", "onMouseenter", "onMouseleave"]);
      var cls = (_cls = {}, _defineProperty$T(_cls, prefixCls, true), _defineProperty$T(_cls, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$T(_cls, attrs.class, !!attrs.class), _cls);
      var dirProps = directory ? {
        directory: "directory",
        webkitdirectory: "webkitdirectory"
      } : {};
      var events2 = disabled ? {} : {
        onClick: openFileDialogOnClick ? onClick2 : function() {
        },
        onKeydown: openFileDialogOnClick ? onKeyDown : function() {
        },
        onMouseenter: onMouseenter2,
        onMouseleave: onMouseleave2,
        onDrop: onFileDrop,
        onDragover: onFileDrop,
        tabindex: "0"
      };
      return Vue.createVNode(Tag2, _objectSpread2$1(_objectSpread2$1({}, events2), {}, {
        "class": cls,
        "role": "button",
        "style": attrs.style
      }), {
        default: function _default5() {
          return [Vue.createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickAttrs(otherProps, {
            aria: true,
            data: true
          })), {}, {
            "id": id,
            "type": "file",
            "ref": fileInput,
            "onClick": function onClick3(e2) {
              return e2.stopPropagation();
            },
            "key": uid$1.value,
            "style": {
              display: "none"
            },
            "accept": accept
          }, dirProps), {}, {
            "multiple": multiple,
            "onChange": onChange
          }, capture != null ? {
            capture
          } : {}), null), (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)];
        }
      });
    };
  }
});
function empty() {
}
var Upload$1 = Vue.defineComponent({
  name: "Upload",
  inheritAttrs: false,
  props: initDefaultProps$1(uploadProps$1(), {
    componentTag: "span",
    prefixCls: "rc-upload",
    data: {},
    headers: {},
    name: "file",
    multipart: false,
    onStart: empty,
    onError: empty,
    onSuccess: empty,
    multiple: false,
    beforeUpload: null,
    customRequest: null,
    withCredentials: false,
    openFileDialogOnClick: true
  }),
  setup: function setup10(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var uploader = Vue.ref();
    var abort = function abort2(file) {
      var _a;
      (_a = uploader.value) === null || _a === void 0 ? void 0 : _a.abort(file);
    };
    expose({
      abort
    });
    return function() {
      return Vue.createVNode(AjaxUpload, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props2), attrs), {}, {
        "ref": uploader
      }), slots);
    };
  }
});
var PaperClipOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z"
      }
    }]
  },
  "name": "paper-clip",
  "theme": "outlined"
};
var PaperClipOutlinedSvg = PaperClipOutlined$2;
function _objectSpread$E(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$F(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$F(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PaperClipOutlined = function PaperClipOutlined2(props2, context) {
  var p2 = _objectSpread$E({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$E({}, p2, {
    "icon": PaperClipOutlinedSvg
  }), null);
};
PaperClipOutlined.displayName = "PaperClipOutlined";
PaperClipOutlined.inheritAttrs = false;
var PaperClipOutlined$1 = PaperClipOutlined;
var PictureTwoTone$2 = {
  "icon": function render(primaryColor, secondaryColor) {
    return {
      "tag": "svg",
      "attrs": {
        "viewBox": "64 64 896 896",
        "focusable": "false"
      },
      "children": [{
        "tag": "path",
        "attrs": {
          "d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z",
          "fill": primaryColor
        }
      }, {
        "tag": "path",
        "attrs": {
          "d": "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z",
          "fill": secondaryColor
        }
      }, {
        "tag": "path",
        "attrs": {
          "d": "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z",
          "fill": secondaryColor
        }
      }, {
        "tag": "path",
        "attrs": {
          "d": "M276 368a28 28 0 1056 0 28 28 0 10-56 0z",
          "fill": secondaryColor
        }
      }, {
        "tag": "path",
        "attrs": {
          "d": "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z",
          "fill": primaryColor
        }
      }]
    };
  },
  "name": "picture",
  "theme": "twotone"
};
var PictureTwoToneSvg = PictureTwoTone$2;
function _objectSpread$D(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$E(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$E(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PictureTwoTone = function PictureTwoTone2(props2, context) {
  var p2 = _objectSpread$D({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$D({}, p2, {
    "icon": PictureTwoToneSvg
  }), null);
};
PictureTwoTone.displayName = "PictureTwoTone";
PictureTwoTone.inheritAttrs = false;
var PictureTwoTone$1 = PictureTwoTone;
var FileTwoTone$2 = {
  "icon": function render2(primaryColor, secondaryColor) {
    return {
      "tag": "svg",
      "attrs": {
        "viewBox": "64 64 896 896",
        "focusable": "false"
      },
      "children": [{
        "tag": "path",
        "attrs": {
          "d": "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z",
          "fill": secondaryColor
        }
      }, {
        "tag": "path",
        "attrs": {
          "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z",
          "fill": primaryColor
        }
      }]
    };
  },
  "name": "file",
  "theme": "twotone"
};
var FileTwoToneSvg = FileTwoTone$2;
function _objectSpread$C(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$D(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$D(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FileTwoTone = function FileTwoTone2(props2, context) {
  var p2 = _objectSpread$C({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$C({}, p2, {
    "icon": FileTwoToneSvg
  }), null);
};
FileTwoTone.displayName = "FileTwoTone";
FileTwoTone.inheritAttrs = false;
var FileTwoTone$1 = FileTwoTone;
function uploadProps() {
  return {
    capture: [Boolean, String],
    type: String,
    name: String,
    defaultFileList: Array,
    fileList: Array,
    action: [String, Function],
    directory: {
      type: Boolean,
      default: void 0
    },
    data: [Object, Function],
    method: String,
    headers: Object,
    showUploadList: {
      type: [Boolean, Object],
      default: void 0
    },
    multiple: {
      type: Boolean,
      default: void 0
    },
    accept: String,
    beforeUpload: Function,
    onChange: Function,
    "onUpdate:fileList": Function,
    onDrop: Function,
    listType: String,
    onPreview: Function,
    onDownload: Function,
    onReject: Function,
    onRemove: Function,
    remove: Function,
    supportServerRender: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    customRequest: Function,
    withCredentials: {
      type: Boolean,
      default: void 0
    },
    openFileDialogOnClick: {
      type: Boolean,
      default: void 0
    },
    locale: {
      type: Object,
      default: void 0
    },
    id: String,
    previewFile: Function,
    transformFile: Function,
    iconRender: Function,
    isImageUrl: Function,
    progress: Object,
    itemRender: Function,
    maxCount: Number,
    height: [Number, String],
    removeIcon: Function,
    downloadIcon: Function,
    previewIcon: Function
  };
}
function uploadListProps() {
  return {
    listType: String,
    onPreview: Function,
    onDownload: Function,
    onRemove: Function,
    items: Array,
    progress: Object,
    prefixCls: String,
    showRemoveIcon: {
      type: Boolean,
      default: void 0
    },
    showDownloadIcon: {
      type: Boolean,
      default: void 0
    },
    showPreviewIcon: {
      type: Boolean,
      default: void 0
    },
    removeIcon: Function,
    downloadIcon: Function,
    previewIcon: Function,
    locale: {
      type: Object,
      default: void 0
    },
    previewFile: Function,
    iconRender: Function,
    isImageUrl: Function,
    appendAction: Function,
    appendActionVisible: {
      type: Boolean,
      default: void 0
    },
    itemRender: Function
  };
}
function file2Obj(file) {
  return _extends(_extends({}, file), {
    lastModified: file.lastModified,
    lastModifiedDate: file.lastModifiedDate,
    name: file.name,
    size: file.size,
    type: file.type,
    uid: file.uid,
    percent: 0,
    originFileObj: file
  });
}
function updateFileList(file, fileList) {
  var nextFileList = _toConsumableArray(fileList);
  var fileIndex = nextFileList.findIndex(function(_ref) {
    var uid2 = _ref.uid;
    return uid2 === file.uid;
  });
  if (fileIndex === -1) {
    nextFileList.push(file);
  } else {
    nextFileList[fileIndex] = file;
  }
  return nextFileList;
}
function getFileItem(file, fileList) {
  var matchKey = file.uid !== void 0 ? "uid" : "name";
  return fileList.filter(function(item) {
    return item[matchKey] === file[matchKey];
  })[0];
}
function removeFileItem(file, fileList) {
  var matchKey = file.uid !== void 0 ? "uid" : "name";
  var removed = fileList.filter(function(item) {
    return item[matchKey] !== file[matchKey];
  });
  if (removed.length === fileList.length) {
    return null;
  }
  return removed;
}
var extname = function extname2() {
  var url2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var temp = url2.split("/");
  var filename = temp[temp.length - 1];
  var filenameWithoutSuffix = filename.split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
};
var isImageFileType = function isImageFileType2(type2) {
  return type2.indexOf("image/") === 0;
};
var isImageUrl = function isImageUrl2(file) {
  if (file.type && !file.thumbUrl) {
    return isImageFileType(file.type);
  }
  var url2 = file.thumbUrl || file.url || "";
  var extension = extname(url2);
  if (/^data:image\//.test(url2) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i.test(extension)) {
    return true;
  }
  if (/^data:/.test(url2)) {
    return false;
  }
  if (extension) {
    return false;
  }
  return true;
};
var MEASURE_SIZE = 200;
function previewImage(file) {
  return new Promise(function(resolve) {
    if (!file.type || !isImageFileType(file.type)) {
      resolve("");
      return;
    }
    var canvas = document.createElement("canvas");
    canvas.width = MEASURE_SIZE;
    canvas.height = MEASURE_SIZE;
    canvas.style.cssText = "position: fixed; left: 0; top: 0; width: ".concat(MEASURE_SIZE, "px; height: ").concat(MEASURE_SIZE, "px; z-index: 9999; display: none;");
    document.body.appendChild(canvas);
    var ctx = canvas.getContext("2d");
    var img = new Image();
    img.onload = function() {
      var width = img.width, height = img.height;
      var drawWidth = MEASURE_SIZE;
      var drawHeight = MEASURE_SIZE;
      var offsetX = 0;
      var offsetY = 0;
      if (width > height) {
        drawHeight = height * (MEASURE_SIZE / width);
        offsetY = -(drawHeight - drawWidth) / 2;
      } else {
        drawWidth = width * (MEASURE_SIZE / height);
        offsetX = -(drawWidth - drawHeight) / 2;
      }
      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      var dataURL = canvas.toDataURL();
      document.body.removeChild(canvas);
      resolve(dataURL);
    };
    img.src = window.URL.createObjectURL(file);
  });
}
function convertLegacyProps(type2) {
  if (type2 === "danger") {
    return {
      danger: true
    };
  }
  return {
    type: type2
  };
}
var buttonProps = function buttonProps2() {
  return {
    prefixCls: String,
    type: String,
    htmlType: {
      type: String,
      default: "button"
    },
    shape: {
      type: String
    },
    size: {
      type: String
    },
    loading: {
      type: [Boolean, Object],
      default: function _default5() {
        return false;
      }
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    ghost: {
      type: Boolean,
      default: void 0
    },
    block: {
      type: Boolean,
      default: void 0
    },
    danger: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes$1.any,
    href: String,
    target: String,
    title: String,
    onClick: {
      type: Function
    },
    onMousedown: {
      type: Function
    }
  };
};
var buttonTypes = buttonProps;
var getCollapsedWidth = function getCollapsedWidth2(node) {
  if (node) {
    node.style.width = "0px";
    node.style.opacity = "0";
    node.style.transform = "scale(0)";
  }
};
var getRealWidth = function getRealWidth2(node) {
  Vue.nextTick(function() {
    if (node) {
      node.style.width = "".concat(node.scrollWidth, "px");
      node.style.opacity = "1";
      node.style.transform = "scale(1)";
    }
  });
};
var resetStyle = function resetStyle2(node) {
  if (node && node.style) {
    node.style.width = null;
    node.style.opacity = null;
    node.style.transform = null;
  }
};
var LoadingIcon = Vue.defineComponent({
  name: "LoadingIcon",
  props: {
    prefixCls: String,
    loading: [Boolean, Object],
    existIcon: Boolean
  },
  setup: function setup11(props2) {
    return function() {
      var existIcon = props2.existIcon, prefixCls = props2.prefixCls, loading = props2.loading;
      if (existIcon) {
        return Vue.createVNode("span", {
          "class": "".concat(prefixCls, "-loading-icon")
        }, [Vue.createVNode(LoadingOutlined$1, null, null)]);
      }
      var visible = !!loading;
      return Vue.createVNode(Transition$1, {
        "name": "".concat(prefixCls, "-loading-icon-motion"),
        "onBeforeEnter": getCollapsedWidth,
        "onEnter": getRealWidth,
        "onAfterEnter": resetStyle,
        "onBeforeLeave": getRealWidth,
        "onLeave": function onLeave(node) {
          setTimeout(function() {
            getCollapsedWidth(node);
          });
        },
        "onAfterLeave": resetStyle
      }, {
        default: function _default5() {
          return [visible ? Vue.createVNode("span", {
            "class": "".concat(prefixCls, "-loading-icon")
          }, [Vue.createVNode(LoadingOutlined$1, null, null)]) : null];
        }
      });
    };
  }
});
var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function isUnborderedButtonType(type2) {
  return type2 === "text" || type2 === "link";
}
var Button$1 = Vue.defineComponent({
  name: "AButton",
  inheritAttrs: false,
  __ANT_BUTTON: true,
  props: initDefaultProps$1(buttonTypes(), {
    type: "default"
  }),
  slots: ["icon"],
  setup: function setup12(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
    var _useConfigInject = useConfigInject("btn", props2), prefixCls = _useConfigInject.prefixCls, autoInsertSpaceInButton = _useConfigInject.autoInsertSpaceInButton, direction = _useConfigInject.direction, size = _useConfigInject.size;
    var buttonNodeRef = Vue.ref(null);
    var delayTimeoutRef = Vue.ref(void 0);
    var isNeedInserted = false;
    var innerLoading = Vue.ref(false);
    var hasTwoCNChar = Vue.ref(false);
    var autoInsertSpace = Vue.computed(function() {
      return autoInsertSpaceInButton.value !== false;
    });
    var loadingOrDelay = Vue.computed(function() {
      return _typeof$1(props2.loading) === "object" && props2.loading.delay ? props2.loading.delay || true : !!props2.loading;
    });
    Vue.watch(loadingOrDelay, function(val) {
      clearTimeout(delayTimeoutRef.value);
      if (typeof loadingOrDelay.value === "number") {
        delayTimeoutRef.value = setTimeout(function() {
          innerLoading.value = val;
        }, loadingOrDelay.value);
      } else {
        innerLoading.value = val;
      }
    }, {
      immediate: true
    });
    var classes = Vue.computed(function() {
      var _ref2;
      var type2 = props2.type, _props$shape = props2.shape, shape = _props$shape === void 0 ? "default" : _props$shape, ghost = props2.ghost, block = props2.block, danger = props2.danger;
      var pre = prefixCls.value;
      var sizeClassNameMap = {
        large: "lg",
        small: "sm",
        middle: void 0
      };
      var sizeFullname = size.value;
      var sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
      return _ref2 = {}, _defineProperty$T(_ref2, "".concat(pre), true), _defineProperty$T(_ref2, "".concat(pre, "-").concat(type2), type2), _defineProperty$T(_ref2, "".concat(pre, "-").concat(shape), shape !== "default" && shape), _defineProperty$T(_ref2, "".concat(pre, "-").concat(sizeCls), sizeCls), _defineProperty$T(_ref2, "".concat(pre, "-loading"), innerLoading.value), _defineProperty$T(_ref2, "".concat(pre, "-background-ghost"), ghost && !isUnborderedButtonType(type2)), _defineProperty$T(_ref2, "".concat(pre, "-two-chinese-chars"), hasTwoCNChar.value && autoInsertSpace.value), _defineProperty$T(_ref2, "".concat(pre, "-block"), block), _defineProperty$T(_ref2, "".concat(pre, "-dangerous"), !!danger), _defineProperty$T(_ref2, "".concat(pre, "-rtl"), direction.value === "rtl"), _ref2;
    });
    var fixTwoCNChar = function fixTwoCNChar2() {
      var node = buttonNodeRef.value;
      if (!node || autoInsertSpaceInButton.value === false) {
        return;
      }
      var buttonText = node.textContent;
      if (isNeedInserted && isTwoCNChar(buttonText)) {
        if (!hasTwoCNChar.value) {
          hasTwoCNChar.value = true;
        }
      } else if (hasTwoCNChar.value) {
        hasTwoCNChar.value = false;
      }
    };
    var handleClick = function handleClick2(event) {
      if (innerLoading.value || props2.disabled) {
        event.preventDefault();
        return;
      }
      emit("click", event);
    };
    var insertSpace = function insertSpace2(child, needInserted) {
      var SPACE = needInserted ? " " : "";
      if (child.type === Vue.Text) {
        var text = child.children.trim();
        if (isTwoCNChar(text)) {
          text = text.split("").join(SPACE);
        }
        return Vue.createVNode("span", null, [text]);
      }
      return child;
    };
    Vue.watchEffect(function() {
      devWarning(!(props2.ghost && isUnborderedButtonType(props2.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
    });
    Vue.onMounted(fixTwoCNChar);
    Vue.onUpdated(fixTwoCNChar);
    Vue.onBeforeUnmount(function() {
      delayTimeoutRef.value && clearTimeout(delayTimeoutRef.value);
    });
    return function() {
      var _a, _b;
      var _props$icon = props2.icon, icon = _props$icon === void 0 ? (_a = slots.icon) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$icon;
      var children = flattenChildren((_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots));
      isNeedInserted = children.length === 1 && !icon && !isUnborderedButtonType(props2.type);
      var type2 = props2.type, htmlType = props2.htmlType, disabled = props2.disabled, href = props2.href, title = props2.title, target = props2.target, onMousedown2 = props2.onMousedown;
      var iconType = innerLoading.value ? "loading" : icon;
      var buttonProps3 = _extends(_extends({}, attrs), {
        title,
        disabled,
        class: [classes.value, attrs.class, _defineProperty$T({}, "".concat(prefixCls.value, "-icon-only"), children.length === 0 && !!iconType)],
        onClick: handleClick,
        onMousedown: onMousedown2
      });
      if (!disabled) {
        delete buttonProps3.disabled;
      }
      var iconNode = icon && !innerLoading.value ? icon : Vue.createVNode(LoadingIcon, {
        "existIcon": !!icon,
        "prefixCls": prefixCls.value,
        "loading": !!innerLoading.value
      }, null);
      var kids = children.map(function(child) {
        return insertSpace(child, isNeedInserted && autoInsertSpace.value);
      });
      if (href !== void 0) {
        return Vue.createVNode("a", _objectSpread2$1(_objectSpread2$1({}, buttonProps3), {}, {
          "href": href,
          "target": target,
          "ref": buttonNodeRef
        }), [iconNode, kids]);
      }
      var buttonNode = Vue.createVNode("button", _objectSpread2$1(_objectSpread2$1({}, buttonProps3), {}, {
        "ref": buttonNodeRef,
        "type": htmlType
      }), [iconNode, kids]);
      if (isUnborderedButtonType(type2)) {
        return buttonNode;
      }
      return Vue.createVNode(Wave, {
        "ref": "wave",
        "disabled": !!innerLoading.value
      }, {
        default: function _default5() {
          return [buttonNode];
        }
      });
    };
  }
});
function _defineProperties(target, props2) {
  for (var i2 = 0; i2 < props2.length; i2++) {
    var descriptor = props2[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var UnreachableException = /* @__PURE__ */ _createClass(function UnreachableException2(value) {
  _classCallCheck(this, UnreachableException2);
  this.error = new Error("unreachable case: ".concat(JSON.stringify(value)));
});
var buttonGroupProps = function buttonGroupProps2() {
  return {
    prefixCls: String,
    size: {
      type: String
    }
  };
};
var ButtonGroup$1 = Vue.defineComponent({
  name: "AButtonGroup",
  props: buttonGroupProps(),
  setup: function setup13(props2, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("btn-group", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var classes = Vue.computed(function() {
      var _ref2;
      var size = props2.size;
      var sizeCls = "";
      switch (size) {
        case "large":
          sizeCls = "lg";
          break;
        case "small":
          sizeCls = "sm";
          break;
        case "middle":
        case void 0:
          break;
        default:
          console.warn(new UnreachableException(size).error);
      }
      return _ref2 = {}, _defineProperty$T(_ref2, "".concat(prefixCls.value), true), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-").concat(sizeCls), sizeCls), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _ref2;
    });
    return function() {
      var _a;
      return Vue.createVNode("div", {
        "class": classes.value
      }, [flattenChildren((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots))]);
    };
  }
});
Button$1.Group = ButtonGroup$1;
Button$1.install = function(app) {
  app.component(Button$1.name, Button$1);
  app.component(ButtonGroup$1.name, ButtonGroup$1);
  return app;
};
var EyeOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z"
      }
    }]
  },
  "name": "eye",
  "theme": "outlined"
};
var EyeOutlinedSvg = EyeOutlined$2;
function _objectSpread$B(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$C(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$C(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EyeOutlined = function EyeOutlined2(props2, context) {
  var p2 = _objectSpread$B({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$B({}, p2, {
    "icon": EyeOutlinedSvg
  }), null);
};
EyeOutlined.displayName = "EyeOutlined";
EyeOutlined.inheritAttrs = false;
var EyeOutlined$1 = EyeOutlined;
var DeleteOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z"
      }
    }]
  },
  "name": "delete",
  "theme": "outlined"
};
var DeleteOutlinedSvg = DeleteOutlined$2;
function _objectSpread$A(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$B(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$B(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DeleteOutlined = function DeleteOutlined2(props2, context) {
  var p2 = _objectSpread$A({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$A({}, p2, {
    "icon": DeleteOutlinedSvg
  }), null);
};
DeleteOutlined.displayName = "DeleteOutlined";
DeleteOutlined.inheritAttrs = false;
var DeleteOutlined$1 = DeleteOutlined;
var DownloadOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z"
      }
    }]
  },
  "name": "download",
  "theme": "outlined"
};
var DownloadOutlinedSvg = DownloadOutlined$2;
function _objectSpread$z(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$A(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$A(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DownloadOutlined = function DownloadOutlined2(props2, context) {
  var p2 = _objectSpread$z({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$z({}, p2, {
    "icon": DownloadOutlinedSvg
  }), null);
};
DownloadOutlined.displayName = "DownloadOutlined";
DownloadOutlined.inheritAttrs = false;
var DownloadOutlined$1 = DownloadOutlined;
function contains(root2, n2) {
  if (!root2) {
    return false;
  }
  return root2.contains(n2);
}
var availablePrefixs = ["moz", "ms", "webkit"];
function requestAnimationFramePolyfill() {
  var lastTime = 0;
  return function(callback) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function() {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}
function getRequestAnimationFrame() {
  if (typeof window === "undefined") {
    return function() {
    };
  }
  if (window.requestAnimationFrame) {
    return window.requestAnimationFrame.bind(window);
  }
  var prefix = availablePrefixs.filter(function(key2) {
    return "".concat(key2, "RequestAnimationFrame") in window;
  })[0];
  return prefix ? window["".concat(prefix, "RequestAnimationFrame")] : requestAnimationFramePolyfill();
}
function cancelRequestAnimationFrame(id) {
  if (typeof window === "undefined") {
    return null;
  }
  if (window.cancelAnimationFrame) {
    return window.cancelAnimationFrame(id);
  }
  var prefix = availablePrefixs.filter(function(key2) {
    return "".concat(key2, "CancelAnimationFrame") in window || "".concat(key2, "CancelRequestAnimationFrame") in window;
  })[0];
  return prefix ? (window["".concat(prefix, "CancelAnimationFrame")] || window["".concat(prefix, "CancelRequestAnimationFrame")]).call(this, id) : clearTimeout(id);
}
var raf = getRequestAnimationFrame();
var cancelAnimationTimeout = function cancelAnimationTimeout2(frame) {
  return cancelRequestAnimationFrame(frame.id);
};
var requestAnimationTimeout = function requestAnimationTimeout2(callback) {
  var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var start = Date.now();
  function timeout() {
    if (Date.now() - start >= delay) {
      callback.call();
    } else {
      frame.id = raf(timeout);
    }
  }
  var frame = {
    id: raf(timeout)
  };
  return frame;
};
var supportsPassive = false;
try {
  var opts = Object.defineProperty({}, "passive", {
    get: function get2() {
      supportsPassive = true;
    }
  });
  window.addEventListener("testPassive", null, opts);
  window.removeEventListener("testPassive", null, opts);
} catch (e2) {
}
var supportsPassive$1 = supportsPassive;
function addEventListenerWrap(target, eventType, cb, option) {
  if (target && target.addEventListener) {
    var opt = option;
    if (opt === void 0 && supportsPassive$1 && (eventType === "touchstart" || eventType === "touchmove" || eventType === "wheel")) {
      opt = {
        passive: false
      };
    }
    target.addEventListener(eventType, cb, opt);
  }
  return {
    remove: function remove() {
      if (target && target.removeEventListener) {
        target.removeEventListener(eventType, cb);
      }
    }
  };
}
var innerProps = {
  visible: Boolean,
  prefixCls: String,
  zIndex: Number,
  destroyPopupOnHide: Boolean,
  forceRender: Boolean,
  animation: [String, Object],
  transitionName: String,
  stretch: {
    type: String
  },
  align: {
    type: Object
  },
  point: {
    type: Object
  },
  getRootDomNode: {
    type: Function
  },
  getClassNameFromAlign: {
    type: Function
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onTouchstart: {
    type: Function
  }
};
var mobileProps = _extends(_extends({}, innerProps), {
  mobile: {
    type: Object
  }
});
var popupProps = _extends(_extends({}, innerProps), {
  mask: Boolean,
  mobile: {
    type: Object
  },
  maskAnimation: String,
  maskTransitionName: String
});
function getMotion(_ref) {
  var prefixCls = _ref.prefixCls, animation = _ref.animation, transitionName2 = _ref.transitionName;
  if (animation) {
    return {
      name: "".concat(prefixCls, "-").concat(animation)
    };
  }
  if (transitionName2) {
    return {
      name: transitionName2
    };
  }
  return {};
}
function Mask$1(props2) {
  var prefixCls = props2.prefixCls, visible = props2.visible, zIndex = props2.zIndex, mask = props2.mask, maskAnimation = props2.maskAnimation, maskTransitionName = props2.maskTransitionName;
  if (!mask) {
    return null;
  }
  var motion = {};
  if (maskTransitionName || maskAnimation) {
    motion = getMotion({
      prefixCls,
      transitionName: maskTransitionName,
      animation: maskAnimation
    });
  }
  return Vue.createVNode(Vue.Transition, _objectSpread2$1({
    "appear": true
  }, motion), {
    default: function _default5() {
      return [Vue.withDirectives(Vue.createVNode("div", {
        "style": {
          zIndex
        },
        "class": "".concat(prefixCls, "-mask")
      }, null), [[Vue.resolveDirective("if"), visible]])];
    }
  });
}
Mask$1.displayName = "Mask";
var MobilePopupInner = Vue.defineComponent({
  name: "MobilePopupInner",
  inheritAttrs: false,
  props: mobileProps,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup: function setup14(props2, _ref) {
    var expose = _ref.expose, slots = _ref.slots;
    var elementRef = Vue.ref();
    expose({
      forceAlign: function forceAlign() {
      },
      getElement: function getElement2() {
        return elementRef.value;
      }
    });
    return function() {
      var _a;
      var zIndex = props2.zIndex, visible = props2.visible, prefixCls = props2.prefixCls, _props$mobile = props2.mobile;
      _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
      var popupClassName = _props$mobile.popupClassName, popupStyle = _props$mobile.popupStyle, _props$mobile$popupMo = _props$mobile.popupMotion, popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo, popupRender = _props$mobile.popupRender;
      var mergedStyle = _extends({
        zIndex
      }, popupStyle);
      var childNode = flattenChildren((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
      if (childNode.length > 1) {
        childNode = Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-content")
        }, [childNode]);
      }
      if (popupRender) {
        childNode = popupRender(childNode);
      }
      var mergedClassName = classNames(prefixCls, popupClassName);
      return Vue.createVNode(Vue.Transition, _objectSpread2$1({
        "ref": elementRef
      }, popupMotion), {
        default: function _default5() {
          return [visible ? Vue.createVNode("div", {
            "class": mergedClassName,
            "style": mergedStyle
          }, [childNode]) : null];
        }
      });
    };
  }
});
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator2) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator2["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
var StatusQueue = ["measure", "align", null, "motion"];
var useVisibleStatus = function(visible, doMeasure) {
  var status = Vue.ref(null);
  var rafRef = Vue.ref();
  var destroyRef = Vue.ref(false);
  function setStatus(nextStatus) {
    if (!destroyRef.value) {
      status.value = nextStatus;
    }
  }
  function cancelRaf() {
    wrapperRaf.cancel(rafRef.value);
  }
  function goNextStatus(callback) {
    cancelRaf();
    rafRef.value = wrapperRaf(function() {
      var newStatus = status.value;
      switch (status.value) {
        case "align":
          newStatus = "motion";
          break;
        case "motion":
          newStatus = "stable";
          break;
      }
      setStatus(newStatus);
      callback === null || callback === void 0 ? void 0 : callback();
    });
  }
  Vue.watch(visible, function() {
    setStatus("measure");
  }, {
    immediate: true,
    flush: "post"
  });
  Vue.onMounted(function() {
    Vue.watch(status, function() {
      switch (status.value) {
        case "measure":
          doMeasure();
          break;
      }
      if (status.value) {
        rafRef.value = wrapperRaf(function() {
          return __awaiter$1(void 0, void 0, void 0, /* @__PURE__ */ regenerator.mark(function _callee() {
            var index2, nextStatus;
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    index2 = StatusQueue.indexOf(status.value);
                    nextStatus = StatusQueue[index2 + 1];
                    if (nextStatus && index2 !== -1) {
                      setStatus(nextStatus);
                    }
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
        });
      }
    }, {
      immediate: true,
      flush: "post"
    });
  });
  Vue.onBeforeUnmount(function() {
    destroyRef.value = true;
    cancelRaf();
  });
  return [status, goNextStatus];
};
var useStretchStyle = function(stretch) {
  var targetSize = Vue.ref({
    width: 0,
    height: 0
  });
  function measureStretch(element) {
    targetSize.value = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  var style = Vue.computed(function() {
    var sizeStyle = {};
    if (stretch.value) {
      var _targetSize$value = targetSize.value, width = _targetSize$value.width, height = _targetSize$value.height;
      if (stretch.value.indexOf("height") !== -1 && height) {
        sizeStyle.height = "".concat(height, "px");
      } else if (stretch.value.indexOf("minHeight") !== -1 && height) {
        sizeStyle.minHeight = "".concat(height, "px");
      }
      if (stretch.value.indexOf("width") !== -1 && width) {
        sizeStyle.width = "".concat(width, "px");
      } else if (stretch.value.indexOf("minWidth") !== -1 && width) {
        sizeStyle.minWidth = "".concat(width, "px");
      }
    }
    return sizeStyle;
  });
  return [style, measureStretch];
};
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty$z(target, key2, source[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty$z(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var vendorPrefix;
var jsCssMap = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  ms: "-ms-",
  O: "-o-"
};
function getVendorPrefix() {
  if (vendorPrefix !== void 0) {
    return vendorPrefix;
  }
  vendorPrefix = "";
  var style = document.createElement("p").style;
  var testProp = "Transform";
  for (var key2 in jsCssMap) {
    if (key2 + testProp in style) {
      vendorPrefix = key2;
    }
  }
  return vendorPrefix;
}
function getTransitionName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
}
function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
}
function setTransitionProperty(node, value) {
  var name = getTransitionName();
  if (name) {
    node.style[name] = value;
    if (name !== "transitionProperty") {
      node.style.transitionProperty = value;
    }
  }
}
function setTransform(node, value) {
  var name = getTransformName();
  if (name) {
    node.style[name] = value;
    if (name !== "transform") {
      node.style.transform = value;
    }
  }
}
function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[getTransitionName()];
}
function getTransformXY(node) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
  if (transform && transform !== "none") {
    var matrix = transform.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node, xy) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
  if (transform && transform !== "none") {
    var arr;
    var match2d = transform.match(matrix2d);
    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node, "matrix(".concat(arr.join(","), ")"));
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node, "matrix3d(".concat(arr.join(","), ")"));
    }
  } else {
    setTransform(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX;
function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = "none";
  elem.offsetHeight;
  elem.style.display = originalStyle;
}
function css(el, name, v2) {
  var value = v2;
  if (_typeof(name) === "object") {
    for (var i2 in name) {
      if (name.hasOwnProperty(i2)) {
        css(el, i2, name[i2]);
      }
    }
    return void 0;
  }
  if (typeof value !== "undefined") {
    if (typeof value === "number") {
      value = "".concat(value, "px");
    }
    el.style[name] = value;
    return void 0;
  }
  return getComputedStyleX(el, name);
}
function getClientPosition(elem) {
  var box;
  var x2;
  var y2;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  box = elem.getBoundingClientRect();
  x2 = Math.floor(box.left);
  y2 = Math.floor(box.top);
  x2 -= docElem.clientLeft || body.clientLeft || 0;
  y2 -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x2,
    top: y2
  };
}
function getScroll$2(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method];
    if (typeof ret !== "number") {
      ret = d2.body[method];
    }
  }
  return ret;
}
function getScrollLeft(w2) {
  return getScroll$2(w2);
}
function getScrollTop(w2) {
  return getScroll$2(w2, true);
}
function getOffset$1(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w2 = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w2);
  pos.top += getScrollTop(w2);
  return pos;
}
function isWindow$1(obj) {
  return obj !== null && obj !== void 0 && obj == obj.window;
}
function getDocument(node) {
  if (isWindow$1(node)) {
    return node.document;
  }
  if (node.nodeType === 9) {
    return node;
  }
  return node.ownerDocument;
}
function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = "";
  var d2 = getDocument(elem);
  computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }
  return val;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = "currentStyle";
var RUNTIME_STYLE = "runtimeStyle";
var LEFT = "left";
var PX = "px";
function _getComputedStyleIE(elem, name) {
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT];
    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];
    style[LEFT] = name === "fontSize" ? "1em" : ret || 0;
    ret = style.pixelLeft + PX;
    style[LEFT] = left;
    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }
  return ret === "" ? "auto" : ret;
}
if (typeof window !== "undefined") {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}
function getOffsetDirection(dir, option) {
  if (dir === "left") {
    return option.useCssRight ? "right" : dir;
  }
  return option.useCssBottom ? "bottom" : dir;
}
function oppositeOffsetDirection(dir) {
  if (dir === "left") {
    return "right";
  } else if (dir === "right") {
    return "left";
  } else if (dir === "top") {
    return "bottom";
  } else if (dir === "bottom") {
    return "top";
  }
}
function setLeftTop(elem, offset3, option) {
  if (css(elem, "position") === "static") {
    elem.style.position = "relative";
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection("left", option);
  var verticalProperty = getOffsetDirection("top", option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
  if (horizontalProperty !== "left") {
    presetH = 999;
  }
  if (verticalProperty !== "top") {
    presetV = 999;
  }
  var originalTransition = "";
  var originalOffset = getOffset$1(elem);
  if ("left" in offset3 || "top" in offset3) {
    originalTransition = getTransitionProperty(elem) || "";
    setTransitionProperty(elem, "none");
  }
  if ("left" in offset3) {
    elem.style[oppositeHorizontalProperty] = "";
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }
  if ("top" in offset3) {
    elem.style[oppositeVerticalProperty] = "";
    elem.style[verticalProperty] = "".concat(presetV, "px");
  }
  forceRelayout(elem);
  var old = getOffset$1(elem);
  var originalStyle = {};
  for (var key2 in offset3) {
    if (offset3.hasOwnProperty(key2)) {
      var dir = getOffsetDirection(key2, option);
      var preset = key2 === "left" ? presetH : presetV;
      var off = originalOffset[key2] - old[key2];
      if (dir === key2) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }
  css(elem, originalStyle);
  forceRelayout(elem);
  if ("left" in offset3 || "top" in offset3) {
    setTransitionProperty(elem, originalTransition);
  }
  var ret = {};
  for (var _key in offset3) {
    if (offset3.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset3[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }
  css(elem, ret);
}
function setTransform$1(elem, offset3) {
  var originalOffset = getOffset$1(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };
  if ("left" in offset3) {
    resultXY.x = originalXY.x + offset3.left - originalOffset.left;
  }
  if ("top" in offset3) {
    resultXY.y = originalXY.y + offset3.top - originalOffset.top;
  }
  setTransformXY(elem, resultXY);
}
function setOffset(elem, offset3, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset$1(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset3.left.toFixed(0);
    var tTop = offset3.top.toFixed(0);
    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset3, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset3);
  } else {
    setLeftTop(elem, offset3, option);
  }
}
function each$1(arr, fn) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    fn(arr[i2]);
  }
}
function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, "boxSizing") === "border-box";
}
var BOX_MODELS = ["margin", "border", "padding"];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;
function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name;
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }
  callback.call(elem);
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}
function getPBMWidth(elem, props2, which) {
  var value = 0;
  var prop;
  var j2;
  var i2;
  for (j2 = 0; j2 < props2.length; j2++) {
    prop = props2[j2];
    if (prop) {
      for (i2 = 0; i2 < which.length; i2++) {
        var cssProp = void 0;
        if (prop === "border") {
          cssProp = "".concat(prop).concat(which[i2], "Width");
        } else {
          cssProp = prop + which[i2];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}
var domUtils = {
  getParent: function getParent2(element) {
    var parent = element;
    do {
      if (parent.nodeType === 11 && parent.host) {
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);
    return parent;
  }
};
each$1(["Width", "Height"], function(name) {
  domUtils["doc".concat(name)] = function(refWin) {
    var d2 = refWin.document;
    return Math.max(d2.documentElement["scroll".concat(name)], d2.body["scroll".concat(name)], domUtils["viewport".concat(name)](d2));
  };
  domUtils["viewport".concat(name)] = function(win) {
    var prop = "client".concat(name);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    return doc.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
  };
});
function getWH(elem, name, ex) {
  var extra = ex;
  if (isWindow$1(elem)) {
    return name === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  var borderBoxValue = name === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
    borderBoxValue = void 0;
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }
  if (extra === void 0) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ["border", "padding"], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var val;
  var elem = args[0];
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(void 0, args);
  } else {
    swap(elem, cssShow, function() {
      val = getWH.apply(void 0, args);
    });
  }
  return val;
}
each$1(["width", "height"], function(name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils["outer".concat(first)] = function(el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  domUtils[name] = function(elem, v2) {
    var val = v2;
    if (val !== void 0) {
      if (elem) {
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ["padding", "border"], which);
        }
        return css(elem, name, val);
      }
      return void 0;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});
function mix(to, from) {
  for (var i2 in from) {
    if (from.hasOwnProperty(i2)) {
      to[i2] = from[i2];
    }
  }
  return to;
}
var utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument,
  offset: function offset2(el, value, option) {
    if (typeof value !== "undefined") {
      setOffset(el, value, option || {});
    } else {
      return getOffset$1(el);
    }
  },
  isWindow: isWindow$1,
  each: each$1,
  css,
  clone: function clone(obj) {
    var i2;
    var ret = {};
    for (i2 in obj) {
      if (obj.hasOwnProperty(i2)) {
        ret[i2] = obj[i2];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i2 in obj) {
        if (obj.hasOwnProperty(i2)) {
          ret.overflow[i2] = obj.overflow[i2];
        }
      }
    }
    return ret;
  },
  mix,
  getWindowScrollLeft: function getWindowScrollLeft(w2) {
    return getScrollLeft(w2);
  },
  getWindowScrollTop: function getWindowScrollTop(w2) {
    return getScrollTop(w2);
  },
  merge: function merge() {
    var ret = {};
    for (var i2 = 0; i2 < arguments.length; i2++) {
      utils.mix(ret, i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(utils, domUtils);
var getParent$1 = utils.getParent;
function getOffsetParent(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return null;
  }
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent;
  var positionStyle = utils.css(element, "position");
  var skipStatic = positionStyle === "fixed" || positionStyle === "absolute";
  if (!skipStatic) {
    return element.nodeName.toLowerCase() === "html" ? null : getParent$1(element);
  }
  for (parent = getParent$1(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent$1(parent)) {
    positionStyle = utils.css(parent, "position");
    if (positionStyle !== "static") {
      return parent;
    }
  }
  return null;
}
var getParent$1$1 = utils.getParent;
function isAncestorFixed(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return false;
  }
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent = null;
  for (parent = getParent$1$1(element); parent && parent !== body && parent !== doc; parent = getParent$1$1(parent)) {
    var positionStyle = utils.css(parent, "position");
    if (positionStyle === "fixed") {
      return true;
    }
  }
  return false;
}
function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element);
  var doc = utils.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;
  while (el) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || el.clientWidth !== 0) && el !== body && el !== documentElement && utils.css(el, "overflow") !== "visible") {
      var pos = utils.offset(el);
      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right, pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = getOffsetParent(el);
  }
  var originalPosition = null;
  if (!utils.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position = utils.css(element, "position");
    if (position === "absolute") {
      element.style.position = "fixed";
    }
  }
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight;
  var bodyStyle = window.getComputedStyle(body);
  if (bodyStyle.overflowX === "hidden") {
    documentWidth = win.innerWidth;
  }
  if (bodyStyle.overflowY === "hidden") {
    documentHeight = win.innerHeight;
  }
  if (element.style) {
    element.style.position = originalPosition;
  }
  if (alwaysByViewport || isAncestorFixed(element)) {
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}
function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = utils.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };
  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  }
  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  }
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  }
  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }
  return utils.mix(pos, size);
}
function getRegion(node) {
  var offset3;
  var w2;
  var h2;
  if (!utils.isWindow(node) && node.nodeType !== 9) {
    offset3 = utils.offset(node);
    w2 = utils.outerWidth(node);
    h2 = utils.outerHeight(node);
  } else {
    var win = utils.getWindow(node);
    offset3 = {
      left: utils.getWindowScrollLeft(win),
      top: utils.getWindowScrollTop(win)
    };
    w2 = utils.viewportWidth(win);
    h2 = utils.viewportHeight(win);
  }
  offset3.width = w2;
  offset3.height = h2;
  return offset3;
}
function getAlignOffset(region, align) {
  var V2 = align.charAt(0);
  var H = align.charAt(1);
  var w2 = region.width;
  var h2 = region.height;
  var x2 = region.left;
  var y2 = region.top;
  if (V2 === "c") {
    y2 += h2 / 2;
  } else if (V2 === "b") {
    y2 += h2;
  }
  if (H === "c") {
    x2 += w2 / 2;
  } else if (H === "r") {
    x2 += w2;
  }
  return {
    left: x2,
    top: y2
  };
}
function getElFuturePos(elRegion, refNodeRegion, points, offset3, targetOffset2) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff[0] + offset3[0] - targetOffset2[0]),
    top: Math.round(elRegion.top - diff[1] + offset3[1] - targetOffset2[1])
  };
}
function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}
function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}
function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}
function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}
function flip(points, reg, map) {
  var ret = [];
  utils.each(points, function(p2) {
    ret.push(p2.replace(reg, function(m2) {
      return map[m2];
    }));
  });
  return ret;
}
function flipOffset(offset3, index2) {
  offset3[index2] = -offset3[index2];
  return offset3;
}
function convertOffset(str, offsetLen) {
  var n2;
  if (/%$/.test(str)) {
    n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n2 = parseInt(str, 10);
  }
  return n2 || 0;
}
function normalizeOffset(offset3, el) {
  offset3[0] = convertOffset(offset3[0], el.width);
  offset3[1] = convertOffset(offset3[1], el.height);
}
function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset3 = align.offset || [0, 0];
  var targetOffset2 = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el;
  offset3 = [].concat(offset3);
  targetOffset2 = [].concat(targetOffset2);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
  var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
  var elRegion = getRegion(source);
  normalizeOffset(offset3, elRegion);
  normalizeOffset(targetOffset2, tgtRegion);
  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
  var newElRegion = utils.merge(elRegion, elFuturePos);
  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        var newPoints = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
        var newOffset = flipOffset(offset3, 0);
        var newTargetOffset = flipOffset(targetOffset2, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset3 = newOffset;
          targetOffset2 = newTargetOffset;
        }
      }
    }
    if (overflow.adjustY) {
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        var _newPoints = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
        var _newOffset = flipOffset(offset3, 1);
        var _newTargetOffset = flipOffset(targetOffset2, 1);
        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset3 = _newOffset;
          targetOffset2 = _newTargetOffset;
        }
      }
    }
    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
      utils.mix(newElRegion, elFuturePos);
    }
    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
    if (isStillFailX || isStillFailY) {
      var _newPoints2 = points;
      if (isStillFailX) {
        _newPoints2 = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
      }
      if (isStillFailY) {
        _newPoints2 = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
      }
      points = _newPoints2;
      offset3 = align.offset || [0, 0];
      targetOffset2 = align.targetOffset || [0, 0];
    }
    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }
  if (newElRegion.width !== elRegion.width) {
    utils.css(source, "width", utils.width(source) + newElRegion.width - elRegion.width);
  }
  if (newElRegion.height !== elRegion.height) {
    utils.css(source, "height", utils.height(source) + newElRegion.height - elRegion.height);
  }
  utils.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points,
    offset: offset3,
    targetOffset: targetOffset2,
    overflow: newOverflowCfg
  };
}
function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}
function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;
function alignPoint(el, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = utils.getDocument(el);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  if ("pageX" in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }
  if ("pageY" in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }
  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
  var points = [align.points[0], "cc"];
  return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
    points
  }), pointInView);
}
function cloneElement(vnode) {
  var nodeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var mergeRef = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var ele = vnode;
  if (Array.isArray(vnode)) {
    ele = filterEmpty(vnode)[0];
  }
  if (!ele) {
    return null;
  }
  var node = Vue.cloneVNode(ele, nodeProps, mergeRef);
  node.props = override ? _extends(_extends({}, node.props), nodeProps) : node.props;
  warning(_typeof$1(node.props.class) !== "object", "class must be string");
  return node;
}
function cloneVNodes(vnodes) {
  var nodeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  return vnodes.map(function(vnode) {
    return cloneElement(vnode, nodeProps, override);
  });
}
var isVisible = function(element) {
  if (!element) {
    return false;
  }
  if (element.offsetParent) {
    return true;
  }
  if (element.getBBox) {
    var box = element.getBBox();
    if (box.width || box.height) {
      return true;
    }
  }
  if (element.getBoundingClientRect) {
    var _box = element.getBoundingClientRect();
    if (_box.width || _box.height) {
      return true;
    }
  }
  return false;
};
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key2) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key2) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key2) {
      var index2 = getIndex(this.__entries__, key2);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key2, value) {
      var index2 = getIndex(this.__entries__, key2);
      if (~index2) {
        this.__entries__[index2][1] = value;
      } else {
        this.__entries__.push([key2, value]);
      }
    };
    class_1.prototype.delete = function(key2) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key2);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key2) {
      return !!~getIndex(this.__entries__, key2);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx) {
      if (ctx === void 0) {
        ctx = null;
      }
      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
        var entry = _a[_i];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
    var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key2) {
      return !!~propertyName.indexOf(key2);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props2) {
  for (var _i = 0, _a = Object.keys(props2); _i < _a.length; _i++) {
    var key2 = _a[_i];
    Object.defineProperty(target, key2, {
      value: props2[key2],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles2) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles2["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles2) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles2["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles2 = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles2);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles2.width), height = toFloat(styles2.height);
  if (styles2.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles2, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles2, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y2, width, height) {
  return {
    x: x2,
    y: y2,
    width,
    height
  };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, {
      target,
      contentRect
    });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver$2 = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
["observe", "unobserve", "disconnect"].forEach(function(method) {
  ResizeObserver$2.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index$w = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$2;
}();
function isSamePoint(prev2, next2) {
  if (prev2 === next2)
    return true;
  if (!prev2 || !next2)
    return false;
  if ("pageX" in next2 && "pageY" in next2) {
    return prev2.pageX === next2.pageX && prev2.pageY === next2.pageY;
  }
  if ("clientX" in next2 && "clientY" in next2) {
    return prev2.clientX === next2.clientX && prev2.clientY === next2.clientY;
  }
  return false;
}
function restoreFocus(activeElement, container) {
  if (activeElement !== document.activeElement && contains(container, activeElement) && typeof activeElement.focus === "function") {
    activeElement.focus();
  }
}
function monitorResize(element, callback) {
  var prevWidth = null;
  var prevHeight = null;
  function onResize(_ref) {
    var _ref2 = _slicedToArray(_ref, 1), target = _ref2[0].target;
    if (!document.documentElement.contains(target))
      return;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
      Promise.resolve().then(function() {
        callback({
          width: fixedWidth,
          height: fixedHeight
        });
      });
    }
    prevWidth = fixedWidth;
    prevHeight = fixedHeight;
  }
  var resizeObserver = new index$w(onResize);
  if (element) {
    resizeObserver.observe(element);
  }
  return function() {
    resizeObserver.disconnect();
  };
}
var useBuffer = function(callback, buffer) {
  var called = false;
  var timeout = null;
  function cancelTrigger() {
    clearTimeout(timeout);
  }
  function trigger2(force) {
    if (!called || force === true) {
      if (callback() === false) {
        return;
      }
      called = true;
      cancelTrigger();
      timeout = setTimeout(function() {
        called = false;
      }, buffer.value);
    } else {
      cancelTrigger();
      timeout = setTimeout(function() {
        called = false;
        trigger2();
      }, buffer.value);
    }
  }
  return [trigger2, function() {
    called = false;
    cancelTrigger();
  }];
};
function isEqual$1(value, other) {
  return baseIsEqual(value, other);
}
var alignProps = {
  align: Object,
  target: [Object, Function],
  onAlign: Function,
  monitorBufferTime: Number,
  monitorWindowResize: Boolean,
  disabled: Boolean
};
function getElement(func) {
  if (typeof func !== "function")
    return null;
  return func();
}
function getPoint(point) {
  if (_typeof$1(point) !== "object" || !point)
    return null;
  return point;
}
var Align = Vue.defineComponent({
  name: "Align",
  props: alignProps,
  emits: ["align"],
  setup: function setup15(props2, _ref) {
    var expose = _ref.expose, slots = _ref.slots;
    var cacheRef = Vue.ref({});
    var nodeRef = Vue.ref();
    var _useBuffer = useBuffer(function() {
      var latestDisabled = props2.disabled, latestTarget = props2.target, latestAlign = props2.align, latestOnAlign = props2.onAlign;
      if (!latestDisabled && latestTarget && nodeRef.value) {
        var source = nodeRef.value;
        var result;
        var element = getElement(latestTarget);
        var point = getPoint(latestTarget);
        cacheRef.value.element = element;
        cacheRef.value.point = point;
        cacheRef.value.align = latestAlign;
        var _document = document, activeElement = _document.activeElement;
        if (element && isVisible(element)) {
          result = alignElement(source, element, latestAlign);
        } else if (point) {
          result = alignPoint(source, point, latestAlign);
        }
        restoreFocus(activeElement, source);
        if (latestOnAlign && result) {
          latestOnAlign(source, result);
        }
        return true;
      }
      return false;
    }, Vue.computed(function() {
      return props2.monitorBufferTime;
    })), _useBuffer2 = _slicedToArray(_useBuffer, 2), _forceAlign = _useBuffer2[0], cancelForceAlign = _useBuffer2[1];
    var resizeMonitor = Vue.ref({
      cancel: function cancel() {
      }
    });
    var sourceResizeMonitor = Vue.ref({
      cancel: function cancel() {
      }
    });
    var goAlign = function goAlign2() {
      var target = props2.target;
      var element = getElement(target);
      var point = getPoint(target);
      if (nodeRef.value !== sourceResizeMonitor.value.element) {
        sourceResizeMonitor.value.cancel();
        sourceResizeMonitor.value.element = nodeRef.value;
        sourceResizeMonitor.value.cancel = monitorResize(nodeRef.value, _forceAlign);
      }
      if (cacheRef.value.element !== element || !isSamePoint(cacheRef.value.point, point) || !isEqual$1(cacheRef.value.align, props2.align)) {
        _forceAlign();
        if (resizeMonitor.value.element !== element) {
          resizeMonitor.value.cancel();
          resizeMonitor.value.element = element;
          resizeMonitor.value.cancel = monitorResize(element, _forceAlign);
        }
      }
    };
    Vue.onMounted(function() {
      Vue.nextTick(function() {
        goAlign();
      });
    });
    Vue.onUpdated(function() {
      Vue.nextTick(function() {
        goAlign();
      });
    });
    Vue.watch(function() {
      return props2.disabled;
    }, function(disabled) {
      if (!disabled) {
        _forceAlign();
      } else {
        cancelForceAlign();
      }
    }, {
      immediate: true,
      flush: "post"
    });
    var winResizeRef = Vue.ref(null);
    Vue.watch(function() {
      return props2.monitorWindowResize;
    }, function(monitorWindowResize) {
      if (monitorWindowResize) {
        if (!winResizeRef.value) {
          winResizeRef.value = addEventListenerWrap(window, "resize", _forceAlign);
        }
      } else if (winResizeRef.value) {
        winResizeRef.value.remove();
        winResizeRef.value = null;
      }
    }, {
      flush: "post"
    });
    Vue.onUnmounted(function() {
      resizeMonitor.value.cancel();
      sourceResizeMonitor.value.cancel();
      if (winResizeRef.value)
        winResizeRef.value.remove();
      cancelForceAlign();
    });
    expose({
      forceAlign: function forceAlign() {
        return _forceAlign(true);
      }
    });
    return function() {
      var child = slots === null || slots === void 0 ? void 0 : slots.default();
      if (child) {
        return cloneElement(child[0], {
          ref: nodeRef
        }, true, true);
      }
      return null;
    };
  }
});
var PopupInner = Vue.defineComponent({
  name: "PopupInner",
  inheritAttrs: false,
  props: innerProps,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup: function setup16(props2, _ref) {
    var expose = _ref.expose, attrs = _ref.attrs, slots = _ref.slots;
    var alignRef = Vue.ref();
    var elementRef = Vue.ref();
    var alignedClassName = Vue.ref();
    var _useStretchStyle = useStretchStyle(Vue.toRef(props2, "stretch")), _useStretchStyle2 = _slicedToArray(_useStretchStyle, 2), stretchStyle = _useStretchStyle2[0], measureStretchStyle = _useStretchStyle2[1];
    var doMeasure = function doMeasure2() {
      if (props2.stretch) {
        measureStretchStyle(props2.getRootDomNode());
      }
    };
    var visible = Vue.ref(false);
    var timeoutId;
    Vue.watch(function() {
      return props2.visible;
    }, function(val) {
      clearTimeout(timeoutId);
      if (val) {
        timeoutId = setTimeout(function() {
          visible.value = props2.visible;
        });
      } else {
        visible.value = false;
      }
    }, {
      immediate: true
    });
    var _useVisibleStatus = useVisibleStatus(visible, doMeasure), _useVisibleStatus2 = _slicedToArray(_useVisibleStatus, 2), status = _useVisibleStatus2[0], goNextStatus = _useVisibleStatus2[1];
    var prepareResolveRef = Vue.ref();
    var getAlignTarget = function getAlignTarget2() {
      if (props2.point) {
        return props2.point;
      }
      return props2.getRootDomNode;
    };
    var forceAlign = function forceAlign2() {
      var _a;
      (_a = alignRef.value) === null || _a === void 0 ? void 0 : _a.forceAlign();
    };
    var onInternalAlign = function onInternalAlign2(popupDomNode, matchAlign) {
      var _a;
      var nextAlignedClassName = props2.getClassNameFromAlign(matchAlign);
      var preAlignedClassName = alignedClassName.value;
      if (alignedClassName.value !== nextAlignedClassName) {
        alignedClassName.value = nextAlignedClassName;
      }
      if (status.value === "align") {
        if (preAlignedClassName !== nextAlignedClassName) {
          Promise.resolve().then(function() {
            forceAlign();
          });
        } else {
          goNextStatus(function() {
            var _a2;
            (_a2 = prepareResolveRef.value) === null || _a2 === void 0 ? void 0 : _a2.call(prepareResolveRef);
          });
        }
        (_a = props2.onAlign) === null || _a === void 0 ? void 0 : _a.call(props2, popupDomNode, matchAlign);
      }
    };
    var motion = Vue.computed(function() {
      var m2 = _typeof$1(props2.animation) === "object" ? props2.animation : getMotion(props2);
      ["onAfterEnter", "onAfterLeave"].forEach(function(eventName) {
        var originFn = m2[eventName];
        m2[eventName] = function(node) {
          goNextStatus();
          status.value = "stable";
          originFn === null || originFn === void 0 ? void 0 : originFn(node);
        };
      });
      return m2;
    });
    var onShowPrepare = function onShowPrepare2() {
      return new Promise(function(resolve) {
        prepareResolveRef.value = resolve;
      });
    };
    Vue.watch([motion, status], function() {
      if (!motion.value && status.value === "motion") {
        goNextStatus();
      }
    }, {
      immediate: true
    });
    expose({
      forceAlign,
      getElement: function getElement2() {
        return elementRef.value.$el || elementRef.value;
      }
    });
    var alignDisabled = Vue.computed(function() {
      var _a;
      if (((_a = props2.align) === null || _a === void 0 ? void 0 : _a.points) && (status.value === "align" || status.value === "stable")) {
        return false;
      }
      return true;
    });
    return function() {
      var _a;
      var zIndex = props2.zIndex, align = props2.align, prefixCls = props2.prefixCls, destroyPopupOnHide = props2.destroyPopupOnHide, onMouseenter2 = props2.onMouseenter, onMouseleave2 = props2.onMouseleave, _props$onTouchstart = props2.onTouchstart, onTouchstart2 = _props$onTouchstart === void 0 ? function() {
      } : _props$onTouchstart, onMousedown2 = props2.onMousedown;
      var statusValue = status.value;
      var mergedStyle = [_extends(_extends({}, stretchStyle.value), {
        zIndex,
        opacity: statusValue === "motion" || statusValue === "stable" || !visible.value ? null : 0,
        pointerEvents: statusValue === "stable" ? null : "none"
      }), attrs.style];
      var childNode = flattenChildren((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, {
        visible: props2.visible
      }));
      if (childNode.length > 1) {
        childNode = Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-content")
        }, [childNode]);
      }
      var mergedClassName = classNames(prefixCls, attrs.class, alignedClassName.value);
      var hasAnimate = visible.value || !props2.visible;
      var transitionProps = hasAnimate ? getTransitionProps(motion.value.name, motion.value) : {};
      return Vue.createVNode(Vue.Transition, _objectSpread2$1(_objectSpread2$1({
        "ref": elementRef
      }, transitionProps), {}, {
        "onBeforeEnter": onShowPrepare
      }), {
        default: function _default5() {
          return !destroyPopupOnHide || props2.visible ? Vue.withDirectives(Vue.createVNode(Align, {
            "target": getAlignTarget(),
            "key": "popup",
            "ref": alignRef,
            "monitorWindowResize": true,
            "disabled": alignDisabled.value,
            "align": align,
            "onAlign": onInternalAlign
          }, {
            default: function _default6() {
              return Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({
                "class": mergedClassName,
                "onMouseenter": onMouseenter2,
                "onMouseleave": onMouseleave2,
                "onMousedown": Vue.withModifiers(onMousedown2, ["capture"])
              }, _defineProperty$T({}, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", Vue.withModifiers(onTouchstart2, ["capture"]))), {}, {
                "style": mergedStyle
              }), [childNode]);
            }
          }), [[Vue.vShow, visible.value]]) : null;
        }
      });
    };
  }
});
var Popup = Vue.defineComponent({
  name: "Popup",
  inheritAttrs: false,
  props: popupProps,
  setup: function setup17(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose;
    var innerVisible = Vue.ref(false);
    var inMobile = Vue.ref(false);
    var popupRef = Vue.ref();
    Vue.watch([function() {
      return props2.visible;
    }, function() {
      return props2.mobile;
    }], function() {
      innerVisible.value = props2.visible;
      if (props2.visible && props2.mobile) {
        inMobile.value = true;
      }
    }, {
      immediate: true,
      flush: "post"
    });
    expose({
      forceAlign: function forceAlign() {
        var _a;
        (_a = popupRef.value) === null || _a === void 0 ? void 0 : _a.forceAlign();
      },
      getElement: function getElement2() {
        var _a;
        return (_a = popupRef.value) === null || _a === void 0 ? void 0 : _a.getElement();
      }
    });
    return function() {
      var cloneProps = _extends(_extends(_extends({}, props2), attrs), {
        visible: innerVisible.value
      });
      var popupNode = inMobile.value ? Vue.createVNode(MobilePopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
        "mobile": props2.mobile,
        "ref": popupRef
      }), {
        default: slots.default
      }) : Vue.createVNode(PopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
        "ref": popupRef
      }), {
        default: slots.default
      });
      return Vue.createVNode("div", null, [Vue.createVNode(Mask$1, cloneProps, null), popupNode]);
    };
  }
});
function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _extends(_extends({}, baseAlign), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements2 = Object.keys(builtinPlacements);
  for (var i2 = 0; i2 < placements2.length; i2 += 1) {
    var placement = placements2[i2];
    if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }
  return "";
}
var BaseMixin = {
  methods: {
    setState: function setState() {
      var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      var newState = typeof state === "function" ? state(this.$data, this.$props) : state;
      if (this.getDerivedStateFromProps) {
        var s2 = this.getDerivedStateFromProps(getOptionProps(this), _extends(_extends({}, this.$data), newState));
        if (s2 === null) {
          return;
        } else {
          newState = _extends(_extends({}, newState), s2 || {});
        }
      }
      _extends(this.$data, newState);
      if (this._.isMounted) {
        this.$forceUpdate();
      }
      Vue.nextTick(function() {
        callback && callback();
      });
    },
    __emit: function __emit() {
      var args = [].slice.call(arguments, 0);
      var eventName = args[0];
      eventName = "on".concat(eventName[0].toUpperCase()).concat(eventName.substring(1));
      var event = this.$props[eventName] || this.$attrs[eventName];
      if (args.length && event) {
        if (Array.isArray(event)) {
          for (var i2 = 0, l2 = event.length; i2 < l2; i2++) {
            event[i2].apply(event, _toConsumableArray(args.slice(1)));
          }
        } else {
          event.apply(void 0, _toConsumableArray(args.slice(1)));
        }
      }
    }
  }
};
var TriggerContextKey = Symbol("TriggerContextKey");
var useProviderTrigger = function useProviderTrigger2() {
  var portal = null;
  Vue.provide(TriggerContextKey, {
    setPortal: function setPortal(val) {
      portal = val;
    },
    popPortal: true
  });
  return function() {
    return portal;
  };
};
var useInjectTrigger = function useInjectTrigger2() {
  return Vue.inject(TriggerContextKey, {
    setPortal: function setPortal() {
    },
    popPortal: false
  });
};
var PortalContextKey = Symbol("PortalContextKey");
var useProvidePortal = function useProvidePortal2(instance) {
  var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inTriggerContext: true
  };
  Vue.provide(PortalContextKey, {
    inTriggerContext: config.inTriggerContext,
    shouldRender: Vue.computed(function() {
      var _ref = instance || {}, sPopupVisible = _ref.sPopupVisible, popupRef = _ref.popupRef, forceRender = _ref.forceRender, autoDestroy = _ref.autoDestroy;
      var shouldRender = false;
      if (sPopupVisible || popupRef || forceRender) {
        shouldRender = true;
      }
      if (!sPopupVisible && autoDestroy) {
        shouldRender = false;
      }
      return shouldRender;
    })
  });
};
var useInjectPortal = function useInjectPortal2() {
  useProvidePortal({}, {
    inTriggerContext: false
  });
  var portalContext = Vue.inject(PortalContextKey, {
    shouldRender: Vue.computed(function() {
      return false;
    }),
    inTriggerContext: false
  });
  return {
    shouldRender: Vue.computed(function() {
      return portalContext.shouldRender.value || portalContext.inTriggerContext === false;
    })
  };
};
var Portal$1 = Vue.defineComponent({
  name: "Portal",
  inheritAttrs: false,
  props: {
    getContainer: PropTypes$1.func.isRequired,
    didUpdate: Function
  },
  setup: function setup18(props2, _ref) {
    var slots = _ref.slots;
    var isSSR = true;
    var container;
    var _useInjectPortal = useInjectPortal(), shouldRender = _useInjectPortal.shouldRender;
    Vue.onBeforeMount(function() {
      isSSR = false;
      if (shouldRender.value) {
        container = props2.getContainer();
      }
    });
    var stopWatch = Vue.watch(shouldRender, function() {
      if (shouldRender.value && !container) {
        container = props2.getContainer();
      }
      if (container) {
        stopWatch();
      }
    });
    Vue.onUpdated(function() {
      Vue.nextTick(function() {
        var _a;
        if (shouldRender.value) {
          (_a = props2.didUpdate) === null || _a === void 0 ? void 0 : _a.call(props2, props2);
        }
      });
    });
    Vue.onBeforeUnmount(function() {
      if (container && container.parentNode) {
        container.parentNode.removeChild(container);
      }
    });
    return function() {
      var _a;
      if (!shouldRender.value)
        return null;
      if (isSSR) {
        return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
      }
      return container ? Vue.createVNode(Vue.Teleport, {
        "to": container
      }, slots) : null;
    };
  }
});
function noop$3() {
}
function returnEmptyString() {
  return "";
}
function returnDocument(element) {
  if (element) {
    return element.ownerDocument;
  }
  return window.document;
}
var ALL_HANDLERS = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"];
var Trigger = Vue.defineComponent({
  name: "Trigger",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: {
    action: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.arrayOf(PropTypes$1.string)]).def([]),
    showAction: PropTypes$1.any.def([]),
    hideAction: PropTypes$1.any.def([]),
    getPopupClassNameFromAlign: PropTypes$1.any.def(returnEmptyString),
    onPopupVisibleChange: Function,
    afterPopupVisibleChange: PropTypes$1.func.def(noop$3),
    popup: PropTypes$1.any,
    popupStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: PropTypes$1.string.def("rc-trigger-popup"),
    popupClassName: PropTypes$1.string.def(""),
    popupPlacement: String,
    builtinPlacements: PropTypes$1.object,
    popupTransitionName: String,
    popupAnimation: PropTypes$1.any,
    mouseEnterDelay: PropTypes$1.number.def(0),
    mouseLeaveDelay: PropTypes$1.number.def(0.1),
    zIndex: Number,
    focusDelay: PropTypes$1.number.def(0),
    blurDelay: PropTypes$1.number.def(0.15),
    getPopupContainer: Function,
    getDocument: PropTypes$1.func.def(returnDocument),
    forceRender: {
      type: Boolean,
      default: void 0
    },
    destroyPopupOnHide: {
      type: Boolean,
      default: false
    },
    mask: {
      type: Boolean,
      default: false
    },
    maskClosable: {
      type: Boolean,
      default: true
    },
    popupAlign: PropTypes$1.object.def(function() {
      return {};
    }),
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    maskTransitionName: String,
    maskAnimation: String,
    stretch: String,
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    autoDestroy: {
      type: Boolean,
      default: false
    },
    mobile: Object,
    getTriggerDOMNode: Function
  },
  setup: function setup19(props2) {
    var align = Vue.computed(function() {
      var popupPlacement = props2.popupPlacement, popupAlign = props2.popupAlign, builtinPlacements = props2.builtinPlacements;
      if (popupPlacement && builtinPlacements) {
        return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
      }
      return popupAlign;
    });
    var _useInjectTrigger = useInjectTrigger(), setPortal = _useInjectTrigger.setPortal, popPortal = _useInjectTrigger.popPortal;
    var popupRef = Vue.ref(null);
    var setPopupRef = function setPopupRef2(val) {
      popupRef.value = val;
    };
    return {
      popPortal,
      setPortal,
      vcTriggerContext: Vue.inject("vcTriggerContext", {}),
      popupRef,
      setPopupRef,
      triggerRef: Vue.ref(null),
      align,
      focusTime: null,
      clickOutsideHandler: null,
      contextmenuOutsideHandler1: null,
      contextmenuOutsideHandler2: null,
      touchOutsideHandler: null,
      attachId: null,
      delayTimer: null,
      hasPopupMouseDown: false,
      preClickTime: null,
      preTouchTime: null,
      mouseDownTimeout: null,
      childOriginEvents: {}
    };
  },
  data: function data() {
    var _this = this;
    var _a, _b;
    var props2 = this.$props;
    var popupVisible2;
    if (this.popupVisible !== void 0) {
      popupVisible2 = !!props2.popupVisible;
    } else {
      popupVisible2 = !!props2.defaultPopupVisible;
    }
    ALL_HANDLERS.forEach(function(h2) {
      _this["fire".concat(h2)] = function(e2) {
        _this.fireEvents(h2, e2);
      };
    });
    (_b = (_a = this).setPortal) === null || _b === void 0 ? void 0 : _b.call(_a, Vue.createVNode(Portal$1, {
      "key": "portal",
      "getContainer": this.getContainer,
      "didUpdate": this.handlePortalUpdate
    }, {
      default: this.getComponent
    }));
    return {
      prevPopupVisible: popupVisible2,
      sPopupVisible: popupVisible2,
      point: null
    };
  },
  watch: {
    popupVisible: function popupVisible(val) {
      if (val !== void 0) {
        this.prevPopupVisible = this.sPopupVisible;
        this.sPopupVisible = val;
      }
    }
  },
  created: function created() {
    Vue.provide("vcTriggerContext", {
      onPopupMouseDown: this.onPopupMouseDown
    });
    useProvidePortal(this);
  },
  deactivated: function deactivated() {
    this.setPopupVisible(false);
  },
  mounted: function mounted() {
    var _this2 = this;
    this.$nextTick(function() {
      _this2.updatedCal();
    });
  },
  updated: function updated() {
    var _this3 = this;
    this.$nextTick(function() {
      _this3.updatedCal();
    });
  },
  beforeUnmount: function beforeUnmount() {
    this.clearDelayTimer();
    this.clearOutsideHandler();
    clearTimeout(this.mouseDownTimeout);
    wrapperRaf.cancel(this.attachId);
  },
  methods: {
    updatedCal: function updatedCal() {
      var props2 = this.$props;
      var state = this.$data;
      if (state.sPopupVisible) {
        var currentDocument;
        if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow())) {
          currentDocument = props2.getDocument(this.getRootDomNode());
          this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
        }
        if (!this.touchOutsideHandler) {
          currentDocument = currentDocument || props2.getDocument(this.getRootDomNode());
          this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick, supportsPassive$1 ? {
            passive: false
          } : false);
        }
        if (!this.contextmenuOutsideHandler1 && this.isContextmenuToShow()) {
          currentDocument = currentDocument || props2.getDocument(this.getRootDomNode());
          this.contextmenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextmenuClose);
        }
        if (!this.contextmenuOutsideHandler2 && this.isContextmenuToShow()) {
          this.contextmenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextmenuClose);
        }
      } else {
        this.clearOutsideHandler();
      }
    },
    onMouseenter: function onMouseenter(e2) {
      var mouseEnterDelay = this.$props.mouseEnterDelay;
      this.fireEvents("onMouseenter", e2);
      this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);
    },
    onMouseMove: function onMouseMove(e2) {
      this.fireEvents("onMousemove", e2);
      this.setPoint(e2);
    },
    onMouseleave: function onMouseleave(e2) {
      this.fireEvents("onMouseleave", e2);
      this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
    },
    onPopupMouseenter: function onPopupMouseenter() {
      this.clearDelayTimer();
    },
    onPopupMouseleave: function onPopupMouseleave(e2) {
      var _a;
      if (e2 && e2.relatedTarget && !e2.relatedTarget.setTimeout && contains((_a = this.popupRef) === null || _a === void 0 ? void 0 : _a.getElement(), e2.relatedTarget)) {
        return;
      }
      this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
    },
    onFocus: function onFocus(e2) {
      this.fireEvents("onFocus", e2);
      this.clearDelayTimer();
      if (this.isFocusToShow()) {
        this.focusTime = Date.now();
        this.delaySetPopupVisible(true, this.$props.focusDelay);
      }
    },
    onMousedown: function onMousedown(e2) {
      this.fireEvents("onMousedown", e2);
      this.preClickTime = Date.now();
    },
    onTouchstart: function onTouchstart(e2) {
      this.fireEvents("onTouchstart", e2);
      this.preTouchTime = Date.now();
    },
    onBlur: function onBlur(e2) {
      if (!contains(e2.target, e2.relatedTarget || document.activeElement)) {
        this.fireEvents("onBlur", e2);
        this.clearDelayTimer();
        if (this.isBlurToHide()) {
          this.delaySetPopupVisible(false, this.$props.blurDelay);
        }
      }
    },
    onContextmenu: function onContextmenu(e2) {
      e2.preventDefault();
      this.fireEvents("onContextmenu", e2);
      this.setPopupVisible(true, e2);
    },
    onContextmenuClose: function onContextmenuClose() {
      if (this.isContextmenuToShow()) {
        this.close();
      }
    },
    onClick: function onClick(event) {
      this.fireEvents("onClick", event);
      if (this.focusTime) {
        var preTime;
        if (this.preClickTime && this.preTouchTime) {
          preTime = Math.min(this.preClickTime, this.preTouchTime);
        } else if (this.preClickTime) {
          preTime = this.preClickTime;
        } else if (this.preTouchTime) {
          preTime = this.preTouchTime;
        }
        if (Math.abs(preTime - this.focusTime) < 20) {
          return;
        }
        this.focusTime = 0;
      }
      this.preClickTime = 0;
      this.preTouchTime = 0;
      if (this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && event && event.preventDefault) {
        event.preventDefault();
      }
      if (event && event.domEvent) {
        event.domEvent.preventDefault();
      }
      var nextVisible = !this.$data.sPopupVisible;
      if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
        this.setPopupVisible(!this.$data.sPopupVisible, event);
      }
    },
    onPopupMouseDown: function onPopupMouseDown() {
      var _this4 = this;
      var _this$vcTriggerContex = this.vcTriggerContext, vcTriggerContext = _this$vcTriggerContex === void 0 ? {} : _this$vcTriggerContex;
      this.hasPopupMouseDown = true;
      clearTimeout(this.mouseDownTimeout);
      this.mouseDownTimeout = setTimeout(function() {
        _this4.hasPopupMouseDown = false;
      }, 0);
      if (vcTriggerContext.onPopupMouseDown) {
        vcTriggerContext.onPopupMouseDown.apply(vcTriggerContext, arguments);
      }
    },
    onDocumentClick: function onDocumentClick(event) {
      if (this.$props.mask && !this.$props.maskClosable) {
        return;
      }
      var target = event.target;
      var root2 = this.getRootDomNode();
      var popupNode = this.getPopupDomNode();
      if ((!contains(root2, target) || this.isContextMenuOnly()) && !contains(popupNode, target) && !this.hasPopupMouseDown) {
        this.delaySetPopupVisible(false, 0.1);
      }
    },
    getPopupDomNode: function getPopupDomNode() {
      var _a;
      return ((_a = this.popupRef) === null || _a === void 0 ? void 0 : _a.getElement()) || null;
    },
    getRootDomNode: function getRootDomNode() {
      var getTriggerDOMNode = this.$props.getTriggerDOMNode;
      if (getTriggerDOMNode) {
        return getTriggerDOMNode(this.triggerRef);
      }
      try {
        var domNode = findDOMNode(this.triggerRef);
        if (domNode) {
          return domNode;
        }
      } catch (err) {
      }
      return findDOMNode(this);
    },
    handleGetPopupClassFromAlign: function handleGetPopupClassFromAlign(align) {
      var className = [];
      var props2 = this.$props;
      var popupPlacement = props2.popupPlacement, builtinPlacements = props2.builtinPlacements, prefixCls = props2.prefixCls, alignPoint2 = props2.alignPoint, getPopupClassNameFromAlign = props2.getPopupClassNameFromAlign;
      if (popupPlacement && builtinPlacements) {
        className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));
      }
      if (getPopupClassNameFromAlign) {
        className.push(getPopupClassNameFromAlign(align));
      }
      return className.join(" ");
    },
    getPopupAlign: function getPopupAlign() {
      var props2 = this.$props;
      var popupPlacement = props2.popupPlacement, popupAlign = props2.popupAlign, builtinPlacements = props2.builtinPlacements;
      if (popupPlacement && builtinPlacements) {
        return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
      }
      return popupAlign;
    },
    getComponent: function getComponent$1() {
      var _this5 = this;
      var mouseProps = {};
      if (this.isMouseEnterToShow()) {
        mouseProps.onMouseenter = this.onPopupMouseenter;
      }
      if (this.isMouseLeaveToHide()) {
        mouseProps.onMouseleave = this.onPopupMouseleave;
      }
      mouseProps.onMousedown = this.onPopupMouseDown;
      mouseProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
      var handleGetPopupClassFromAlign2 = this.handleGetPopupClassFromAlign, getRootDomNode2 = this.getRootDomNode, getContainer4 = this.getContainer, $attrs = this.$attrs;
      var _this$$props = this.$props, prefixCls = _this$$props.prefixCls, destroyPopupOnHide = _this$$props.destroyPopupOnHide, popupClassName = _this$$props.popupClassName, popupAnimation = _this$$props.popupAnimation, popupTransitionName = _this$$props.popupTransitionName, popupStyle = _this$$props.popupStyle, mask = _this$$props.mask, maskAnimation = _this$$props.maskAnimation, maskTransitionName = _this$$props.maskTransitionName, zIndex = _this$$props.zIndex, stretch = _this$$props.stretch, alignPoint2 = _this$$props.alignPoint, mobile = _this$$props.mobile, forceRender = _this$$props.forceRender;
      var _this$$data = this.$data, sPopupVisible = _this$$data.sPopupVisible, point = _this$$data.point;
      var popupProps2 = _extends(_extends({
        prefixCls,
        destroyPopupOnHide,
        visible: sPopupVisible,
        point: alignPoint2 ? point : null,
        align: this.align,
        animation: popupAnimation,
        getClassNameFromAlign: handleGetPopupClassFromAlign2,
        stretch,
        getRootDomNode: getRootDomNode2,
        mask,
        zIndex,
        transitionName: popupTransitionName,
        maskAnimation,
        maskTransitionName,
        getContainer: getContainer4,
        class: popupClassName,
        style: popupStyle,
        onAlign: $attrs.onPopupAlign || noop$3
      }, mouseProps), {
        ref: this.setPopupRef,
        mobile,
        forceRender
      });
      return Vue.createVNode(Popup, popupProps2, {
        default: this.$slots.popup || function() {
          return getComponent(_this5, "popup");
        }
      });
    },
    attachParent: function attachParent(popupContainer) {
      var _this6 = this;
      wrapperRaf.cancel(this.attachId);
      var _this$$props2 = this.$props, getPopupContainer = _this$$props2.getPopupContainer, getDocument2 = _this$$props2.getDocument;
      var domNode = this.getRootDomNode();
      var mountNode;
      if (!getPopupContainer) {
        mountNode = getDocument2(this.getRootDomNode()).body;
      } else if (domNode || getPopupContainer.length === 0) {
        mountNode = getPopupContainer(domNode);
      }
      if (mountNode) {
        mountNode.appendChild(popupContainer);
      } else {
        this.attachId = wrapperRaf(function() {
          _this6.attachParent(popupContainer);
        });
      }
    },
    getContainer: function getContainer3() {
      var props2 = this.$props;
      var getDocument2 = props2.getDocument;
      var popupContainer = getDocument2(this.getRootDomNode()).createElement("div");
      popupContainer.style.position = "absolute";
      popupContainer.style.top = "0";
      popupContainer.style.left = "0";
      popupContainer.style.width = "100%";
      this.attachParent(popupContainer);
      return popupContainer;
    },
    setPopupVisible: function setPopupVisible(sPopupVisible, event) {
      var alignPoint2 = this.alignPoint, prevPopupVisible = this.sPopupVisible, onPopupVisibleChange = this.onPopupVisibleChange;
      this.clearDelayTimer();
      if (prevPopupVisible !== sPopupVisible) {
        if (!hasProp(this, "popupVisible")) {
          this.setState({
            sPopupVisible,
            prevPopupVisible
          });
        }
        onPopupVisibleChange && onPopupVisibleChange(sPopupVisible);
      }
      if (alignPoint2 && event && sPopupVisible) {
        this.setPoint(event);
      }
    },
    setPoint: function setPoint(point) {
      var alignPoint2 = this.$props.alignPoint;
      if (!alignPoint2 || !point)
        return;
      this.setState({
        point: {
          pageX: point.pageX,
          pageY: point.pageY
        }
      });
    },
    handlePortalUpdate: function handlePortalUpdate() {
      if (this.prevPopupVisible !== this.sPopupVisible) {
        this.afterPopupVisibleChange(this.sPopupVisible);
      }
    },
    delaySetPopupVisible: function delaySetPopupVisible(visible, delayS, event) {
      var _this7 = this;
      var delay = delayS * 1e3;
      this.clearDelayTimer();
      if (delay) {
        var point = event ? {
          pageX: event.pageX,
          pageY: event.pageY
        } : null;
        this.delayTimer = requestAnimationTimeout(function() {
          _this7.setPopupVisible(visible, point);
          _this7.clearDelayTimer();
        }, delay);
      } else {
        this.setPopupVisible(visible, event);
      }
    },
    clearDelayTimer: function clearDelayTimer() {
      if (this.delayTimer) {
        cancelAnimationTimeout(this.delayTimer);
        this.delayTimer = null;
      }
    },
    clearOutsideHandler: function clearOutsideHandler() {
      if (this.clickOutsideHandler) {
        this.clickOutsideHandler.remove();
        this.clickOutsideHandler = null;
      }
      if (this.contextmenuOutsideHandler1) {
        this.contextmenuOutsideHandler1.remove();
        this.contextmenuOutsideHandler1 = null;
      }
      if (this.contextmenuOutsideHandler2) {
        this.contextmenuOutsideHandler2.remove();
        this.contextmenuOutsideHandler2 = null;
      }
      if (this.touchOutsideHandler) {
        this.touchOutsideHandler.remove();
        this.touchOutsideHandler = null;
      }
    },
    createTwoChains: function createTwoChains(event) {
      var fn = function fn2() {
      };
      var events2 = getEvents(this);
      if (this.childOriginEvents[event] && events2[event]) {
        return this["fire".concat(event)];
      }
      fn = this.childOriginEvents[event] || events2[event] || fn;
      return fn;
    },
    isClickToShow: function isClickToShow() {
      var _this$$props3 = this.$props, action = _this$$props3.action, showAction = _this$$props3.showAction;
      return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
    },
    isContextMenuOnly: function isContextMenuOnly() {
      var action = this.$props.action;
      return action === "contextmenu" || action.length === 1 && action[0] === "contextmenu";
    },
    isContextmenuToShow: function isContextmenuToShow() {
      var _this$$props4 = this.$props, action = _this$$props4.action, showAction = _this$$props4.showAction;
      return action.indexOf("contextmenu") !== -1 || showAction.indexOf("contextmenu") !== -1;
    },
    isClickToHide: function isClickToHide() {
      var _this$$props5 = this.$props, action = _this$$props5.action, hideAction = _this$$props5.hideAction;
      return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
    },
    isMouseEnterToShow: function isMouseEnterToShow() {
      var _this$$props6 = this.$props, action = _this$$props6.action, showAction = _this$$props6.showAction;
      return action.indexOf("hover") !== -1 || showAction.indexOf("mouseenter") !== -1;
    },
    isMouseLeaveToHide: function isMouseLeaveToHide() {
      var _this$$props7 = this.$props, action = _this$$props7.action, hideAction = _this$$props7.hideAction;
      return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseleave") !== -1;
    },
    isFocusToShow: function isFocusToShow() {
      var _this$$props8 = this.$props, action = _this$$props8.action, showAction = _this$$props8.showAction;
      return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
    },
    isBlurToHide: function isBlurToHide() {
      var _this$$props9 = this.$props, action = _this$$props9.action, hideAction = _this$$props9.hideAction;
      return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
    },
    forcePopupAlign: function forcePopupAlign() {
      var _a;
      if (this.$data.sPopupVisible) {
        (_a = this.popupRef) === null || _a === void 0 ? void 0 : _a.forceAlign();
      }
    },
    fireEvents: function fireEvents(type2, e2) {
      if (this.childOriginEvents[type2]) {
        this.childOriginEvents[type2](e2);
      }
      var event = this.$props[type2] || this.$attrs[type2];
      if (event) {
        event(e2);
      }
    },
    close: function close2() {
      this.setPopupVisible(false);
    }
  },
  render: function render3() {
    var _this8 = this;
    var $attrs = this.$attrs;
    var children = filterEmpty(getSlot(this));
    var alignPoint2 = this.$props.alignPoint;
    var child = children[0];
    this.childOriginEvents = getEvents(child);
    var newChildProps = {
      key: "trigger"
    };
    if (this.isContextmenuToShow()) {
      newChildProps.onContextmenu = this.onContextmenu;
    } else {
      newChildProps.onContextmenu = this.createTwoChains("onContextmenu");
    }
    if (this.isClickToHide() || this.isClickToShow()) {
      newChildProps.onClick = this.onClick;
      newChildProps.onMousedown = this.onMousedown;
      newChildProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart;
    } else {
      newChildProps.onClick = this.createTwoChains("onClick");
      newChildProps.onMousedown = this.createTwoChains("onMousedown");
      newChildProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart");
    }
    if (this.isMouseEnterToShow()) {
      newChildProps.onMouseenter = this.onMouseenter;
      if (alignPoint2) {
        newChildProps.onMousemove = this.onMouseMove;
      }
    } else {
      newChildProps.onMouseenter = this.createTwoChains("onMouseenter");
    }
    if (this.isMouseLeaveToHide()) {
      newChildProps.onMouseleave = this.onMouseleave;
    } else {
      newChildProps.onMouseleave = this.createTwoChains("onMouseleave");
    }
    if (this.isFocusToShow() || this.isBlurToHide()) {
      newChildProps.onFocus = this.onFocus;
      newChildProps.onBlur = this.onBlur;
    } else {
      newChildProps.onFocus = this.createTwoChains("onFocus");
      newChildProps.onBlur = function(e2) {
        if (e2 && (!e2.relatedTarget || !contains(e2.target, e2.relatedTarget))) {
          _this8.createTwoChains("onBlur")(e2);
        }
      };
    }
    var childrenClassName = classNames(child && child.props && child.props.class, $attrs.class);
    if (childrenClassName) {
      newChildProps.class = childrenClassName;
    }
    var trigger2 = cloneElement(child, _extends(_extends({}, newChildProps), {
      ref: "triggerRef"
    }), true, true);
    if (this.popPortal) {
      return trigger2;
    } else {
      var portal = Vue.createVNode(Portal$1, {
        "key": "portal",
        "getContainer": this.getContainer,
        "didUpdate": this.handlePortalUpdate
      }, {
        default: this.getComponent
      });
      return Vue.createVNode(Vue.Fragment, null, [portal, trigger2]);
    }
  }
});
var autoAdjustOverflow$2 = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset$2 = [0, 0];
var placements$3 = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  }
};
var tooltipContentProps = {
  prefixCls: String,
  id: String,
  overlayInnerStyle: PropTypes$1.any
};
var Content$2 = Vue.defineComponent({
  name: "Content",
  props: tooltipContentProps,
  slots: ["overlay"],
  setup: function setup20(props2, _ref) {
    var slots = _ref.slots;
    return function() {
      var _a;
      return Vue.createVNode("div", {
        "class": "".concat(props2.prefixCls, "-inner"),
        "id": props2.id,
        "role": "tooltip",
        "style": props2.overlayInnerStyle
      }, [(_a = slots.overlay) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
var __rest$E = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function noop$2() {
}
var Tooltip = Vue.defineComponent({
  name: "Tooltip",
  inheritAttrs: false,
  props: {
    trigger: PropTypes$1.any.def(["hover"]),
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    placement: PropTypes$1.string.def("right"),
    transitionName: String,
    animation: PropTypes$1.any,
    afterVisibleChange: PropTypes$1.func.def(function() {
    }),
    overlayStyle: {
      type: Object,
      default: void 0
    },
    overlayClassName: String,
    prefixCls: PropTypes$1.string.def("rc-tooltip"),
    mouseEnterDelay: PropTypes$1.number.def(0.1),
    mouseLeaveDelay: PropTypes$1.number.def(0.1),
    getTooltipContainer: Function,
    destroyTooltipOnHide: {
      type: Boolean,
      default: false
    },
    align: PropTypes$1.object.def(function() {
      return {};
    }),
    arrowContent: PropTypes$1.any.def(null),
    tipId: String,
    builtinPlacements: PropTypes$1.object,
    overlayInnerStyle: {
      type: Object,
      default: void 0
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    onVisibleChange: Function,
    onPopupAlign: Function
  },
  slots: ["arrowContent", "overlay"],
  setup: function setup21(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var triggerDOM = Vue.ref();
    var getPopupElement = function getPopupElement2() {
      var prefixCls = props2.prefixCls, tipId = props2.tipId, overlayInnerStyle = props2.overlayInnerStyle;
      return [Vue.createVNode("div", {
        "class": "".concat(prefixCls, "-arrow"),
        "key": "arrow"
      }, [getPropsSlot(slots, props2, "arrowContent")]), Vue.createVNode(Content$2, {
        "key": "content",
        "prefixCls": prefixCls,
        "id": tipId,
        "overlayInnerStyle": overlayInnerStyle
      }, {
        overlay: slots.overlay
      })];
    };
    var getPopupDomNode2 = function getPopupDomNode3() {
      return triggerDOM.value.getPopupDomNode();
    };
    expose({
      getPopupDomNode: getPopupDomNode2,
      triggerDOM,
      forcePopupAlign: function forcePopupAlign2() {
        var _a;
        return (_a = triggerDOM.value) === null || _a === void 0 ? void 0 : _a.forcePopupAlign();
      }
    });
    var destroyTooltip = Vue.ref(false);
    var autoDestroy = Vue.ref(false);
    Vue.watchEffect(function() {
      var destroyTooltipOnHide = props2.destroyTooltipOnHide;
      if (typeof destroyTooltipOnHide === "boolean") {
        destroyTooltip.value = destroyTooltipOnHide;
      } else if (destroyTooltipOnHide && _typeof$1(destroyTooltipOnHide) === "object") {
        var keepParent = destroyTooltipOnHide.keepParent;
        destroyTooltip.value = keepParent === true;
        autoDestroy.value = keepParent === false;
      }
    });
    return function() {
      var overlayClassName = props2.overlayClassName, trigger2 = props2.trigger, mouseEnterDelay = props2.mouseEnterDelay, mouseLeaveDelay = props2.mouseLeaveDelay, overlayStyle = props2.overlayStyle, prefixCls = props2.prefixCls, afterVisibleChange = props2.afterVisibleChange, transitionName2 = props2.transitionName, animation = props2.animation, placement = props2.placement, align = props2.align;
      props2.destroyTooltipOnHide;
      var defaultVisible = props2.defaultVisible, getTooltipContainer = props2.getTooltipContainer, restProps = __rest$E(props2, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer"]);
      var extraProps = _extends({}, restProps);
      if (props2.visible !== void 0) {
        extraProps.popupVisible = props2.visible;
      }
      var triggerProps = _extends(_extends(_extends({
        popupClassName: overlayClassName,
        prefixCls,
        action: trigger2,
        builtinPlacements: placements$3,
        popupPlacement: placement,
        popupAlign: align,
        getPopupContainer: getTooltipContainer,
        afterPopupVisibleChange: afterVisibleChange,
        popupTransitionName: transitionName2,
        popupAnimation: animation,
        defaultPopupVisible: defaultVisible,
        destroyPopupOnHide: destroyTooltip.value,
        autoDestroy: autoDestroy.value,
        mouseLeaveDelay,
        popupStyle: overlayStyle,
        mouseEnterDelay
      }, extraProps), attrs), {
        onPopupVisibleChange: props2.onVisibleChange || noop$2,
        onPopupAlign: props2.onPopupAlign || noop$2,
        ref: triggerDOM,
        popup: getPopupElement()
      });
      return Vue.createVNode(Trigger, triggerProps, {
        default: slots.default
      });
    };
  }
});
var PresetStatusColorTypes = tuple$1("success", "processing", "error", "default", "warning");
var PresetColorTypes = tuple$1("pink", "red", "yellow", "orange", "cyan", "green", "blue", "purple", "geekblue", "magenta", "volcano", "gold", "lime");
var abstractTooltipProps = function() {
  return {
    trigger: [String, Array],
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    placement: String,
    color: String,
    transitionName: String,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    overlayClassName: String,
    openClassName: String,
    prefixCls: String,
    mouseEnterDelay: Number,
    mouseLeaveDelay: Number,
    getPopupContainer: Function,
    arrowPointAtCenter: {
      type: Boolean,
      default: void 0
    },
    autoAdjustOverflow: {
      type: [Boolean, Object],
      default: void 0
    },
    destroyTooltipOnHide: {
      type: Boolean,
      default: void 0
    },
    align: {
      type: Object,
      default: void 0
    },
    builtinPlacements: {
      type: Object,
      default: void 0
    },
    children: Array,
    onVisibleChange: Function,
    "onUpdate:visible": Function
  };
};
var autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
};
var autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
};
var targetOffset$1 = [0, 0];
function getOverflowOptions(autoAdjustOverflow2) {
  if (typeof autoAdjustOverflow2 === "boolean") {
    return autoAdjustOverflow2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
  }
  return _extends(_extends({}, autoAdjustOverflowDisabled), autoAdjustOverflow2);
}
function getPlacements(config) {
  var _config$arrowWidth = config.arrowWidth, arrowWidth = _config$arrowWidth === void 0 ? 4 : _config$arrowWidth, _config$horizontalArr = config.horizontalArrowShift, horizontalArrowShift = _config$horizontalArr === void 0 ? 16 : _config$horizontalArr, _config$verticalArrow = config.verticalArrowShift, verticalArrowShift = _config$verticalArrow === void 0 ? 8 : _config$verticalArrow, autoAdjustOverflow2 = config.autoAdjustOverflow, arrowPointAtCenter = config.arrowPointAtCenter;
  var placementMap = {
    left: {
      points: ["cr", "cl"],
      offset: [-4, 0]
    },
    right: {
      points: ["cl", "cr"],
      offset: [4, 0]
    },
    top: {
      points: ["bc", "tc"],
      offset: [0, -4]
    },
    bottom: {
      points: ["tc", "bc"],
      offset: [0, 4]
    },
    topLeft: {
      points: ["bl", "tc"],
      offset: [-(horizontalArrowShift + arrowWidth), -4]
    },
    leftTop: {
      points: ["tr", "cl"],
      offset: [-4, -(verticalArrowShift + arrowWidth)]
    },
    topRight: {
      points: ["br", "tc"],
      offset: [horizontalArrowShift + arrowWidth, -4]
    },
    rightTop: {
      points: ["tl", "cr"],
      offset: [4, -(verticalArrowShift + arrowWidth)]
    },
    bottomRight: {
      points: ["tr", "bc"],
      offset: [horizontalArrowShift + arrowWidth, 4]
    },
    rightBottom: {
      points: ["bl", "cr"],
      offset: [4, verticalArrowShift + arrowWidth]
    },
    bottomLeft: {
      points: ["tl", "bc"],
      offset: [-(horizontalArrowShift + arrowWidth), 4]
    },
    leftBottom: {
      points: ["br", "cl"],
      offset: [-4, verticalArrowShift + arrowWidth]
    }
  };
  Object.keys(placementMap).forEach(function(key2) {
    placementMap[key2] = arrowPointAtCenter ? _extends(_extends({}, placementMap[key2]), {
      overflow: getOverflowOptions(autoAdjustOverflow2),
      targetOffset: targetOffset$1
    }) : _extends(_extends({}, placements$3[key2]), {
      overflow: getOverflowOptions(autoAdjustOverflow2)
    });
    placementMap[key2].ignoreShake = true;
  });
  return placementMap;
}
function firstNotUndefined() {
  var arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  for (var i2 = 0, len = arr.length; i2 < len; i2++) {
    if (arr[i2] !== void 0) {
      return arr[i2];
    }
  }
  return void 0;
}
var splitObject = function splitObject2(obj, keys2) {
  var picked = {};
  var omitted = _extends({}, obj);
  keys2.forEach(function(key2) {
    if (obj && key2 in obj) {
      picked[key2] = obj[key2];
      delete omitted[key2];
    }
  });
  return {
    picked,
    omitted
  };
};
var PresetColorRegex$1 = new RegExp("^(".concat(PresetColorTypes.join("|"), ")(-inverse)?$"));
var tooltipProps = function tooltipProps2() {
  return _extends(_extends({}, abstractTooltipProps()), {
    title: PropTypes$1.any
  });
};
var tooltipDefaultProps = function tooltipDefaultProps2() {
  return {
    trigger: "hover",
    transitionName: "zoom-big-fast",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: false,
    autoAdjustOverflow: true
  };
};
var ToolTip = Vue.defineComponent({
  name: "ATooltip",
  inheritAttrs: false,
  props: initDefaultProps$1(tooltipProps(), {
    trigger: "hover",
    transitionName: "zoom-big-fast",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: false,
    autoAdjustOverflow: true
  }),
  slots: ["title"],
  setup: function setup22(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs, expose = _ref.expose;
    var _useConfigInject = useConfigInject("tooltip", props2), prefixCls = _useConfigInject.prefixCls, getTargetContainer = _useConfigInject.getTargetContainer;
    var visible = Vue.ref(firstNotUndefined([props2.visible, props2.defaultVisible]));
    var tooltip = Vue.ref();
    Vue.onMounted(function() {
      warning(props2.defaultVisible === void 0, "Tooltip", "'defaultVisible' is deprecated, please use 'v-model:visible'");
    });
    var rafId;
    Vue.watch(function() {
      return props2.visible;
    }, function(val) {
      wrapperRaf.cancel(rafId);
      rafId = wrapperRaf(function() {
        visible.value = !!val;
      });
    });
    var isNoTitle = function isNoTitle2() {
      var _a;
      var title = (_a = props2.title) !== null && _a !== void 0 ? _a : slots.title;
      return !title && title !== 0;
    };
    var handleVisibleChange = function handleVisibleChange2(val) {
      var noTitle = isNoTitle();
      if (props2.visible === void 0) {
        visible.value = noTitle ? false : val;
      }
      if (!noTitle) {
        emit("update:visible", val);
        emit("visibleChange", val);
      }
    };
    var getPopupDomNode2 = function getPopupDomNode3() {
      return tooltip.value.getPopupDomNode();
    };
    expose({
      getPopupDomNode: getPopupDomNode2,
      visible,
      forcePopupAlign: function forcePopupAlign2() {
        var _a;
        return (_a = tooltip.value) === null || _a === void 0 ? void 0 : _a.forcePopupAlign();
      }
    });
    var tooltipPlacements = Vue.computed(function() {
      var builtinPlacements = props2.builtinPlacements, arrowPointAtCenter = props2.arrowPointAtCenter, autoAdjustOverflow2 = props2.autoAdjustOverflow;
      return builtinPlacements || getPlacements({
        arrowPointAtCenter,
        autoAdjustOverflow: autoAdjustOverflow2
      });
    });
    var isTrueProps = function isTrueProps2(val) {
      return val || val === "";
    };
    var getDisabledCompatibleChildren = function getDisabledCompatibleChildren2(ele) {
      var elementType = ele.type;
      if (_typeof$1(elementType) === "object" && ele.props) {
        if ((elementType.__ANT_BUTTON === true || elementType === "button") && isTrueProps(ele.props.disabled) || elementType.__ANT_SWITCH === true && (isTrueProps(ele.props.disabled) || isTrueProps(ele.props.loading))) {
          var _splitObject = splitObject(getStyle(ele), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]), picked = _splitObject.picked, omitted = _splitObject.omitted;
          var spanStyle = _extends(_extends({
            display: "inline-block"
          }, picked), {
            cursor: "not-allowed",
            width: ele.props && ele.props.block ? "100%" : null
          });
          var buttonStyle = _extends(_extends({}, omitted), {
            pointerEvents: "none"
          });
          var child = cloneElement(ele, {
            style: buttonStyle
          }, true);
          return Vue.createVNode("span", {
            "style": spanStyle,
            "class": "".concat(prefixCls, "-disabled-compatible-wrapper")
          }, [child]);
        }
      }
      return ele;
    };
    var getOverlay = function getOverlay2() {
      var _a, _b;
      return (_a = props2.title) !== null && _a !== void 0 ? _a : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
    };
    var onPopupAlign = function onPopupAlign2(domNode, align) {
      var placements2 = tooltipPlacements.value;
      var placement = Object.keys(placements2).filter(function(key2) {
        return placements2[key2].points[0] === align.points[0] && placements2[key2].points[1] === align.points[1];
      })[0];
      if (!placement) {
        return;
      }
      var rect = domNode.getBoundingClientRect();
      var transformOrigin = {
        top: "50%",
        left: "50%"
      };
      if (placement.indexOf("top") >= 0 || placement.indexOf("Bottom") >= 0) {
        transformOrigin.top = "".concat(rect.height - align.offset[1], "px");
      } else if (placement.indexOf("Top") >= 0 || placement.indexOf("bottom") >= 0) {
        transformOrigin.top = "".concat(-align.offset[1], "px");
      }
      if (placement.indexOf("left") >= 0 || placement.indexOf("Right") >= 0) {
        transformOrigin.left = "".concat(rect.width - align.offset[0], "px");
      } else if (placement.indexOf("right") >= 0 || placement.indexOf("Left") >= 0) {
        transformOrigin.left = "".concat(-align.offset[0], "px");
      }
      domNode.style.transformOrigin = "".concat(transformOrigin.left, " ").concat(transformOrigin.top);
    };
    return function() {
      var _classNames;
      var _a, _b;
      var openClassName = props2.openClassName, getPopupContainer = props2.getPopupContainer, color = props2.color, overlayClassName = props2.overlayClassName;
      var children = (_b = filterEmpty((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots))) !== null && _b !== void 0 ? _b : null;
      children = children.length === 1 ? children[0] : children;
      var tempVisible = visible.value;
      if (props2.visible === void 0 && isNoTitle()) {
        tempVisible = false;
      }
      if (!children) {
        return null;
      }
      var child = getDisabledCompatibleChildren(isValidElement(children) ? children : Vue.createVNode("span", null, [children]));
      var childCls = classNames((_classNames = {}, _defineProperty$T(_classNames, openClassName || "".concat(prefixCls.value, "-open"), true), _defineProperty$T(_classNames, child.props && child.props.class, child.props && child.props.class), _classNames));
      var customOverlayClassName = classNames(overlayClassName, _defineProperty$T({}, "".concat(prefixCls.value, "-").concat(color), color && PresetColorRegex$1.test(color)));
      var formattedOverlayInnerStyle;
      var arrowContentStyle;
      if (color && !PresetColorRegex$1.test(color)) {
        formattedOverlayInnerStyle = {
          backgroundColor: color
        };
        arrowContentStyle = {
          backgroundColor: color
        };
      }
      var vcTooltipProps = _extends(_extends(_extends({}, attrs), props2), {
        prefixCls: prefixCls.value,
        getTooltipContainer: getPopupContainer || getTargetContainer.value,
        builtinPlacements: tooltipPlacements.value,
        visible: tempVisible,
        ref: tooltip,
        overlayClassName: customOverlayClassName,
        overlayInnerStyle: formattedOverlayInnerStyle,
        onVisibleChange: handleVisibleChange,
        onPopupAlign
      });
      return Vue.createVNode(Tooltip, vcTooltipProps, {
        default: function _default5() {
          return [visible.value ? cloneElement(child, {
            class: childCls
          }) : child];
        },
        arrowContent: function arrowContent() {
          return Vue.createVNode("span", {
            "class": "".concat(prefixCls.value, "-arrow-content"),
            "style": arrowContentStyle
          }, null);
        },
        overlay: getOverlay
      });
    };
  }
});
var _Tooltip = withInstall(ToolTip);
var CheckOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z"
      }
    }]
  },
  "name": "check",
  "theme": "outlined"
};
var CheckOutlinedSvg = CheckOutlined$2;
function _objectSpread$y(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$y(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$y(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CheckOutlined = function CheckOutlined2(props2, context) {
  var p2 = _objectSpread$y({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$y({}, p2, {
    "icon": CheckOutlinedSvg
  }), null);
};
CheckOutlined.displayName = "CheckOutlined";
CheckOutlined.inheritAttrs = false;
var CheckOutlined$1 = CheckOutlined;
var progressStatuses = tuple$1("normal", "exception", "active", "success");
var ProgressType = tuple$1("line", "circle", "dashboard");
var ProgressSize = tuple$1("default", "small");
var progressProps = function progressProps2() {
  return {
    prefixCls: String,
    type: PropTypes$1.oneOf(ProgressType),
    percent: Number,
    format: {
      type: Function
    },
    status: PropTypes$1.oneOf(progressStatuses),
    showInfo: {
      type: Boolean,
      default: void 0
    },
    strokeWidth: Number,
    strokeLinecap: String,
    strokeColor: {
      type: [String, Object],
      default: void 0
    },
    trailColor: String,
    width: Number,
    success: {
      type: Object,
      default: function _default5() {
        return {};
      }
    },
    gapDegree: Number,
    gapPosition: String,
    size: PropTypes$1.oneOf(ProgressSize),
    steps: Number,
    successPercent: Number,
    title: String
  };
};
function validProgress(progress) {
  if (!progress || progress < 0) {
    return 0;
  }
  if (progress > 100) {
    return 100;
  }
  return progress;
}
function getSuccessPercent(_ref) {
  var success = _ref.success, successPercent = _ref.successPercent;
  var percent = successPercent;
  if (success && "progress" in success) {
    devWarning(false, "Progress", "`success.progress` is deprecated. Please use `success.percent` instead.");
    percent = success.progress;
  }
  if (success && "percent" in success) {
    percent = success.percent;
  }
  return percent;
}
var __rest$D = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var lineProps = function lineProps2() {
  return _extends(_extends({}, progressProps()), {
    prefixCls: String,
    direction: {
      type: String
    }
  });
};
var sortGradient = function sortGradient2(gradients) {
  var tempArr = [];
  Object.keys(gradients).forEach(function(key2) {
    var formattedKey = parseFloat(key2.replace(/%/g, ""));
    if (!isNaN(formattedKey)) {
      tempArr.push({
        key: formattedKey,
        value: gradients[key2]
      });
    }
  });
  tempArr = tempArr.sort(function(a2, b2) {
    return a2.key - b2.key;
  });
  return tempArr.map(function(_ref) {
    var key2 = _ref.key, value = _ref.value;
    return "".concat(value, " ").concat(key2, "%");
  }).join(", ");
};
var handleGradient = function handleGradient2(strokeColor, directionConfig) {
  var _strokeColor$from = strokeColor.from, from = _strokeColor$from === void 0 ? presetPrimaryColors.blue : _strokeColor$from, _strokeColor$to = strokeColor.to, to = _strokeColor$to === void 0 ? presetPrimaryColors.blue : _strokeColor$to, _strokeColor$directio = strokeColor.direction, direction = _strokeColor$directio === void 0 ? directionConfig === "rtl" ? "to left" : "to right" : _strokeColor$directio, rest = __rest$D(strokeColor, ["from", "to", "direction"]);
  if (Object.keys(rest).length !== 0) {
    var sortedGradients = sortGradient(rest);
    return {
      backgroundImage: "linear-gradient(".concat(direction, ", ").concat(sortedGradients, ")")
    };
  }
  return {
    backgroundImage: "linear-gradient(".concat(direction, ", ").concat(from, ", ").concat(to, ")")
  };
};
var Line = Vue.defineComponent({
  name: "Line",
  props: lineProps(),
  setup: function setup23(props2, _ref2) {
    var slots = _ref2.slots;
    var backgroundProps = Vue.computed(function() {
      var strokeColor = props2.strokeColor, direction = props2.direction;
      return strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, direction) : {
        background: strokeColor
      };
    });
    var trailStyle = Vue.computed(function() {
      return props2.trailColor ? {
        backgroundColor: props2.trailColor
      } : void 0;
    });
    var percentStyle = Vue.computed(function() {
      var percent = props2.percent, strokeWidth = props2.strokeWidth, strokeLinecap = props2.strokeLinecap, size = props2.size;
      return _extends({
        width: "".concat(validProgress(percent), "%"),
        height: "".concat(strokeWidth || (size === "small" ? 6 : 8), "px"),
        borderRadius: strokeLinecap === "square" ? 0 : ""
      }, backgroundProps.value);
    });
    var successPercent = Vue.computed(function() {
      return getSuccessPercent(props2);
    });
    var successPercentStyle = Vue.computed(function() {
      var strokeWidth = props2.strokeWidth, size = props2.size, strokeLinecap = props2.strokeLinecap, success = props2.success;
      return {
        width: "".concat(validProgress(successPercent.value), "%"),
        height: "".concat(strokeWidth || (size === "small" ? 6 : 8), "px"),
        borderRadius: strokeLinecap === "square" ? 0 : "",
        backgroundColor: success === null || success === void 0 ? void 0 : success.strokeColor
      };
    });
    return function() {
      var _a;
      return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode("div", {
        "class": "".concat(props2.prefixCls, "-outer")
      }, [Vue.createVNode("div", {
        "class": "".concat(props2.prefixCls, "-inner"),
        "style": trailStyle.value
      }, [Vue.createVNode("div", {
        "class": "".concat(props2.prefixCls, "-bg"),
        "style": percentStyle.value
      }, null), successPercent.value !== void 0 ? Vue.createVNode("div", {
        "class": "".concat(props2.prefixCls, "-success-bg"),
        "style": successPercentStyle.value
      }, null) : null])]), (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
var useRefs = function useRefs2() {
  var refs = Vue.ref(/* @__PURE__ */ new Map());
  var setRef = function setRef2(key2) {
    return function(el) {
      refs.value.set(key2, el);
    };
  };
  Vue.onBeforeUpdate(function() {
    refs.value = /* @__PURE__ */ new Map();
  });
  return [setRef, refs];
};
var useRefs$1 = useRefs;
var defaultProps = {
  percent: 0,
  prefixCls: "vc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  trailColor: "#D9D9D9",
  trailWidth: 1
};
var useTransitionDuration = function useTransitionDuration2(paths) {
  var prevTimeStamp = Vue.ref(null);
  Vue.onUpdated(function() {
    var now2 = Date.now();
    var updated3 = false;
    paths.value.forEach(function(val) {
      var _a;
      var path = ((_a = val) === null || _a === void 0 ? void 0 : _a.$el) || val;
      if (!path) {
        return;
      }
      updated3 = true;
      var pathStyle = path.style;
      pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
      if (prevTimeStamp.value && now2 - prevTimeStamp.value < 100) {
        pathStyle.transitionDuration = "0s, 0s";
      }
    });
    if (updated3) {
      prevTimeStamp.value = Date.now();
    }
  });
  return paths;
};
var propTypes = {
  gapDegree: Number,
  gapPosition: {
    type: String
  },
  percent: {
    type: [Array, Number]
  },
  prefixCls: String,
  strokeColor: {
    type: [Object, String, Array]
  },
  strokeLinecap: {
    type: String
  },
  strokeWidth: Number,
  trailColor: String,
  trailWidth: Number,
  transition: String
};
var __rest$C = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var gradientSeed = 0;
function stripPercentToNumber(percent) {
  return +percent.replace("%", "");
}
function toArray$4(value) {
  return Array.isArray(value) ? value : [value];
}
function getPathStyles(offset3, percent, strokeColor, strokeWidth) {
  var gapDegree = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  var gapPosition = arguments.length > 5 ? arguments[5] : void 0;
  var radius = 50 - strokeWidth / 2;
  var beginPositionX = 0;
  var beginPositionY = -radius;
  var endPositionX = 0;
  var endPositionY = -2 * radius;
  switch (gapPosition) {
    case "left":
      beginPositionX = -radius;
      beginPositionY = 0;
      endPositionX = 2 * radius;
      endPositionY = 0;
      break;
    case "right":
      beginPositionX = radius;
      beginPositionY = 0;
      endPositionX = -2 * radius;
      endPositionY = 0;
      break;
    case "bottom":
      beginPositionY = radius;
      endPositionY = 2 * radius;
      break;
  }
  var pathString = "M 50,50 m ".concat(beginPositionX, ",").concat(beginPositionY, "\n   a ").concat(radius, ",").concat(radius, " 0 1 1 ").concat(endPositionX, ",").concat(-endPositionY, "\n   a ").concat(radius, ",").concat(radius, " 0 1 1 ").concat(-endPositionX, ",").concat(endPositionY);
  var len = Math.PI * 2 * radius;
  var pathStyle = {
    stroke: strokeColor,
    strokeDasharray: "".concat(percent / 100 * (len - gapDegree), "px ").concat(len, "px"),
    strokeDashoffset: "-".concat(gapDegree / 2 + offset3 / 100 * (len - gapDegree), "px"),
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s"
  };
  return {
    pathString,
    pathStyle
  };
}
var VCCircle = Vue.defineComponent({
  name: "VCCircle",
  props: initDefaultProps$1(propTypes, defaultProps),
  setup: function setup24(props2) {
    gradientSeed += 1;
    var gradientId = Vue.ref(gradientSeed);
    var percentList = Vue.computed(function() {
      return toArray$4(props2.percent);
    });
    var strokeColorList = Vue.computed(function() {
      return toArray$4(props2.strokeColor);
    });
    var _useRefs = useRefs$1(), _useRefs2 = _slicedToArray(_useRefs, 2), setRef = _useRefs2[0], paths = _useRefs2[1];
    useTransitionDuration(paths);
    var getStokeList = function getStokeList2() {
      var prefixCls = props2.prefixCls, strokeWidth = props2.strokeWidth, strokeLinecap = props2.strokeLinecap, gapDegree = props2.gapDegree, gapPosition = props2.gapPosition;
      var stackPtg = 0;
      return percentList.value.map(function(ptg, index2) {
        var color = strokeColorList.value[index2] || strokeColorList.value[strokeColorList.value.length - 1];
        var stroke = Object.prototype.toString.call(color) === "[object Object]" ? "url(#".concat(prefixCls, "-gradient-").concat(gradientId.value, ")") : "";
        var _getPathStyles = getPathStyles(stackPtg, ptg, color, strokeWidth, gapDegree, gapPosition), pathString = _getPathStyles.pathString, pathStyle = _getPathStyles.pathStyle;
        stackPtg += ptg;
        var pathProps = {
          key: index2,
          d: pathString,
          stroke,
          "stroke-linecap": strokeLinecap,
          "stroke-width": strokeWidth,
          opacity: ptg === 0 ? 0 : 1,
          "fill-opacity": "0",
          class: "".concat(prefixCls, "-circle-path"),
          style: pathStyle
        };
        return Vue.createVNode("path", _objectSpread2$1({
          "ref": setRef(index2)
        }, pathProps), null);
      });
    };
    return function() {
      var prefixCls = props2.prefixCls, strokeWidth = props2.strokeWidth, trailWidth = props2.trailWidth, gapDegree = props2.gapDegree, gapPosition = props2.gapPosition, trailColor = props2.trailColor, strokeLinecap = props2.strokeLinecap;
      props2.strokeColor;
      var restProps = __rest$C(props2, ["prefixCls", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "strokeColor"]);
      var _getPathStyles2 = getPathStyles(0, 100, trailColor, strokeWidth, gapDegree, gapPosition), pathString = _getPathStyles2.pathString, pathStyle = _getPathStyles2.pathStyle;
      delete restProps.percent;
      var gradient = strokeColorList.value.find(function(color) {
        return Object.prototype.toString.call(color) === "[object Object]";
      });
      var pathFirst = {
        d: pathString,
        stroke: trailColor,
        "stroke-linecap": strokeLinecap,
        "stroke-width": trailWidth || strokeWidth,
        "fill-opacity": "0",
        class: "".concat(prefixCls, "-circle-trail"),
        style: pathStyle
      };
      return Vue.createVNode("svg", _objectSpread2$1({
        "class": "".concat(prefixCls, "-circle"),
        "viewBox": "0 0 100 100"
      }, restProps), [gradient && Vue.createVNode("defs", null, [Vue.createVNode("linearGradient", {
        "id": "".concat(prefixCls, "-gradient-").concat(gradientId.value),
        "x1": "100%",
        "y1": "0%",
        "x2": "0%",
        "y2": "0%"
      }, [Object.keys(gradient).sort(function(a2, b2) {
        return stripPercentToNumber(a2) - stripPercentToNumber(b2);
      }).map(function(key2, index2) {
        return Vue.createVNode("stop", {
          "key": index2,
          "offset": key2,
          "stop-color": gradient[key2]
        }, null);
      })])]), Vue.createVNode("path", pathFirst, null), getStokeList().reverse()]);
    };
  }
});
function getPercentage(_ref) {
  var percent = _ref.percent, success = _ref.success, successPercent = _ref.successPercent;
  var realSuccessPercent = validProgress(getSuccessPercent({
    success,
    successPercent
  }));
  return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
}
function getStrokeColor(_ref2) {
  var _ref2$success = _ref2.success, success = _ref2$success === void 0 ? {} : _ref2$success, strokeColor = _ref2.strokeColor;
  var successColor = success.strokeColor;
  return [successColor || presetPrimaryColors.green, strokeColor || null];
}
var Circle = Vue.defineComponent({
  name: "Circle",
  inheritAttrs: false,
  props: progressProps(),
  setup: function setup25(props2, _ref3) {
    var slots = _ref3.slots;
    var gapDeg = Vue.computed(function() {
      if (props2.gapDegree || props2.gapDegree === 0) {
        return props2.gapDegree;
      }
      if (props2.type === "dashboard") {
        return 75;
      }
      return void 0;
    });
    var circleStyle = Vue.computed(function() {
      var circleSize = props2.width || 120;
      return {
        width: typeof circleSize === "number" ? "".concat(circleSize, "px") : circleSize,
        height: typeof circleSize === "number" ? "".concat(circleSize, "px") : circleSize,
        fontSize: "".concat(circleSize * 0.15 + 6, "px")
      };
    });
    var circleWidth = Vue.computed(function() {
      return props2.strokeWidth || 6;
    });
    var gapPos = Vue.computed(function() {
      return props2.gapPosition || props2.type === "dashboard" && "bottom" || "top";
    });
    var percent = Vue.computed(function() {
      return getPercentage(props2);
    });
    var isGradient = Vue.computed(function() {
      return Object.prototype.toString.call(props2.strokeColor) === "[object Object]";
    });
    var strokeColor = Vue.computed(function() {
      return getStrokeColor({
        success: props2.success,
        strokeColor: props2.strokeColor
      });
    });
    var wrapperClassName = Vue.computed(function() {
      var _ref4;
      return _ref4 = {}, _defineProperty$T(_ref4, "".concat(props2.prefixCls, "-inner"), true), _defineProperty$T(_ref4, "".concat(props2.prefixCls, "-circle-gradient"), isGradient.value), _ref4;
    });
    return function() {
      var _a;
      return Vue.createVNode("div", {
        "class": wrapperClassName.value,
        "style": circleStyle.value
      }, [Vue.createVNode(VCCircle, {
        "percent": percent.value,
        "strokeWidth": circleWidth.value,
        "trailWidth": circleWidth.value,
        "strokeColor": strokeColor.value,
        "strokeLinecap": props2.strokeLinecap,
        "trailColor": props2.trailColor,
        "prefixCls": props2.prefixCls,
        "gapDegree": gapDeg.value,
        "gapPosition": gapPos.value
      }, null), (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
var stepsProps = function stepsProps2() {
  return _extends(_extends({}, progressProps()), {
    steps: Number,
    size: {
      type: String
    },
    strokeColor: String,
    trailColor: String
  });
};
var Steps = Vue.defineComponent({
  name: "Steps",
  props: stepsProps(),
  setup: function setup26(props2, _ref) {
    var slots = _ref.slots;
    var current2 = Vue.computed(function() {
      return Math.round(props2.steps * ((props2.percent || 0) / 100));
    });
    var stepWidth = Vue.computed(function() {
      return props2.size === "small" ? 2 : 14;
    });
    var styledSteps = Vue.computed(function() {
      var steps = props2.steps, _props$strokeWidth = props2.strokeWidth, strokeWidth = _props$strokeWidth === void 0 ? 8 : _props$strokeWidth, strokeColor = props2.strokeColor, trailColor = props2.trailColor, prefixCls = props2.prefixCls;
      var temp = [];
      for (var i2 = 0; i2 < steps; i2 += 1) {
        var _cls;
        var cls = (_cls = {}, _defineProperty$T(_cls, "".concat(prefixCls, "-steps-item"), true), _defineProperty$T(_cls, "".concat(prefixCls, "-steps-item-active"), i2 <= current2.value - 1), _cls);
        temp.push(Vue.createVNode("div", {
          "key": i2,
          "class": cls,
          "style": {
            backgroundColor: i2 <= current2.value - 1 ? strokeColor : trailColor,
            width: "".concat(stepWidth.value, "px"),
            height: "".concat(strokeWidth, "px")
          }
        }, null));
      }
      return temp;
    });
    return function() {
      var _a;
      return Vue.createVNode("div", {
        "class": "".concat(props2.prefixCls, "-steps-outer")
      }, [styledSteps.value, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
var Progress = Vue.defineComponent({
  name: "AProgress",
  props: initDefaultProps$1(progressProps(), {
    type: "line",
    percent: 0,
    showInfo: true,
    trailColor: null,
    size: "default",
    strokeLinecap: "round"
  }),
  slots: ["format"],
  setup: function setup27(props2, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("progress", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    devWarning(props2.successPercent == void 0, "Progress", "`successPercent` is deprecated. Please use `success.percent` instead.");
    var classString = Vue.computed(function() {
      var _ref2;
      var type2 = props2.type, showInfo = props2.showInfo, size = props2.size;
      var pre = prefixCls.value;
      return _ref2 = {}, _defineProperty$T(_ref2, pre, true), _defineProperty$T(_ref2, "".concat(pre, "-").concat(type2 === "dashboard" && "circle" || type2), true), _defineProperty$T(_ref2, "".concat(pre, "-show-info"), showInfo), _defineProperty$T(_ref2, "".concat(pre, "-").concat(size), size), _defineProperty$T(_ref2, "".concat(pre, "-rtl"), direction.value === "rtl"), _ref2;
    });
    var percentNumber = Vue.computed(function() {
      var _props$percent = props2.percent, percent = _props$percent === void 0 ? 0 : _props$percent;
      var successPercent = getSuccessPercent(props2);
      return parseInt(successPercent !== void 0 ? successPercent.toString() : percent.toString(), 10);
    });
    var progressStatus = Vue.computed(function() {
      var status = props2.status;
      if (progressStatuses.indexOf(status) < 0 && percentNumber.value >= 100) {
        return "success";
      }
      return status || "normal";
    });
    var renderProcessInfo = function renderProcessInfo2() {
      var showInfo = props2.showInfo, format2 = props2.format, type2 = props2.type, percent = props2.percent, title = props2.title;
      var successPercent = getSuccessPercent(props2);
      if (!showInfo)
        return null;
      var text;
      var textFormatter = format2 || (slots === null || slots === void 0 ? void 0 : slots.format) || function(val) {
        return "".concat(val, "%");
      };
      var isLineType = type2 === "line";
      if (format2 || (slots === null || slots === void 0 ? void 0 : slots.format) || progressStatus.value !== "exception" && progressStatus.value !== "success") {
        text = textFormatter(validProgress(percent), validProgress(successPercent));
      } else if (progressStatus.value === "exception") {
        text = isLineType ? Vue.createVNode(CloseCircleFilled$1, null, null) : Vue.createVNode(CloseOutlined$1, null, null);
      } else if (progressStatus.value === "success") {
        text = isLineType ? Vue.createVNode(CheckCircleFilled$1, null, null) : Vue.createVNode(CheckOutlined$1, null, null);
      }
      return Vue.createVNode("span", {
        "class": "".concat(prefixCls.value, "-text"),
        "title": title === void 0 && typeof text === "string" ? text : void 0
      }, [text]);
    };
    return function() {
      var type2 = props2.type, steps = props2.steps, strokeColor = props2.strokeColor, title = props2.title;
      var progressInfo = renderProcessInfo();
      var progress;
      if (type2 === "line") {
        progress = steps ? Vue.createVNode(Steps, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
          "strokeColor": typeof strokeColor === "string" ? strokeColor : void 0,
          "prefixCls": prefixCls.value,
          "steps": steps
        }), {
          default: function _default5() {
            return [progressInfo];
          }
        }) : Vue.createVNode(Line, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
          "prefixCls": prefixCls.value
        }), {
          default: function _default5() {
            return [progressInfo];
          }
        });
      } else if (type2 === "circle" || type2 === "dashboard") {
        progress = Vue.createVNode(Circle, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
          "prefixCls": prefixCls.value
        }), {
          default: function _default5() {
            return [progressInfo];
          }
        });
      }
      var classNames2 = _extends(_extends({}, classString.value), _defineProperty$T({}, "".concat(prefixCls.value, "-status-").concat(progressStatus.value), true));
      return Vue.createVNode("div", {
        "class": classNames2,
        "title": title
      }, [progress]);
    };
  }
});
var _Progress = withInstall(Progress);
var listItemProps$1 = function listItemProps2() {
  return {
    prefixCls: String,
    locale: {
      type: Object,
      default: void 0
    },
    file: Object,
    items: Array,
    listType: String,
    isImgUrl: Function,
    showRemoveIcon: {
      type: Boolean,
      default: void 0
    },
    showDownloadIcon: {
      type: Boolean,
      default: void 0
    },
    showPreviewIcon: {
      type: Boolean,
      default: void 0
    },
    removeIcon: Function,
    downloadIcon: Function,
    previewIcon: Function,
    iconRender: Function,
    actionIconRender: Function,
    itemRender: Function,
    onPreview: Function,
    onClose: Function,
    onDownload: Function,
    progress: Object
  };
};
var ListItem = Vue.defineComponent({
  name: "ListItem",
  inheritAttrs: false,
  props: listItemProps$1(),
  setup: function setup28(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var showProgress = Vue.ref(false);
    var progressRafRef = Vue.ref();
    Vue.onMounted(function() {
      progressRafRef.value = setTimeout(function() {
        showProgress.value = true;
      }, 300);
    });
    Vue.onBeforeUnmount(function() {
      clearTimeout(progressRafRef.value);
    });
    var _useConfigInject = useConfigInject("upload", props2), rootPrefixCls = _useConfigInject.rootPrefixCls;
    var transitionProps = Vue.computed(function() {
      return getTransitionProps("".concat(rootPrefixCls.value, "-fade"));
    });
    return function() {
      var _infoUploadingClass, _listContainerNameCla;
      var _a, _b;
      var prefixCls = props2.prefixCls, locale2 = props2.locale, listType = props2.listType, file = props2.file, items = props2.items, progressProps3 = props2.progress, _props$iconRender = props2.iconRender, iconRender = _props$iconRender === void 0 ? slots.iconRender : _props$iconRender, _props$actionIconRend = props2.actionIconRender, actionIconRender = _props$actionIconRend === void 0 ? slots.actionIconRender : _props$actionIconRend, _props$itemRender = props2.itemRender, itemRender = _props$itemRender === void 0 ? slots.itemRender : _props$itemRender, isImgUrl = props2.isImgUrl, showPreviewIcon = props2.showPreviewIcon, showRemoveIcon = props2.showRemoveIcon, showDownloadIcon = props2.showDownloadIcon, _props$previewIcon = props2.previewIcon, customPreviewIcon = _props$previewIcon === void 0 ? slots.previewIcon : _props$previewIcon, _props$removeIcon = props2.removeIcon, customRemoveIcon = _props$removeIcon === void 0 ? slots.removeIcon : _props$removeIcon, _props$downloadIcon = props2.downloadIcon, customDownloadIcon = _props$downloadIcon === void 0 ? slots.downloadIcon : _props$downloadIcon, onPreview = props2.onPreview, onDownload = props2.onDownload, onClose = props2.onClose;
      var className = attrs.class, style = attrs.style;
      var spanClassName = "".concat(prefixCls, "-span");
      var iconNode = iconRender({
        file
      });
      var icon = Vue.createVNode("div", {
        "class": "".concat(prefixCls, "-text-icon")
      }, [iconNode]);
      if (listType === "picture" || listType === "picture-card") {
        if (file.status === "uploading" || !file.thumbUrl && !file.url) {
          var _uploadingClassName;
          var uploadingClassName = (_uploadingClassName = {}, _defineProperty$T(_uploadingClassName, "".concat(prefixCls, "-list-item-thumbnail"), true), _defineProperty$T(_uploadingClassName, "".concat(prefixCls, "-list-item-file"), file.status !== "uploading"), _uploadingClassName);
          icon = Vue.createVNode("div", {
            "class": uploadingClassName
          }, [iconNode]);
        } else {
          var _aClassName;
          var thumbnail = (isImgUrl === null || isImgUrl === void 0 ? void 0 : isImgUrl(file)) ? Vue.createVNode("img", {
            "src": file.thumbUrl || file.url,
            "alt": file.name,
            "class": "".concat(prefixCls, "-list-item-image")
          }, null) : iconNode;
          var aClassName = (_aClassName = {}, _defineProperty$T(_aClassName, "".concat(prefixCls, "-list-item-thumbnail"), true), _defineProperty$T(_aClassName, "".concat(prefixCls, "-list-item-file"), isImgUrl && !isImgUrl(file)), _aClassName);
          icon = Vue.createVNode("a", {
            "class": aClassName,
            "onClick": function onClick2(e2) {
              return onPreview(file, e2);
            },
            "href": file.url || file.thumbUrl,
            "target": "_blank",
            "rel": "noopener noreferrer"
          }, [thumbnail]);
        }
      }
      var infoUploadingClass = (_infoUploadingClass = {}, _defineProperty$T(_infoUploadingClass, "".concat(prefixCls, "-list-item"), true), _defineProperty$T(_infoUploadingClass, "".concat(prefixCls, "-list-item-").concat(file.status), true), _defineProperty$T(_infoUploadingClass, "".concat(prefixCls, "-list-item-list-type-").concat(listType), true), _infoUploadingClass);
      var linkProps = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
      var removeIcon = showRemoveIcon ? actionIconRender({
        customIcon: customRemoveIcon ? customRemoveIcon({
          file
        }) : Vue.createVNode(DeleteOutlined$1, null, null),
        callback: function callback() {
          return onClose(file);
        },
        prefixCls,
        title: locale2.removeFile
      }) : null;
      var downloadIcon = showDownloadIcon && file.status === "done" ? actionIconRender({
        customIcon: customDownloadIcon ? customDownloadIcon({
          file
        }) : Vue.createVNode(DownloadOutlined$1, null, null),
        callback: function callback() {
          return onDownload(file);
        },
        prefixCls,
        title: locale2.downloadFile
      }) : null;
      var downloadOrDelete = listType !== "picture-card" && Vue.createVNode("span", {
        "key": "download-delete",
        "class": ["".concat(prefixCls, "-list-item-card-actions"), {
          picture: listType === "picture"
        }]
      }, [downloadIcon, removeIcon]);
      var listItemNameClass = "".concat(prefixCls, "-list-item-name");
      var preview = file.url ? [Vue.createVNode("a", _objectSpread2$1(_objectSpread2$1({
        "key": "view",
        "target": "_blank",
        "rel": "noopener noreferrer",
        "class": listItemNameClass,
        "title": file.name
      }, linkProps), {}, {
        "href": file.url,
        "onClick": function onClick2(e2) {
          return onPreview(file, e2);
        }
      }), [file.name]), downloadOrDelete] : [Vue.createVNode("span", {
        "key": "view",
        "class": listItemNameClass,
        "onClick": function onClick2(e2) {
          return onPreview(file, e2);
        },
        "title": file.name
      }, [file.name]), downloadOrDelete];
      var previewStyle = {
        pointerEvents: "none",
        opacity: 0.5
      };
      var previewIcon = showPreviewIcon ? Vue.createVNode("a", {
        "href": file.url || file.thumbUrl,
        "target": "_blank",
        "rel": "noopener noreferrer",
        "style": file.url || file.thumbUrl ? void 0 : previewStyle,
        "onClick": function onClick2(e2) {
          return onPreview(file, e2);
        },
        "title": locale2.previewFile
      }, [customPreviewIcon ? customPreviewIcon({
        file
      }) : Vue.createVNode(EyeOutlined$1, null, null)]) : null;
      var actions = listType === "picture-card" && file.status !== "uploading" && Vue.createVNode("span", {
        "class": "".concat(prefixCls, "-list-item-actions")
      }, [previewIcon, file.status === "done" && downloadIcon, removeIcon]);
      var message;
      if (file.response && typeof file.response === "string") {
        message = file.response;
      } else {
        message = ((_a = file.error) === null || _a === void 0 ? void 0 : _a.statusText) || ((_b = file.error) === null || _b === void 0 ? void 0 : _b.message) || locale2.uploadError;
      }
      var iconAndPreview = Vue.createVNode("span", {
        "class": spanClassName
      }, [icon, preview]);
      var dom = Vue.createVNode("div", {
        "class": infoUploadingClass
      }, [Vue.createVNode("div", {
        "class": "".concat(prefixCls, "-list-item-info")
      }, [iconAndPreview]), actions, showProgress.value && Vue.createVNode(Transition$1, transitionProps.value, {
        default: function _default5() {
          return [Vue.withDirectives(Vue.createVNode("div", {
            "class": "".concat(prefixCls, "-list-item-progress")
          }, ["percent" in file ? Vue.createVNode(_Progress, _objectSpread2$1(_objectSpread2$1({}, progressProps3), {}, {
            "type": "line",
            "percent": file.percent
          }), null) : null]), [[Vue.vShow, file.status === "uploading"]])];
        }
      })]);
      var listContainerNameClass = (_listContainerNameCla = {}, _defineProperty$T(_listContainerNameCla, "".concat(prefixCls, "-list-").concat(listType, "-container"), true), _defineProperty$T(_listContainerNameCla, "".concat(className), !!className), _listContainerNameCla);
      var item = file.status === "error" ? Vue.createVNode(_Tooltip, {
        "title": message,
        "getPopupContainer": function getPopupContainer(node) {
          return node.parentNode;
        }
      }, {
        default: function _default5() {
          return [dom];
        }
      }) : dom;
      return Vue.createVNode("div", {
        "class": listContainerNameClass,
        "style": style,
        "ref": Vue.ref
      }, [itemRender ? itemRender({
        originNode: item,
        file,
        fileList: items,
        actions: {
          download: onDownload.bind(null, file),
          preview: onPreview.bind(null, file),
          remove: onClose.bind(null, file)
        }
      }) : item]);
    };
  }
});
function hasClass(node, className) {
  if (node.classList) {
    return node.classList.contains(className);
  }
  var originClass = node.className;
  return " ".concat(originClass, " ").indexOf(" ".concat(className, " ")) > -1;
}
function addClass(node, className) {
  if (node.classList) {
    node.classList.add(className);
  } else {
    if (!hasClass(node, className)) {
      node.className = "".concat(node.className, " ").concat(className);
    }
  }
}
function removeClass(node, className) {
  if (node.classList) {
    node.classList.remove(className);
  } else {
    if (hasClass(node, className)) {
      var originClass = node.className;
      node.className = " ".concat(originClass, " ").replace(" ".concat(className, " "), " ");
    }
  }
}
var collapseMotion = function collapseMotion2() {
  var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse";
  var appear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return {
    name,
    appear,
    css: true,
    onBeforeEnter: function onBeforeEnter(node) {
      node.style.height = "0px";
      node.style.opacity = "0";
      addClass(node, name);
    },
    onEnter: function onEnter(node) {
      Vue.nextTick(function() {
        node.style.height = "".concat(node.scrollHeight, "px");
        node.style.opacity = "1";
      });
    },
    onAfterEnter: function onAfterEnter(node) {
      if (node) {
        removeClass(node, name);
        node.style.height = null;
        node.style.opacity = null;
      }
    },
    onBeforeLeave: function onBeforeLeave(node) {
      addClass(node, name);
      node.style.height = "".concat(node.offsetHeight, "px");
      node.style.opacity = null;
    },
    onLeave: function onLeave(node) {
      setTimeout(function() {
        node.style.height = "0px";
        node.style.opacity = "0";
      });
    },
    onAfterLeave: function onAfterLeave(node) {
      if (node) {
        removeClass(node, name);
        if (node.style) {
          node.style.height = null;
          node.style.opacity = null;
        }
      }
    }
  };
};
var collapseMotion$1 = collapseMotion;
var HackSlot = function HackSlot2(_2, _ref) {
  var slots = _ref.slots;
  var _a;
  return filterEmpty((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots))[0];
};
var UploadList = Vue.defineComponent({
  name: "AUploadList",
  props: initDefaultProps$1(uploadListProps(), {
    listType: "text",
    progress: {
      strokeWidth: 2,
      showInfo: false
    },
    showRemoveIcon: true,
    showDownloadIcon: false,
    showPreviewIcon: true,
    previewFile: previewImage,
    isImageUrl,
    items: [],
    appendActionVisible: true
  }),
  setup: function setup29(props2, _ref2) {
    var slots = _ref2.slots, expose = _ref2.expose;
    var motionAppear = Vue.ref(false);
    var instance = Vue.getCurrentInstance();
    Vue.onMounted(function() {
      motionAppear.value == true;
    });
    Vue.watchEffect(function() {
      if (props2.listType !== "picture" && props2.listType !== "picture-card") {
        return;
      }
      (props2.items || []).forEach(function(file) {
        if (typeof document === "undefined" || typeof window === "undefined" || !window.FileReader || !window.File || !(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0) {
          return;
        }
        file.thumbUrl = "";
        if (props2.previewFile) {
          props2.previewFile(file.originFileObj).then(function(previewDataUrl) {
            file.thumbUrl = previewDataUrl || "";
            instance.update();
          });
        }
      });
    });
    var onInternalPreview = function onInternalPreview2(file, e2) {
      if (!props2.onPreview) {
        return;
      }
      e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
      return props2.onPreview(file);
    };
    var onInternalDownload = function onInternalDownload2(file) {
      if (typeof props2.onDownload === "function") {
        props2.onDownload(file);
      } else if (file.url) {
        window.open(file.url);
      }
    };
    var onInternalClose = function onInternalClose2(file) {
      var _a;
      (_a = props2.onRemove) === null || _a === void 0 ? void 0 : _a.call(props2, file);
    };
    var internalIconRender = function internalIconRender2(_ref3) {
      var file = _ref3.file;
      var iconRender = props2.iconRender || slots.iconRender;
      if (iconRender) {
        return iconRender({
          file,
          listType: props2.listType
        });
      }
      var isLoading = file.status === "uploading";
      var fileIcon = props2.isImageUrl && props2.isImageUrl(file) ? Vue.createVNode(PictureTwoTone$1, null, null) : Vue.createVNode(FileTwoTone$1, null, null);
      var icon = isLoading ? Vue.createVNode(LoadingOutlined$1, null, null) : Vue.createVNode(PaperClipOutlined$1, null, null);
      if (props2.listType === "picture") {
        icon = isLoading ? Vue.createVNode(LoadingOutlined$1, null, null) : fileIcon;
      } else if (props2.listType === "picture-card") {
        icon = isLoading ? props2.locale.uploading : fileIcon;
      }
      return icon;
    };
    var actionIconRender = function actionIconRender2(opt) {
      var customIcon = opt.customIcon, callback = opt.callback, prefixCls2 = opt.prefixCls, title = opt.title;
      var btnProps = {
        type: "text",
        size: "small",
        title,
        onClick: function onClick2() {
          callback();
        },
        class: "".concat(prefixCls2, "-list-item-card-actions-btn")
      };
      if (isValidElement(customIcon)) {
        return Vue.createVNode(Button$1, btnProps, {
          icon: function icon() {
            return customIcon;
          }
        });
      }
      return Vue.createVNode(Button$1, btnProps, {
        default: function _default5() {
          return [Vue.createVNode("span", null, [customIcon])];
        }
      });
    };
    expose({
      handlePreview: onInternalPreview,
      handleDownload: onInternalDownload
    });
    var _useConfigInject = useConfigInject("upload", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var listClassNames = Vue.computed(function() {
      var _ref4;
      return _ref4 = {}, _defineProperty$T(_ref4, "".concat(prefixCls.value, "-list"), true), _defineProperty$T(_ref4, "".concat(prefixCls.value, "-list-").concat(props2.listType), true), _defineProperty$T(_ref4, "".concat(prefixCls.value, "-list-rtl"), direction.value === "rtl"), _ref4;
    });
    var transitionGroupProps = Vue.computed(function() {
      return _extends(_extends(_extends({}, collapseMotion$1("".concat(prefixCls.value, "-").concat(props2.listType === "picture-card" ? "animate-inline" : "animate"))), getTransitionGroupProps("".concat(prefixCls.value, "-").concat(props2.listType === "picture-card" ? "animate-inline" : "animate"))), {
        class: listClassNames.value,
        appear: motionAppear.value
      });
    });
    return function() {
      var listType = props2.listType, locale2 = props2.locale, isImgUrl = props2.isImageUrl, _props$items = props2.items, items = _props$items === void 0 ? [] : _props$items, showPreviewIcon = props2.showPreviewIcon, showRemoveIcon = props2.showRemoveIcon, showDownloadIcon = props2.showDownloadIcon, removeIcon = props2.removeIcon, previewIcon = props2.previewIcon, downloadIcon = props2.downloadIcon, progress = props2.progress, appendAction = props2.appendAction, itemRender = props2.itemRender, appendActionVisible = props2.appendActionVisible;
      var appendActionDom = appendAction === null || appendAction === void 0 ? void 0 : appendAction();
      return Vue.createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({}, transitionGroupProps.value), {}, {
        "tag": "div"
      }), {
        default: function _default5() {
          return [items.map(function(file) {
            var key2 = file.uid;
            return Vue.createVNode(ListItem, {
              "key": key2,
              "locale": locale2,
              "prefixCls": prefixCls.value,
              "file": file,
              "items": items,
              "progress": progress,
              "listType": listType,
              "isImgUrl": isImgUrl,
              "showPreviewIcon": showPreviewIcon,
              "showRemoveIcon": showRemoveIcon,
              "showDownloadIcon": showDownloadIcon,
              "onPreview": onInternalPreview,
              "onDownload": onInternalDownload,
              "onClose": onInternalClose,
              "removeIcon": removeIcon,
              "previewIcon": previewIcon,
              "downloadIcon": downloadIcon,
              "itemRender": itemRender
            }, _extends(_extends({}, slots), {
              iconRender: internalIconRender,
              actionIconRender
            }));
          }), appendAction ? Vue.withDirectives(Vue.createVNode(HackSlot, {
            "key": "__ant_upload_appendAction"
          }, {
            default: function _default6() {
              return appendActionDom;
            }
          }), [[Vue.vShow, !!appendActionVisible]]) : null];
        }
      });
    };
  }
});
function useMergedState(defaultStateValue, option) {
  var _ref = option || {}, defaultValue = _ref.defaultValue, _ref$value = _ref.value, value = _ref$value === void 0 ? Vue.ref() : _ref$value;
  var initValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
  if (value.value !== void 0) {
    initValue = Vue.unref(value);
  }
  if (defaultValue !== void 0) {
    initValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
  }
  var innerValue = Vue.ref(initValue);
  var mergedValue = Vue.ref(initValue);
  Vue.watchEffect(function() {
    var val = value.value !== void 0 ? value.value : innerValue.value;
    if (option.postState) {
      val = option.postState(val);
    }
    mergedValue.value = val;
  });
  function triggerChange(newValue) {
    var preVal = mergedValue.value;
    innerValue.value = newValue;
    if (Vue.toRaw(mergedValue.value) !== newValue && option.onChange) {
      option.onChange(newValue, preVal);
    }
  }
  Vue.watch(value, function() {
    innerValue.value = value.value;
  });
  return [mergedValue, triggerChange];
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var defineProperty$1 = defineProperty;
function baseAssignValue(object, key2, value) {
  if (key2 == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key2] = value;
  }
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
function assignValue(object, key2, value) {
  var objValue = object[key2];
  if (!(hasOwnProperty$4.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
    baseAssignValue(object, key2, value);
  }
}
var responsiveArray = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"];
var responsiveMap = {
  xs: "(max-width: 575px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)",
  xxl: "(min-width: 1600px)",
  xxxl: "(min-width: 2000px)"
};
var subscribers = /* @__PURE__ */ new Map();
var subUid = -1;
var screens = {};
var responsiveObserve = {
  matchHandlers: {},
  dispatch: function dispatch(pointMap) {
    screens = pointMap;
    subscribers.forEach(function(func) {
      return func(screens);
    });
    return subscribers.size >= 1;
  },
  subscribe: function subscribe(func) {
    if (!subscribers.size)
      this.register();
    subUid += 1;
    subscribers.set(subUid, func);
    func(screens);
    return subUid;
  },
  unsubscribe: function unsubscribe(token) {
    subscribers.delete(token);
    if (!subscribers.size)
      this.unregister();
  },
  unregister: function unregister() {
    var _this = this;
    Object.keys(responsiveMap).forEach(function(screen) {
      var matchMediaQuery = responsiveMap[screen];
      var handler2 = _this.matchHandlers[matchMediaQuery];
      handler2 === null || handler2 === void 0 ? void 0 : handler2.mql.removeListener(handler2 === null || handler2 === void 0 ? void 0 : handler2.listener);
    });
    subscribers.clear();
  },
  register: function register() {
    var _this2 = this;
    Object.keys(responsiveMap).forEach(function(screen) {
      var matchMediaQuery = responsiveMap[screen];
      var listener = function listener2(_ref) {
        var matches = _ref.matches;
        _this2.dispatch(_extends(_extends({}, screens), _defineProperty$T({}, screen, matches)));
      };
      var mql = window.matchMedia(matchMediaQuery);
      mql.addListener(listener);
      _this2.matchHandlers[matchMediaQuery] = {
        mql,
        listener
      };
      listener(mql);
    });
  }
};
var ResponsiveObserve = responsiveObserve;
var canUseDocElement = function canUseDocElement2() {
  return canUseDom() && window.document.documentElement;
};
var isStyleNameSupport = function isStyleNameSupport2(styleName) {
  if (canUseDom() && window.document.documentElement) {
    var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    var documentElement = window.document.documentElement;
    return styleNameList.some(function(name) {
      return name in documentElement.style;
    });
  }
  return false;
};
var isStyleValueSupport = function isStyleValueSupport2(styleName, value) {
  if (!isStyleNameSupport(styleName)) {
    return false;
  }
  var ele = document.createElement("div");
  var origin = ele.style[styleName];
  ele.style[styleName] = value;
  return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== void 0) {
    return isStyleValueSupport(styleName, styleValue);
  }
  return isStyleNameSupport(styleName);
}
var flexGapSupported;
var detectFlexGapSupported = function detectFlexGapSupported2() {
  if (!canUseDocElement()) {
    return false;
  }
  if (flexGapSupported !== void 0) {
    return flexGapSupported;
  }
  var flex = document.createElement("div");
  flex.style.display = "flex";
  flex.style.flexDirection = "column";
  flex.style.rowGap = "1px";
  flex.appendChild(document.createElement("div"));
  flex.appendChild(document.createElement("div"));
  document.body.appendChild(flex);
  flexGapSupported = flex.scrollHeight === 1;
  document.body.removeChild(flex);
  return flexGapSupported;
};
var useFlexGapSupport = function() {
  var flexible = Vue.ref(false);
  Vue.onMounted(function() {
    flexible.value = detectFlexGapSupported();
  });
  return flexible;
};
var RowContextKey = Symbol("rowContextKey");
var useProvideRow = function useProvideRow2(state) {
  Vue.provide(RowContextKey, state);
};
var useInjectRow = function useInjectRow2() {
  return Vue.inject(RowContextKey, {
    gutter: Vue.computed(function() {
      return void 0;
    }),
    wrap: Vue.computed(function() {
      return void 0;
    }),
    supportFlexGap: Vue.computed(function() {
      return void 0;
    })
  });
};
tuple$1("top", "middle", "bottom", "stretch");
tuple$1("start", "end", "center", "space-around", "space-between");
var rowProps = function rowProps2() {
  return {
    align: String,
    justify: String,
    prefixCls: String,
    gutter: {
      type: [Number, Array],
      default: 0
    },
    wrap: {
      type: Boolean,
      default: void 0
    }
  };
};
var ARow = Vue.defineComponent({
  name: "ARow",
  props: rowProps(),
  setup: function setup30(props2, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("row", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var token;
    var screens2 = Vue.ref({
      xs: true,
      sm: true,
      md: true,
      lg: true,
      xl: true,
      xxl: true,
      xxxl: true
    });
    var supportFlexGap = useFlexGapSupport();
    Vue.onMounted(function() {
      token = ResponsiveObserve.subscribe(function(screen) {
        var currentGutter = props2.gutter || 0;
        if (!Array.isArray(currentGutter) && _typeof$1(currentGutter) === "object" || Array.isArray(currentGutter) && (_typeof$1(currentGutter[0]) === "object" || _typeof$1(currentGutter[1]) === "object")) {
          screens2.value = screen;
        }
      });
    });
    Vue.onBeforeUnmount(function() {
      ResponsiveObserve.unsubscribe(token);
    });
    var gutter = Vue.computed(function() {
      var results = [0, 0];
      var _props$gutter = props2.gutter, gutter2 = _props$gutter === void 0 ? 0 : _props$gutter;
      var normalizedGutter = Array.isArray(gutter2) ? gutter2 : [gutter2, 0];
      normalizedGutter.forEach(function(g2, index2) {
        if (_typeof$1(g2) === "object") {
          for (var i2 = 0; i2 < responsiveArray.length; i2++) {
            var breakpoint = responsiveArray[i2];
            if (screens2.value[breakpoint] && g2[breakpoint] !== void 0) {
              results[index2] = g2[breakpoint];
              break;
            }
          }
        } else {
          results[index2] = g2 || 0;
        }
      });
      return results;
    });
    useProvideRow({
      gutter,
      supportFlexGap,
      wrap: Vue.computed(function() {
        return props2.wrap;
      })
    });
    var classes = Vue.computed(function() {
      var _classNames;
      return classNames(prefixCls.value, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls.value, "-no-wrap"), props2.wrap === false), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-").concat(props2.justify), props2.justify), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-").concat(props2.align), props2.align), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames));
    });
    var rowStyle = Vue.computed(function() {
      var gt = gutter.value;
      var style = {};
      var horizontalGutter = gt[0] > 0 ? "".concat(gt[0] / -2, "px") : void 0;
      var verticalGutter = gt[1] > 0 ? "".concat(gt[1] / -2, "px") : void 0;
      if (horizontalGutter) {
        style.marginLeft = horizontalGutter;
        style.marginRight = horizontalGutter;
      }
      if (supportFlexGap.value) {
        style.rowGap = "".concat(gt[1], "px");
      } else if (verticalGutter) {
        style.marginTop = verticalGutter;
        style.marginBottom = verticalGutter;
      }
      return style;
    });
    return function() {
      var _a;
      return Vue.createVNode("div", {
        "class": classes.value,
        "style": rowStyle.value
      }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
var Row$3 = ARow;
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$2(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
function parseFlex(flex) {
  if (typeof flex === "number") {
    return "".concat(flex, " ").concat(flex, " auto");
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return "0 0 ".concat(flex);
  }
  return flex;
}
var colProps = function colProps2() {
  return {
    span: [String, Number],
    order: [String, Number],
    offset: [String, Number],
    push: [String, Number],
    pull: [String, Number],
    xs: {
      type: [String, Number, Object],
      default: void 0
    },
    sm: {
      type: [String, Number, Object],
      default: void 0
    },
    md: {
      type: [String, Number, Object],
      default: void 0
    },
    lg: {
      type: [String, Number, Object],
      default: void 0
    },
    xl: {
      type: [String, Number, Object],
      default: void 0
    },
    xxl: {
      type: [String, Number, Object],
      default: void 0
    },
    xxxl: {
      type: [String, Number, Object],
      default: void 0
    },
    prefixCls: String,
    flex: [String, Number]
  };
};
var Col$1 = Vue.defineComponent({
  name: "ACol",
  props: colProps(),
  setup: function setup31(props2, _ref) {
    var slots = _ref.slots;
    var _useInjectRow = useInjectRow(), gutter = _useInjectRow.gutter, supportFlexGap = _useInjectRow.supportFlexGap, wrap = _useInjectRow.wrap;
    var _useConfigInject = useConfigInject("col", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var classes = Vue.computed(function() {
      var _classNames;
      var span = props2.span, order = props2.order, offset3 = props2.offset, push = props2.push, pull = props2.pull;
      var pre = prefixCls.value;
      var sizeClassObj = {};
      ["xs", "sm", "md", "lg", "xl", "xxl", "xxxl"].forEach(function(size) {
        var _extends2;
        var sizeProps = {};
        var propSize = props2[size];
        if (typeof propSize === "number") {
          sizeProps.span = propSize;
        } else if (_typeof$1(propSize) === "object") {
          sizeProps = propSize || {};
        }
        sizeClassObj = _extends(_extends({}, sizeClassObj), (_extends2 = {}, _defineProperty$T(_extends2, "".concat(pre, "-").concat(size, "-").concat(sizeProps.span), sizeProps.span !== void 0), _defineProperty$T(_extends2, "".concat(pre, "-").concat(size, "-order-").concat(sizeProps.order), sizeProps.order || sizeProps.order === 0), _defineProperty$T(_extends2, "".concat(pre, "-").concat(size, "-offset-").concat(sizeProps.offset), sizeProps.offset || sizeProps.offset === 0), _defineProperty$T(_extends2, "".concat(pre, "-").concat(size, "-push-").concat(sizeProps.push), sizeProps.push || sizeProps.push === 0), _defineProperty$T(_extends2, "".concat(pre, "-").concat(size, "-pull-").concat(sizeProps.pull), sizeProps.pull || sizeProps.pull === 0), _defineProperty$T(_extends2, "".concat(pre, "-rtl"), direction.value === "rtl"), _extends2));
      });
      return classNames(pre, (_classNames = {}, _defineProperty$T(_classNames, "".concat(pre, "-").concat(span), span !== void 0), _defineProperty$T(_classNames, "".concat(pre, "-order-").concat(order), order), _defineProperty$T(_classNames, "".concat(pre, "-offset-").concat(offset3), offset3), _defineProperty$T(_classNames, "".concat(pre, "-push-").concat(push), push), _defineProperty$T(_classNames, "".concat(pre, "-pull-").concat(pull), pull), _classNames), sizeClassObj);
    });
    var mergedStyle = Vue.computed(function() {
      var flex = props2.flex;
      var gutterVal = gutter.value;
      var style = {};
      if (gutterVal && gutterVal[0] > 0) {
        var horizontalGutter = "".concat(gutterVal[0] / 2, "px");
        style.paddingLeft = horizontalGutter;
        style.paddingRight = horizontalGutter;
      }
      if (gutterVal && gutterVal[1] > 0 && !supportFlexGap.value) {
        var verticalGutter = "".concat(gutterVal[1] / 2, "px");
        style.paddingTop = verticalGutter;
        style.paddingBottom = verticalGutter;
      }
      if (flex) {
        style.flex = parseFlex(flex);
        if (wrap.value === false && !style.minWidth) {
          style.minWidth = 0;
        }
      }
      return style;
    });
    return function() {
      var _a;
      return Vue.createVNode("div", {
        "class": classes.value,
        "style": mergedStyle.value
      }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
var sizeProvider = Symbol("SizeProvider");
var useProvideSize = function useProvideSize2(props2) {
  var configProvider = Vue.inject("configProvider", defaultConfigProvider);
  var size = Vue.computed(function() {
    return props2.size || configProvider.componentSize;
  });
  Vue.provide(sizeProvider, size);
  return size;
};
var useInjectSize = function useInjectSize2(props2) {
  var size = props2 ? Vue.computed(function() {
    return props2.size;
  }) : Vue.inject(sizeProvider, Vue.computed(function() {
    return "default";
  }));
  return size;
};
function baseIsNaN(value) {
  return value !== value;
}
function strictIndexOf(array, value, fromIndex) {
  var index2 = fromIndex - 1, length = array.length;
  while (++index2 < length) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}
function arrayIncludesWith(array, value, comparator) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (comparator(value, array[index2])) {
      return true;
    }
  }
  return false;
}
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var nativeMax$1 = Math.max;
function overRest(func, start, transform) {
  start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var baseSetToString = !defineProperty$1 ? identity$2 : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var baseSetToString$1 = baseSetToString;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;
var now = function() {
  return root$3.Date.now();
};
var now$1 = now;
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$2(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var spreadableSymbol = Symbol$5 ? Symbol$5.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray$4(value) || isArguments$3(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index2 = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
function flatRest(func) {
  return setToString$1(overRest(func, void 0, flatten), func + "");
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator2) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator2["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
var LIST_IGNORE = "__LIST_IGNORE_".concat(Date.now(), "__");
var Upload = Vue.defineComponent({
  name: "AUpload",
  inheritAttrs: false,
  props: initDefaultProps$1(uploadProps(), {
    type: "select",
    multiple: false,
    action: "",
    data: {},
    accept: "",
    showUploadList: true,
    listType: "text",
    disabled: false,
    supportServerRender: true
  }),
  setup: function setup32(props2, _ref) {
    var _this = this;
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var formItemContext = useInjectFormItemContext();
    var _useMergedState = useMergedState(props2.defaultFileList || [], {
      value: Vue.toRef(props2, "fileList"),
      postState: function postState(list) {
        var timestamp = Date.now();
        return (list !== null && list !== void 0 ? list : []).map(function(file, index2) {
          if (!file.uid && !Object.isFrozen(file)) {
            file.uid = "__AUTO__".concat(timestamp, "_").concat(index2, "__");
          }
          return file;
        });
      }
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedFileList = _useMergedState2[0], setMergedFileList = _useMergedState2[1];
    var dragState = Vue.ref("drop");
    var upload2 = Vue.ref();
    Vue.onMounted(function() {
      devWarning(props2.fileList !== void 0 || attrs.value === void 0, "Upload", "`value` is not a valid prop, do you mean `fileList`?");
      devWarning(props2.transformFile === void 0, "Upload", "`transformFile` is deprecated. Please use `beforeUpload` directly.");
      devWarning(props2.remove === void 0, "Upload", "`remove` props is deprecated. Please use `remove` event.");
    });
    var onInternalChange = function onInternalChange2(file, changedFileList, event) {
      var _a, _b;
      var cloneList = _toConsumableArray(changedFileList);
      if (props2.maxCount === 1) {
        cloneList = cloneList.slice(-1);
      } else if (props2.maxCount) {
        cloneList = cloneList.slice(0, props2.maxCount);
      }
      setMergedFileList(cloneList);
      var changeInfo = {
        file,
        fileList: cloneList
      };
      if (event) {
        changeInfo.event = event;
      }
      (_a = props2["onUpdate:fileList"]) === null || _a === void 0 ? void 0 : _a.call(props2, changeInfo.fileList);
      (_b = props2.onChange) === null || _b === void 0 ? void 0 : _b.call(props2, changeInfo);
      formItemContext.onFieldChange();
    };
    var mergedBeforeUpload = function mergedBeforeUpload2(file, fileListArgs) {
      return __awaiter(_this, void 0, void 0, /* @__PURE__ */ regenerator.mark(function _callee() {
        var beforeUpload, transformFile, parsedFile, result;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                beforeUpload = props2.beforeUpload, transformFile = props2.transformFile;
                parsedFile = file;
                if (!beforeUpload) {
                  _context.next = 13;
                  break;
                }
                _context.next = 5;
                return beforeUpload(file, fileListArgs);
              case 5:
                result = _context.sent;
                if (!(result === false)) {
                  _context.next = 8;
                  break;
                }
                return _context.abrupt("return", false);
              case 8:
                delete file[LIST_IGNORE];
                if (!(result === LIST_IGNORE)) {
                  _context.next = 12;
                  break;
                }
                Object.defineProperty(file, LIST_IGNORE, {
                  value: true,
                  configurable: true
                });
                return _context.abrupt("return", false);
              case 12:
                if (_typeof$1(result) === "object" && result) {
                  parsedFile = result;
                }
              case 13:
                if (!transformFile) {
                  _context.next = 17;
                  break;
                }
                _context.next = 16;
                return transformFile(parsedFile);
              case 16:
                parsedFile = _context.sent;
              case 17:
                return _context.abrupt("return", parsedFile);
              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
    };
    var onBatchStart = function onBatchStart2(batchFileInfoList) {
      var filteredFileInfoList = batchFileInfoList.filter(function(info) {
        return !info.file[LIST_IGNORE];
      });
      if (!filteredFileInfoList.length) {
        return;
      }
      var objectFileList = filteredFileInfoList.map(function(info) {
        return file2Obj(info.file);
      });
      var newFileList = _toConsumableArray(mergedFileList.value);
      objectFileList.forEach(function(fileObj) {
        newFileList = updateFileList(fileObj, newFileList);
      });
      objectFileList.forEach(function(fileObj, index2) {
        var triggerFileObj = fileObj;
        if (!filteredFileInfoList[index2].parsedFile) {
          var originFileObj = fileObj.originFileObj;
          var clone2;
          try {
            clone2 = new File([originFileObj], originFileObj.name, {
              type: originFileObj.type
            });
          } catch (e2) {
            clone2 = new Blob([originFileObj], {
              type: originFileObj.type
            });
            clone2.name = originFileObj.name;
            clone2.lastModifiedDate = new Date();
            clone2.lastModified = new Date().getTime();
          }
          clone2.uid = fileObj.uid;
          triggerFileObj = clone2;
        } else {
          fileObj.status = "uploading";
        }
        onInternalChange(triggerFileObj, newFileList);
      });
    };
    var onSuccess = function onSuccess2(response, file, xhr) {
      try {
        if (typeof response === "string") {
          response = JSON.parse(response);
        }
      } catch (e2) {
      }
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      var targetItem = file2Obj(file);
      targetItem.status = "done";
      targetItem.percent = 100;
      targetItem.response = response;
      targetItem.xhr = xhr;
      var nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList);
    };
    var onProgress = function onProgress2(e2, file) {
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      var targetItem = file2Obj(file);
      targetItem.status = "uploading";
      targetItem.percent = e2.percent;
      var nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList, e2);
    };
    var onError = function onError2(error, response, file) {
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      var targetItem = file2Obj(file);
      targetItem.error = error;
      targetItem.response = response;
      targetItem.status = "error";
      var nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList);
    };
    var handleRemove = function handleRemove2(file) {
      var currentFile;
      var mergedRemove = props2.onRemove || props2.remove;
      Promise.resolve(typeof mergedRemove === "function" ? mergedRemove(file) : mergedRemove).then(function(ret) {
        var _a, _b;
        if (ret === false) {
          return;
        }
        var removedFileList = removeFileItem(file, mergedFileList.value);
        if (removedFileList) {
          currentFile = _extends(_extends({}, file), {
            status: "removed"
          });
          (_a = mergedFileList.value) === null || _a === void 0 ? void 0 : _a.forEach(function(item) {
            var matchKey = currentFile.uid !== void 0 ? "uid" : "name";
            if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) {
              item.status = "removed";
            }
          });
          (_b = upload2.value) === null || _b === void 0 ? void 0 : _b.abort(currentFile);
          onInternalChange(currentFile, removedFileList);
        }
      });
    };
    var onFileDrop = function onFileDrop2(e2) {
      var _a;
      dragState.value = e2.type;
      if (e2.type === "drop") {
        (_a = props2.onDrop) === null || _a === void 0 ? void 0 : _a.call(props2, e2);
      }
    };
    expose({
      onBatchStart,
      onSuccess,
      onProgress,
      onError,
      fileList: mergedFileList,
      upload: upload2
    });
    var _useConfigInject = useConfigInject("upload", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var _useLocaleReceiver = useLocaleReceiver("Upload", defaultLocale.Upload, Vue.computed(function() {
      return props2.locale;
    })), _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 1), locale2 = _useLocaleReceiver2[0];
    var renderUploadList = function renderUploadList2(button, buttonVisible) {
      var removeIcon = props2.removeIcon, previewIcon = props2.previewIcon, downloadIcon = props2.downloadIcon, previewFile = props2.previewFile, onPreview = props2.onPreview, onDownload = props2.onDownload, disabled = props2.disabled, isImageUrl3 = props2.isImageUrl, progress = props2.progress, itemRender = props2.itemRender, iconRender = props2.iconRender, showUploadList = props2.showUploadList;
      var _ref2 = typeof showUploadList === "boolean" ? {} : showUploadList, showDownloadIcon = _ref2.showDownloadIcon, showPreviewIcon = _ref2.showPreviewIcon, showRemoveIcon = _ref2.showRemoveIcon;
      return showUploadList ? Vue.createVNode(UploadList, {
        "listType": props2.listType,
        "items": mergedFileList.value,
        "previewFile": previewFile,
        "onPreview": onPreview,
        "onDownload": onDownload,
        "onRemove": handleRemove,
        "showRemoveIcon": !disabled && showRemoveIcon,
        "showPreviewIcon": showPreviewIcon,
        "showDownloadIcon": showDownloadIcon,
        "removeIcon": removeIcon,
        "previewIcon": previewIcon,
        "downloadIcon": downloadIcon,
        "iconRender": iconRender,
        "locale": locale2.value,
        "isImageUrl": isImageUrl3,
        "progress": progress,
        "itemRender": itemRender,
        "appendActionVisible": buttonVisible,
        "appendAction": button
      }, _extends({}, slots)) : button === null || button === void 0 ? void 0 : button();
    };
    return function() {
      var _classNames2;
      var _a, _b, _c;
      var listType = props2.listType, disabled = props2.disabled, type2 = props2.type;
      var rcUploadProps = _extends(_extends({
        onBatchStart,
        onError,
        onProgress,
        onSuccess
      }, props2), {
        id: (_a = props2.id) !== null && _a !== void 0 ? _a : formItemContext.id.value,
        prefixCls: prefixCls.value,
        beforeUpload: mergedBeforeUpload,
        onChange: void 0
      });
      delete rcUploadProps.remove;
      if (!slots.default || disabled) {
        delete rcUploadProps.id;
      }
      if (type2 === "drag") {
        var _classNames;
        var dragCls = classNames(prefixCls.value, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls.value, "-drag"), true), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-drag-uploading"), mergedFileList.value.some(function(file) {
          return file.status === "uploading";
        })), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-drag-hover"), dragState.value === "dragover"), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-disabled"), disabled), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames), attrs.class);
        return Vue.createVNode("span", null, [Vue.createVNode("div", {
          "class": dragCls,
          "onDrop": onFileDrop,
          "onDragover": onFileDrop,
          "onDragleave": onFileDrop,
          "style": attrs.style
        }, [Vue.createVNode(Upload$1, _objectSpread2$1(_objectSpread2$1({}, rcUploadProps), {}, {
          "ref": upload2,
          "class": "".concat(prefixCls.value, "-btn")
        }), _objectSpread2$1({
          default: function _default5() {
            return [Vue.createVNode("div", {
              "class": "".concat(prefixCls, "-drag-container")
            }, [(_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots)])];
          }
        }, slots))]), renderUploadList()]);
      }
      var uploadButtonCls = classNames(prefixCls.value, (_classNames2 = {}, _defineProperty$T(_classNames2, "".concat(prefixCls.value, "-select"), true), _defineProperty$T(_classNames2, "".concat(prefixCls.value, "-select-").concat(listType), true), _defineProperty$T(_classNames2, "".concat(prefixCls.value, "-disabled"), disabled), _defineProperty$T(_classNames2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames2));
      var children = flattenChildren((_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots));
      var renderUploadButton = function renderUploadButton2(uploadButtonStyle) {
        return Vue.createVNode("div", {
          "class": uploadButtonCls,
          "style": uploadButtonStyle
        }, [Vue.createVNode(Upload$1, _objectSpread2$1(_objectSpread2$1({}, rcUploadProps), {}, {
          "ref": upload2
        }), slots)]);
      };
      if (listType === "picture-card") {
        return Vue.createVNode("span", {
          "class": classNames("".concat(prefixCls.value, "-picture-card-wrapper"), attrs.class)
        }, [renderUploadList(renderUploadButton, !!(children && children.length))]);
      }
      return Vue.createVNode("span", {
        "class": attrs.class
      }, [renderUploadButton(children && children.length ? void 0 : {
        display: "none"
      }), renderUploadList()]);
    };
  }
});
var __rest$B = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var Dragger = Vue.defineComponent({
  name: "AUploadDragger",
  inheritAttrs: false,
  props: uploadProps(),
  setup: function setup33(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    return function() {
      var height = props2.height, restProps = __rest$B(props2, ["height"]);
      var style = attrs.style, restAttrs = __rest$B(attrs, ["style"]);
      var draggerProps = _extends(_extends(_extends({}, restProps), restAttrs), {
        type: "drag",
        style: _extends(_extends({}, style), {
          height: typeof height === "number" ? "".concat(height, "px") : height
        })
      });
      return Vue.createVNode(Upload, draggerProps, slots);
    };
  }
});
var _Upload = _extends(Upload, {
  Dragger,
  LIST_IGNORE,
  install: function install(app) {
    app.component(Upload.name, Upload);
    app.component(Dragger.name, Dragger);
    return app;
  }
});
var index$v = "";
var SiderCollapsedKey = Symbol("siderCollapsed");
var SiderHookProviderKey = Symbol("siderHookProvider");
var basicProps = function basicProps2() {
  return {
    prefixCls: String,
    hasSider: {
      type: Boolean,
      default: void 0
    },
    tagName: String
  };
};
function generator(_ref) {
  var suffixCls = _ref.suffixCls, tagName = _ref.tagName, name = _ref.name;
  return function(BasicComponent) {
    var Adapter = Vue.defineComponent({
      name,
      props: basicProps(),
      setup: function setup153(props2, _ref2) {
        var slots = _ref2.slots;
        var _useConfigInject = useConfigInject(suffixCls, props2), prefixCls = _useConfigInject.prefixCls;
        return function() {
          var basicComponentProps = _extends(_extends({}, props2), {
            prefixCls: prefixCls.value,
            tagName
          });
          return Vue.createVNode(BasicComponent, basicComponentProps, slots);
        };
      }
    });
    return Adapter;
  };
}
var Basic = Vue.defineComponent({
  props: basicProps(),
  setup: function setup34(props2, _ref3) {
    var slots = _ref3.slots;
    return function() {
      return Vue.createVNode(props2.tagName, {
        class: props2.prefixCls
      }, slots);
    };
  }
});
var BasicLayout = Vue.defineComponent({
  props: basicProps(),
  setup: function setup35(props2, _ref4) {
    var slots = _ref4.slots;
    var _useConfigInject2 = useConfigInject("", props2), direction = _useConfigInject2.direction;
    var siders = Vue.ref([]);
    var siderHookProvider = {
      addSider: function addSider(id) {
        siders.value = [].concat(_toConsumableArray(siders.value), [id]);
      },
      removeSider: function removeSider(id) {
        siders.value = siders.value.filter(function(currentId) {
          return currentId !== id;
        });
      }
    };
    Vue.provide(SiderHookProviderKey, siderHookProvider);
    var divCls = Vue.computed(function() {
      var _ref5;
      var prefixCls = props2.prefixCls, hasSider = props2.hasSider;
      return _ref5 = {}, _defineProperty$T(_ref5, "".concat(prefixCls), true), _defineProperty$T(_ref5, "".concat(prefixCls, "-has-sider"), typeof hasSider === "boolean" ? hasSider : siders.value.length > 0), _defineProperty$T(_ref5, "".concat(prefixCls, "-rtl"), direction.value === "rtl"), _ref5;
    });
    return function() {
      var tagName = props2.tagName;
      return Vue.createVNode(tagName, {
        class: divCls.value
      }, slots);
    };
  }
});
var Layout = generator({
  suffixCls: "layout",
  tagName: "section",
  name: "ALayout"
})(BasicLayout);
var Header$2 = generator({
  suffixCls: "layout-header",
  tagName: "header",
  name: "ALayoutHeader"
})(Basic);
var Footer$1 = generator({
  suffixCls: "layout-footer",
  tagName: "footer",
  name: "ALayoutFooter"
})(Basic);
var Content$1 = generator({
  suffixCls: "layout-content",
  tagName: "main",
  name: "ALayoutContent"
})(Basic);
var Layout$1 = Layout;
var isNumeric = function isNumeric2(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
};
var isNumeric$1 = isNumeric;
var BarsOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "0 0 1024 1024",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z"
      }
    }]
  },
  "name": "bars",
  "theme": "outlined"
};
var BarsOutlinedSvg = BarsOutlined$2;
function _objectSpread$x(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$x(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$x(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var BarsOutlined = function BarsOutlined2(props2, context) {
  var p2 = _objectSpread$x({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$x({}, p2, {
    "icon": BarsOutlinedSvg
  }), null);
};
BarsOutlined.displayName = "BarsOutlined";
BarsOutlined.inheritAttrs = false;
var BarsOutlined$1 = BarsOutlined;
var RightOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"
      }
    }]
  },
  "name": "right",
  "theme": "outlined"
};
var RightOutlinedSvg = RightOutlined$2;
function _objectSpread$w(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$w(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$w(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var RightOutlined = function RightOutlined2(props2, context) {
  var p2 = _objectSpread$w({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$w({}, p2, {
    "icon": RightOutlinedSvg
  }), null);
};
RightOutlined.displayName = "RightOutlined";
RightOutlined.inheritAttrs = false;
var RightOutlined$1 = RightOutlined;
var LeftOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"
      }
    }]
  },
  "name": "left",
  "theme": "outlined"
};
var LeftOutlinedSvg = LeftOutlined$2;
function _objectSpread$v(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$v(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$v(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var LeftOutlined = function LeftOutlined2(props2, context) {
  var p2 = _objectSpread$v({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$v({}, p2, {
    "icon": LeftOutlinedSvg
  }), null);
};
LeftOutlined.displayName = "LeftOutlined";
LeftOutlined.inheritAttrs = false;
var LeftOutlined$1 = LeftOutlined;
var dimensionMaxMap = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px",
  xxxl: "1999.98px"
};
var siderProps = function siderProps2() {
  return {
    prefixCls: String,
    collapsible: {
      type: Boolean,
      default: void 0
    },
    collapsed: {
      type: Boolean,
      default: void 0
    },
    defaultCollapsed: {
      type: Boolean,
      default: void 0
    },
    reverseArrow: {
      type: Boolean,
      default: void 0
    },
    zeroWidthTriggerStyle: {
      type: Object,
      default: void 0
    },
    trigger: PropTypes$1.any,
    width: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    collapsedWidth: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    breakpoint: PropTypes$1.oneOf(tuple$1("xs", "sm", "md", "lg", "xl", "xxl", "xxxl")),
    theme: PropTypes$1.oneOf(tuple$1("light", "dark")).def("dark"),
    onBreakpoint: Function,
    onCollapse: Function
  };
};
var generateId = function() {
  var i2 = 0;
  return function() {
    var prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    i2 += 1;
    return "".concat(prefix).concat(i2);
  };
}();
var Sider = Vue.defineComponent({
  name: "ALayoutSider",
  inheritAttrs: false,
  props: initDefaultProps$1(siderProps(), {
    collapsible: false,
    defaultCollapsed: false,
    reverseArrow: false,
    width: 200,
    collapsedWidth: 80
  }),
  emits: ["breakpoint", "update:collapsed", "collapse"],
  setup: function setup36(props2, _ref) {
    var emit = _ref.emit, attrs = _ref.attrs, slots = _ref.slots;
    var _useConfigInject = useConfigInject("layout-sider", props2), prefixCls = _useConfigInject.prefixCls;
    var siderHook = Vue.inject(SiderHookProviderKey, void 0);
    var collapsed = Vue.ref(!!(props2.collapsed !== void 0 ? props2.collapsed : props2.defaultCollapsed));
    var below = Vue.ref(false);
    Vue.watch(function() {
      return props2.collapsed;
    }, function() {
      collapsed.value = !!props2.collapsed;
    });
    Vue.provide(SiderCollapsedKey, collapsed);
    var handleSetCollapsed = function handleSetCollapsed2(value, type2) {
      if (props2.collapsed === void 0) {
        collapsed.value = value;
      }
      emit("update:collapsed", value);
      emit("collapse", value, type2);
    };
    var responsiveHandlerRef = Vue.ref(function(mql2) {
      below.value = mql2.matches;
      emit("breakpoint", mql2.matches);
      if (collapsed.value !== mql2.matches) {
        handleSetCollapsed(mql2.matches, "responsive");
      }
    });
    var mql;
    function responsiveHandler(mql2) {
      return responsiveHandlerRef.value(mql2);
    }
    var uniqueId = generateId("ant-sider-");
    siderHook && siderHook.addSider(uniqueId);
    Vue.onMounted(function() {
      Vue.watch(function() {
        return props2.breakpoint;
      }, function() {
        try {
          mql === null || mql === void 0 ? void 0 : mql.removeEventListener("change", responsiveHandler);
        } catch (error) {
          mql === null || mql === void 0 ? void 0 : mql.removeListener(responsiveHandler);
        }
        if (typeof window !== "undefined") {
          var _window = window, matchMedia = _window.matchMedia;
          if (matchMedia && props2.breakpoint && props2.breakpoint in dimensionMaxMap) {
            mql = matchMedia("(max-width: ".concat(dimensionMaxMap[props2.breakpoint], ")"));
            try {
              mql.addEventListener("change", responsiveHandler);
            } catch (error) {
              mql.addListener(responsiveHandler);
            }
            responsiveHandler(mql);
          }
        }
      }, {
        immediate: true
      });
    });
    Vue.onBeforeUnmount(function() {
      try {
        mql === null || mql === void 0 ? void 0 : mql.removeEventListener("change", responsiveHandler);
      } catch (error) {
        mql === null || mql === void 0 ? void 0 : mql.removeListener(responsiveHandler);
      }
      siderHook && siderHook.removeSider(uniqueId);
    });
    var toggle = function toggle2() {
      handleSetCollapsed(!collapsed.value, "clickTrigger");
    };
    return function() {
      var _classNames;
      var _a, _b;
      var pre = prefixCls.value;
      var collapsedWidth = props2.collapsedWidth, width = props2.width, reverseArrow = props2.reverseArrow, zeroWidthTriggerStyle = props2.zeroWidthTriggerStyle, _props$trigger = props2.trigger, trigger2 = _props$trigger === void 0 ? (_a = slots.trigger) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$trigger, collapsible = props2.collapsible, theme = props2.theme;
      var rawWidth = collapsed.value ? collapsedWidth : width;
      var siderWidth = isNumeric$1(rawWidth) ? "".concat(rawWidth, "px") : String(rawWidth);
      var zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? Vue.createVNode("span", {
        "onClick": toggle,
        "class": classNames("".concat(pre, "-zero-width-trigger"), "".concat(pre, "-zero-width-trigger-").concat(reverseArrow ? "right" : "left")),
        "style": zeroWidthTriggerStyle
      }, [trigger2 || Vue.createVNode(BarsOutlined$1, null, null)]) : null;
      var iconObj = {
        expanded: reverseArrow ? Vue.createVNode(RightOutlined$1, null, null) : Vue.createVNode(LeftOutlined$1, null, null),
        collapsed: reverseArrow ? Vue.createVNode(LeftOutlined$1, null, null) : Vue.createVNode(RightOutlined$1, null, null)
      };
      var status = collapsed.value ? "collapsed" : "expanded";
      var defaultTrigger = iconObj[status];
      var triggerDom = trigger2 !== null ? zeroWidthTrigger || Vue.createVNode("div", {
        "class": "".concat(pre, "-trigger"),
        "onClick": toggle,
        "style": {
          width: siderWidth
        }
      }, [trigger2 || defaultTrigger]) : null;
      var divStyle = [attrs.style, {
        flex: "0 0 ".concat(siderWidth),
        maxWidth: siderWidth,
        minWidth: siderWidth,
        width: siderWidth
      }];
      var siderCls = classNames(pre, "".concat(pre, "-").concat(theme), (_classNames = {}, _defineProperty$T(_classNames, "".concat(pre, "-collapsed"), !!collapsed.value), _defineProperty$T(_classNames, "".concat(pre, "-has-trigger"), collapsible && trigger2 !== null && !zeroWidthTrigger), _defineProperty$T(_classNames, "".concat(pre, "-below"), !!below.value), _defineProperty$T(_classNames, "".concat(pre, "-zero-width"), parseFloat(siderWidth) === 0), _classNames), attrs.class);
      return Vue.createVNode("aside", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": siderCls,
        "style": divStyle
      }), [Vue.createVNode("div", {
        "class": "".concat(pre, "-children")
      }, [(_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots)]), collapsible || below.value && zeroWidthTrigger ? triggerDom : null]);
    };
  }
});
var LayoutHeader = Header$2;
var LayoutFooter = Footer$1;
var LayoutSider = Sider;
var LayoutContent = Content$1;
var _Layout = _extends(Layout$1, {
  Header: Header$2,
  Footer: Footer$1,
  Content: Content$1,
  Sider,
  install: function install2(app) {
    app.component(Layout$1.name, Layout$1);
    app.component(Header$2.name, Header$2);
    app.component(Footer$1.name, Footer$1);
    app.component(Sider.name, Sider);
    app.component(Content$1.name, Content$1);
    return app;
  }
});
var index$u = "";
var __rest$A = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var spinProps = function spinProps2() {
  return {
    prefixCls: String,
    spinning: {
      type: Boolean,
      default: void 0
    },
    size: String,
    wrapperClassName: String,
    tip: PropTypes$1.any,
    delay: Number,
    indicator: PropTypes$1.any
  };
};
var defaultIndicator = null;
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
function setDefaultIndicator(Content2) {
  var Indicator = Content2.indicator;
  defaultIndicator = typeof Indicator === "function" ? Indicator : function() {
    return Vue.createVNode(Indicator, null, null);
  };
}
var Spin = Vue.defineComponent({
  name: "ASpin",
  inheritAttrs: false,
  props: initDefaultProps$1(spinProps(), {
    size: "default",
    spinning: true,
    wrapperClassName: ""
  }),
  setup: function setup37() {
    return {
      originalUpdateSpinning: null,
      configProvider: Vue.inject("configProvider", defaultConfigProvider)
    };
  },
  data: function data2() {
    var spinning = this.spinning, delay = this.delay;
    var shouldBeDelayed = shouldDelay(spinning, delay);
    return {
      sSpinning: spinning && !shouldBeDelayed
    };
  },
  created: function created2() {
    this.originalUpdateSpinning = this.updateSpinning;
    this.debouncifyUpdateSpinning(this.$props);
  },
  mounted: function mounted2() {
    this.updateSpinning();
  },
  updated: function updated2() {
    var _this = this;
    Vue.nextTick(function() {
      _this.debouncifyUpdateSpinning();
      _this.updateSpinning();
    });
  },
  beforeUnmount: function beforeUnmount2() {
    this.cancelExistingSpin();
  },
  methods: {
    debouncifyUpdateSpinning: function debouncifyUpdateSpinning(props2) {
      var _ref = props2 || this.$props, delay = _ref.delay;
      if (delay) {
        this.cancelExistingSpin();
        this.updateSpinning = debounce(this.originalUpdateSpinning, delay);
      }
    },
    updateSpinning: function updateSpinning() {
      var spinning = this.spinning, sSpinning = this.sSpinning;
      if (sSpinning !== spinning) {
        this.sSpinning = spinning;
      }
    },
    cancelExistingSpin: function cancelExistingSpin() {
      var updateSpinning2 = this.updateSpinning;
      if (updateSpinning2 && updateSpinning2.cancel) {
        updateSpinning2.cancel();
      }
    },
    renderIndicator: function renderIndicator(prefixCls) {
      var dotClassName = "".concat(prefixCls, "-dot");
      var indicator = getComponent(this, "indicator");
      if (indicator === null) {
        return null;
      }
      if (Array.isArray(indicator)) {
        indicator = indicator.length === 1 ? indicator[0] : indicator;
      }
      if (Vue.isVNode(indicator)) {
        return Vue.cloneVNode(indicator, {
          class: dotClassName
        });
      }
      if (defaultIndicator && Vue.isVNode(defaultIndicator())) {
        return Vue.cloneVNode(defaultIndicator(), {
          class: dotClassName
        });
      }
      return Vue.createVNode("span", {
        "class": "".concat(dotClassName, " ").concat(prefixCls, "-dot-spin")
      }, [Vue.createVNode("i", {
        "class": "".concat(prefixCls, "-dot-item")
      }, null), Vue.createVNode("i", {
        "class": "".concat(prefixCls, "-dot-item")
      }, null), Vue.createVNode("i", {
        "class": "".concat(prefixCls, "-dot-item")
      }, null), Vue.createVNode("i", {
        "class": "".concat(prefixCls, "-dot-item")
      }, null)]);
    }
  },
  render: function render4() {
    var _spinClassName;
    var _a, _b;
    var _this$$props = this.$props, size = _this$$props.size, customizePrefixCls = _this$$props.prefixCls, _this$$props$tip = _this$$props.tip, tip = _this$$props$tip === void 0 ? (_b = (_a = this.$slots).tip) === null || _b === void 0 ? void 0 : _b.call(_a) : _this$$props$tip, wrapperClassName = _this$$props.wrapperClassName;
    var _c = this.$attrs, cls = _c.class, style = _c.style, divProps = __rest$A(_c, ["class", "style"]);
    var _this$configProvider = this.configProvider, getPrefixCls2 = _this$configProvider.getPrefixCls, direction = _this$configProvider.direction;
    var prefixCls = getPrefixCls2("spin", customizePrefixCls);
    var sSpinning = this.sSpinning;
    var spinClassName = (_spinClassName = {}, _defineProperty$T(_spinClassName, prefixCls, true), _defineProperty$T(_spinClassName, "".concat(prefixCls, "-sm"), size === "small"), _defineProperty$T(_spinClassName, "".concat(prefixCls, "-lg"), size === "large"), _defineProperty$T(_spinClassName, "".concat(prefixCls, "-spinning"), sSpinning), _defineProperty$T(_spinClassName, "".concat(prefixCls, "-show-text"), !!tip), _defineProperty$T(_spinClassName, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$T(_spinClassName, cls, !!cls), _spinClassName);
    var spinElement = Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({}, divProps), {}, {
      "style": style,
      "class": spinClassName
    }), [this.renderIndicator(prefixCls), tip ? Vue.createVNode("div", {
      "class": "".concat(prefixCls, "-text")
    }, [tip]) : null]);
    var children = getSlot(this);
    if (children && children.length) {
      var _containerClassName;
      var containerClassName = (_containerClassName = {}, _defineProperty$T(_containerClassName, "".concat(prefixCls, "-container"), true), _defineProperty$T(_containerClassName, "".concat(prefixCls, "-blur"), sSpinning), _containerClassName);
      return Vue.createVNode("div", {
        "class": ["".concat(prefixCls, "-nested-loading"), wrapperClassName]
      }, [sSpinning && Vue.createVNode("div", {
        "key": "loading"
      }, [spinElement]), Vue.createVNode("div", {
        "class": containerClassName,
        "key": "container"
      }, [children])]);
    }
    return spinElement;
  }
});
Spin.setDefaultIndicator = setDefaultIndicator;
Spin.install = function(app) {
  app.component(Spin.name, Spin);
  return app;
};
var index$t = "";
function useRaf(callback) {
  var rafRef = Vue.ref();
  var removedRef = Vue.ref(false);
  function trigger2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (!removedRef.value) {
      wrapperRaf.cancel(rafRef.value);
      rafRef.value = wrapperRaf(function() {
        callback.apply(void 0, args);
      });
    }
  }
  Vue.onBeforeUnmount(function() {
    removedRef.value = true;
    wrapperRaf.cancel(rafRef.value);
  });
  return trigger2;
}
function useRafState(defaultState) {
  var batchRef = Vue.ref([]);
  var state = Vue.ref(typeof defaultState === "function" ? defaultState() : defaultState);
  var flushUpdate = useRaf(function() {
    var value = state.value;
    batchRef.value.forEach(function(callback) {
      value = callback(value);
    });
    batchRef.value = [];
    state.value = value;
  });
  function updater(callback) {
    batchRef.value.push(callback);
    flushUpdate();
  }
  return [state, updater];
}
var TabNode = Vue.defineComponent({
  name: "TabNode",
  props: {
    id: {
      type: String
    },
    prefixCls: {
      type: String
    },
    tab: {
      type: Object
    },
    active: {
      type: Boolean
    },
    closable: {
      type: Boolean
    },
    editable: {
      type: Object
    },
    onClick: {
      type: Function
    },
    onResize: {
      type: Function
    },
    renderWrapper: {
      type: Function
    },
    removeAriaLabel: {
      type: String
    },
    onFocus: {
      type: Function
    }
  },
  emits: ["click", "resize", "remove", "focus"],
  setup: function setup38(props2, _ref) {
    var expose = _ref.expose, attrs = _ref.attrs;
    var domRef = Vue.ref();
    function onInternalClick(e2) {
      var _a;
      if ((_a = props2.tab) === null || _a === void 0 ? void 0 : _a.disabled) {
        return;
      }
      props2.onClick(e2);
    }
    expose({
      domRef
    });
    function onRemoveTab(event) {
      var _a;
      event.preventDefault();
      event.stopPropagation();
      props2.editable.onEdit("remove", {
        key: (_a = props2.tab) === null || _a === void 0 ? void 0 : _a.key,
        event
      });
    }
    var removable = Vue.computed(function() {
      var _a;
      return props2.editable && props2.closable !== false && !((_a = props2.tab) === null || _a === void 0 ? void 0 : _a.disabled);
    });
    return function() {
      var _classNames;
      var _a;
      var prefixCls = props2.prefixCls, id = props2.id, active = props2.active, _props$tab = props2.tab, key2 = _props$tab.key, tab = _props$tab.tab, disabled = _props$tab.disabled, closeIcon = _props$tab.closeIcon, renderWrapper = props2.renderWrapper, removeAriaLabel = props2.removeAriaLabel, editable = props2.editable, onFocus2 = props2.onFocus;
      var tabPrefix = "".concat(prefixCls, "-tab");
      var node = Vue.createVNode("div", {
        "key": key2,
        "ref": domRef,
        "class": classNames(tabPrefix, (_classNames = {}, _defineProperty$T(_classNames, "".concat(tabPrefix, "-with-remove"), removable.value), _defineProperty$T(_classNames, "".concat(tabPrefix, "-active"), active), _defineProperty$T(_classNames, "".concat(tabPrefix, "-disabled"), disabled), _classNames)),
        "style": attrs.style,
        "onClick": onInternalClick
      }, [Vue.createVNode("div", {
        "role": "tab",
        "aria-selected": active,
        "id": id && "".concat(id, "-tab-").concat(key2),
        "class": "".concat(tabPrefix, "-btn"),
        "aria-controls": id && "".concat(id, "-panel-").concat(key2),
        "aria-disabled": disabled,
        "tabindex": disabled ? null : 0,
        "onClick": function onClick2(e2) {
          e2.stopPropagation();
          onInternalClick(e2);
        },
        "onKeydown": function onKeydown(e2) {
          if ([KeyCode$1.SPACE, KeyCode$1.ENTER].includes(e2.which)) {
            e2.preventDefault();
            onInternalClick(e2);
          }
        },
        "onFocus": onFocus2
      }, [typeof tab === "function" ? tab() : tab]), removable.value && Vue.createVNode("button", {
        "type": "button",
        "aria-label": removeAriaLabel || "remove",
        "tabindex": 0,
        "class": "".concat(tabPrefix, "-remove"),
        "onClick": function onClick2(e2) {
          e2.stopPropagation();
          onRemoveTab(e2);
        }
      }, [(closeIcon === null || closeIcon === void 0 ? void 0 : closeIcon()) || ((_a = editable.removeIcon) === null || _a === void 0 ? void 0 : _a.call(editable)) || "\xD7"])]);
      return renderWrapper ? renderWrapper(node) : node;
    };
  }
});
var DEFAULT_SIZE$1 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function useOffsets(tabs, tabSizes) {
  var offsetMap = Vue.ref(/* @__PURE__ */ new Map());
  Vue.watchEffect(function() {
    var _a, _b;
    var map = /* @__PURE__ */ new Map();
    var tabsValue = tabs.value;
    var lastOffset = tabSizes.value.get((_a = tabsValue[0]) === null || _a === void 0 ? void 0 : _a.key) || DEFAULT_SIZE$1;
    var rightOffset = lastOffset.left + lastOffset.width;
    for (var i2 = 0; i2 < tabsValue.length; i2 += 1) {
      var key2 = tabsValue[i2].key;
      var data4 = tabSizes.value.get(key2);
      if (!data4) {
        data4 = tabSizes.value.get((_b = tabsValue[i2 - 1]) === null || _b === void 0 ? void 0 : _b.key) || DEFAULT_SIZE$1;
      }
      var entity = map.get(key2) || _extends({}, data4);
      entity.right = rightOffset - entity.left - entity.width;
      map.set(key2, entity);
    }
    offsetMap.value = new Map(map);
  });
  return offsetMap;
}
function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
  if (ret !== void 0) {
    return !!ret;
  }
  if (objA === objB) {
    return true;
  }
  if (_typeof$1(objA) !== "object" || !objA || _typeof$1(objB) !== "object" || !objB) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var idx = 0; idx < keysA.length; idx++) {
    var key2 = keysA[idx];
    if (!bHasOwnProperty(key2)) {
      return false;
    }
    var valueA = objA[key2];
    var valueB = objB[key2];
    ret = compare ? compare.call(compareContext, valueA, valueB, key2) : void 0;
    if (ret === false || ret === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
}
function shallowequal(value, other, customizer, thisArg) {
  return shallowEqual(Vue.toRaw(value), Vue.toRaw(other), customizer, thisArg);
}
var MenuContextKey = Symbol("menuContextKey");
var useProvideMenu = function useProvideMenu2(props2) {
  Vue.provide(MenuContextKey, props2);
};
var useInjectMenu = function useInjectMenu2() {
  return Vue.inject(MenuContextKey);
};
var ForceRenderKey = Symbol("ForceRenderKey");
var useProvideForceRender = function useProvideForceRender2(forceRender) {
  Vue.provide(ForceRenderKey, forceRender);
};
var useInjectForceRender = function useInjectForceRender2() {
  return Vue.inject(ForceRenderKey, false);
};
var MenuFirstLevelContextKey = Symbol("menuFirstLevelContextKey");
var useProvideFirstLevel = function useProvideFirstLevel2(firstLevel) {
  Vue.provide(MenuFirstLevelContextKey, firstLevel);
};
var useInjectFirstLevel = function useInjectFirstLevel2() {
  return Vue.inject(MenuFirstLevelContextKey, true);
};
var MenuContextProvider = Vue.defineComponent({
  name: "MenuContextProvider",
  inheritAttrs: false,
  props: {
    mode: {
      type: String,
      default: void 0
    },
    overflowDisabled: {
      type: Boolean,
      default: void 0
    },
    isRootMenu: {
      type: Boolean,
      default: void 0
    }
  },
  setup: function setup39(props2, _ref) {
    var slots = _ref.slots;
    var menuContext = useInjectMenu();
    var newContext = _extends({}, menuContext);
    if (props2.mode !== void 0) {
      newContext.mode = Vue.toRef(props2, "mode");
    }
    if (props2.isRootMenu !== void 0) {
      newContext.isRootMenu = Vue.toRef(props2, "isRootMenu");
    }
    if (props2.overflowDisabled !== void 0) {
      newContext.overflowDisabled = Vue.toRef(props2, "overflowDisabled");
    }
    useProvideMenu(newContext);
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
  }
});
var useProvideMenu$1 = useProvideMenu;
function noop$1() {
}
var INFINITY = 1 / 0;
var createSet = !(Set$2 && 1 / setToArray(new Set$2([, -0]))[1] == INFINITY) ? noop$1 : function(values) {
  return new Set$2(values);
};
var createSet$1 = createSet;
var LARGE_ARRAY_SIZE = 200;
function baseUniq(array, iteratee, comparator) {
  var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result = [], seen2 = result;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet$1(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes2 = cacheHas;
    seen2 = new SetCache();
  } else {
    seen2 = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length) {
      var value = array[index2], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen2.length;
        while (seenIndex--) {
          if (seen2[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen2.push(computed);
        }
        result.push(value);
      } else if (!includes2(seen2, computed, comparator)) {
        if (seen2 !== result) {
          seen2.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
function uniq(array) {
  return array && array.length ? baseUniq(array) : [];
}
var ResizeObserver$1 = Vue.defineComponent({
  name: "ResizeObserver",
  props: {
    disabled: Boolean,
    onResize: Function
  },
  emits: ["resize"],
  setup: function setup40(props2, _ref) {
    var slots = _ref.slots;
    var state = Vue.reactive({
      width: 0,
      height: 0,
      offsetHeight: 0,
      offsetWidth: 0
    });
    var currentElement = null;
    var resizeObserver = null;
    var destroyObserver = function destroyObserver2() {
      if (resizeObserver) {
        resizeObserver.disconnect();
        resizeObserver = null;
      }
    };
    var onResize = function onResize2(entries) {
      var onResize3 = props2.onResize;
      var target = entries[0].target;
      var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
      var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
      var fixedWidth = Math.floor(width);
      var fixedHeight = Math.floor(height);
      if (state.width !== fixedWidth || state.height !== fixedHeight || state.offsetWidth !== offsetWidth || state.offsetHeight !== offsetHeight) {
        var size = {
          width: fixedWidth,
          height: fixedHeight,
          offsetWidth,
          offsetHeight
        };
        _extends(state, size);
        if (onResize3) {
          Promise.resolve().then(function() {
            onResize3(_extends(_extends({}, size), {
              offsetWidth,
              offsetHeight
            }), target);
          });
        }
      }
    };
    var instance = Vue.getCurrentInstance();
    var registerObserver = function registerObserver2() {
      var disabled = props2.disabled;
      if (disabled) {
        destroyObserver();
        return;
      }
      var element = findDOMNode(instance);
      var elementChanged = element !== currentElement;
      if (elementChanged) {
        destroyObserver();
        currentElement = element;
      }
      if (!resizeObserver && element) {
        resizeObserver = new index$w(onResize);
        resizeObserver.observe(element);
      }
    };
    Vue.onMounted(function() {
      registerObserver();
    });
    Vue.onUpdated(function() {
      registerObserver();
    });
    Vue.onUnmounted(function() {
      destroyObserver();
    });
    Vue.watch(function() {
      return props2.disabled;
    }, function() {
      registerObserver();
    }, {
      flush: "post"
    });
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)[0];
    };
  }
});
var OverflowContextProviderKey = Symbol("OverflowContextProviderKey");
var OverflowContextProvider = Vue.defineComponent({
  name: "OverflowContextProvider",
  inheritAttrs: false,
  props: {
    value: {
      type: Object
    }
  },
  setup: function setup41(props2, _ref) {
    var slots = _ref.slots;
    Vue.provide(OverflowContextProviderKey, Vue.computed(function() {
      return props2.value;
    }));
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
  }
});
var useInjectOverflowContext = function useInjectOverflowContext2() {
  return Vue.inject(OverflowContextProviderKey, Vue.computed(function() {
    return null;
  }));
};
var __rest$z = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var UNDEFINED = void 0;
var Item$3 = Vue.defineComponent({
  name: "Item",
  props: {
    prefixCls: String,
    item: PropTypes$1.any,
    renderItem: Function,
    responsive: Boolean,
    itemKey: {
      type: [String, Number]
    },
    registerSize: Function,
    display: Boolean,
    order: Number,
    component: PropTypes$1.any,
    invalidate: Boolean
  },
  setup: function setup42(props2, _ref) {
    var slots = _ref.slots, expose = _ref.expose;
    var mergedHidden = Vue.computed(function() {
      return props2.responsive && !props2.display;
    });
    var itemNodeRef = Vue.ref();
    expose({
      itemNodeRef
    });
    function internalRegisterSize(width) {
      props2.registerSize(props2.itemKey, width);
    }
    Vue.onUnmounted(function() {
      internalRegisterSize(null);
    });
    return function() {
      var _a;
      var prefixCls = props2.prefixCls, invalidate = props2.invalidate, item = props2.item, renderItem = props2.renderItem, responsive = props2.responsive;
      props2.registerSize;
      props2.itemKey;
      props2.display;
      var order = props2.order, _props$component = props2.component, Component = _props$component === void 0 ? "div" : _props$component, restProps = __rest$z(props2, ["prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display", "order", "component"]);
      var children = (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
      var childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
      var overflowStyle;
      if (!invalidate) {
        overflowStyle = {
          opacity: mergedHidden.value ? 0 : 1,
          height: mergedHidden.value ? 0 : UNDEFINED,
          overflowY: mergedHidden.value ? "hidden" : UNDEFINED,
          order: responsive ? order : UNDEFINED,
          pointerEvents: mergedHidden.value ? "none" : UNDEFINED,
          position: mergedHidden.value ? "absolute" : UNDEFINED
        };
      }
      var overflowProps3 = {};
      if (mergedHidden.value) {
        overflowProps3["aria-hidden"] = true;
      }
      return Vue.createVNode(ResizeObserver$1, {
        "disabled": !responsive,
        "onResize": function onResize(_ref2) {
          var offsetWidth = _ref2.offsetWidth;
          internalRegisterSize(offsetWidth);
        }
      }, {
        default: function _default5() {
          return Vue.createVNode(Component, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "class": classNames(!invalidate && prefixCls),
            "style": overflowStyle
          }, overflowProps3), restProps), {}, {
            "ref": itemNodeRef
          }), {
            default: function _default6() {
              return [childNode];
            }
          });
        }
      });
    };
  }
});
var __rest$y = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var RawItem = Vue.defineComponent({
  name: "RawItem",
  inheritAttrs: false,
  props: {
    component: PropTypes$1.any,
    title: PropTypes$1.any,
    id: String,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onFocus: {
      type: Function
    }
  },
  setup: function setup43(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var context = useInjectOverflowContext();
    return function() {
      var _a;
      if (!context.value) {
        var _props$component = props2.component, Component = _props$component === void 0 ? "div" : _props$component, _restProps = __rest$y(props2, ["component"]);
        return Vue.createVNode(Component, _objectSpread2$1(_objectSpread2$1({}, _restProps), attrs), {
          default: function _default5() {
            return [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)];
          }
        });
      }
      var _b = context.value, contextClassName = _b.className, restContext = __rest$y(_b, ["className"]);
      var className = attrs.class, restProps = __rest$y(attrs, ["class"]);
      return Vue.createVNode(OverflowContextProvider, {
        "value": null
      }, {
        default: function _default5() {
          return [Vue.createVNode(Item$3, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "class": classNames(contextClassName, className)
          }, restContext), restProps), props2), slots)];
        }
      });
    };
  }
});
var __rest$x = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
var overflowProps = function overflowProps2() {
  return {
    id: String,
    prefixCls: String,
    data: Array,
    itemKey: [String, Number, Function],
    itemWidth: {
      type: Number,
      default: 10
    },
    renderItem: Function,
    renderRawItem: Function,
    maxCount: [Number, String],
    renderRest: Function,
    renderRawRest: Function,
    suffix: PropTypes$1.any,
    component: String,
    itemComponent: PropTypes$1.any,
    onVisibleChange: Function,
    ssr: String,
    onMousedown: Function
  };
};
var Overflow = Vue.defineComponent({
  name: "Overflow",
  inheritAttrs: false,
  props: overflowProps(),
  emits: ["visibleChange"],
  setup: function setup44(props2, _ref) {
    var attrs = _ref.attrs, emit = _ref.emit;
    var fullySSR = Vue.computed(function() {
      return props2.ssr === "full";
    });
    var containerWidth = Vue.ref(null);
    var mergedContainerWidth = Vue.computed(function() {
      return containerWidth.value || 0;
    });
    var itemWidths = Vue.ref(/* @__PURE__ */ new Map());
    var prevRestWidth = Vue.ref(0);
    var restWidth = Vue.ref(0);
    var suffixWidth = Vue.ref(0);
    var suffixFixedStart = Vue.ref(null);
    var displayCount = Vue.ref(null);
    var mergedDisplayCount = Vue.computed(function() {
      if (displayCount.value === null && fullySSR.value) {
        return Number.MAX_SAFE_INTEGER;
      }
      return displayCount.value || 0;
    });
    var restReady = Vue.ref(false);
    var itemPrefixCls = Vue.computed(function() {
      return "".concat(props2.prefixCls, "-item");
    });
    var mergedRestWidth = Vue.computed(function() {
      return Math.max(prevRestWidth.value, restWidth.value);
    });
    var isResponsive = Vue.computed(function() {
      return !!(props2.data.length && props2.maxCount === RESPONSIVE);
    });
    var invalidate = Vue.computed(function() {
      return props2.maxCount === INVALIDATE;
    });
    var showRest = Vue.computed(function() {
      return isResponsive.value || typeof props2.maxCount === "number" && props2.data.length > props2.maxCount;
    });
    var mergedData = Vue.computed(function() {
      var items = props2.data;
      if (isResponsive.value) {
        if (containerWidth.value === null && fullySSR.value) {
          items = props2.data;
        } else {
          items = props2.data.slice(0, Math.min(props2.data.length, mergedContainerWidth.value / props2.itemWidth));
        }
      } else if (typeof props2.maxCount === "number") {
        items = props2.data.slice(0, props2.maxCount);
      }
      return items;
    });
    var omittedItems = Vue.computed(function() {
      if (isResponsive.value) {
        return props2.data.slice(mergedDisplayCount.value + 1);
      }
      return props2.data.slice(mergedData.value.length);
    });
    var getKey2 = function getKey3(item, index2) {
      var _a, _b;
      if (typeof props2.itemKey === "function") {
        return props2.itemKey(item);
      }
      return (_b = props2.itemKey && ((_a = item) === null || _a === void 0 ? void 0 : _a[props2.itemKey])) !== null && _b !== void 0 ? _b : index2;
    };
    var mergedRenderItem = Vue.computed(function() {
      return props2.renderItem || function(item) {
        return item;
      };
    });
    var updateDisplayCount = function updateDisplayCount2(count, notReady) {
      displayCount.value = count;
      if (!notReady) {
        restReady.value = count < props2.data.length - 1;
        emit("visibleChange", count);
      }
    };
    var onOverflowResize = function onOverflowResize2(_2, element) {
      containerWidth.value = element.clientWidth;
    };
    var registerSize = function registerSize2(key2, width) {
      var clone2 = new Map(itemWidths.value);
      if (width === null) {
        clone2.delete(key2);
      } else {
        clone2.set(key2, width);
      }
      itemWidths.value = clone2;
    };
    var registerOverflowSize = function registerOverflowSize2(_2, width) {
      prevRestWidth.value = restWidth.value;
      restWidth.value = width;
    };
    var registerSuffixSize = function registerSuffixSize2(_2, width) {
      suffixWidth.value = width;
    };
    var getItemWidth = function getItemWidth2(index2) {
      return itemWidths.value.get(getKey2(mergedData.value[index2], index2));
    };
    Vue.watch([mergedContainerWidth, itemWidths, restWidth, suffixWidth, function() {
      return props2.itemKey;
    }, mergedData], function() {
      if (mergedContainerWidth.value && mergedRestWidth.value && mergedData.value) {
        var totalWidth = suffixWidth.value;
        var len = mergedData.value.length;
        var lastIndex = len - 1;
        if (!len) {
          updateDisplayCount(0);
          suffixFixedStart.value = null;
          return;
        }
        for (var i2 = 0; i2 < len; i2 += 1) {
          var currentItemWidth = getItemWidth(i2);
          if (currentItemWidth === void 0) {
            updateDisplayCount(i2 - 1, true);
            break;
          }
          totalWidth += currentItemWidth;
          if (lastIndex === 0 && totalWidth <= mergedContainerWidth.value || i2 === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth.value) {
            updateDisplayCount(lastIndex);
            suffixFixedStart.value = null;
            break;
          } else if (totalWidth + mergedRestWidth.value > mergedContainerWidth.value) {
            updateDisplayCount(i2 - 1);
            suffixFixedStart.value = totalWidth - currentItemWidth - suffixWidth.value + restWidth.value;
            break;
          }
        }
        if (props2.suffix && getItemWidth(0) + suffixWidth.value > mergedContainerWidth.value) {
          suffixFixedStart.value = null;
        }
      }
    });
    return function() {
      var displayRest = restReady.value && !!omittedItems.value.length;
      var itemComponent = props2.itemComponent, renderRawItem = props2.renderRawItem, renderRawRest = props2.renderRawRest, renderRest = props2.renderRest, _props$prefixCls = props2.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, suffix = props2.suffix, _props$component = props2.component, Component = _props$component === void 0 ? "div" : _props$component, id = props2.id, onMousedown2 = props2.onMousedown;
      var className = attrs.class, style = attrs.style, restAttrs = __rest$x(attrs, ["class", "style"]);
      var suffixStyle = {};
      if (suffixFixedStart.value !== null && isResponsive.value) {
        suffixStyle = {
          position: "absolute",
          left: "".concat(suffixFixedStart.value, "px"),
          top: 0
        };
      }
      var itemSharedProps = {
        prefixCls: itemPrefixCls.value,
        responsive: isResponsive.value,
        component: itemComponent,
        invalidate: invalidate.value
      };
      var internalRenderItemNode = renderRawItem ? function(item, index2) {
        var key2 = getKey2(item, index2);
        return Vue.createVNode(OverflowContextProvider, {
          "key": key2,
          "value": _extends(_extends({}, itemSharedProps), {
            order: index2,
            item,
            itemKey: key2,
            registerSize,
            display: index2 <= mergedDisplayCount.value
          })
        }, {
          default: function _default5() {
            return [renderRawItem(item, index2)];
          }
        });
      } : function(item, index2) {
        var key2 = getKey2(item, index2);
        return Vue.createVNode(Item$3, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
          "order": index2,
          "key": key2,
          "item": item,
          "renderItem": mergedRenderItem.value,
          "itemKey": key2,
          "registerSize": registerSize,
          "display": index2 <= mergedDisplayCount.value
        }), null);
      };
      var restNode = function restNode2() {
        return null;
      };
      var restContextProps = {
        order: displayRest ? mergedDisplayCount.value : Number.MAX_SAFE_INTEGER,
        className: "".concat(itemPrefixCls.value, " ").concat(itemPrefixCls.value, "-rest"),
        registerSize: registerOverflowSize,
        display: displayRest
      };
      if (!renderRawRest) {
        var mergedRenderRest = renderRest || defaultRenderRest;
        restNode = function restNode2() {
          return Vue.createVNode(Item$3, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), restContextProps), {
            default: function _default5() {
              return typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems.value) : mergedRenderRest;
            }
          });
        };
      } else if (renderRawRest) {
        restNode = function restNode2() {
          return Vue.createVNode(OverflowContextProvider, {
            "value": _extends(_extends({}, itemSharedProps), restContextProps)
          }, {
            default: function _default5() {
              return [renderRawRest(omittedItems.value)];
            }
          });
        };
      }
      var overflowNode = function overflowNode2() {
        return Vue.createVNode(Component, _objectSpread2$1({
          "id": id,
          "class": classNames(!invalidate.value && prefixCls, className),
          "style": style,
          "onMousedown": onMousedown2
        }, restAttrs), {
          default: function _default5() {
            return [mergedData.value.map(internalRenderItemNode), showRest.value ? restNode() : null, suffix && Vue.createVNode(Item$3, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
              "order": mergedDisplayCount.value,
              "class": "".concat(itemPrefixCls.value, "-suffix"),
              "registerSize": registerSuffixSize,
              "display": true,
              "style": suffixStyle
            }), {
              default: function _default6() {
                return suffix;
              }
            })];
          }
        });
      };
      return Vue.createVNode(ResizeObserver$1, {
        "disabled": !isResponsive.value,
        "onResize": onOverflowResize
      }, {
        default: overflowNode
      });
    };
  }
});
Overflow.Item = RawItem;
Overflow.RESPONSIVE = RESPONSIVE;
Overflow.INVALIDATE = INVALIDATE;
var Overflow$1 = Overflow;
var OVERFLOW_KEY = "$$__vc-menu-more__key";
var KeyPathContext = Symbol("KeyPathContext");
var useInjectKeyPath = function useInjectKeyPath2() {
  return Vue.inject(KeyPathContext, {
    parentEventKeys: Vue.computed(function() {
      return [];
    }),
    parentKeys: Vue.computed(function() {
      return [];
    }),
    parentInfo: {}
  });
};
var useProvideKeyPath = function useProvideKeyPath2(eventKey, key2, menuInfo) {
  var _useInjectKeyPath = useInjectKeyPath(), parentEventKeys = _useInjectKeyPath.parentEventKeys, parentKeys = _useInjectKeyPath.parentKeys;
  var eventKeys = Vue.computed(function() {
    return [].concat(_toConsumableArray(parentEventKeys.value), [eventKey]);
  });
  var keys2 = Vue.computed(function() {
    return [].concat(_toConsumableArray(parentKeys.value), [key2]);
  });
  Vue.provide(KeyPathContext, {
    parentEventKeys: eventKeys,
    parentKeys: keys2,
    parentInfo: menuInfo
  });
  return keys2;
};
var measure = Symbol("measure");
var PathContext = Vue.defineComponent({
  setup: function setup45(_props, _ref) {
    var slots = _ref.slots;
    Vue.provide(measure, true);
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
  }
});
var useMeasure = function useMeasure2() {
  return Vue.inject(measure, false);
};
var useProvideKeyPath$1 = useProvideKeyPath;
function useDirectionStyle(level) {
  var _useInjectMenu = useInjectMenu(), mode = _useInjectMenu.mode, rtl2 = _useInjectMenu.rtl, inlineIndent = _useInjectMenu.inlineIndent;
  return Vue.computed(function() {
    return mode.value !== "inline" ? null : rtl2.value ? {
      paddingRight: "".concat(level.value * inlineIndent.value, "px")
    } : {
      paddingLeft: "".concat(level.value * inlineIndent.value, "px")
    };
  });
}
var indexGuid$2 = 0;
var menuItemProps = function menuItemProps2() {
  return {
    id: String,
    role: String,
    disabled: Boolean,
    danger: Boolean,
    title: {
      type: [String, Boolean],
      default: void 0
    },
    icon: PropTypes$1.any,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function,
    onKeydown: Function,
    onFocus: Function
  };
};
var MenuItem$1 = Vue.defineComponent({
  name: "AMenuItem",
  inheritAttrs: false,
  props: menuItemProps(),
  slots: ["icon", "title"],
  setup: function setup46(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs;
    var instance = Vue.getCurrentInstance();
    var isMeasure = useMeasure();
    var key2 = _typeof$1(instance.vnode.key) === "symbol" ? String(instance.vnode.key) : instance.vnode.key;
    devWarning(_typeof$1(instance.vnode.key) !== "symbol", "MenuItem", 'MenuItem `:key="'.concat(String(key2), '"` not support Symbol type'));
    var eventKey = "menu_item_".concat(++indexGuid$2, "_$$_").concat(key2);
    var _useInjectKeyPath = useInjectKeyPath(), parentEventKeys = _useInjectKeyPath.parentEventKeys, parentKeys = _useInjectKeyPath.parentKeys;
    var _useInjectMenu = useInjectMenu(), prefixCls = _useInjectMenu.prefixCls, activeKeys = _useInjectMenu.activeKeys, disabled = _useInjectMenu.disabled, changeActiveKeys = _useInjectMenu.changeActiveKeys, rtl2 = _useInjectMenu.rtl, inlineCollapsed = _useInjectMenu.inlineCollapsed, siderCollapsed = _useInjectMenu.siderCollapsed, onItemClick = _useInjectMenu.onItemClick, selectedKeys = _useInjectMenu.selectedKeys, registerMenuInfo = _useInjectMenu.registerMenuInfo, unRegisterMenuInfo = _useInjectMenu.unRegisterMenuInfo;
    var firstLevel = useInjectFirstLevel();
    var isActive = Vue.ref(false);
    var keysPath = Vue.computed(function() {
      return [].concat(_toConsumableArray(parentKeys.value), [key2]);
    });
    var menuInfo = {
      eventKey,
      key: key2,
      parentEventKeys,
      parentKeys,
      isLeaf: true
    };
    registerMenuInfo(eventKey, menuInfo);
    Vue.onBeforeUnmount(function() {
      unRegisterMenuInfo(eventKey);
    });
    Vue.watch(activeKeys, function() {
      isActive.value = !!activeKeys.value.find(function(val) {
        return val === key2;
      });
    }, {
      immediate: true
    });
    var mergedDisabled = Vue.computed(function() {
      return disabled.value || props2.disabled;
    });
    var selected = Vue.computed(function() {
      return selectedKeys.value.includes(key2);
    });
    var classNames2 = Vue.computed(function() {
      var _ref2;
      var itemCls = "".concat(prefixCls.value, "-item");
      return _ref2 = {}, _defineProperty$T(_ref2, "".concat(itemCls), true), _defineProperty$T(_ref2, "".concat(itemCls, "-danger"), props2.danger), _defineProperty$T(_ref2, "".concat(itemCls, "-active"), isActive.value), _defineProperty$T(_ref2, "".concat(itemCls, "-selected"), selected.value), _defineProperty$T(_ref2, "".concat(itemCls, "-disabled"), mergedDisabled.value), _ref2;
    });
    var getEventInfo = function getEventInfo2(e2) {
      return {
        key: key2,
        eventKey,
        keyPath: keysPath.value,
        eventKeyPath: [].concat(_toConsumableArray(parentEventKeys.value), [eventKey]),
        domEvent: e2,
        item: _extends(_extends({}, props2), attrs)
      };
    };
    var onInternalClick = function onInternalClick2(e2) {
      if (mergedDisabled.value) {
        return;
      }
      var info = getEventInfo(e2);
      emit("click", e2);
      onItemClick(info);
    };
    var onMouseEnter = function onMouseEnter2(event) {
      if (!mergedDisabled.value) {
        changeActiveKeys(keysPath.value);
        emit("mouseenter", event);
      }
    };
    var onMouseLeave = function onMouseLeave2(event) {
      if (!mergedDisabled.value) {
        changeActiveKeys([]);
        emit("mouseleave", event);
      }
    };
    var onInternalKeyDown = function onInternalKeyDown2(e2) {
      emit("keydown", e2);
      if (e2.which === KeyCode$1.ENTER) {
        var info = getEventInfo(e2);
        emit("click", e2);
        onItemClick(info);
      }
    };
    var onInternalFocus = function onInternalFocus2(e2) {
      changeActiveKeys(keysPath.value);
      emit("focus", e2);
    };
    var renderItemChildren = function renderItemChildren2(icon, children) {
      var wrapNode = Vue.createVNode("span", {
        "class": "".concat(prefixCls.value, "-title-content")
      }, [children]);
      if (!icon || isValidElement(children) && children.type === "span") {
        if (children && inlineCollapsed.value && firstLevel && typeof children === "string") {
          return Vue.createVNode("div", {
            "class": "".concat(prefixCls.value, "-inline-collapsed-noicon")
          }, [children.charAt(0)]);
        }
      }
      return wrapNode;
    };
    var directionStyle = useDirectionStyle(Vue.computed(function() {
      return keysPath.value.length;
    }));
    return function() {
      var _ref3;
      var _a, _b, _c;
      if (isMeasure)
        return null;
      var title = (_a = props2.title) !== null && _a !== void 0 ? _a : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      var children = flattenChildren((_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots));
      var childrenLength = children.length;
      var tooltipTitle = title;
      if (typeof title === "undefined") {
        tooltipTitle = firstLevel && childrenLength ? children : "";
      } else if (title === false) {
        tooltipTitle = "";
      }
      var tooltipProps3 = {
        title: tooltipTitle
      };
      if (!siderCollapsed.value && !inlineCollapsed.value) {
        tooltipProps3.title = null;
        tooltipProps3.visible = false;
      }
      var optionRoleProps = {};
      if (props2.role === "option") {
        optionRoleProps["aria-selected"] = selected.value;
      }
      var icon = getPropsSlot(slots, props2, "icon");
      return Vue.createVNode(_Tooltip, _objectSpread2$1(_objectSpread2$1({}, tooltipProps3), {}, {
        "placement": rtl2.value ? "left" : "right",
        "overlayClassName": "".concat(prefixCls.value, "-inline-collapsed-tooltip")
      }), {
        default: function _default5() {
          return [Vue.createVNode(Overflow$1.Item, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "component": "li"
          }, attrs), {}, {
            "id": props2.id,
            "style": _extends(_extends({}, attrs.style || {}), directionStyle.value),
            "class": [classNames2.value, (_ref3 = {}, _defineProperty$T(_ref3, "".concat(attrs.class), !!attrs.class), _defineProperty$T(_ref3, "".concat(prefixCls.value, "-item-only-child"), (icon ? childrenLength + 1 : childrenLength) === 1), _ref3)],
            "role": props2.role || "menuitem",
            "tabindex": props2.disabled ? null : -1,
            "data-menu-id": key2,
            "aria-disabled": props2.disabled
          }, optionRoleProps), {}, {
            "onMouseenter": onMouseEnter,
            "onMouseleave": onMouseLeave,
            "onClick": onInternalClick,
            "onKeydown": onInternalKeyDown,
            "onFocus": onInternalFocus,
            "title": typeof title === "string" ? title : void 0
          }), {
            default: function _default6() {
              return [cloneElement(icon, {
                class: "".concat(prefixCls.value, "-item-icon")
              }, false), renderItemChildren(icon, children)];
            }
          })];
        }
      });
    };
  }
});
var autoAdjustOverflow$1 = {
  adjustX: 1,
  adjustY: 1
};
var placements$2 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};
var placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};
var popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
var PopupTrigger = Vue.defineComponent({
  name: "PopupTrigger",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    mode: String,
    visible: Boolean,
    popupClassName: String,
    popupOffset: Array,
    disabled: Boolean,
    onVisibleChange: Function
  },
  slots: ["popup"],
  emits: ["visibleChange"],
  setup: function setup47(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit;
    var innerVisible = Vue.ref(false);
    var _useInjectMenu = useInjectMenu(), getPopupContainer = _useInjectMenu.getPopupContainer, rtl2 = _useInjectMenu.rtl, subMenuOpenDelay = _useInjectMenu.subMenuOpenDelay, subMenuCloseDelay = _useInjectMenu.subMenuCloseDelay, builtinPlacements = _useInjectMenu.builtinPlacements, triggerSubMenuAction = _useInjectMenu.triggerSubMenuAction, isRootMenu = _useInjectMenu.isRootMenu, forceSubMenuRender = _useInjectMenu.forceSubMenuRender, motion = _useInjectMenu.motion, defaultMotions = _useInjectMenu.defaultMotions;
    var forceRender = useInjectForceRender();
    var placement = Vue.computed(function() {
      return rtl2.value ? _extends(_extends({}, placementsRtl), builtinPlacements.value) : _extends(_extends({}, placements$2), builtinPlacements.value);
    });
    var popupPlacement = Vue.computed(function() {
      return popupPlacementMap[props2.mode];
    });
    var visibleRef = Vue.ref();
    Vue.watch(function() {
      return props2.visible;
    }, function(visible) {
      wrapperRaf.cancel(visibleRef.value);
      visibleRef.value = wrapperRaf(function() {
        innerVisible.value = visible;
      });
    }, {
      immediate: true
    });
    Vue.onBeforeUnmount(function() {
      wrapperRaf.cancel(visibleRef.value);
    });
    var onVisibleChange = function onVisibleChange2(visible) {
      emit("visibleChange", visible);
    };
    var mergedMotion = Vue.computed(function() {
      var _a, _b;
      var m2 = motion.value || ((_a = defaultMotions.value) === null || _a === void 0 ? void 0 : _a[props2.mode]) || ((_b = defaultMotions.value) === null || _b === void 0 ? void 0 : _b.other);
      var res = typeof m2 === "function" ? m2() : m2;
      return res ? getTransitionProps(res.name, {
        css: true
      }) : void 0;
    });
    return function() {
      var prefixCls = props2.prefixCls, popupClassName = props2.popupClassName, mode = props2.mode, popupOffset = props2.popupOffset, disabled = props2.disabled;
      return Vue.createVNode(Trigger, {
        "prefixCls": prefixCls,
        "popupClassName": classNames("".concat(prefixCls, "-popup"), _defineProperty$T({}, "".concat(prefixCls, "-rtl"), rtl2.value), popupClassName),
        "stretch": mode === "horizontal" ? "minWidth" : null,
        "getPopupContainer": isRootMenu.value ? getPopupContainer.value : function(triggerNode) {
          return triggerNode.parentNode;
        },
        "builtinPlacements": placement.value,
        "popupPlacement": popupPlacement.value,
        "popupVisible": innerVisible.value,
        "popupAlign": popupOffset && {
          offset: popupOffset
        },
        "action": disabled ? [] : [triggerSubMenuAction.value],
        "mouseEnterDelay": subMenuOpenDelay.value,
        "mouseLeaveDelay": subMenuCloseDelay.value,
        "onPopupVisibleChange": onVisibleChange,
        "forceRender": forceRender || forceSubMenuRender.value,
        "popupAnimation": mergedMotion.value
      }, {
        popup: slots.popup,
        default: slots.default
      });
    };
  }
});
var InternalSubMenuList = function InternalSubMenuList2(_props, _ref) {
  var slots = _ref.slots, attrs = _ref.attrs;
  var _a;
  var _useInjectMenu = useInjectMenu(), prefixCls = _useInjectMenu.prefixCls, mode = _useInjectMenu.mode;
  return Vue.createVNode("ul", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
    "class": classNames(prefixCls.value, "".concat(prefixCls.value, "-sub"), "".concat(prefixCls.value, "-").concat(mode.value === "inline" ? "inline" : "vertical")),
    "data-menu-list": true
  }), [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
};
InternalSubMenuList.displayName = "SubMenuList";
var SubMenuList = InternalSubMenuList;
var InlineSubMenuList = Vue.defineComponent({
  name: "InlineSubMenuList",
  inheritAttrs: false,
  props: {
    id: String,
    open: Boolean,
    keyPath: Array
  },
  setup: function setup48(props2, _ref) {
    var slots = _ref.slots;
    var fixedMode = Vue.computed(function() {
      return "inline";
    });
    var _useInjectMenu = useInjectMenu(), motion = _useInjectMenu.motion, mode = _useInjectMenu.mode, defaultMotions = _useInjectMenu.defaultMotions;
    var sameModeRef = Vue.computed(function() {
      return mode.value === fixedMode.value;
    });
    var destroy3 = Vue.ref(!sameModeRef.value);
    var mergedOpen = Vue.computed(function() {
      return sameModeRef.value ? props2.open : false;
    });
    Vue.watch(mode, function() {
      if (sameModeRef.value) {
        destroy3.value = false;
      }
    }, {
      flush: "post"
    });
    var mergedMotion = Vue.computed(function() {
      var _a, _b;
      var m2 = motion.value || ((_a = defaultMotions.value) === null || _a === void 0 ? void 0 : _a[fixedMode.value]) || ((_b = defaultMotions.value) === null || _b === void 0 ? void 0 : _b.other);
      var res = typeof m2 === "function" ? m2() : m2;
      return _extends(_extends({}, res), {
        appear: props2.keyPath.length <= 1
      });
    });
    return function() {
      var _a;
      if (destroy3.value) {
        return null;
      }
      return Vue.createVNode(MenuContextProvider, {
        "mode": fixedMode.value
      }, {
        default: function _default5() {
          return [Vue.createVNode(Transition$1, mergedMotion.value, {
            default: function _default6() {
              return [Vue.withDirectives(Vue.createVNode(SubMenuList, {
                "id": props2.id
              }, {
                default: function _default7() {
                  return [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)];
                }
              }), [[Vue.vShow, mergedOpen.value]])];
            }
          })];
        }
      });
    };
  }
});
var indexGuid$1 = 0;
var subMenuProps = function subMenuProps2() {
  return {
    icon: PropTypes$1.any,
    title: PropTypes$1.any,
    disabled: Boolean,
    level: Number,
    popupClassName: String,
    popupOffset: Array,
    internalPopupClose: Boolean,
    eventKey: String,
    expandIcon: Function,
    onMouseenter: Function,
    onMouseleave: Function,
    onTitleClick: Function
  };
};
var SubMenu$1 = Vue.defineComponent({
  name: "ASubMenu",
  inheritAttrs: false,
  props: subMenuProps(),
  slots: ["icon", "title", "expandIcon"],
  setup: function setup49(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
    var _a, _b;
    useProvideFirstLevel(false);
    var isMeasure = useMeasure();
    var instance = Vue.getCurrentInstance();
    var vnodeKey = _typeof$1(instance.vnode.key) === "symbol" ? String(instance.vnode.key) : instance.vnode.key;
    devWarning(_typeof$1(instance.vnode.key) !== "symbol", "SubMenu", 'SubMenu `:key="'.concat(String(vnodeKey), '"` not support Symbol type'));
    var key2 = isValid$2(vnodeKey) ? vnodeKey : "sub_menu_".concat(++indexGuid$1, "_$$_not_set_key");
    var eventKey = (_a = props2.eventKey) !== null && _a !== void 0 ? _a : isValid$2(vnodeKey) ? "sub_menu_".concat(++indexGuid$1, "_$$_").concat(vnodeKey) : key2;
    var _useInjectKeyPath = useInjectKeyPath(), parentEventKeys = _useInjectKeyPath.parentEventKeys, parentInfo = _useInjectKeyPath.parentInfo, parentKeys = _useInjectKeyPath.parentKeys;
    var keysPath = Vue.computed(function() {
      return [].concat(_toConsumableArray(parentKeys.value), [key2]);
    });
    var childrenEventKeys = Vue.ref([]);
    var menuInfo = {
      eventKey,
      key: key2,
      parentEventKeys,
      childrenEventKeys,
      parentKeys
    };
    (_b = parentInfo.childrenEventKeys) === null || _b === void 0 ? void 0 : _b.value.push(eventKey);
    Vue.onBeforeUnmount(function() {
      var _a2;
      if (parentInfo.childrenEventKeys) {
        parentInfo.childrenEventKeys.value = (_a2 = parentInfo.childrenEventKeys) === null || _a2 === void 0 ? void 0 : _a2.value.filter(function(k2) {
          return k2 != eventKey;
        });
      }
    });
    useProvideKeyPath$1(eventKey, key2, menuInfo);
    var _useInjectMenu = useInjectMenu(), prefixCls = _useInjectMenu.prefixCls, activeKeys = _useInjectMenu.activeKeys, contextDisabled = _useInjectMenu.disabled, changeActiveKeys = _useInjectMenu.changeActiveKeys, mode = _useInjectMenu.mode, inlineCollapsed = _useInjectMenu.inlineCollapsed, antdMenuTheme = _useInjectMenu.antdMenuTheme, openKeys = _useInjectMenu.openKeys, overflowDisabled = _useInjectMenu.overflowDisabled, onOpenChange = _useInjectMenu.onOpenChange, registerMenuInfo = _useInjectMenu.registerMenuInfo, unRegisterMenuInfo = _useInjectMenu.unRegisterMenuInfo, selectedSubMenuKeys = _useInjectMenu.selectedSubMenuKeys, menuExpandIcon = _useInjectMenu.expandIcon;
    var hasKey = vnodeKey !== void 0 && vnodeKey !== null;
    var forceRender = !isMeasure && (useInjectForceRender() || !hasKey);
    useProvideForceRender(forceRender);
    if (isMeasure && hasKey || !isMeasure && !hasKey || forceRender) {
      registerMenuInfo(eventKey, menuInfo);
      Vue.onBeforeUnmount(function() {
        unRegisterMenuInfo(eventKey);
      });
    }
    var subMenuPrefixCls = Vue.computed(function() {
      return "".concat(prefixCls.value, "-submenu");
    });
    var mergedDisabled = Vue.computed(function() {
      return contextDisabled.value || props2.disabled;
    });
    var elementRef = Vue.ref();
    var popupRef = Vue.ref();
    var originOpen = Vue.computed(function() {
      return openKeys.value.includes(key2);
    });
    var open2 = Vue.computed(function() {
      return !overflowDisabled.value && originOpen.value;
    });
    var childrenSelected = Vue.computed(function() {
      return selectedSubMenuKeys.value.includes(key2);
    });
    var isActive = Vue.ref(false);
    Vue.watch(activeKeys, function() {
      isActive.value = !!activeKeys.value.find(function(val) {
        return val === key2;
      });
    }, {
      immediate: true
    });
    var onInternalTitleClick = function onInternalTitleClick2(e2) {
      if (mergedDisabled.value) {
        return;
      }
      emit("titleClick", e2, key2);
      if (mode.value === "inline") {
        onOpenChange(key2, !originOpen.value);
      }
    };
    var onMouseEnter = function onMouseEnter2(event) {
      if (!mergedDisabled.value) {
        changeActiveKeys(keysPath.value);
        emit("mouseenter", event);
      }
    };
    var onMouseLeave = function onMouseLeave2(event) {
      if (!mergedDisabled.value) {
        changeActiveKeys([]);
        emit("mouseleave", event);
      }
    };
    var directionStyle = useDirectionStyle(Vue.computed(function() {
      return keysPath.value.length;
    }));
    var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
      if (mode.value !== "inline") {
        onOpenChange(key2, newVisible);
      }
    };
    var onInternalFocus = function onInternalFocus2() {
      changeActiveKeys(keysPath.value);
    };
    var popupId = eventKey && "".concat(eventKey, "-popup");
    var popupClassName = Vue.computed(function() {
      return classNames(prefixCls.value, "".concat(prefixCls.value, "-").concat(antdMenuTheme.value), props2.popupClassName);
    });
    var renderTitle = function renderTitle2(title, icon) {
      if (!icon) {
        return inlineCollapsed.value && !parentKeys.value.length && title && typeof title === "string" ? Vue.createVNode("div", {
          "class": "".concat(prefixCls.value, "-inline-collapsed-noicon")
        }, [title.charAt(0)]) : Vue.createVNode("span", {
          "class": "".concat(prefixCls.value, "-title-content")
        }, [title]);
      }
      var titleIsSpan = isValidElement(title) && title.type === "span";
      return Vue.createVNode(Vue.Fragment, null, [cloneElement(icon, {
        class: "".concat(prefixCls.value, "-item-icon")
      }, false), titleIsSpan ? title : Vue.createVNode("span", {
        "class": "".concat(prefixCls.value, "-title-content")
      }, [title])]);
    };
    var triggerModeRef = Vue.computed(function() {
      return mode.value !== "inline" && keysPath.value.length > 1 ? "vertical" : mode.value;
    });
    var renderMode = Vue.computed(function() {
      return mode.value === "horizontal" ? "vertical" : mode.value;
    });
    var subMenuTriggerModeRef = Vue.computed(function() {
      return triggerModeRef.value === "horizontal" ? "vertical" : triggerModeRef.value;
    });
    var baseTitleNode = function baseTitleNode2() {
      var subMenuPrefixClsValue = subMenuPrefixCls.value;
      var icon = getPropsSlot(slots, props2, "icon");
      var expandIcon = props2.expandIcon || slots.expandIcon || menuExpandIcon.value;
      var title = renderTitle(getPropsSlot(slots, props2, "title"), icon);
      return Vue.createVNode("div", {
        "style": directionStyle.value,
        "class": "".concat(subMenuPrefixClsValue, "-title"),
        "tabindex": mergedDisabled.value ? null : -1,
        "ref": elementRef,
        "title": typeof title === "string" ? title : null,
        "data-menu-id": key2,
        "aria-expanded": open2.value,
        "aria-haspopup": true,
        "aria-controls": popupId,
        "aria-disabled": mergedDisabled.value,
        "onClick": onInternalTitleClick,
        "onFocus": onInternalFocus
      }, [title, mode.value !== "horizontal" && expandIcon ? expandIcon(_extends(_extends({}, props2), {
        isOpen: open2.value
      })) : Vue.createVNode("i", {
        "class": "".concat(subMenuPrefixClsValue, "-arrow")
      }, null)]);
    };
    return function() {
      var _classNames;
      var _a2;
      if (isMeasure) {
        if (!hasKey) {
          return null;
        }
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      }
      var subMenuPrefixClsValue = subMenuPrefixCls.value;
      var titleNode = function titleNode2() {
        return null;
      };
      if (!overflowDisabled.value && mode.value !== "inline") {
        titleNode = function titleNode2() {
          return Vue.createVNode(PopupTrigger, {
            "mode": triggerModeRef.value,
            "prefixCls": subMenuPrefixClsValue,
            "visible": !props2.internalPopupClose && open2.value,
            "popupClassName": popupClassName.value,
            "popupOffset": props2.popupOffset,
            "disabled": mergedDisabled.value,
            "onVisibleChange": onPopupVisibleChange
          }, {
            default: function _default5() {
              return [baseTitleNode()];
            },
            popup: function popup() {
              return Vue.createVNode(MenuContextProvider, {
                "mode": subMenuTriggerModeRef.value,
                "isRootMenu": false
              }, {
                default: function _default5() {
                  return [Vue.createVNode(SubMenuList, {
                    "id": popupId,
                    "ref": popupRef
                  }, {
                    default: slots.default
                  })];
                }
              });
            }
          });
        };
      } else {
        titleNode = function titleNode2() {
          return Vue.createVNode(PopupTrigger, null, {
            default: baseTitleNode
          });
        };
      }
      return Vue.createVNode(MenuContextProvider, {
        "mode": renderMode.value
      }, {
        default: function _default5() {
          return [Vue.createVNode(Overflow$1.Item, _objectSpread2$1(_objectSpread2$1({
            "component": "li"
          }, attrs), {}, {
            "role": "none",
            "class": classNames(subMenuPrefixClsValue, "".concat(subMenuPrefixClsValue, "-").concat(mode.value), attrs.class, (_classNames = {}, _defineProperty$T(_classNames, "".concat(subMenuPrefixClsValue, "-open"), open2.value), _defineProperty$T(_classNames, "".concat(subMenuPrefixClsValue, "-active"), isActive.value), _defineProperty$T(_classNames, "".concat(subMenuPrefixClsValue, "-selected"), childrenSelected.value), _defineProperty$T(_classNames, "".concat(subMenuPrefixClsValue, "-disabled"), mergedDisabled.value), _classNames)),
            "onMouseenter": onMouseEnter,
            "onMouseleave": onMouseLeave,
            "data-submenu-id": key2
          }), {
            default: function _default6() {
              return Vue.createVNode(Vue.Fragment, null, [titleNode(), !overflowDisabled.value && Vue.createVNode(InlineSubMenuList, {
                "id": popupId,
                "open": open2.value,
                "keyPath": keysPath.value
              }, {
                default: slots.default
              })]);
            }
          })];
        }
      });
    };
  }
});
var EllipsisOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z"
      }
    }]
  },
  "name": "ellipsis",
  "theme": "outlined"
};
var EllipsisOutlinedSvg = EllipsisOutlined$2;
function _objectSpread$u(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$u(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$u(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EllipsisOutlined = function EllipsisOutlined2(props2, context) {
  var p2 = _objectSpread$u({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$u({}, p2, {
    "icon": EllipsisOutlinedSvg
  }), null);
};
EllipsisOutlined.displayName = "EllipsisOutlined";
EllipsisOutlined.inheritAttrs = false;
var EllipsisOutlined$1 = EllipsisOutlined;
var menuProps = function menuProps2() {
  return {
    id: String,
    prefixCls: String,
    disabled: Boolean,
    inlineCollapsed: Boolean,
    disabledOverflow: Boolean,
    forceSubMenuRender: Boolean,
    openKeys: Array,
    selectedKeys: Array,
    activeKey: String,
    selectable: {
      type: Boolean,
      default: true
    },
    multiple: {
      type: Boolean,
      default: false
    },
    motion: Object,
    theme: {
      type: String,
      default: "light"
    },
    mode: {
      type: String,
      default: "vertical"
    },
    inlineIndent: {
      type: Number,
      default: 24
    },
    subMenuOpenDelay: {
      type: Number,
      default: 0.1
    },
    subMenuCloseDelay: {
      type: Number,
      default: 0.1
    },
    builtinPlacements: {
      type: Object
    },
    triggerSubMenuAction: {
      type: String,
      default: "hover"
    },
    getPopupContainer: Function,
    expandIcon: Function,
    onOpenChange: Function,
    onSelect: Function,
    onDeselect: Function,
    onClick: [Function, Array],
    onFocus: Function,
    onBlur: Function,
    onMousedown: Function,
    "onUpdate:openKeys": Function,
    "onUpdate:selectedKeys": Function,
    "onUpdate:activeKey": Function
  };
};
var EMPTY_LIST$2 = [];
var Menu = Vue.defineComponent({
  name: "AMenu",
  inheritAttrs: false,
  props: menuProps(),
  slots: ["expandIcon", "overflowedIndicator"],
  setup: function setup50(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("menu", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, getPrefixCls2 = _useConfigInject.getPrefixCls;
    var store = Vue.ref({});
    var siderCollapsed = Vue.inject(SiderCollapsedKey, Vue.ref(void 0));
    var inlineCollapsed = Vue.computed(function() {
      if (siderCollapsed.value !== void 0) {
        return siderCollapsed.value;
      }
      return props2.inlineCollapsed;
    });
    var isMounted = Vue.ref(false);
    Vue.onMounted(function() {
      isMounted.value = true;
    });
    Vue.watchEffect(function() {
      devWarning(!(props2.inlineCollapsed === true && props2.mode !== "inline"), "Menu", "`inlineCollapsed` should only be used when `mode` is inline.");
      devWarning(!(siderCollapsed.value !== void 0 && props2.inlineCollapsed === true), "Menu", "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead.");
    });
    var activeKeys = Vue.ref([]);
    var mergedSelectedKeys = Vue.ref([]);
    var keyMapStore = Vue.ref({});
    Vue.watch(store, function() {
      var newKeyMapStore = {};
      for (var _i = 0, _Object$values = Object.values(store.value); _i < _Object$values.length; _i++) {
        var menuInfo = _Object$values[_i];
        newKeyMapStore[menuInfo.key] = menuInfo;
      }
      keyMapStore.value = newKeyMapStore;
    }, {
      flush: "post"
    });
    Vue.watchEffect(function() {
      if (props2.activeKey !== void 0) {
        var keys2 = [];
        var menuInfo = props2.activeKey ? keyMapStore.value[props2.activeKey] : void 0;
        if (menuInfo && props2.activeKey !== void 0) {
          keys2 = uniq([].concat(Vue.unref(menuInfo.parentKeys), props2.activeKey));
        } else {
          keys2 = [];
        }
        if (!shallowequal(activeKeys.value, keys2)) {
          activeKeys.value = keys2;
        }
      }
    });
    Vue.watch(function() {
      return props2.selectedKeys;
    }, function(selectedKeys) {
      if (selectedKeys) {
        mergedSelectedKeys.value = selectedKeys.slice();
      }
    }, {
      immediate: true,
      deep: true
    });
    var selectedSubMenuKeys = Vue.ref([]);
    Vue.watch([keyMapStore, mergedSelectedKeys], function() {
      var subMenuParentKeys = [];
      mergedSelectedKeys.value.forEach(function(key2) {
        var menuInfo = keyMapStore.value[key2];
        if (menuInfo) {
          subMenuParentKeys = subMenuParentKeys.concat(Vue.unref(menuInfo.parentKeys));
        }
      });
      subMenuParentKeys = uniq(subMenuParentKeys);
      if (!shallowequal(selectedSubMenuKeys.value, subMenuParentKeys)) {
        selectedSubMenuKeys.value = subMenuParentKeys;
      }
    }, {
      immediate: true
    });
    var triggerSelection = function triggerSelection2(info) {
      if (!props2.selectable) {
        return;
      }
      var targetKey = info.key;
      var exist = mergedSelectedKeys.value.includes(targetKey);
      var newSelectedKeys;
      if (props2.multiple) {
        if (exist) {
          newSelectedKeys = mergedSelectedKeys.value.filter(function(key2) {
            return key2 !== targetKey;
          });
        } else {
          newSelectedKeys = [].concat(_toConsumableArray(mergedSelectedKeys.value), [targetKey]);
        }
      } else {
        newSelectedKeys = [targetKey];
      }
      var selectInfo = _extends(_extends({}, info), {
        selectedKeys: newSelectedKeys
      });
      if (!shallowequal(newSelectedKeys, mergedSelectedKeys.value)) {
        if (props2.selectedKeys === void 0) {
          mergedSelectedKeys.value = newSelectedKeys;
        }
        emit("update:selectedKeys", newSelectedKeys);
        if (exist && props2.multiple) {
          emit("deselect", selectInfo);
        } else {
          emit("select", selectInfo);
        }
      }
      if (mergedMode.value !== "inline" && !props2.multiple && mergedOpenKeys.value.length) {
        triggerOpenKeys(EMPTY_LIST$2);
      }
    };
    var mergedOpenKeys = Vue.ref([]);
    Vue.watch(function() {
      return props2.openKeys;
    }, function() {
      var openKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : mergedOpenKeys.value;
      if (!shallowequal(mergedOpenKeys.value, openKeys)) {
        mergedOpenKeys.value = openKeys.slice();
      }
    }, {
      immediate: true,
      deep: true
    });
    var timeout;
    var changeActiveKeys = function changeActiveKeys2(keys2) {
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        if (props2.activeKey === void 0) {
          activeKeys.value = keys2;
        }
        emit("update:activeKey", keys2[keys2.length - 1]);
      });
    };
    var disabled = Vue.computed(function() {
      return !!props2.disabled;
    });
    var isRtl = Vue.computed(function() {
      return direction.value === "rtl";
    });
    var mergedMode = Vue.ref("vertical");
    var mergedInlineCollapsed = Vue.ref(false);
    Vue.watchEffect(function() {
      if ((props2.mode === "inline" || props2.mode === "vertical") && inlineCollapsed.value) {
        mergedMode.value = "vertical";
        mergedInlineCollapsed.value = inlineCollapsed.value;
      } else {
        mergedMode.value = props2.mode;
        mergedInlineCollapsed.value = false;
      }
    });
    var isInlineMode = Vue.computed(function() {
      return mergedMode.value === "inline";
    });
    var triggerOpenKeys = function triggerOpenKeys2(keys2) {
      mergedOpenKeys.value = keys2;
      emit("update:openKeys", keys2);
      emit("openChange", keys2);
    };
    var inlineCacheOpenKeys = Vue.ref(mergedOpenKeys.value);
    var mountRef = Vue.ref(false);
    Vue.watch(mergedOpenKeys, function() {
      if (isInlineMode.value) {
        inlineCacheOpenKeys.value = mergedOpenKeys.value;
      }
    }, {
      immediate: true
    });
    Vue.watch(isInlineMode, function() {
      if (!mountRef.value) {
        mountRef.value = true;
        return;
      }
      if (isInlineMode.value) {
        mergedOpenKeys.value = inlineCacheOpenKeys.value;
      } else {
        triggerOpenKeys(EMPTY_LIST$2);
      }
    }, {
      immediate: true
    });
    var className = Vue.computed(function() {
      var _ref2;
      return _ref2 = {}, _defineProperty$T(_ref2, "".concat(prefixCls.value), true), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-root"), true), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-").concat(mergedMode.value), true), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-inline-collapsed"), mergedInlineCollapsed.value), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-rtl"), isRtl.value), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-").concat(props2.theme), true), _ref2;
    });
    var rootPrefixCls = Vue.computed(function() {
      return getPrefixCls2();
    });
    var defaultMotions = Vue.computed(function() {
      return {
        horizontal: {
          name: "".concat(rootPrefixCls.value, "-slide-up")
        },
        inline: collapseMotion$1,
        other: {
          name: "".concat(rootPrefixCls.value, "-zoom-big")
        }
      };
    });
    useProvideFirstLevel(true);
    var getChildrenKeys = function getChildrenKeys2() {
      var eventKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var keys2 = [];
      var storeValue = store.value;
      eventKeys.forEach(function(eventKey) {
        var _storeValue$eventKey = storeValue[eventKey], key2 = _storeValue$eventKey.key, childrenEventKeys = _storeValue$eventKey.childrenEventKeys;
        keys2.push.apply(keys2, [key2].concat(_toConsumableArray(getChildrenKeys2(childrenEventKeys))));
      });
      return keys2;
    };
    var onInternalClick = function onInternalClick2(info) {
      emit("click", info);
      triggerSelection(info);
    };
    var onInternalOpenChange = function onInternalOpenChange2(key2, open2) {
      var childrenEventKeys = keyMapStore.value[key2].childrenEventKeys;
      var newOpenKeys = mergedOpenKeys.value.filter(function(k2) {
        return k2 !== key2;
      });
      if (open2) {
        newOpenKeys.push(key2);
      } else if (mergedMode.value !== "inline") {
        var subPathKeys = getChildrenKeys(childrenEventKeys);
        newOpenKeys = uniq(newOpenKeys.filter(function(k2) {
          return !subPathKeys.includes(k2);
        }));
      }
      if (!shallowequal(mergedOpenKeys, newOpenKeys)) {
        triggerOpenKeys(newOpenKeys);
      }
    };
    var registerMenuInfo = function registerMenuInfo2(key2, info) {
      store.value = _extends(_extends({}, store.value), _defineProperty$T({}, key2, info));
    };
    var unRegisterMenuInfo = function unRegisterMenuInfo2(key2) {
      delete store.value[key2];
      store.value = _extends({}, store.value);
    };
    var lastVisibleIndex = Vue.ref(0);
    var expandIcon = Vue.computed(function() {
      return props2.expandIcon || slots.expandIcon ? function(opt) {
        var icon = props2.expandIcon || slots.expandIcon;
        icon = typeof icon === "function" ? icon(opt) : icon;
        return cloneElement(icon, {
          class: "".concat(prefixCls.value, "-submenu-expand-icon")
        }, false);
      } : null;
    });
    useProvideMenu$1({
      store,
      prefixCls,
      activeKeys,
      openKeys: mergedOpenKeys,
      selectedKeys: mergedSelectedKeys,
      changeActiveKeys,
      disabled,
      rtl: isRtl,
      mode: mergedMode,
      inlineIndent: Vue.computed(function() {
        return props2.inlineIndent;
      }),
      subMenuCloseDelay: Vue.computed(function() {
        return props2.subMenuCloseDelay;
      }),
      subMenuOpenDelay: Vue.computed(function() {
        return props2.subMenuOpenDelay;
      }),
      builtinPlacements: Vue.computed(function() {
        return props2.builtinPlacements;
      }),
      triggerSubMenuAction: Vue.computed(function() {
        return props2.triggerSubMenuAction;
      }),
      getPopupContainer: Vue.computed(function() {
        return props2.getPopupContainer;
      }),
      inlineCollapsed: mergedInlineCollapsed,
      antdMenuTheme: Vue.computed(function() {
        return props2.theme;
      }),
      siderCollapsed,
      defaultMotions: Vue.computed(function() {
        return isMounted.value ? defaultMotions.value : null;
      }),
      motion: Vue.computed(function() {
        return isMounted.value ? props2.motion : null;
      }),
      overflowDisabled: Vue.ref(void 0),
      onOpenChange: onInternalOpenChange,
      onItemClick: onInternalClick,
      registerMenuInfo,
      unRegisterMenuInfo,
      selectedSubMenuKeys,
      isRootMenu: Vue.ref(true),
      expandIcon,
      forceSubMenuRender: Vue.computed(function() {
        return props2.forceSubMenuRender;
      })
    });
    return function() {
      var _a, _b;
      var childList = flattenChildren((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
      var allVisible = lastVisibleIndex.value >= childList.length - 1 || mergedMode.value !== "horizontal" || props2.disabledOverflow;
      var wrappedChildList = mergedMode.value !== "horizontal" || props2.disabledOverflow ? childList : childList.map(function(child, index2) {
        return Vue.createVNode(MenuContextProvider, {
          "key": child.key,
          "overflowDisabled": index2 > lastVisibleIndex.value
        }, {
          default: function _default5() {
            return child;
          }
        });
      });
      var overflowedIndicator = ((_b = slots.overflowedIndicator) === null || _b === void 0 ? void 0 : _b.call(slots)) || Vue.createVNode(EllipsisOutlined$1, null, null);
      return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode(Overflow$1, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "onMousedown": props2.onMousedown,
        "prefixCls": "".concat(prefixCls.value, "-overflow"),
        "component": "ul",
        "itemComponent": MenuItem$1,
        "class": [className.value, attrs.class],
        "role": "menu",
        "id": props2.id,
        "data": wrappedChildList,
        "renderRawItem": function renderRawItem(node) {
          return node;
        },
        "renderRawRest": function renderRawRest(omitItems) {
          var len = omitItems.length;
          var originOmitItems = len ? childList.slice(-len) : null;
          return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode(SubMenu$1, {
            "eventKey": OVERFLOW_KEY,
            "key": OVERFLOW_KEY,
            "title": overflowedIndicator,
            "disabled": allVisible,
            "internalPopupClose": len === 0
          }, {
            default: function _default5() {
              return originOmitItems;
            }
          }), Vue.createVNode(PathContext, null, {
            default: function _default5() {
              return [Vue.createVNode(SubMenu$1, {
                "eventKey": OVERFLOW_KEY,
                "key": OVERFLOW_KEY,
                "title": overflowedIndicator,
                "disabled": allVisible,
                "internalPopupClose": len === 0
              }, {
                default: function _default6() {
                  return originOmitItems;
                }
              })];
            }
          })]);
        },
        "maxCount": mergedMode.value !== "horizontal" || props2.disabledOverflow ? Overflow$1.INVALIDATE : Overflow$1.RESPONSIVE,
        "ssr": "full",
        "data-menu-list": true,
        "onVisibleChange": function onVisibleChange(newLastIndex) {
          lastVisibleIndex.value = newLastIndex;
        }
      }), null), Vue.createVNode("div", {
        "style": {
          display: "none"
        },
        "aria-hidden": true
      }, [Vue.createVNode(PathContext, null, {
        default: function _default5() {
          return [wrappedChildList];
        }
      })])]);
    };
  }
});
var menuItemGroupProps = function menuItemGroupProps2() {
  return {
    title: PropTypes$1.any
  };
};
var ItemGroup = Vue.defineComponent({
  name: "AMenuItemGroup",
  inheritAttrs: false,
  props: menuItemGroupProps(),
  slots: ["title"],
  setup: function setup51(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useInjectMenu = useInjectMenu(), prefixCls = _useInjectMenu.prefixCls;
    var groupPrefixCls = Vue.computed(function() {
      return "".concat(prefixCls.value, "-item-group");
    });
    var isMeasure = useMeasure();
    return function() {
      var _a, _b;
      if (isMeasure)
        return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
      return Vue.createVNode("li", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "onClick": function onClick2(e2) {
          return e2.stopPropagation();
        },
        "class": groupPrefixCls.value
      }), [Vue.createVNode("div", {
        "title": typeof props2.title === "string" ? props2.title : void 0,
        "class": "".concat(groupPrefixCls.value, "-title")
      }, [getPropsSlot(slots, props2, "title")]), Vue.createVNode("ul", {
        "class": "".concat(groupPrefixCls.value, "-list")
      }, [(_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots)])]);
    };
  }
});
var menuDividerProps = function menuDividerProps2() {
  return {
    prefixCls: String,
    dashed: Boolean
  };
};
var Divider = Vue.defineComponent({
  name: "AMenuDivider",
  props: menuDividerProps(),
  setup: function setup52(props2) {
    var _useConfigInject = useConfigInject("menu", props2), prefixCls = _useConfigInject.prefixCls;
    var cls = Vue.computed(function() {
      var _ref;
      return _ref = {}, _defineProperty$T(_ref, "".concat(prefixCls.value, "-item-divider"), true), _defineProperty$T(_ref, "".concat(prefixCls.value, "-item-divider-dashed"), !!props2.dashed), _ref;
    });
    return function() {
      return Vue.createVNode("li", {
        "class": cls.value
      }, null);
    };
  }
});
Menu.install = function(app) {
  app.component(Menu.name, Menu);
  app.component(MenuItem$1.name, MenuItem$1);
  app.component(SubMenu$1.name, SubMenu$1);
  app.component(Divider.name, Divider);
  app.component(ItemGroup.name, ItemGroup);
  return app;
};
Menu.Item = MenuItem$1;
Menu.Divider = Divider;
Menu.SubMenu = SubMenu$1;
Menu.ItemGroup = ItemGroup;
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  topCenter: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  },
  bottomCenter: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  }
};
var placements$1 = placements;
var __rest$w = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var Dropdown$1 = Vue.defineComponent({
  props: {
    minOverlayWidthMatchTrigger: {
      type: Boolean,
      default: void 0
    },
    arrow: {
      type: Boolean,
      default: false
    },
    prefixCls: PropTypes$1.string.def("rc-dropdown"),
    transitionName: String,
    overlayClassName: PropTypes$1.string.def(""),
    openClassName: String,
    animation: PropTypes$1.any,
    align: PropTypes$1.object,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    placement: PropTypes$1.string.def("bottomLeft"),
    overlay: PropTypes$1.any,
    trigger: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.arrayOf(PropTypes$1.string)]).def("hover"),
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    showAction: PropTypes$1.array,
    hideAction: PropTypes$1.array,
    getPopupContainer: Function,
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: false
    },
    mouseEnterDelay: PropTypes$1.number.def(0.15),
    mouseLeaveDelay: PropTypes$1.number.def(0.1)
  },
  emits: ["visibleChange", "overlayClick"],
  slots: ["overlay"],
  setup: function setup53(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    var triggerVisible = Vue.ref(!!props2.visible);
    Vue.watch(function() {
      return props2.visible;
    }, function(val) {
      if (val !== void 0) {
        triggerVisible.value = val;
      }
    });
    var triggerRef = Vue.ref();
    expose({
      triggerRef
    });
    var onClick2 = function onClick3(e2) {
      if (props2.visible === void 0) {
        triggerVisible.value = false;
      }
      emit("overlayClick", e2);
    };
    var onVisibleChange = function onVisibleChange2(visible) {
      if (props2.visible === void 0) {
        triggerVisible.value = visible;
      }
      emit("visibleChange", visible);
    };
    var getMenuElement = function getMenuElement2() {
      var _a;
      var overlayElement = (_a = slots.overlay) === null || _a === void 0 ? void 0 : _a.call(slots);
      var extraOverlayProps = {
        prefixCls: "".concat(props2.prefixCls, "-menu"),
        onClick: onClick2,
        getPopupContainer: function getPopupContainer() {
          return triggerRef.value.getPopupDomNode();
        }
      };
      return Vue.createVNode(Vue.Fragment, null, [props2.arrow && Vue.createVNode("div", {
        "class": "".concat(props2.prefixCls, "-arrow")
      }, null), cloneElement(overlayElement, extraOverlayProps, false)]);
    };
    var minOverlayWidthMatchTrigger = Vue.computed(function() {
      var _props$minOverlayWidt = props2.minOverlayWidthMatchTrigger, matchTrigger = _props$minOverlayWidt === void 0 ? !props2.alignPoint : _props$minOverlayWidt;
      return matchTrigger;
    });
    var renderChildren2 = function renderChildren3() {
      var _a;
      var children = (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
      return triggerVisible.value && children ? cloneElement(children[0], {
        class: props2.openClassName || "".concat(props2.prefixCls, "-open")
      }, false) : children;
    };
    var triggerHideAction = Vue.computed(function() {
      if (!props2.hideAction && props2.trigger.indexOf("contextmenu") !== -1) {
        return ["click"];
      }
      return props2.hideAction;
    });
    return function() {
      var prefixCls = props2.prefixCls, arrow = props2.arrow, showAction = props2.showAction, overlayStyle = props2.overlayStyle, trigger2 = props2.trigger, placement = props2.placement, align = props2.align, getPopupContainer = props2.getPopupContainer, transitionName2 = props2.transitionName, animation = props2.animation, overlayClassName = props2.overlayClassName, otherProps = __rest$w(props2, ["prefixCls", "arrow", "showAction", "overlayStyle", "trigger", "placement", "align", "getPopupContainer", "transitionName", "animation", "overlayClassName"]);
      return Vue.createVNode(Trigger, _objectSpread2$1(_objectSpread2$1({}, otherProps), {}, {
        "prefixCls": prefixCls,
        "ref": triggerRef,
        "popupClassName": classNames(overlayClassName, _defineProperty$T({}, "".concat(prefixCls, "-show-arrow"), arrow)),
        "popupStyle": overlayStyle,
        "builtinPlacements": placements$1,
        "action": trigger2,
        "showAction": showAction,
        "hideAction": triggerHideAction.value || [],
        "popupPlacement": placement,
        "popupAlign": align,
        "popupTransitionName": transitionName2,
        "popupAnimation": animation,
        "popupVisible": triggerVisible.value,
        "stretch": minOverlayWidthMatchTrigger.value ? "minWidth" : "",
        "onPopupVisibleChange": onVisibleChange,
        "getPopupContainer": getPopupContainer
      }), {
        popup: getMenuElement,
        default: renderChildren2
      });
    };
  }
});
var AddButton = Vue.defineComponent({
  name: "AddButton",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    editable: {
      type: Object
    },
    locale: {
      type: Object,
      default: void 0
    }
  },
  setup: function setup54(props2, _ref) {
    var expose = _ref.expose, attrs = _ref.attrs;
    var domRef = Vue.ref();
    expose({
      domRef
    });
    return function() {
      var prefixCls = props2.prefixCls, editable = props2.editable, locale2 = props2.locale;
      if (!editable || editable.showAdd === false) {
        return null;
      }
      return Vue.createVNode("button", {
        "ref": domRef,
        "type": "button",
        "class": "".concat(prefixCls, "-nav-add"),
        "style": attrs.style,
        "aria-label": (locale2 === null || locale2 === void 0 ? void 0 : locale2.addAriaLabel) || "Add tab",
        "onClick": function onClick2(event) {
          editable.onEdit("add", {
            event
          });
        }
      }, [editable.addIcon ? editable.addIcon() : "+"]);
    };
  }
});
function useState(defaultStateValue) {
  var initValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
  var innerValue = Vue.ref(initValue);
  function triggerChange(newValue) {
    innerValue.value = newValue;
  }
  return [innerValue, triggerChange];
}
var ArrowLeftOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8a31.96 31.96 0 000 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z"
      }
    }]
  },
  "name": "arrow-left",
  "theme": "outlined"
};
var ArrowLeftOutlinedSvg = ArrowLeftOutlined$2;
function _objectSpread$t(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$t(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$t(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ArrowLeftOutlined = function ArrowLeftOutlined2(props2, context) {
  var p2 = _objectSpread$t({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$t({}, p2, {
    "icon": ArrowLeftOutlinedSvg
  }), null);
};
ArrowLeftOutlined.displayName = "ArrowLeftOutlined";
ArrowLeftOutlined.inheritAttrs = false;
var ArrowLeftOutlined$1 = ArrowLeftOutlined;
var ArrowRightOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M869 487.8L491.2 159.9c-2.9-2.5-6.6-3.9-10.5-3.9h-88.5c-7.4 0-10.8 9.2-5.2 14l350.2 304H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h585.1L386.9 854c-5.6 4.9-2.2 14 5.2 14h91.5c1.9 0 3.8-.7 5.2-2L869 536.2a32.07 32.07 0 000-48.4z"
      }
    }]
  },
  "name": "arrow-right",
  "theme": "outlined"
};
var ArrowRightOutlinedSvg = ArrowRightOutlined$2;
function _objectSpread$s(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$s(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$s(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ArrowRightOutlined = function ArrowRightOutlined2(props2, context) {
  var p2 = _objectSpread$s({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$s({}, p2, {
    "icon": ArrowRightOutlinedSvg
  }), null);
};
ArrowRightOutlined.displayName = "ArrowRightOutlined";
ArrowRightOutlined.inheritAttrs = false;
var ArrowRightOutlined$1 = ArrowRightOutlined;
var CalendarOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z"
      }
    }]
  },
  "name": "calendar",
  "theme": "outlined"
};
var CalendarOutlinedSvg = CalendarOutlined$2;
function _objectSpread$r(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$r(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$r(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CalendarOutlined = function CalendarOutlined2(props2, context) {
  var p2 = _objectSpread$r({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$r({}, p2, {
    "icon": CalendarOutlinedSvg
  }), null);
};
CalendarOutlined.displayName = "CalendarOutlined";
CalendarOutlined.inheritAttrs = false;
var CalendarOutlined$1 = CalendarOutlined;
var CaretDownFilled$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "0 0 1024 1024",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z"
      }
    }]
  },
  "name": "caret-down",
  "theme": "filled"
};
var CaretDownFilledSvg = CaretDownFilled$2;
function _objectSpread$q(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$q(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$q(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CaretDownFilled = function CaretDownFilled2(props2, context) {
  var p2 = _objectSpread$q({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$q({}, p2, {
    "icon": CaretDownFilledSvg
  }), null);
};
CaretDownFilled.displayName = "CaretDownFilled";
CaretDownFilled.inheritAttrs = false;
var CaretDownFilled$1 = CaretDownFilled;
var CaretDownOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "0 0 1024 1024",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z"
      }
    }]
  },
  "name": "caret-down",
  "theme": "outlined"
};
var CaretDownOutlinedSvg = CaretDownOutlined$2;
function _objectSpread$p(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$p(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$p(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CaretDownOutlined = function CaretDownOutlined2(props2, context) {
  var p2 = _objectSpread$p({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$p({}, p2, {
    "icon": CaretDownOutlinedSvg
  }), null);
};
CaretDownOutlined.displayName = "CaretDownOutlined";
CaretDownOutlined.inheritAttrs = false;
var CaretDownOutlined$1 = CaretDownOutlined;
var CaretUpOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "0 0 1024 1024",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z"
      }
    }]
  },
  "name": "caret-up",
  "theme": "outlined"
};
var CaretUpOutlinedSvg = CaretUpOutlined$2;
function _objectSpread$o(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$o(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$o(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CaretUpOutlined = function CaretUpOutlined2(props2, context) {
  var p2 = _objectSpread$o({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$o({}, p2, {
    "icon": CaretUpOutlinedSvg
  }), null);
};
CaretUpOutlined.displayName = "CaretUpOutlined";
CaretUpOutlined.inheritAttrs = false;
var CaretUpOutlined$1 = CaretUpOutlined;
var ClockCircleOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z"
      }
    }]
  },
  "name": "clock-circle",
  "theme": "outlined"
};
var ClockCircleOutlinedSvg = ClockCircleOutlined$2;
function _objectSpread$n(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$n(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$n(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ClockCircleOutlined = function ClockCircleOutlined2(props2, context) {
  var p2 = _objectSpread$n({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$n({}, p2, {
    "icon": ClockCircleOutlinedSvg
  }), null);
};
ClockCircleOutlined.displayName = "ClockCircleOutlined";
ClockCircleOutlined.inheritAttrs = false;
var ClockCircleOutlined$1 = ClockCircleOutlined;
var DoubleLeftOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z"
      }
    }]
  },
  "name": "double-left",
  "theme": "outlined"
};
var DoubleLeftOutlinedSvg = DoubleLeftOutlined$2;
function _objectSpread$m(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$m(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$m(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DoubleLeftOutlined = function DoubleLeftOutlined2(props2, context) {
  var p2 = _objectSpread$m({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$m({}, p2, {
    "icon": DoubleLeftOutlinedSvg
  }), null);
};
DoubleLeftOutlined.displayName = "DoubleLeftOutlined";
DoubleLeftOutlined.inheritAttrs = false;
var DoubleLeftOutlined$1 = DoubleLeftOutlined;
var DoubleRightOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z"
      }
    }]
  },
  "name": "double-right",
  "theme": "outlined"
};
var DoubleRightOutlinedSvg = DoubleRightOutlined$2;
function _objectSpread$l(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$l(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$l(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DoubleRightOutlined = function DoubleRightOutlined2(props2, context) {
  var p2 = _objectSpread$l({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$l({}, p2, {
    "icon": DoubleRightOutlinedSvg
  }), null);
};
DoubleRightOutlined.displayName = "DoubleRightOutlined";
DoubleRightOutlined.inheritAttrs = false;
var DoubleRightOutlined$1 = DoubleRightOutlined;
var DownOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"
      }
    }]
  },
  "name": "down",
  "theme": "outlined"
};
var DownOutlinedSvg = DownOutlined$2;
function _objectSpread$k(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$k(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$k(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DownOutlined = function DownOutlined2(props2, context) {
  var p2 = _objectSpread$k({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$k({}, p2, {
    "icon": DownOutlinedSvg
  }), null);
};
DownOutlined.displayName = "DownOutlined";
DownOutlined.inheritAttrs = false;
var DownOutlined$1 = DownOutlined;
var EyeInvisibleOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z"
      }
    }]
  },
  "name": "eye-invisible",
  "theme": "outlined"
};
var EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;
function _objectSpread$j(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$j(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$j(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props2, context) {
  var p2 = _objectSpread$j({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$j({}, p2, {
    "icon": EyeInvisibleOutlinedSvg
  }), null);
};
EyeInvisibleOutlined.displayName = "EyeInvisibleOutlined";
EyeInvisibleOutlined.inheritAttrs = false;
var EyeInvisibleOutlined$1 = EyeInvisibleOutlined;
var FileOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z"
      }
    }]
  },
  "name": "file",
  "theme": "outlined"
};
var FileOutlinedSvg = FileOutlined$2;
function _objectSpread$i(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$i(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$i(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FileOutlined = function FileOutlined2(props2, context) {
  var p2 = _objectSpread$i({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$i({}, p2, {
    "icon": FileOutlinedSvg
  }), null);
};
FileOutlined.displayName = "FileOutlined";
FileOutlined.inheritAttrs = false;
var FileOutlined$1 = FileOutlined;
var FilterFilled$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z"
      }
    }]
  },
  "name": "filter",
  "theme": "filled"
};
var FilterFilledSvg = FilterFilled$2;
function _objectSpread$h(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$h(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$h(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FilterFilled = function FilterFilled2(props2, context) {
  var p2 = _objectSpread$h({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$h({}, p2, {
    "icon": FilterFilledSvg
  }), null);
};
FilterFilled.displayName = "FilterFilled";
FilterFilled.inheritAttrs = false;
var FilterFilled$1 = FilterFilled;
var FolderOpenOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z"
      }
    }]
  },
  "name": "folder-open",
  "theme": "outlined"
};
var FolderOpenOutlinedSvg = FolderOpenOutlined$2;
function _objectSpread$g(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$g(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$g(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FolderOpenOutlined = function FolderOpenOutlined2(props2, context) {
  var p2 = _objectSpread$g({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$g({}, p2, {
    "icon": FolderOpenOutlinedSvg
  }), null);
};
FolderOpenOutlined.displayName = "FolderOpenOutlined";
FolderOpenOutlined.inheritAttrs = false;
var FolderOpenOutlined$1 = FolderOpenOutlined;
var FolderOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z"
      }
    }]
  },
  "name": "folder",
  "theme": "outlined"
};
var FolderOutlinedSvg = FolderOutlined$2;
function _objectSpread$f(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$f(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$f(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FolderOutlined = function FolderOutlined2(props2, context) {
  var p2 = _objectSpread$f({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$f({}, p2, {
    "icon": FolderOutlinedSvg
  }), null);
};
FolderOutlined.displayName = "FolderOutlined";
FolderOutlined.inheritAttrs = false;
var FolderOutlined$1 = FolderOutlined;
var GlobalOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M854.4 800.9c.2-.3.5-.6.7-.9C920.6 722.1 960 621.7 960 512s-39.4-210.1-104.8-288c-.2-.3-.5-.5-.7-.8-1.1-1.3-2.1-2.5-3.2-3.7-.4-.5-.8-.9-1.2-1.4l-4.1-4.7-.1-.1c-1.5-1.7-3.1-3.4-4.6-5.1l-.1-.1c-3.2-3.4-6.4-6.8-9.7-10.1l-.1-.1-4.8-4.8-.3-.3c-1.5-1.5-3-2.9-4.5-4.3-.5-.5-1-1-1.6-1.5-1-1-2-1.9-3-2.8-.3-.3-.7-.6-1-1C736.4 109.2 629.5 64 512 64s-224.4 45.2-304.3 119.2c-.3.3-.7.6-1 1-1 .9-2 1.9-3 2.9-.5.5-1 1-1.6 1.5-1.5 1.4-3 2.9-4.5 4.3l-.3.3-4.8 4.8-.1.1c-3.3 3.3-6.5 6.7-9.7 10.1l-.1.1c-1.6 1.7-3.1 3.4-4.6 5.1l-.1.1c-1.4 1.5-2.8 3.1-4.1 4.7-.4.5-.8.9-1.2 1.4-1.1 1.2-2.1 2.5-3.2 3.7-.2.3-.5.5-.7.8C103.4 301.9 64 402.3 64 512s39.4 210.1 104.8 288c.2.3.5.6.7.9l3.1 3.7c.4.5.8.9 1.2 1.4l4.1 4.7c0 .1.1.1.1.2 1.5 1.7 3 3.4 4.6 5l.1.1c3.2 3.4 6.4 6.8 9.6 10.1l.1.1c1.6 1.6 3.1 3.2 4.7 4.7l.3.3c3.3 3.3 6.7 6.5 10.1 9.6 80.1 74 187 119.2 304.5 119.2s224.4-45.2 304.3-119.2a300 300 0 0010-9.6l.3-.3c1.6-1.6 3.2-3.1 4.7-4.7l.1-.1c3.3-3.3 6.5-6.7 9.6-10.1l.1-.1c1.5-1.7 3.1-3.3 4.6-5 0-.1.1-.1.1-.2 1.4-1.5 2.8-3.1 4.1-4.7.4-.5.8-.9 1.2-1.4a99 99 0 003.3-3.7zm4.1-142.6c-13.8 32.6-32 62.8-54.2 90.2a444.07 444.07 0 00-81.5-55.9c11.6-46.9 18.8-98.4 20.7-152.6H887c-3 40.9-12.6 80.6-28.5 118.3zM887 484H743.5c-1.9-54.2-9.1-105.7-20.7-152.6 29.3-15.6 56.6-34.4 81.5-55.9A373.86 373.86 0 01887 484zM658.3 165.5c39.7 16.8 75.8 40 107.6 69.2a394.72 394.72 0 01-59.4 41.8c-15.7-45-35.8-84.1-59.2-115.4 3.7 1.4 7.4 2.9 11 4.4zm-90.6 700.6c-9.2 7.2-18.4 12.7-27.7 16.4V697a389.1 389.1 0 01115.7 26.2c-8.3 24.6-17.9 47.3-29 67.8-17.4 32.4-37.8 58.3-59 75.1zm59-633.1c11 20.6 20.7 43.3 29 67.8A389.1 389.1 0 01540 327V141.6c9.2 3.7 18.5 9.1 27.7 16.4 21.2 16.7 41.6 42.6 59 75zM540 640.9V540h147.5c-1.6 44.2-7.1 87.1-16.3 127.8l-.3 1.2A445.02 445.02 0 00540 640.9zm0-156.9V383.1c45.8-2.8 89.8-12.5 130.9-28.1l.3 1.2c9.2 40.7 14.7 83.5 16.3 127.8H540zm-56 56v100.9c-45.8 2.8-89.8 12.5-130.9 28.1l-.3-1.2c-9.2-40.7-14.7-83.5-16.3-127.8H484zm-147.5-56c1.6-44.2 7.1-87.1 16.3-127.8l.3-1.2c41.1 15.6 85 25.3 130.9 28.1V484H336.5zM484 697v185.4c-9.2-3.7-18.5-9.1-27.7-16.4-21.2-16.7-41.7-42.7-59.1-75.1-11-20.6-20.7-43.3-29-67.8 37.2-14.6 75.9-23.3 115.8-26.1zm0-370a389.1 389.1 0 01-115.7-26.2c8.3-24.6 17.9-47.3 29-67.8 17.4-32.4 37.8-58.4 59.1-75.1 9.2-7.2 18.4-12.7 27.7-16.4V327zM365.7 165.5c3.7-1.5 7.3-3 11-4.4-23.4 31.3-43.5 70.4-59.2 115.4-21-12-40.9-26-59.4-41.8 31.8-29.2 67.9-52.4 107.6-69.2zM165.5 365.7c13.8-32.6 32-62.8 54.2-90.2 24.9 21.5 52.2 40.3 81.5 55.9-11.6 46.9-18.8 98.4-20.7 152.6H137c3-40.9 12.6-80.6 28.5-118.3zM137 540h143.5c1.9 54.2 9.1 105.7 20.7 152.6a444.07 444.07 0 00-81.5 55.9A373.86 373.86 0 01137 540zm228.7 318.5c-39.7-16.8-75.8-40-107.6-69.2 18.5-15.8 38.4-29.7 59.4-41.8 15.7 45 35.8 84.1 59.2 115.4-3.7-1.4-7.4-2.9-11-4.4zm292.6 0c-3.7 1.5-7.3 3-11 4.4 23.4-31.3 43.5-70.4 59.2-115.4 21 12 40.9 26 59.4 41.8a373.81 373.81 0 01-107.6 69.2z"
      }
    }]
  },
  "name": "global",
  "theme": "outlined"
};
var GlobalOutlinedSvg = GlobalOutlined$2;
function _objectSpread$e(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$e(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$e(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var GlobalOutlined = function GlobalOutlined2(props2, context) {
  var p2 = _objectSpread$e({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$e({}, p2, {
    "icon": GlobalOutlinedSvg
  }), null);
};
GlobalOutlined.displayName = "GlobalOutlined";
GlobalOutlined.inheritAttrs = false;
var GlobalOutlined$1 = GlobalOutlined;
var LockOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M832 464h-68V240c0-70.7-57.3-128-128-128H388c-70.7 0-128 57.3-128 128v224h-68c-17.7 0-32 14.3-32 32v384c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V496c0-17.7-14.3-32-32-32zM332 240c0-30.9 25.1-56 56-56h248c30.9 0 56 25.1 56 56v224H332V240zm460 600H232V536h560v304zM484 701v53c0 4.4 3.6 8 8 8h40c4.4 0 8-3.6 8-8v-53a48.01 48.01 0 10-56 0z"
      }
    }]
  },
  "name": "lock",
  "theme": "outlined"
};
var LockOutlinedSvg = LockOutlined$2;
function _objectSpread$d(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$d(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$d(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var LockOutlined = function LockOutlined2(props2, context) {
  var p2 = _objectSpread$d({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$d({}, p2, {
    "icon": LockOutlinedSvg
  }), null);
};
LockOutlined.displayName = "LockOutlined";
LockOutlined.inheritAttrs = false;
var LockOutlined$1 = LockOutlined;
var MailOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 110.8V792H136V270.8l-27.6-21.5 39.3-50.5 42.8 33.3h643.1l42.8-33.3 39.3 50.5-27.7 21.5zM833.6 232L512 482 190.4 232l-42.8-33.3-39.3 50.5 27.6 21.5 341.6 265.6a55.99 55.99 0 0068.7 0L888 270.8l27.6-21.5-39.3-50.5-42.7 33.2z"
      }
    }]
  },
  "name": "mail",
  "theme": "outlined"
};
var MailOutlinedSvg = MailOutlined$2;
function _objectSpread$c(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$c(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$c(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var MailOutlined = function MailOutlined2(props2, context) {
  var p2 = _objectSpread$c({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$c({}, p2, {
    "icon": MailOutlinedSvg
  }), null);
};
MailOutlined.displayName = "MailOutlined";
MailOutlined.inheritAttrs = false;
var MailOutlined$1 = MailOutlined;
var MinusSquareOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"
      }
    }]
  },
  "name": "minus-square",
  "theme": "outlined"
};
var MinusSquareOutlinedSvg = MinusSquareOutlined$2;
function _objectSpread$b(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$b(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$b(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var MinusSquareOutlined = function MinusSquareOutlined2(props2, context) {
  var p2 = _objectSpread$b({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$b({}, p2, {
    "icon": MinusSquareOutlinedSvg
  }), null);
};
MinusSquareOutlined.displayName = "MinusSquareOutlined";
MinusSquareOutlined.inheritAttrs = false;
var MinusSquareOutlined$1 = MinusSquareOutlined;
var PlusOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "defs",
      "attrs": {},
      "children": [{
        "tag": "style",
        "attrs": {}
      }]
    }, {
      "tag": "path",
      "attrs": {
        "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M176 474h672q8 0 8 8v60q0 8-8 8H176q-8 0-8-8v-60q0-8 8-8z"
      }
    }]
  },
  "name": "plus",
  "theme": "outlined"
};
var PlusOutlinedSvg = PlusOutlined$2;
function _objectSpread$a(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$a(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$a(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PlusOutlined = function PlusOutlined2(props2, context) {
  var p2 = _objectSpread$a({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$a({}, p2, {
    "icon": PlusOutlinedSvg
  }), null);
};
PlusOutlined.displayName = "PlusOutlined";
PlusOutlined.inheritAttrs = false;
var PlusOutlined$1 = PlusOutlined;
var PlusSquareOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z"
      }
    }, {
      "tag": "path",
      "attrs": {
        "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"
      }
    }]
  },
  "name": "plus-square",
  "theme": "outlined"
};
var PlusSquareOutlinedSvg = PlusSquareOutlined$2;
function _objectSpread$9(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$9(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$9(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PlusSquareOutlined = function PlusSquareOutlined2(props2, context) {
  var p2 = _objectSpread$9({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$9({}, p2, {
    "icon": PlusSquareOutlinedSvg
  }), null);
};
PlusSquareOutlined.displayName = "PlusSquareOutlined";
PlusSquareOutlined.inheritAttrs = false;
var PlusSquareOutlined$1 = PlusSquareOutlined;
var SaveOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M893.3 293.3L730.7 130.7c-7.5-7.5-16.7-13-26.7-16V112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V338.5c0-17-6.7-33.2-18.7-45.2zM384 184h256v104H384V184zm456 656H184V184h136v136c0 17.7 14.3 32 32 32h320c17.7 0 32-14.3 32-32V205.8l136 136V840zM512 442c-79.5 0-144 64.5-144 144s64.5 144 144 144 144-64.5 144-144-64.5-144-144-144zm0 224c-44.2 0-80-35.8-80-80s35.8-80 80-80 80 35.8 80 80-35.8 80-80 80z"
      }
    }]
  },
  "name": "save",
  "theme": "outlined"
};
var SaveOutlinedSvg = SaveOutlined$2;
function _objectSpread$8(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$8(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$8(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var SaveOutlined = function SaveOutlined2(props2, context) {
  var p2 = _objectSpread$8({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$8({}, p2, {
    "icon": SaveOutlinedSvg
  }), null);
};
SaveOutlined.displayName = "SaveOutlined";
SaveOutlined.inheritAttrs = false;
var SaveOutlined$1 = SaveOutlined;
var SearchOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z"
      }
    }]
  },
  "name": "search",
  "theme": "outlined"
};
var SearchOutlinedSvg = SearchOutlined$2;
function _objectSpread$7(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$7(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$7(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var SearchOutlined = function SearchOutlined2(props2, context) {
  var p2 = _objectSpread$7({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$7({}, p2, {
    "icon": SearchOutlinedSvg
  }), null);
};
SearchOutlined.displayName = "SearchOutlined";
SearchOutlined.inheritAttrs = false;
var SearchOutlined$1 = SearchOutlined;
var SettingOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M924.8 625.7l-65.5-56c3.1-19 4.7-38.4 4.7-57.8s-1.6-38.8-4.7-57.8l65.5-56a32.03 32.03 0 009.3-35.2l-.9-2.6a443.74 443.74 0 00-79.7-137.9l-1.8-2.1a32.12 32.12 0 00-35.1-9.5l-81.3 28.9c-30-24.6-63.5-44-99.7-57.6l-15.7-85a32.05 32.05 0 00-25.8-25.7l-2.7-.5c-52.1-9.4-106.9-9.4-159 0l-2.7.5a32.05 32.05 0 00-25.8 25.7l-15.8 85.4a351.86 351.86 0 00-99 57.4l-81.9-29.1a32 32 0 00-35.1 9.5l-1.8 2.1a446.02 446.02 0 00-79.7 137.9l-.9 2.6c-4.5 12.5-.8 26.5 9.3 35.2l66.3 56.6c-3.1 18.8-4.6 38-4.6 57.1 0 19.2 1.5 38.4 4.6 57.1L99 625.5a32.03 32.03 0 00-9.3 35.2l.9 2.6c18.1 50.4 44.9 96.9 79.7 137.9l1.8 2.1a32.12 32.12 0 0035.1 9.5l81.9-29.1c29.8 24.5 63.1 43.9 99 57.4l15.8 85.4a32.05 32.05 0 0025.8 25.7l2.7.5a449.4 449.4 0 00159 0l2.7-.5a32.05 32.05 0 0025.8-25.7l15.7-85a350 350 0 0099.7-57.6l81.3 28.9a32 32 0 0035.1-9.5l1.8-2.1c34.8-41.1 61.6-87.5 79.7-137.9l.9-2.6c4.5-12.3.8-26.3-9.3-35zM788.3 465.9c2.5 15.1 3.8 30.6 3.8 46.1s-1.3 31-3.8 46.1l-6.6 40.1 74.7 63.9a370.03 370.03 0 01-42.6 73.6L721 702.8l-31.4 25.8c-23.9 19.6-50.5 35-79.3 45.8l-38.1 14.3-17.9 97a377.5 377.5 0 01-85 0l-17.9-97.2-37.8-14.5c-28.5-10.8-55-26.2-78.7-45.7l-31.4-25.9-93.4 33.2c-17-22.9-31.2-47.6-42.6-73.6l75.5-64.5-6.5-40c-2.4-14.9-3.7-30.3-3.7-45.5 0-15.3 1.2-30.6 3.7-45.5l6.5-40-75.5-64.5c11.3-26.1 25.6-50.7 42.6-73.6l93.4 33.2 31.4-25.9c23.7-19.5 50.2-34.9 78.7-45.7l37.9-14.3 17.9-97.2c28.1-3.2 56.8-3.2 85 0l17.9 97 38.1 14.3c28.7 10.8 55.4 26.2 79.3 45.8l31.4 25.8 92.8-32.9c17 22.9 31.2 47.6 42.6 73.6L781.8 426l6.5 39.9zM512 326c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm79.2 255.2A111.6 111.6 0 01512 614c-29.9 0-58-11.7-79.2-32.8A111.6 111.6 0 01400 502c0-29.9 11.7-58 32.8-79.2C454 401.6 482.1 390 512 390c29.9 0 58 11.6 79.2 32.8A111.6 111.6 0 01624 502c0 29.9-11.7 58-32.8 79.2z"
      }
    }]
  },
  "name": "setting",
  "theme": "outlined"
};
var SettingOutlinedSvg = SettingOutlined$2;
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$6(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$6(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var SettingOutlined = function SettingOutlined2(props2, context) {
  var p2 = _objectSpread$6({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$6({}, p2, {
    "icon": SettingOutlinedSvg
  }), null);
};
SettingOutlined.displayName = "SettingOutlined";
SettingOutlined.inheritAttrs = false;
var SettingOutlined$1 = SettingOutlined;
var SwapRightOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "0 0 1024 1024",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z"
      }
    }]
  },
  "name": "swap-right",
  "theme": "outlined"
};
var SwapRightOutlinedSvg = SwapRightOutlined$2;
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$5(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$5(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var SwapRightOutlined = function SwapRightOutlined2(props2, context) {
  var p2 = _objectSpread$5({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$5({}, p2, {
    "icon": SwapRightOutlinedSvg
  }), null);
};
SwapRightOutlined.displayName = "SwapRightOutlined";
SwapRightOutlined.inheritAttrs = false;
var SwapRightOutlined$1 = SwapRightOutlined;
var SyncOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M168 504.2c1-43.7 10-86.1 26.9-126 17.3-41 42.1-77.7 73.7-109.4S337 212.3 378 195c42.4-17.9 87.4-27 133.9-27s91.5 9.1 133.8 27A341.5 341.5 0 01755 268.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.7 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c0-6.7-7.7-10.5-12.9-6.3l-56.4 44.1C765.8 155.1 646.2 92 511.8 92 282.7 92 96.3 275.6 92 503.8a8 8 0 008 8.2h60c4.4 0 7.9-3.5 8-7.8zm756 7.8h-60c-4.4 0-7.9 3.5-8 7.8-1 43.7-10 86.1-26.9 126-17.3 41-42.1 77.8-73.7 109.4A342.45 342.45 0 01512.1 856a342.24 342.24 0 01-243.2-100.8c-9.9-9.9-19.2-20.4-27.8-31.4l60.2-47a8 8 0 00-3-14.1l-175.7-43c-5-1.2-9.9 2.6-9.9 7.7l-.7 181c0 6.7 7.7 10.5 12.9 6.3l56.4-44.1C258.2 868.9 377.8 932 512.2 932c229.2 0 415.5-183.7 419.8-411.8a8 8 0 00-8-8.2z"
      }
    }]
  },
  "name": "sync",
  "theme": "outlined"
};
var SyncOutlinedSvg = SyncOutlined$2;
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$4(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$4(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var SyncOutlined = function SyncOutlined2(props2, context) {
  var p2 = _objectSpread$4({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$4({}, p2, {
    "icon": SyncOutlinedSvg
  }), null);
};
SyncOutlined.displayName = "SyncOutlined";
SyncOutlined.inheritAttrs = false;
var SyncOutlined$1 = SyncOutlined;
var UpOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z"
      }
    }]
  },
  "name": "up",
  "theme": "outlined"
};
var UpOutlinedSvg = UpOutlined$2;
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$3(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$3(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var UpOutlined = function UpOutlined2(props2, context) {
  var p2 = _objectSpread$3({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$3({}, p2, {
    "icon": UpOutlinedSvg
  }), null);
};
UpOutlined.displayName = "UpOutlined";
UpOutlined.inheritAttrs = false;
var UpOutlined$1 = UpOutlined;
var UploadOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M400 317.7h73.9V656c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V317.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 163a8 8 0 00-12.6 0l-112 141.7c-4.1 5.3-.4 13 6.3 13zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z"
      }
    }]
  },
  "name": "upload",
  "theme": "outlined"
};
var UploadOutlinedSvg = UploadOutlined$2;
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$2(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$2(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var UploadOutlined = function UploadOutlined2(props2, context) {
  var p2 = _objectSpread$2({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$2({}, p2, {
    "icon": UploadOutlinedSvg
  }), null);
};
UploadOutlined.displayName = "UploadOutlined";
UploadOutlined.inheritAttrs = false;
var UploadOutlined$1 = UploadOutlined;
var UserOutlined$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M858.5 763.6a374 374 0 00-80.6-119.5 375.63 375.63 0 00-119.5-80.6c-.4-.2-.8-.3-1.2-.5C719.5 518 760 444.7 760 362c0-137-111-248-248-248S264 225 264 362c0 82.7 40.5 156 102.8 201.1-.4.2-.8.3-1.2.5-44.8 18.9-85 46-119.5 80.6a375.63 375.63 0 00-80.6 119.5A371.7 371.7 0 00136 901.8a8 8 0 008 8.2h60c4.4 0 7.9-3.5 8-7.8 2-77.2 33-149.5 87.8-204.3 56.7-56.7 132-87.9 212.2-87.9s155.5 31.2 212.2 87.9C779 752.7 810 825 812 902.2c.1 4.4 3.6 7.8 8 7.8h60a8 8 0 008-8.2c-1-47.8-10.9-94.3-29.5-138.2zM512 534c-45.9 0-89.1-17.9-121.6-50.4S340 407.9 340 362c0-45.9 17.9-89.1 50.4-121.6S466.1 190 512 190s89.1 17.9 121.6 50.4S684 316.1 684 362c0 45.9-17.9 89.1-50.4 121.6S557.9 534 512 534z"
      }
    }]
  },
  "name": "user",
  "theme": "outlined"
};
var UserOutlinedSvg = UserOutlined$2;
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$1(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$1(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var UserOutlined = function UserOutlined2(props2, context) {
  var p2 = _objectSpread$1({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread$1({}, p2, {
    "icon": UserOutlinedSvg
  }), null);
};
UserOutlined.displayName = "UserOutlined";
UserOutlined.inheritAttrs = false;
var UserOutlined$1 = UserOutlined;
var WarningFilled$2 = {
  "icon": {
    "tag": "svg",
    "attrs": {
      "viewBox": "64 64 896 896",
      "focusable": "false"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "d": "M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zM480 416c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v184c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V416zm32 352a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
      }
    }]
  },
  "name": "warning",
  "theme": "filled"
};
var WarningFilledSvg = WarningFilled$2;
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var WarningFilled = function WarningFilled2(props2, context) {
  var p2 = _objectSpread({}, props2, context.attrs);
  return Vue.createVNode(AntdIcon, _objectSpread({}, p2, {
    "icon": WarningFilledSvg
  }), null);
};
WarningFilled.displayName = "WarningFilled";
WarningFilled.inheritAttrs = false;
var WarningFilled$1 = WarningFilled;
var operationNodeProps = {
  prefixCls: {
    type: String
  },
  id: {
    type: String
  },
  tabs: {
    type: Object
  },
  rtl: {
    type: Boolean
  },
  tabBarGutter: {
    type: Number
  },
  activeKey: {
    type: [String, Number]
  },
  mobile: {
    type: Boolean
  },
  moreIcon: PropTypes$1.any,
  moreTransitionName: {
    type: String
  },
  editable: {
    type: Object
  },
  locale: {
    type: Object,
    default: void 0
  },
  removeAriaLabel: String,
  onTabClick: {
    type: Function
  }
};
var OperationNode = Vue.defineComponent({
  name: "OperationNode",
  inheritAttrs: false,
  props: operationNodeProps,
  emits: ["tabClick"],
  slots: ["moreIcon"],
  setup: function setup55(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var _useState = useState(false), _useState2 = _slicedToArray(_useState, 2), open2 = _useState2[0], setOpen = _useState2[1];
    var _useState3 = useState(null), _useState4 = _slicedToArray(_useState3, 2), selectedKey = _useState4[0], setSelectedKey = _useState4[1];
    var selectOffset = function selectOffset2(offset3) {
      var enabledTabs = props2.tabs.filter(function(tab2) {
        return !tab2.disabled;
      });
      var selectedIndex = enabledTabs.findIndex(function(tab2) {
        return tab2.key === selectedKey.value;
      }) || 0;
      var len = enabledTabs.length;
      for (var i2 = 0; i2 < len; i2 += 1) {
        selectedIndex = (selectedIndex + offset3 + len) % len;
        var tab = enabledTabs[selectedIndex];
        if (!tab.disabled) {
          setSelectedKey(tab.key);
          return;
        }
      }
    };
    var onKeyDown = function onKeyDown2(e2) {
      var which = e2.which;
      if (!open2.value) {
        if ([KeyCode$1.DOWN, KeyCode$1.SPACE, KeyCode$1.ENTER].includes(which)) {
          setOpen(true);
          e2.preventDefault();
        }
        return;
      }
      switch (which) {
        case KeyCode$1.UP:
          selectOffset(-1);
          e2.preventDefault();
          break;
        case KeyCode$1.DOWN:
          selectOffset(1);
          e2.preventDefault();
          break;
        case KeyCode$1.ESC:
          setOpen(false);
          break;
        case KeyCode$1.SPACE:
        case KeyCode$1.ENTER:
          if (selectedKey.value !== null)
            props2.onTabClick(selectedKey.value, e2);
          break;
      }
    };
    var popupId = Vue.computed(function() {
      return "".concat(props2.id, "-more-popup");
    });
    var selectedItemId = Vue.computed(function() {
      return selectedKey.value !== null ? "".concat(popupId.value, "-").concat(selectedKey.value) : null;
    });
    var onRemoveTab = function onRemoveTab2(event, key2) {
      event.preventDefault();
      event.stopPropagation();
      props2.editable.onEdit("remove", {
        key: key2,
        event
      });
    };
    Vue.onMounted(function() {
      Vue.watch(selectedKey, function() {
        var ele = document.getElementById(selectedItemId.value);
        if (ele && ele.scrollIntoView) {
          ele.scrollIntoView(false);
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    Vue.watch(open2, function() {
      if (!open2.value) {
        setSelectedKey(null);
      }
    });
    return function() {
      var _a;
      var prefixCls = props2.prefixCls, id = props2.id, tabs = props2.tabs, locale2 = props2.locale, mobile = props2.mobile, _props$moreIcon = props2.moreIcon, moreIcon = _props$moreIcon === void 0 ? ((_a = slots.moreIcon) === null || _a === void 0 ? void 0 : _a.call(slots)) || Vue.createVNode(EllipsisOutlined$1, null, null) : _props$moreIcon, moreTransitionName = props2.moreTransitionName, editable = props2.editable, tabBarGutter = props2.tabBarGutter, rtl2 = props2.rtl, onTabClick = props2.onTabClick;
      var dropdownPrefix = "".concat(prefixCls, "-dropdown");
      var dropdownAriaLabel = locale2 === null || locale2 === void 0 ? void 0 : locale2.dropdownAriaLabel;
      var moreStyle = _defineProperty$T({}, rtl2 ? "marginRight" : "marginLeft", tabBarGutter);
      if (!tabs.length) {
        moreStyle.visibility = "hidden";
        moreStyle.order = 1;
      }
      var overlayClassName = classNames(_defineProperty$T({}, "".concat(dropdownPrefix, "-rtl"), rtl2));
      var moreNode = mobile ? null : Vue.createVNode(Dropdown$1, {
        "prefixCls": dropdownPrefix,
        "trigger": ["hover"],
        "visible": open2.value,
        "transitionName": moreTransitionName,
        "onVisibleChange": setOpen,
        "overlayClassName": overlayClassName,
        "mouseEnterDelay": 0.1,
        "mouseLeaveDelay": 0.1
      }, {
        overlay: function overlay() {
          return Vue.createVNode(Menu, {
            "onClick": function onClick2(_ref2) {
              var key2 = _ref2.key, domEvent = _ref2.domEvent;
              onTabClick(key2, domEvent);
              setOpen(false);
            },
            "id": popupId.value,
            "tabindex": -1,
            "role": "listbox",
            "aria-activedescendant": selectedItemId.value,
            "selectedKeys": [selectedKey.value],
            "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
          }, {
            default: function _default5() {
              return [tabs.map(function(tab) {
                var _a2, _b;
                var removable = editable && tab.closable !== false && !tab.disabled;
                return Vue.createVNode(MenuItem$1, {
                  "key": tab.key,
                  "id": "".concat(popupId.value, "-").concat(tab.key),
                  "role": "option",
                  "aria-controls": id && "".concat(id, "-panel-").concat(tab.key),
                  "disabled": tab.disabled
                }, {
                  default: function _default6() {
                    return [Vue.createVNode("span", null, [typeof tab.tab === "function" ? tab.tab() : tab.tab]), removable && Vue.createVNode("button", {
                      "type": "button",
                      "aria-label": props2.removeAriaLabel || "remove",
                      "tabindex": 0,
                      "class": "".concat(dropdownPrefix, "-menu-item-remove"),
                      "onClick": function onClick2(e2) {
                        e2.stopPropagation();
                        onRemoveTab(e2, tab.key);
                      }
                    }, [((_a2 = tab.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(tab)) || ((_b = editable.removeIcon) === null || _b === void 0 ? void 0 : _b.call(editable)) || "\xD7"])];
                  }
                });
              })];
            }
          });
        },
        default: function _default5() {
          return Vue.createVNode("button", {
            "type": "button",
            "class": "".concat(prefixCls, "-nav-more"),
            "style": moreStyle,
            "tabindex": -1,
            "aria-hidden": "true",
            "aria-haspopup": "listbox",
            "aria-controls": popupId.value,
            "id": "".concat(id, "-more"),
            "aria-expanded": open2.value,
            "onKeydown": onKeyDown
          }, [moreIcon]);
        }
      });
      return Vue.createVNode("div", {
        "class": classNames("".concat(prefixCls, "-nav-operations"), attrs.class),
        "style": attrs.style
      }, [moreNode, Vue.createVNode(AddButton, {
        "prefixCls": prefixCls,
        "locale": locale2,
        "editable": editable
      }, null)]);
    };
  }
});
var TabsContextKey = Symbol("tabsContextKey");
var useProvideTabs = function useProvideTabs2(props2) {
  Vue.provide(TabsContextKey, props2);
};
var useInjectTabs = function useInjectTabs2() {
  return Vue.inject(TabsContextKey, {
    tabs: Vue.ref([]),
    prefixCls: Vue.ref()
  });
};
Vue.defineComponent({
  name: "TabsContextProvider",
  inheritAttrs: false,
  props: {
    tabs: {
      type: Object,
      default: void 0
    },
    prefixCls: {
      type: String,
      default: void 0
    }
  },
  setup: function setup56(props2, _ref) {
    var slots = _ref.slots;
    useProvideTabs(Vue.toRefs(props2));
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
  }
});
var MIN_SWIPE_DISTANCE = 0.1;
var STOP_SWIPE_DISTANCE = 0.01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL);
function useTouchMove(domRef, onOffset) {
  var _useState = useState(), _useState2 = _slicedToArray(_useState, 2), touchPosition = _useState2[0], setTouchPosition = _useState2[1];
  var _useState3 = useState(0), _useState4 = _slicedToArray(_useState3, 2), lastTimestamp = _useState4[0], setLastTimestamp = _useState4[1];
  var _useState5 = useState(0), _useState6 = _slicedToArray(_useState5, 2), lastTimeDiff = _useState6[0], setLastTimeDiff = _useState6[1];
  var _useState7 = useState(), _useState8 = _slicedToArray(_useState7, 2), lastOffset = _useState8[0], setLastOffset = _useState8[1];
  var motionInterval = Vue.ref();
  function onTouchStart(e2) {
    var _e$touches$ = e2.touches[0], screenX = _e$touches$.screenX, screenY = _e$touches$.screenY;
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    clearInterval(motionInterval.value);
  }
  function onTouchMove(e2) {
    if (!touchPosition.value)
      return;
    e2.preventDefault();
    var _e$touches$2 = e2.touches[0], screenX = _e$touches$2.screenX, screenY = _e$touches$2.screenY;
    var offsetX = screenX - touchPosition.value.x;
    var offsetY = screenY - touchPosition.value.y;
    onOffset(offsetX, offsetY);
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    var now2 = Date.now();
    setLastTimeDiff(now2 - lastTimestamp.value);
    setLastTimestamp(now2);
    setLastOffset({
      x: offsetX,
      y: offsetY
    });
  }
  function onTouchEnd() {
    if (!touchPosition.value)
      return;
    var lastOffsetValue = lastOffset.value;
    setTouchPosition(null);
    setLastOffset(null);
    if (lastOffsetValue) {
      var distanceX = lastOffsetValue.x / lastTimeDiff.value;
      var distanceY = lastOffsetValue.y / lastTimeDiff.value;
      var absX = Math.abs(distanceX);
      var absY = Math.abs(distanceY);
      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE)
        return;
      var currentX = distanceX;
      var currentY = distanceY;
      motionInterval.value = setInterval(function() {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          clearInterval(motionInterval.value);
          return;
        }
        currentX *= SPEED_OFF_MULTIPLE;
        currentY *= SPEED_OFF_MULTIPLE;
        onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
      }, REFRESH_INTERVAL);
    }
  }
  var lastWheelDirectionRef = Vue.ref();
  function onWheel(e2) {
    var deltaX = e2.deltaX, deltaY = e2.deltaY;
    var mixed = 0;
    var absX = Math.abs(deltaX);
    var absY = Math.abs(deltaY);
    if (absX === absY) {
      mixed = lastWheelDirectionRef.value === "x" ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.value = "x";
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.value = "y";
    }
    if (onOffset(-mixed, -mixed)) {
      e2.preventDefault();
    }
  }
  var touchEventsRef = Vue.ref({
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onWheel
  });
  function onProxyTouchStart(e2) {
    touchEventsRef.value.onTouchStart(e2);
  }
  function onProxyTouchMove(e2) {
    touchEventsRef.value.onTouchMove(e2);
  }
  function onProxyTouchEnd(e2) {
    touchEventsRef.value.onTouchEnd(e2);
  }
  function onProxyWheel(e2) {
    touchEventsRef.value.onWheel(e2);
  }
  Vue.onMounted(function() {
    var _a, _b;
    document.addEventListener("touchmove", onProxyTouchMove, {
      passive: false
    });
    document.addEventListener("touchend", onProxyTouchEnd, {
      passive: false
    });
    (_a = domRef.value) === null || _a === void 0 ? void 0 : _a.addEventListener("touchstart", onProxyTouchStart, {
      passive: false
    });
    (_b = domRef.value) === null || _b === void 0 ? void 0 : _b.addEventListener("wheel", onProxyWheel, {
      passive: false
    });
  });
  Vue.onBeforeUnmount(function() {
    document.removeEventListener("touchmove", onProxyTouchMove);
    document.removeEventListener("touchend", onProxyTouchEnd);
  });
}
function useSyncState(defaultState, onChange) {
  var stateRef = Vue.ref(defaultState);
  function setState2(updater) {
    var newValue = typeof updater === "function" ? updater(stateRef.value) : updater;
    if (newValue !== stateRef.value) {
      onChange(newValue, stateRef.value);
    }
    stateRef.value = newValue;
  }
  return [stateRef, setState2];
}
function baseSet(object, path, value, customizer) {
  if (!isObject$2(object)) {
    return object;
  }
  path = castPath(path, object);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index2 < length) {
    var key2 = toKey(path[index2]), newValue = value;
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key2];
      newValue = customizer ? customizer(objValue, key2, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$2(objValue) ? objValue : isIndex$2(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key2, newValue);
    nested = nested[key2];
  }
  return object;
}
function basePickBy(object, paths, predicate) {
  var index2 = -1, length = paths.length, result = {};
  while (++index2 < length) {
    var path = paths[index2], value = baseGet(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick$1 = pick;
var DEFAULT_SIZE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
var tabNavListProps = function tabNavListProps2() {
  return {
    id: {
      type: String
    },
    tabPosition: {
      type: String
    },
    activeKey: {
      type: [String, Number]
    },
    rtl: {
      type: Boolean
    },
    animated: {
      type: Object,
      default: void 0
    },
    editable: {
      type: Object
    },
    moreIcon: PropTypes$1.any,
    moreTransitionName: {
      type: String
    },
    mobile: {
      type: Boolean
    },
    tabBarGutter: {
      type: Number
    },
    renderTabBar: {
      type: Function
    },
    locale: {
      type: Object,
      default: void 0
    },
    onTabClick: {
      type: Function
    },
    onTabScroll: {
      type: Function
    }
  };
};
var TabNavList = Vue.defineComponent({
  name: "TabNavList",
  inheritAttrs: false,
  props: tabNavListProps(),
  slots: ["moreIcon", "leftExtra", "rightExtra", "tabBarExtraContent"],
  emits: ["tabClick", "tabScroll"],
  setup: function setup57(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var _useInjectTabs = useInjectTabs(), tabs = _useInjectTabs.tabs, prefixCls = _useInjectTabs.prefixCls;
    var tabsWrapperRef = Vue.ref();
    var tabListRef = Vue.ref();
    var operationsRef = Vue.ref();
    var innerAddButtonRef = Vue.ref();
    var _useRefs = useRefs$1(), _useRefs2 = _slicedToArray(_useRefs, 2), setRef = _useRefs2[0], btnRefs = _useRefs2[1];
    var tabPositionTopOrBottom = Vue.computed(function() {
      return props2.tabPosition === "top" || props2.tabPosition === "bottom";
    });
    var _useSyncState = useSyncState(0, function(next2, prev2) {
      if (tabPositionTopOrBottom.value && props2.onTabScroll) {
        props2.onTabScroll({
          direction: next2 > prev2 ? "left" : "right"
        });
      }
    }), _useSyncState2 = _slicedToArray(_useSyncState, 2), transformLeft = _useSyncState2[0], setTransformLeft = _useSyncState2[1];
    var _useSyncState3 = useSyncState(0, function(next2, prev2) {
      if (!tabPositionTopOrBottom.value && props2.onTabScroll) {
        props2.onTabScroll({
          direction: next2 > prev2 ? "top" : "bottom"
        });
      }
    }), _useSyncState4 = _slicedToArray(_useSyncState3, 2), transformTop = _useSyncState4[0], setTransformTop = _useSyncState4[1];
    var _useState = useState(0), _useState2 = _slicedToArray(_useState, 2), wrapperScrollWidth = _useState2[0], setWrapperScrollWidth = _useState2[1];
    var _useState3 = useState(0), _useState4 = _slicedToArray(_useState3, 2), wrapperScrollHeight = _useState4[0], setWrapperScrollHeight = _useState4[1];
    var _useState5 = useState(null), _useState6 = _slicedToArray(_useState5, 2), wrapperWidth = _useState6[0], setWrapperWidth = _useState6[1];
    var _useState7 = useState(null), _useState8 = _slicedToArray(_useState7, 2), wrapperHeight = _useState8[0], setWrapperHeight = _useState8[1];
    var _useState9 = useState(0), _useState10 = _slicedToArray(_useState9, 2), addWidth = _useState10[0], setAddWidth = _useState10[1];
    var _useState11 = useState(0), _useState12 = _slicedToArray(_useState11, 2), addHeight = _useState12[0], setAddHeight = _useState12[1];
    var _useRafState = useRafState(/* @__PURE__ */ new Map()), _useRafState2 = _slicedToArray(_useRafState, 2), tabSizes = _useRafState2[0], setTabSizes = _useRafState2[1];
    var tabOffsets = useOffsets(tabs, tabSizes);
    var operationsHiddenClassName = Vue.computed(function() {
      return "".concat(prefixCls.value, "-nav-operations-hidden");
    });
    var transformMin = Vue.ref(0);
    var transformMax = Vue.ref(0);
    Vue.watchEffect(function() {
      if (!tabPositionTopOrBottom.value) {
        transformMin.value = Math.min(0, wrapperHeight.value - wrapperScrollHeight.value);
        transformMax.value = 0;
      } else if (props2.rtl) {
        transformMin.value = 0;
        transformMax.value = Math.max(0, wrapperScrollWidth.value - wrapperWidth.value);
      } else {
        transformMin.value = Math.min(0, wrapperWidth.value - wrapperScrollWidth.value);
        transformMax.value = 0;
      }
    });
    var alignInRange = function alignInRange2(value) {
      if (value < transformMin.value) {
        return transformMin.value;
      }
      if (value > transformMax.value) {
        return transformMax.value;
      }
      return value;
    };
    var touchMovingRef = Vue.ref();
    var _useState13 = useState(), _useState14 = _slicedToArray(_useState13, 2), lockAnimation = _useState14[0], setLockAnimation = _useState14[1];
    var doLockAnimation = function doLockAnimation2() {
      setLockAnimation(Date.now());
    };
    var clearTouchMoving = function clearTouchMoving2() {
      clearTimeout(touchMovingRef.value);
    };
    var doMove = function doMove2(setState2, offset3) {
      setState2(function(value) {
        var newValue = alignInRange(value + offset3);
        return newValue;
      });
    };
    useTouchMove(tabsWrapperRef, function(offsetX, offsetY) {
      if (tabPositionTopOrBottom.value) {
        if (wrapperWidth.value >= wrapperScrollWidth.value) {
          return false;
        }
        doMove(setTransformLeft, offsetX);
      } else {
        if (wrapperHeight.value >= wrapperScrollHeight.value) {
          return false;
        }
        doMove(setTransformTop, offsetY);
      }
      clearTouchMoving();
      doLockAnimation();
      return true;
    });
    Vue.watch(lockAnimation, function() {
      clearTouchMoving();
      if (lockAnimation.value) {
        touchMovingRef.value = setTimeout(function() {
          setLockAnimation(0);
        }, 100);
      }
    });
    var scrollToTab = function scrollToTab2() {
      var key2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props2.activeKey;
      var tabOffset = tabOffsets.value.get(key2) || {
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0
      };
      if (tabPositionTopOrBottom.value) {
        var newTransform = transformLeft.value;
        if (props2.rtl) {
          if (tabOffset.right < transformLeft.value) {
            newTransform = tabOffset.right;
          } else if (tabOffset.right + tabOffset.width > transformLeft.value + wrapperWidth.value) {
            newTransform = tabOffset.right + tabOffset.width - wrapperWidth.value;
          }
        } else if (tabOffset.left < -transformLeft.value) {
          newTransform = -tabOffset.left;
        } else if (tabOffset.left + tabOffset.width > -transformLeft.value + wrapperWidth.value) {
          newTransform = -(tabOffset.left + tabOffset.width - wrapperWidth.value);
        }
        setTransformTop(0);
        setTransformLeft(alignInRange(newTransform));
      } else {
        var _newTransform = transformTop.value;
        if (tabOffset.top < -transformTop.value) {
          _newTransform = -tabOffset.top;
        } else if (tabOffset.top + tabOffset.height > -transformTop.value + wrapperHeight.value) {
          _newTransform = -(tabOffset.top + tabOffset.height - wrapperHeight.value);
        }
        setTransformLeft(0);
        setTransformTop(alignInRange(_newTransform));
      }
    };
    var visibleStart = Vue.ref(0);
    var visibleEnd = Vue.ref(0);
    Vue.watchEffect(function() {
      var _ref3;
      var unit;
      var position;
      var transformSize;
      var basicSize;
      var tabContentSize;
      var addSize;
      var tabOffsetsValue = tabOffsets.value;
      if (["top", "bottom"].includes(props2.tabPosition)) {
        unit = "width";
        basicSize = wrapperWidth.value;
        tabContentSize = wrapperScrollWidth.value;
        addSize = addWidth.value;
        position = props2.rtl ? "right" : "left";
        transformSize = Math.abs(transformLeft.value);
      } else {
        unit = "height";
        basicSize = wrapperHeight.value;
        tabContentSize = wrapperScrollWidth.value;
        addSize = addHeight.value;
        position = "top";
        transformSize = -transformTop.value;
      }
      var mergedBasicSize = basicSize;
      if (tabContentSize + addSize > basicSize && tabContentSize < basicSize) {
        mergedBasicSize = basicSize - addSize;
      }
      var tabsVal = tabs.value;
      if (!tabsVal.length) {
        var _ref2;
        return _ref2 = [0, 0], visibleStart.value = _ref2[0], visibleEnd.value = _ref2[1], _ref2;
      }
      var len = tabsVal.length;
      var endIndex = len;
      for (var i2 = 0; i2 < len; i2 += 1) {
        var offset3 = tabOffsetsValue.get(tabsVal[i2].key) || DEFAULT_SIZE;
        if (offset3[position] + offset3[unit] > transformSize + mergedBasicSize) {
          endIndex = i2 - 1;
          break;
        }
      }
      var startIndex = 0;
      for (var _i = len - 1; _i >= 0; _i -= 1) {
        var _offset = tabOffsetsValue.get(tabsVal[_i].key) || DEFAULT_SIZE;
        if (_offset[position] < transformSize) {
          startIndex = _i + 1;
          break;
        }
      }
      return _ref3 = [startIndex, endIndex], visibleStart.value = _ref3[0], visibleEnd.value = _ref3[1], _ref3;
    });
    var onListHolderResize = function onListHolderResize2() {
      var _a, _b, _c, _d, _e;
      var offsetWidth = ((_a = tabsWrapperRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth) || 0;
      var offsetHeight = ((_b = tabsWrapperRef.value) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;
      var addDom = ((_c = innerAddButtonRef.value) === null || _c === void 0 ? void 0 : _c.$el) || {};
      var newAddWidth = addDom.offsetWidth || 0;
      var newAddHeight = addDom.offsetHeight || 0;
      setWrapperWidth(offsetWidth);
      setWrapperHeight(offsetHeight);
      setAddWidth(newAddWidth);
      setAddHeight(newAddHeight);
      var newWrapperScrollWidth = (((_d = tabListRef.value) === null || _d === void 0 ? void 0 : _d.offsetWidth) || 0) - newAddWidth;
      var newWrapperScrollHeight = (((_e = tabListRef.value) === null || _e === void 0 ? void 0 : _e.offsetHeight) || 0) - newAddHeight;
      setWrapperScrollWidth(newWrapperScrollWidth);
      setWrapperScrollHeight(newWrapperScrollHeight);
      setTabSizes(function() {
        var newSizes = /* @__PURE__ */ new Map();
        tabs.value.forEach(function(_ref4) {
          var key2 = _ref4.key;
          var _a2;
          var btnRef = btnRefs.value.get(key2);
          var btnNode = ((_a2 = btnRef) === null || _a2 === void 0 ? void 0 : _a2.$el) || btnRef;
          if (btnNode) {
            newSizes.set(key2, {
              width: btnNode.offsetWidth,
              height: btnNode.offsetHeight,
              left: btnNode.offsetLeft,
              top: btnNode.offsetTop
            });
          }
        });
        return newSizes;
      });
    };
    var hiddenTabs = Vue.computed(function() {
      return [].concat(_toConsumableArray(tabs.value.slice(0, visibleStart.value)), _toConsumableArray(tabs.value.slice(visibleEnd.value + 1)));
    });
    var _useState15 = useState(), _useState16 = _slicedToArray(_useState15, 2), inkStyle = _useState16[0], setInkStyle = _useState16[1];
    var activeTabOffset = Vue.computed(function() {
      return tabOffsets.value.get(props2.activeKey);
    });
    var inkBarRafRef = Vue.ref();
    var cleanInkBarRaf = function cleanInkBarRaf2() {
      wrapperRaf.cancel(inkBarRafRef.value);
    };
    Vue.watch([activeTabOffset, tabPositionTopOrBottom, function() {
      return props2.rtl;
    }], function() {
      var newInkStyle = {};
      if (activeTabOffset.value) {
        if (tabPositionTopOrBottom.value) {
          if (props2.rtl) {
            newInkStyle.right = toPx(activeTabOffset.value.right);
          } else {
            newInkStyle.left = toPx(activeTabOffset.value.left);
          }
          newInkStyle.width = toPx(activeTabOffset.value.width);
        } else {
          newInkStyle.top = toPx(activeTabOffset.value.top);
          newInkStyle.height = toPx(activeTabOffset.value.height);
        }
      }
      cleanInkBarRaf();
      inkBarRafRef.value = wrapperRaf(function() {
        setInkStyle(newInkStyle);
      });
    });
    Vue.watch([function() {
      return props2.activeKey;
    }, activeTabOffset, tabOffsets, tabPositionTopOrBottom], function() {
      scrollToTab();
    }, {
      flush: "post"
    });
    Vue.watch([function() {
      return props2.rtl;
    }, function() {
      return props2.tabBarGutter;
    }, function() {
      return props2.activeKey;
    }, function() {
      return tabs.value;
    }], function() {
      onListHolderResize();
    }, {
      flush: "post"
    });
    var ExtraContent = function ExtraContent2(_ref5) {
      var position = _ref5.position, prefixCls2 = _ref5.prefixCls, extra = _ref5.extra;
      if (!extra)
        return null;
      var content = extra === null || extra === void 0 ? void 0 : extra({
        position
      });
      return content ? Vue.createVNode("div", {
        "class": "".concat(prefixCls2, "-extra-content")
      }, [content]) : null;
    };
    Vue.onBeforeUnmount(function() {
      clearTouchMoving();
      cleanInkBarRaf();
    });
    return function() {
      var _classNames;
      var id = props2.id, animated = props2.animated, activeKey = props2.activeKey, rtl2 = props2.rtl, editable = props2.editable, locale2 = props2.locale, tabPosition = props2.tabPosition, tabBarGutter = props2.tabBarGutter, onTabClick = props2.onTabClick;
      var className = attrs.class, style = attrs.style;
      var pre = prefixCls.value;
      var hasDropdown = !!hiddenTabs.value.length;
      var wrapPrefix = "".concat(pre, "-nav-wrap");
      var pingLeft;
      var pingRight;
      var pingTop;
      var pingBottom;
      if (tabPositionTopOrBottom.value) {
        if (rtl2) {
          pingRight = transformLeft.value > 0;
          pingLeft = transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;
        } else {
          pingLeft = transformLeft.value < 0;
          pingRight = -transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;
        }
      } else {
        pingTop = transformTop.value < 0;
        pingBottom = -transformTop.value + wrapperHeight.value < wrapperScrollHeight.value;
      }
      var tabNodeStyle = {};
      if (tabPosition === "top" || tabPosition === "bottom") {
        tabNodeStyle[rtl2 ? "marginRight" : "marginLeft"] = typeof tabBarGutter === "number" ? "".concat(tabBarGutter, "px") : tabBarGutter;
      } else {
        tabNodeStyle.marginTop = typeof tabBarGutter === "number" ? "".concat(tabBarGutter, "px") : tabBarGutter;
      }
      var tabNodes = tabs.value.map(function(tab, i2) {
        var key2 = tab.key;
        return Vue.createVNode(TabNode, {
          "id": id,
          "prefixCls": pre,
          "key": key2,
          "tab": tab,
          "style": i2 === 0 ? void 0 : tabNodeStyle,
          "closable": tab.closable,
          "editable": editable,
          "active": key2 === activeKey,
          "removeAriaLabel": locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
          "ref": setRef(key2),
          "onClick": function onClick2(e2) {
            onTabClick(key2, e2);
          },
          "onFocus": function onFocus2() {
            scrollToTab(key2);
            doLockAnimation();
            if (!tabsWrapperRef.value) {
              return;
            }
            if (!rtl2) {
              tabsWrapperRef.value.scrollLeft = 0;
            }
            tabsWrapperRef.value.scrollTop = 0;
          }
        }, slots);
      });
      return Vue.createVNode("div", {
        "role": "tablist",
        "class": classNames("".concat(pre, "-nav"), className),
        "style": style,
        "onKeydown": function onKeydown() {
          doLockAnimation();
        }
      }, [Vue.createVNode(ExtraContent, {
        "position": "left",
        "prefixCls": pre,
        "extra": slots.leftExtra
      }, null), Vue.createVNode(ResizeObserver$1, {
        "onResize": onListHolderResize
      }, {
        default: function _default5() {
          return [Vue.createVNode("div", {
            "class": classNames(wrapPrefix, (_classNames = {}, _defineProperty$T(_classNames, "".concat(wrapPrefix, "-ping-left"), pingLeft), _defineProperty$T(_classNames, "".concat(wrapPrefix, "-ping-right"), pingRight), _defineProperty$T(_classNames, "".concat(wrapPrefix, "-ping-top"), pingTop), _defineProperty$T(_classNames, "".concat(wrapPrefix, "-ping-bottom"), pingBottom), _classNames)),
            "ref": tabsWrapperRef
          }, [Vue.createVNode(ResizeObserver$1, {
            "onResize": onListHolderResize
          }, {
            default: function _default6() {
              return [Vue.createVNode("div", {
                "ref": tabListRef,
                "class": "".concat(pre, "-nav-list"),
                "style": {
                  transform: "translate(".concat(transformLeft.value, "px, ").concat(transformTop.value, "px)"),
                  transition: lockAnimation.value ? "none" : void 0
                }
              }, [tabNodes, Vue.createVNode(AddButton, {
                "ref": innerAddButtonRef,
                "prefixCls": pre,
                "locale": locale2,
                "editable": editable,
                "style": _extends(_extends({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {
                  visibility: hasDropdown ? "hidden" : null
                })
              }, null), Vue.createVNode("div", {
                "class": classNames("".concat(pre, "-ink-bar"), _defineProperty$T({}, "".concat(pre, "-ink-bar-animated"), animated.inkBar)),
                "style": inkStyle.value
              }, null)])];
            }
          })])];
        }
      }), Vue.createVNode(OperationNode, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
        "removeAriaLabel": locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
        "ref": operationsRef,
        "prefixCls": pre,
        "tabs": hiddenTabs.value,
        "class": !hasDropdown && operationsHiddenClassName.value
      }), pick$1(slots, ["moreIcon"])), Vue.createVNode(ExtraContent, {
        "position": "right",
        "prefixCls": pre,
        "extra": slots.rightExtra
      }, null), Vue.createVNode(ExtraContent, {
        "position": "right",
        "prefixCls": pre,
        "extra": slots.tabBarExtraContent
      }, null)]);
    };
  }
});
var TabPanelList = Vue.defineComponent({
  name: "TabPanelList",
  inheritAttrs: false,
  props: {
    activeKey: {
      type: [String, Number]
    },
    id: {
      type: String
    },
    rtl: {
      type: Boolean
    },
    animated: {
      type: Object,
      default: void 0
    },
    tabPosition: {
      type: String
    },
    destroyInactiveTabPane: {
      type: Boolean
    }
  },
  setup: function setup58(props2) {
    var _useInjectTabs = useInjectTabs(), tabs = _useInjectTabs.tabs, prefixCls = _useInjectTabs.prefixCls;
    return function() {
      var id = props2.id, activeKey = props2.activeKey, animated = props2.animated, tabPosition = props2.tabPosition, rtl2 = props2.rtl, destroyInactiveTabPane = props2.destroyInactiveTabPane;
      var tabPaneAnimated = animated.tabPane;
      var pre = prefixCls.value;
      var activeIndex = tabs.value.findIndex(function(tab) {
        return tab.key === activeKey;
      });
      return Vue.createVNode("div", {
        "class": "".concat(pre, "-content-holder")
      }, [Vue.createVNode("div", {
        "class": ["".concat(pre, "-content"), "".concat(pre, "-content-").concat(tabPosition), _defineProperty$T({}, "".concat(pre, "-content-animated"), tabPaneAnimated)],
        "style": activeIndex && tabPaneAnimated ? _defineProperty$T({}, rtl2 ? "marginRight" : "marginLeft", "-".concat(activeIndex, "00%")) : null
      }, [tabs.value.map(function(tab) {
        return cloneElement(tab.node, {
          key: tab.key,
          prefixCls: pre,
          tabKey: tab.key,
          id,
          animated: tabPaneAnimated,
          active: tab.key === activeKey,
          destroyInactiveTabPane
        });
      })])]);
    };
  }
});
var isMobile$2 = function() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4))) {
    return true;
  }
  return false;
};
var uuid$3 = 0;
var tabsProps = function tabsProps2() {
  return {
    prefixCls: {
      type: String
    },
    id: {
      type: String
    },
    activeKey: {
      type: [String, Number]
    },
    defaultActiveKey: {
      type: [String, Number]
    },
    direction: {
      type: String
    },
    animated: {
      type: [Boolean, Object]
    },
    renderTabBar: {
      type: Function
    },
    tabBarGutter: {
      type: Number
    },
    tabBarStyle: {
      type: Object
    },
    tabPosition: {
      type: String
    },
    destroyInactiveTabPane: {
      type: Boolean
    },
    hideAdd: Boolean,
    type: {
      type: String
    },
    size: {
      type: String
    },
    centered: Boolean,
    onEdit: {
      type: Function
    },
    onChange: {
      type: Function
    },
    onTabClick: {
      type: Function
    },
    onTabScroll: {
      type: Function
    },
    "onUpdate:activeKey": {
      type: Function
    },
    locale: {
      type: Object,
      default: void 0
    },
    onPrevClick: Function,
    onNextClick: Function,
    tabBarExtraContent: PropTypes$1.any
  };
};
function parseTabList(children) {
  return children.map(function(node) {
    if (isValidElement(node)) {
      var props2 = _extends({}, node.props || {});
      for (var _i = 0, _Object$entries = Object.entries(props2); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), k2 = _Object$entries$_i[0], v2 = _Object$entries$_i[1];
        delete props2[k2];
        props2[Vue.camelize(k2)] = v2;
      }
      var slots = node.children || {};
      var key2 = node.key !== void 0 ? node.key : void 0;
      var _props$tab = props2.tab, tab = _props$tab === void 0 ? slots.tab : _props$tab, disabled = props2.disabled, forceRender = props2.forceRender, closable = props2.closable, animated = props2.animated, active = props2.active, destroyInactiveTabPane = props2.destroyInactiveTabPane;
      return _extends(_extends({
        key: key2
      }, props2), {
        node,
        closeIcon: slots.closeIcon,
        tab,
        disabled: disabled === "" || disabled,
        forceRender: forceRender === "" || forceRender,
        closable: closable === "" || closable,
        animated: animated === "" || animated,
        active: active === "" || active,
        destroyInactiveTabPane: destroyInactiveTabPane === "" || destroyInactiveTabPane
      });
    }
    return null;
  }).filter(function(tab) {
    return tab;
  });
}
var InternalTabs = Vue.defineComponent({
  name: "InternalTabs",
  inheritAttrs: false,
  props: _extends(_extends({}, initDefaultProps$1(tabsProps(), {
    tabPosition: "top",
    animated: {
      inkBar: true,
      tabPane: false
    }
  })), {
    tabs: {
      type: Array
    }
  }),
  slots: ["tabBarExtraContent", "leftExtra", "rightExtra", "moreIcon", "addIcon", "removeIcon", "renderTabBar"],
  setup: function setup59(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    devWarning(!(props2.onPrevClick !== void 0) && !(props2.onNextClick !== void 0), "Tabs", "`onPrevClick / @prevClick` and `onNextClick / @nextClick` has been removed. Please use `onTabScroll / @tabScroll` instead.");
    devWarning(!(props2.tabBarExtraContent !== void 0), "Tabs", "`tabBarExtraContent` prop has been removed. Please use `rightExtra` slot instead.");
    devWarning(!(slots.tabBarExtraContent !== void 0), "Tabs", "`tabBarExtraContent` slot is deprecated. Please use `rightExtra` slot instead.");
    var _useConfigInject = useConfigInject("tabs", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, size = _useConfigInject.size, rootPrefixCls = _useConfigInject.rootPrefixCls;
    var rtl2 = Vue.computed(function() {
      return direction.value === "rtl";
    });
    var mergedAnimated = Vue.computed(function() {
      var animated = props2.animated, tabPosition = props2.tabPosition;
      if (animated === false || ["left", "right"].includes(tabPosition)) {
        return {
          inkBar: false,
          tabPane: false
        };
      } else if (animated === true) {
        return {
          inkBar: true,
          tabPane: true
        };
      } else {
        return _extends({
          inkBar: true,
          tabPane: false
        }, _typeof$1(animated) === "object" ? animated : {});
      }
    });
    var _useState = useState(false), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
    Vue.onMounted(function() {
      setMobile(isMobile$2());
    });
    var _useMergedState = useMergedState(function() {
      var _a;
      return (_a = props2.tabs[0]) === null || _a === void 0 ? void 0 : _a.key;
    }, {
      value: Vue.computed(function() {
        return props2.activeKey;
      }),
      defaultValue: props2.defaultActiveKey
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedActiveKey = _useMergedState2[0], setMergedActiveKey = _useMergedState2[1];
    var _useState3 = useState(function() {
      return props2.tabs.findIndex(function(tab) {
        return tab.key === mergedActiveKey.value;
      });
    }), _useState4 = _slicedToArray(_useState3, 2), activeIndex = _useState4[0], setActiveIndex = _useState4[1];
    Vue.watchEffect(function() {
      var _a;
      var newActiveIndex = props2.tabs.findIndex(function(tab) {
        return tab.key === mergedActiveKey.value;
      });
      if (newActiveIndex === -1) {
        newActiveIndex = Math.max(0, Math.min(activeIndex.value, props2.tabs.length - 1));
        setMergedActiveKey((_a = props2.tabs[newActiveIndex]) === null || _a === void 0 ? void 0 : _a.key);
      }
      setActiveIndex(newActiveIndex);
    });
    var _useMergedState3 = useMergedState(null, {
      value: Vue.computed(function() {
        return props2.id;
      })
    }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedId = _useMergedState4[0], setMergedId = _useMergedState4[1];
    var mergedTabPosition = Vue.computed(function() {
      if (mobile.value && !["left", "right"].includes(props2.tabPosition)) {
        return "top";
      } else {
        return props2.tabPosition;
      }
    });
    Vue.onMounted(function() {
      if (!props2.id) {
        setMergedId("rc-tabs-".concat(uuid$3));
        uuid$3 += 1;
      }
    });
    var onInternalTabClick = function onInternalTabClick2(key2, e2) {
      var _a, _b;
      (_a = props2.onTabClick) === null || _a === void 0 ? void 0 : _a.call(props2, key2, e2);
      var isActiveChanged = key2 !== mergedActiveKey.value;
      setMergedActiveKey(key2);
      if (isActiveChanged) {
        (_b = props2.onChange) === null || _b === void 0 ? void 0 : _b.call(props2, key2);
      }
    };
    useProvideTabs({
      tabs: Vue.computed(function() {
        return props2.tabs;
      }),
      prefixCls
    });
    return function() {
      var _classNames;
      var id = props2.id, type2 = props2.type, tabBarGutter = props2.tabBarGutter, tabBarStyle = props2.tabBarStyle, locale2 = props2.locale, destroyInactiveTabPane = props2.destroyInactiveTabPane, _props$renderTabBar = props2.renderTabBar, renderTabBar = _props$renderTabBar === void 0 ? slots.renderTabBar : _props$renderTabBar, onTabScroll = props2.onTabScroll, hideAdd = props2.hideAdd, centered = props2.centered;
      var sharedProps = {
        id: mergedId.value,
        activeKey: mergedActiveKey.value,
        animated: mergedAnimated.value,
        tabPosition: mergedTabPosition.value,
        rtl: rtl2.value,
        mobile: mobile.value
      };
      var editable;
      if (type2 === "editable-card") {
        editable = {
          onEdit: function onEdit(editType, _ref2) {
            var key2 = _ref2.key, event = _ref2.event;
            var _a;
            (_a = props2.onEdit) === null || _a === void 0 ? void 0 : _a.call(props2, editType === "add" ? event : key2, editType);
          },
          removeIcon: function removeIcon() {
            return Vue.createVNode(CloseOutlined$1, null, null);
          },
          addIcon: slots.addIcon ? slots.addIcon : function() {
            return Vue.createVNode(PlusOutlined$1, null, null);
          },
          showAdd: hideAdd !== true
        };
      }
      var tabNavBar;
      var tabNavBarProps = _extends(_extends({}, sharedProps), {
        moreTransitionName: "".concat(rootPrefixCls.value, "-slide-up"),
        editable,
        locale: locale2,
        tabBarGutter,
        onTabClick: onInternalTabClick,
        onTabScroll,
        style: tabBarStyle
      });
      if (renderTabBar) {
        tabNavBar = renderTabBar(_extends(_extends({}, tabNavBarProps), {
          DefaultTabBar: TabNavList
        }));
      } else {
        tabNavBar = Vue.createVNode(TabNavList, tabNavBarProps, pick$1(slots, ["moreIcon", "leftExtra", "rightExtra", "tabBarExtraContent"]));
      }
      var pre = prefixCls.value;
      return Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "id": id,
        "class": classNames(pre, "".concat(pre, "-").concat(mergedTabPosition.value), (_classNames = {}, _defineProperty$T(_classNames, "".concat(pre, "-").concat(size.value), size.value), _defineProperty$T(_classNames, "".concat(pre, "-card"), ["card", "editable-card"].includes(type2)), _defineProperty$T(_classNames, "".concat(pre, "-editable-card"), type2 === "editable-card"), _defineProperty$T(_classNames, "".concat(pre, "-centered"), centered), _defineProperty$T(_classNames, "".concat(pre, "-mobile"), mobile.value), _defineProperty$T(_classNames, "".concat(pre, "-editable"), type2 === "editable-card"), _defineProperty$T(_classNames, "".concat(pre, "-rtl"), rtl2.value), _classNames), attrs.class)
      }), [tabNavBar, Vue.createVNode(TabPanelList, _objectSpread2$1(_objectSpread2$1({
        "destroyInactiveTabPane": destroyInactiveTabPane
      }, sharedProps), {}, {
        "animated": mergedAnimated.value
      }), null)]);
    };
  }
});
var Tabs = Vue.defineComponent({
  name: "ATabs",
  inheritAttrs: false,
  props: initDefaultProps$1(tabsProps(), {
    tabPosition: "top",
    animated: {
      inkBar: true,
      tabPane: false
    }
  }),
  slots: ["tabBarExtraContent", "leftExtra", "rightExtra", "moreIcon", "addIcon", "removeIcon", "renderTabBar"],
  setup: function setup60(props2, _ref3) {
    var attrs = _ref3.attrs, slots = _ref3.slots, emit = _ref3.emit;
    var handleChange2 = function handleChange3(key2) {
      emit("update:activeKey", key2);
      emit("change", key2);
    };
    return function() {
      var _a;
      var tabs = parseTabList(flattenChildren((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)));
      return Vue.createVNode(InternalTabs, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit(props2, ["onUpdate:activeKey"])), attrs), {}, {
        "onChange": handleChange2,
        "tabs": tabs
      }), slots);
    };
  }
});
var tabPaneProps = function tabPaneProps2() {
  return {
    tab: PropTypes$1.any,
    disabled: {
      type: Boolean
    },
    forceRender: {
      type: Boolean
    },
    closable: {
      type: Boolean
    },
    animated: {
      type: Boolean
    },
    active: {
      type: Boolean
    },
    destroyInactiveTabPane: {
      type: Boolean
    },
    prefixCls: {
      type: String
    },
    tabKey: {
      type: [String, Number]
    },
    id: {
      type: String
    }
  };
};
var TabPane$1 = Vue.defineComponent({
  name: "ATabPane",
  inheritAttrs: false,
  __ANT_TAB_PANE: true,
  props: tabPaneProps(),
  slots: ["closeIcon", "tab"],
  setup: function setup61(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var visited = Vue.ref(props2.forceRender);
    Vue.watch([function() {
      return props2.active;
    }, function() {
      return props2.destroyInactiveTabPane;
    }], function() {
      if (props2.active) {
        visited.value = true;
      } else if (props2.destroyInactiveTabPane) {
        visited.value = false;
      }
    }, {
      immediate: true
    });
    var mergedStyle = Vue.computed(function() {
      if (!props2.active) {
        if (props2.animated) {
          return {
            visibility: "hidden",
            height: 0,
            overflowY: "hidden"
          };
        } else {
          return {
            display: "none"
          };
        }
      }
      return {};
    });
    return function() {
      var _a;
      var prefixCls = props2.prefixCls, forceRender = props2.forceRender, id = props2.id, active = props2.active, tabKey = props2.tabKey;
      return Vue.createVNode("div", {
        "id": id && "".concat(id, "-panel-").concat(tabKey),
        "role": "tabpanel",
        "tabindex": active ? 0 : -1,
        "aria-labelledby": id && "".concat(id, "-tab-").concat(tabKey),
        "aria-hidden": !active,
        "style": [mergedStyle.value, attrs.style],
        "class": ["".concat(prefixCls, "-tabpane"), active && "".concat(prefixCls, "-tabpane-active"), attrs.class]
      }, [(active || visited.value || forceRender) && ((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots))]);
    };
  }
});
Tabs.TabPane = TabPane$1;
Tabs.install = function(app) {
  app.component(Tabs.name, Tabs);
  app.component(TabPane$1.name, TabPane$1);
  return app;
};
var index$s = "";
var index$r = "";
var index$q = "";
var index$p = "";
var index$o = "";
var index$n = "";
var index$m = "";
var index$l = "";
var index$k = "";
var TableContextKey = Symbol("TableContextProps");
var useProvideTable = function useProvideTable2(props2) {
  Vue.provide(TableContextKey, props2);
};
var useInjectTable = function useInjectTable2() {
  return Vue.inject(TableContextKey, {});
};
var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray$3(arr) {
  if (arr === void 0 || arr === null) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
}
function getPathValue(record, path) {
  if (!path && typeof path !== "number") {
    return record;
  }
  var pathList = toArray$3(path);
  var current2 = record;
  for (var i2 = 0; i2 < pathList.length; i2 += 1) {
    if (!current2) {
      return null;
    }
    var prop = pathList[i2];
    current2 = current2[prop];
  }
  return current2;
}
function getColumnsKey(columns) {
  var columnKeys = [];
  var keys2 = {};
  columns.forEach(function(column) {
    var _ref = column || {}, key2 = _ref.key, dataIndex = _ref.dataIndex;
    var mergedKey = key2 || toArray$3(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
    while (keys2[mergedKey]) {
      mergedKey = "".concat(mergedKey, "_next");
    }
    keys2[mergedKey] = true;
    columnKeys.push(mergedKey);
  });
  return columnKeys;
}
function mergeObject() {
  var merged = {};
  function fillProps(obj, clone2) {
    if (clone2) {
      Object.keys(clone2).forEach(function(key2) {
        var value = clone2[key2];
        if (value && _typeof$1(value) === "object") {
          obj[key2] = obj[key2] || {};
          fillProps(obj[key2], value);
        } else {
          obj[key2] = value;
        }
      });
    }
  }
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }
  objects.forEach(function(clone2) {
    fillProps(merged, clone2);
  });
  return merged;
}
function validateValue(val) {
  return val !== null && val !== void 0;
}
var SlotsContextKey = Symbol("SlotsContextProps");
var useProvideSlots = function useProvideSlots2(props2) {
  Vue.provide(SlotsContextKey, props2);
};
var useInjectSlots = function useInjectSlots2() {
  return Vue.inject(SlotsContextKey, Vue.computed(function() {
    return {};
  }));
};
var ContextKey = Symbol("ContextProps");
var useProvideTableContext = function useProvideTableContext2(props2) {
  Vue.provide(ContextKey, props2);
};
var useInjectTableContext = function useInjectTableContext2() {
  return Vue.inject(ContextKey, {
    onResizeColumn: function onResizeColumn() {
    }
  });
};
globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
var HoverContextKey = Symbol("HoverContextProps");
var useProvideHover = function useProvideHover2(props2) {
  Vue.provide(HoverContextKey, props2);
};
var useInjectHover = function useInjectHover2() {
  return Vue.inject(HoverContextKey, {
    startRow: Vue.ref(-1),
    endRow: Vue.ref(-1),
    onHover: function onHover() {
    }
  });
};
var supportSticky = Vue.ref(false);
var useProvideSticky = function useProvideSticky2() {
  Vue.onMounted(function() {
    supportSticky.value = supportSticky.value || isStyleSupport("position", "sticky");
  });
};
var useInjectSticky = function useInjectSticky2() {
  return supportSticky;
};
function eagerComputed(fn) {
  var result = Vue.shallowRef();
  Vue.watchEffect(function() {
    result.value = fn();
  }, {
    flush: "sync"
  });
  return result;
}
var __rest$v = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
  var cellEndRow = cellStartRow + cellRowSpan - 1;
  return cellStartRow <= endRow && cellEndRow >= startRow;
}
function isRenderCell(data4) {
  return data4 && _typeof$1(data4) === "object" && !Array.isArray(data4) && !Vue.isVNode(data4);
}
var Cell$2 = Vue.defineComponent({
  name: "Cell",
  props: ["prefixCls", "record", "index", "renderIndex", "dataIndex", "customRender", "component", "colSpan", "rowSpan", "fixLeft", "fixRight", "firstFixLeft", "lastFixLeft", "firstFixRight", "lastFixRight", "appendNode", "additionalProps", "ellipsis", "align", "rowType", "isSticky", "column", "cellType", "transformCellText"],
  slots: ["appendNode"],
  setup: function setup62(props2, _ref) {
    var slots = _ref.slots;
    var contextSlots = useInjectSlots();
    var _useInjectHover = useInjectHover(), onHover = _useInjectHover.onHover, startRow = _useInjectHover.startRow, endRow = _useInjectHover.endRow;
    var colSpan = Vue.computed(function() {
      var _a, _b, _c, _d;
      return (_c = (_a = props2.colSpan) !== null && _a !== void 0 ? _a : (_b = props2.additionalProps) === null || _b === void 0 ? void 0 : _b.colSpan) !== null && _c !== void 0 ? _c : (_d = props2.additionalProps) === null || _d === void 0 ? void 0 : _d.colspan;
    });
    var rowSpan = Vue.computed(function() {
      var _a, _b, _c, _d;
      return (_c = (_a = props2.rowSpan) !== null && _a !== void 0 ? _a : (_b = props2.additionalProps) === null || _b === void 0 ? void 0 : _b.rowSpan) !== null && _c !== void 0 ? _c : (_d = props2.additionalProps) === null || _d === void 0 ? void 0 : _d.rowspan;
    });
    var hovering = eagerComputed(function() {
      var index2 = props2.index;
      return inHoverRange(index2, rowSpan.value || 1, startRow.value, endRow.value);
    });
    var supportSticky2 = useInjectSticky();
    var _onMouseenter = function onMouseenter2(event, mergedRowSpan) {
      var _a;
      var record = props2.record, index2 = props2.index, additionalProps = props2.additionalProps;
      if (record) {
        onHover(index2, index2 + mergedRowSpan - 1);
      }
      (_a = additionalProps === null || additionalProps === void 0 ? void 0 : additionalProps.onMouseenter) === null || _a === void 0 ? void 0 : _a.call(additionalProps, event);
    };
    var onMouseleave2 = function onMouseleave3(event) {
      var _a;
      var record = props2.record, additionalProps = props2.additionalProps;
      if (record) {
        onHover(-1, -1);
      }
      (_a = additionalProps === null || additionalProps === void 0 ? void 0 : additionalProps.onMouseleave) === null || _a === void 0 ? void 0 : _a.call(additionalProps, event);
    };
    return function() {
      var _classNames;
      var _a, _b, _c, _d, _e, _f;
      var prefixCls = props2.prefixCls, record = props2.record, index2 = props2.index, renderIndex = props2.renderIndex, dataIndex = props2.dataIndex, customRender = props2.customRender, _props$component = props2.component, Component = _props$component === void 0 ? "td" : _props$component, fixLeft = props2.fixLeft, fixRight = props2.fixRight, firstFixLeft = props2.firstFixLeft, lastFixLeft = props2.lastFixLeft, firstFixRight = props2.firstFixRight, lastFixRight = props2.lastFixRight, _props$appendNode = props2.appendNode, appendNode = _props$appendNode === void 0 ? (_a = slots.appendNode) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$appendNode, _props$additionalProp = props2.additionalProps, additionalProps = _props$additionalProp === void 0 ? {} : _props$additionalProp, ellipsis = props2.ellipsis, align = props2.align, rowType = props2.rowType, isSticky = props2.isSticky, _props$column = props2.column, column = _props$column === void 0 ? {} : _props$column, cellType = props2.cellType;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var cellProps;
      var childNode;
      var children = (_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots);
      if (validateValue(children) || cellType === "header") {
        childNode = children;
      } else {
        var value = getPathValue(record, dataIndex);
        childNode = value;
        if (customRender) {
          var renderData = customRender({
            text: value,
            value,
            record,
            index: index2,
            renderIndex,
            column: column.__originColumn__
          });
          if (isRenderCell(renderData)) {
            childNode = renderData.children;
            cellProps = renderData.props;
          } else {
            childNode = renderData;
          }
        }
        if (!(INTERNAL_COL_DEFINE in column) && cellType === "body" && contextSlots.value.bodyCell && !((_c = column.slots) === null || _c === void 0 ? void 0 : _c.customRender)) {
          var child = Vue.renderSlot(contextSlots.value, "bodyCell", {
            text: value,
            value,
            record,
            index: index2,
            column: column.__originColumn__
          }, function() {
            var fallback = childNode === void 0 ? value : childNode;
            return [_typeof$1(fallback) === "object" && isValidElement(fallback) || _typeof$1(fallback) !== "object" ? fallback : null];
          });
          childNode = flattenChildren(child);
        }
        if (props2.transformCellText) {
          childNode = props2.transformCellText({
            text: childNode,
            record,
            index: index2,
            column: column.__originColumn__
          });
        }
      }
      if (_typeof$1(childNode) === "object" && !Array.isArray(childNode) && !Vue.isVNode(childNode)) {
        childNode = null;
      }
      if (ellipsis && (lastFixLeft || firstFixRight)) {
        childNode = Vue.createVNode("span", {
          "class": "".concat(cellPrefixCls, "-content")
        }, [childNode]);
      }
      if (Array.isArray(childNode) && childNode.length === 1) {
        childNode = childNode[0];
      }
      var _g = cellProps || {}, cellColSpan = _g.colSpan, cellRowSpan = _g.rowSpan, cellStyle = _g.style, cellClassName = _g.class, restCellProps = __rest$v(_g, ["colSpan", "rowSpan", "style", "class"]);
      var mergedColSpan = (_d = cellColSpan !== void 0 ? cellColSpan : colSpan.value) !== null && _d !== void 0 ? _d : 1;
      var mergedRowSpan = (_e = cellRowSpan !== void 0 ? cellRowSpan : rowSpan.value) !== null && _e !== void 0 ? _e : 1;
      if (mergedColSpan === 0 || mergedRowSpan === 0) {
        return null;
      }
      var fixedStyle = {};
      var isFixLeft = typeof fixLeft === "number" && supportSticky2.value;
      var isFixRight = typeof fixRight === "number" && supportSticky2.value;
      if (isFixLeft) {
        fixedStyle.position = "sticky";
        fixedStyle.left = "".concat(fixLeft, "px");
      }
      if (isFixRight) {
        fixedStyle.position = "sticky";
        fixedStyle.right = "".concat(fixRight, "px");
      }
      var alignStyle = {};
      if (align) {
        alignStyle.textAlign = align;
      }
      var title;
      var ellipsisConfig = ellipsis === true ? {
        showTitle: true
      } : ellipsis;
      if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
        if (typeof childNode === "string" || typeof childNode === "number") {
          title = childNode.toString();
        } else if (Vue.isVNode(childNode) && typeof childNode.children === "string") {
          title = childNode.children;
        }
      }
      var componentProps = _extends(_extends(_extends({
        title
      }, restCellProps), additionalProps), {
        colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
        rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null,
        class: classNames(cellPrefixCls, (_classNames = {}, _defineProperty$T(_classNames, "".concat(cellPrefixCls, "-fix-left"), isFixLeft && supportSticky2.value), _defineProperty$T(_classNames, "".concat(cellPrefixCls, "-fix-left-first"), firstFixLeft && supportSticky2.value), _defineProperty$T(_classNames, "".concat(cellPrefixCls, "-fix-left-last"), lastFixLeft && supportSticky2.value), _defineProperty$T(_classNames, "".concat(cellPrefixCls, "-fix-right"), isFixRight && supportSticky2.value), _defineProperty$T(_classNames, "".concat(cellPrefixCls, "-fix-right-first"), firstFixRight && supportSticky2.value), _defineProperty$T(_classNames, "".concat(cellPrefixCls, "-fix-right-last"), lastFixRight && supportSticky2.value), _defineProperty$T(_classNames, "".concat(cellPrefixCls, "-ellipsis"), ellipsis), _defineProperty$T(_classNames, "".concat(cellPrefixCls, "-with-append"), appendNode), _defineProperty$T(_classNames, "".concat(cellPrefixCls, "-fix-sticky"), (isFixLeft || isFixRight) && isSticky && supportSticky2.value), _defineProperty$T(_classNames, "".concat(cellPrefixCls, "-row-hover"), !cellProps && hovering.value), _classNames), additionalProps.class, cellClassName),
        onMouseenter: function onMouseenter2(e2) {
          _onMouseenter(e2, mergedRowSpan);
        },
        onMouseleave: onMouseleave2,
        style: _extends(_extends(_extends(_extends({}, parseStyleText(additionalProps.style)), alignStyle), fixedStyle), cellStyle)
      });
      return Vue.createVNode(Component, componentProps, {
        default: function _default5() {
          return [appendNode, childNode, (_f = slots.dragHandle) === null || _f === void 0 ? void 0 : _f.call(slots)];
        }
      });
    };
  }
});
function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction) {
  var startColumn = columns[colStart] || {};
  var endColumn = columns[colEnd] || {};
  var fixLeft;
  var fixRight;
  if (startColumn.fixed === "left") {
    fixLeft = stickyOffsets.left[colStart];
  } else if (endColumn.fixed === "right") {
    fixRight = stickyOffsets.right[colEnd];
  }
  var lastFixLeft = false;
  var firstFixRight = false;
  var lastFixRight = false;
  var firstFixLeft = false;
  var nextColumn = columns[colEnd + 1];
  var prevColumn = columns[colStart - 1];
  if (direction === "rtl") {
    if (fixLeft !== void 0) {
      var prevFixLeft = prevColumn && prevColumn.fixed === "left";
      firstFixLeft = !prevFixLeft;
    } else if (fixRight !== void 0) {
      var nextFixRight = nextColumn && nextColumn.fixed === "right";
      lastFixRight = !nextFixRight;
    }
  } else if (fixLeft !== void 0) {
    var nextFixLeft = nextColumn && nextColumn.fixed === "left";
    lastFixLeft = !nextFixLeft;
  } else if (fixRight !== void 0) {
    var prevFixRight = prevColumn && prevColumn.fixed === "right";
    firstFixRight = !prevFixRight;
  }
  return {
    fixLeft,
    fixRight,
    lastFixLeft,
    firstFixRight,
    lastFixRight,
    firstFixLeft,
    isSticky: stickyOffsets.isSticky
  };
}
var events = {
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  },
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  }
};
var defaultMinWidth = 50;
var DragHandleVue = Vue.defineComponent({
  name: "DragHandle",
  props: {
    prefixCls: String,
    width: {
      type: Number,
      required: true
    },
    minWidth: {
      type: Number,
      default: defaultMinWidth
    },
    maxWidth: {
      type: Number,
      default: Infinity
    },
    column: {
      type: Object,
      default: void 0
    }
  },
  setup: function setup63(props2) {
    var startX = 0;
    var moveEvent = {
      remove: function remove() {
      }
    };
    var stopEvent = {
      remove: function remove() {
      }
    };
    var removeEvents2 = function removeEvents3() {
      moveEvent.remove();
      stopEvent.remove();
    };
    Vue.onUnmounted(function() {
      removeEvents2();
    });
    Vue.watchEffect(function() {
      devWarning(!isNaN(props2.width), "Table", "width must be a number when use resizable");
    });
    var _useInjectTableContex = useInjectTableContext(), onResizeColumn = _useInjectTableContex.onResizeColumn;
    var minWidth = Vue.computed(function() {
      return typeof props2.minWidth === "number" && !isNaN(props2.minWidth) ? props2.minWidth : defaultMinWidth;
    });
    var maxWidth = Vue.computed(function() {
      return typeof props2.maxWidth === "number" && !isNaN(props2.maxWidth) ? props2.maxWidth : Infinity;
    });
    var instance = Vue.getCurrentInstance();
    var baseWidth = 0;
    var dragging = Vue.ref(false);
    var rafId;
    var updateWidth = function updateWidth2(e2) {
      var pageX = 0;
      if (e2.touches) {
        if (e2.touches.length) {
          pageX = e2.touches[0].pageX;
        } else {
          pageX = e2.changedTouches[0].pageX;
        }
      } else {
        pageX = e2.pageX;
      }
      var tmpDeltaX = startX - pageX;
      var w2 = Math.max(baseWidth - tmpDeltaX, minWidth.value);
      w2 = Math.min(w2, maxWidth.value);
      wrapperRaf.cancel(rafId);
      rafId = wrapperRaf(function() {
        onResizeColumn(w2, props2.column.__originColumn__);
      });
    };
    var handleMove = function handleMove2(e2) {
      updateWidth(e2);
    };
    var handleStop = function handleStop2(e2) {
      dragging.value = false;
      updateWidth(e2);
      removeEvents2();
    };
    var handleStart = function handleStart2(e2, eventsFor) {
      dragging.value = true;
      removeEvents2();
      baseWidth = instance.vnode.el.parentNode.getBoundingClientRect().width;
      if (e2 instanceof MouseEvent && e2.which !== 1) {
        return;
      }
      if (e2.stopPropagation)
        e2.stopPropagation();
      startX = e2.touches ? e2.touches[0].pageX : e2.pageX;
      moveEvent = addEventListenerWrap(document.documentElement, eventsFor.move, handleMove);
      stopEvent = addEventListenerWrap(document.documentElement, eventsFor.stop, handleStop);
    };
    var handleDown = function handleDown2(e2) {
      e2.stopPropagation();
      e2.preventDefault();
      handleStart(e2, events.mouse);
    };
    var handleTouchDown = function handleTouchDown2(e2) {
      e2.stopPropagation();
      e2.preventDefault();
      handleStart(e2, events.touch);
    };
    var handleClick = function handleClick2(e2) {
      e2.stopPropagation();
      e2.preventDefault();
    };
    return function() {
      var prefixCls = props2.prefixCls;
      var touchEvents = _defineProperty$T({}, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", function(e2) {
        return handleTouchDown(e2);
      });
      return Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "class": "".concat(prefixCls, "-resize-handle ").concat(dragging.value ? "dragging" : ""),
        "onMousedown": handleDown
      }, touchEvents), {}, {
        "onClick": handleClick
      }), [Vue.createVNode("div", {
        "class": "".concat(prefixCls, "-resize-handle-line")
      }, null)]);
    };
  }
});
var HeaderRow = Vue.defineComponent({
  name: "HeaderRow",
  props: ["cells", "stickyOffsets", "flattenColumns", "rowComponent", "cellComponent", "index", "customHeaderRow"],
  setup: function setup64(props2) {
    var tableContext = useInjectTable();
    return function() {
      var prefixCls = tableContext.prefixCls, direction = tableContext.direction;
      var cells = props2.cells, stickyOffsets = props2.stickyOffsets, flattenColumns = props2.flattenColumns, RowComponent = props2.rowComponent, CellComponent = props2.cellComponent, customHeaderRow = props2.customHeaderRow, index2 = props2.index;
      var rowProps3;
      if (customHeaderRow) {
        rowProps3 = customHeaderRow(cells.map(function(cell) {
          return cell.column;
        }), index2);
      }
      var columnsKey = getColumnsKey(cells.map(function(cell) {
        return cell.column;
      }));
      return Vue.createVNode(RowComponent, rowProps3, {
        default: function _default5() {
          return [cells.map(function(cell, cellIndex) {
            var column = cell.column;
            var fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction);
            var additionalProps;
            if (column && column.customHeaderCell) {
              additionalProps = cell.column.customHeaderCell(column);
            }
            var col = column;
            return Vue.createVNode(Cell$2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, cell), {}, {
              "cellType": "header",
              "ellipsis": column.ellipsis,
              "align": column.align,
              "component": CellComponent,
              "prefixCls": prefixCls,
              "key": columnsKey[cellIndex]
            }, fixedInfo), {}, {
              "additionalProps": additionalProps,
              "rowType": "header",
              "column": column
            }), {
              default: function _default6() {
                return column.title;
              },
              dragHandle: function dragHandle() {
                return col.resizable ? Vue.createVNode(DragHandleVue, {
                  "prefixCls": prefixCls,
                  "width": col.width,
                  "minWidth": col.minWidth,
                  "maxWidth": col.maxWidth,
                  "column": col
                }, null) : null;
              }
            });
          })];
        }
      });
    };
  }
});
function parseHeaderRows(rootColumns) {
  var rows = [];
  function fillRowCells(columns, colIndex) {
    var rowIndex2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    rows[rowIndex2] = rows[rowIndex2] || [];
    var currentColIndex = colIndex;
    var colSpans = columns.filter(Boolean).map(function(column) {
      var cell = {
        key: column.key,
        class: classNames(column.className, column.class),
        column,
        colStart: currentColIndex
      };
      var colSpan = 1;
      var subColumns = column.children;
      if (subColumns && subColumns.length > 0) {
        colSpan = fillRowCells(subColumns, currentColIndex, rowIndex2 + 1).reduce(function(total2, count) {
          return total2 + count;
        }, 0);
        cell.hasSubColumns = true;
      }
      if ("colSpan" in column) {
        colSpan = column.colSpan;
      }
      if ("rowSpan" in column) {
        cell.rowSpan = column.rowSpan;
      }
      cell.colSpan = colSpan;
      cell.colEnd = cell.colStart + colSpan - 1;
      rows[rowIndex2].push(cell);
      currentColIndex += colSpan;
      return colSpan;
    });
    return colSpans;
  }
  fillRowCells(rootColumns, 0);
  var rowCount = rows.length;
  var _loop = function _loop2(rowIndex2) {
    rows[rowIndex2].forEach(function(cell) {
      if (!("rowSpan" in cell) && !cell.hasSubColumns) {
        cell.rowSpan = rowCount - rowIndex2;
      }
    });
  };
  for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
    _loop(rowIndex);
  }
  return rows;
}
var Header$1 = Vue.defineComponent({
  name: "Header",
  inheritAttrs: false,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow"],
  setup: function setup65(props2) {
    var tableContext = useInjectTable();
    var rows = Vue.computed(function() {
      return parseHeaderRows(props2.columns);
    });
    return function() {
      var prefixCls = tableContext.prefixCls, getComponent3 = tableContext.getComponent;
      var stickyOffsets = props2.stickyOffsets, flattenColumns = props2.flattenColumns, customHeaderRow = props2.customHeaderRow;
      var WrapperComponent = getComponent3(["header", "wrapper"], "thead");
      var trComponent = getComponent3(["header", "row"], "tr");
      var thComponent = getComponent3(["header", "cell"], "th");
      return Vue.createVNode(WrapperComponent, {
        "class": "".concat(prefixCls, "-thead")
      }, {
        default: function _default5() {
          return [rows.value.map(function(row, rowIndex) {
            var rowNode = Vue.createVNode(HeaderRow, {
              "key": rowIndex,
              "flattenColumns": flattenColumns,
              "cells": row,
              "stickyOffsets": stickyOffsets,
              "rowComponent": trComponent,
              "cellComponent": thComponent,
              "customHeaderRow": customHeaderRow,
              "index": rowIndex
            }, null);
            return rowNode;
          })];
        }
      });
    };
  }
});
var ExpandedRowContextKey = Symbol("ExpandedRowProps");
var useProvideExpandedRow = function useProvideExpandedRow2(props2) {
  Vue.provide(ExpandedRowContextKey, props2);
};
var useInjectExpandedRow = function useInjectExpandedRow2() {
  return Vue.inject(ExpandedRowContextKey, {});
};
var ExpandedRow = Vue.defineComponent({
  name: "ExpandedRow",
  inheritAttrs: false,
  props: ["prefixCls", "component", "cellComponent", "expanded", "colSpan", "isEmpty"],
  setup: function setup66(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var tableContext = useInjectTable();
    var expandedRowContext = useInjectExpandedRow();
    var fixHeader = expandedRowContext.fixHeader, fixColumn = expandedRowContext.fixColumn, componentWidth = expandedRowContext.componentWidth, horizonScroll = expandedRowContext.horizonScroll;
    return function() {
      var prefixCls = props2.prefixCls, Component = props2.component, cellComponent = props2.cellComponent, expanded = props2.expanded, colSpan = props2.colSpan, isEmpty = props2.isEmpty;
      return Vue.createVNode(Component, {
        "class": attrs.class,
        "style": {
          display: expanded ? null : "none"
        }
      }, {
        default: function _default5() {
          return [Vue.createVNode(Cell$2, {
            "component": cellComponent,
            "prefixCls": prefixCls,
            "colSpan": colSpan
          }, {
            default: function _default6() {
              var _a;
              var contentNode = (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
              if (isEmpty ? horizonScroll.value : fixColumn.value) {
                contentNode = Vue.createVNode("div", {
                  "style": {
                    width: "".concat(componentWidth.value - (fixHeader.value ? tableContext.scrollbarSize : 0), "px"),
                    position: "sticky",
                    left: 0,
                    overflow: "hidden"
                  },
                  "class": "".concat(prefixCls, "-expanded-row-fixed")
                }, [contentNode]);
              }
              return contentNode;
            }
          })];
        }
      });
    };
  }
});
var MeasureCell = Vue.defineComponent({
  name: "MeasureCell",
  props: ["columnKey"],
  setup: function setup67(props2, _ref) {
    var emit = _ref.emit;
    var tdRef = Vue.ref();
    Vue.onMounted(function() {
      if (tdRef.value) {
        emit("columnResize", props2.columnKey, tdRef.value.offsetWidth);
      }
    });
    return function() {
      return Vue.createVNode(ResizeObserver$1, {
        "onResize": function onResize(_ref2) {
          var offsetWidth = _ref2.offsetWidth;
          emit("columnResize", props2.columnKey, offsetWidth);
        }
      }, {
        default: function _default5() {
          return [Vue.createVNode("td", {
            "ref": tdRef,
            "style": {
              padding: 0,
              border: 0,
              height: 0
            }
          }, [Vue.createVNode("div", {
            "style": {
              height: 0,
              overflow: "hidden"
            }
          }, [Vue.createTextVNode("\xA0")])])];
        }
      });
    };
  }
});
var BodyContextKey = Symbol("BodyContextProps");
var useProvideBody = function useProvideBody2(props2) {
  Vue.provide(BodyContextKey, props2);
};
var useInjectBody = function useInjectBody2() {
  return Vue.inject(BodyContextKey, {});
};
var BodyRow = Vue.defineComponent({
  name: "BodyRow",
  inheritAttrs: false,
  props: ["record", "index", "renderIndex", "recordKey", "expandedKeys", "rowComponent", "cellComponent", "customRow", "rowExpandable", "indent", "rowKey", "getRowKey", "childrenColumnName"],
  setup: function setup68(props2, _ref) {
    var attrs = _ref.attrs;
    var tableContext = useInjectTable();
    var bodyContext = useInjectBody();
    var expandRended = Vue.ref(false);
    var expanded = Vue.computed(function() {
      return props2.expandedKeys && props2.expandedKeys.has(props2.recordKey);
    });
    Vue.watchEffect(function() {
      if (expanded.value) {
        expandRended.value = true;
      }
    });
    var rowSupportExpand = Vue.computed(function() {
      return bodyContext.expandableType === "row" && (!props2.rowExpandable || props2.rowExpandable(props2.record));
    });
    var nestExpandable = Vue.computed(function() {
      return bodyContext.expandableType === "nest";
    });
    var hasNestChildren = Vue.computed(function() {
      return props2.childrenColumnName && props2.record && props2.record[props2.childrenColumnName];
    });
    var mergedExpandable = Vue.computed(function() {
      return rowSupportExpand.value || nestExpandable.value;
    });
    var onInternalTriggerExpand = function onInternalTriggerExpand2(record, event) {
      bodyContext.onTriggerExpand(record, event);
    };
    var additionalProps = Vue.computed(function() {
      var _a;
      return ((_a = props2.customRow) === null || _a === void 0 ? void 0 : _a.call(props2, props2.record, props2.index)) || {};
    });
    var onClick2 = function onClick3(event) {
      var _b2;
      var _a, _b;
      if (bodyContext.expandRowByClick && mergedExpandable.value) {
        onInternalTriggerExpand(props2.record, event);
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      (_b = (_a = additionalProps.value) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : (_b2 = _b).call.apply(_b2, [_a, event].concat(args));
    };
    var computeRowClassName = Vue.computed(function() {
      var record = props2.record, index2 = props2.index, indent = props2.indent;
      var rowClassName = bodyContext.rowClassName;
      if (typeof rowClassName === "string") {
        return rowClassName;
      } else if (typeof rowClassName === "function") {
        return rowClassName(record, index2, indent);
      }
      return "";
    });
    var columnsKey = Vue.computed(function() {
      return getColumnsKey(bodyContext.flattenColumns);
    });
    return function() {
      var className = attrs.class, style = attrs.style;
      var record = props2.record, index2 = props2.index, rowKey = props2.rowKey, _props$indent = props2.indent, indent = _props$indent === void 0 ? 0 : _props$indent, RowComponent = props2.rowComponent, cellComponent = props2.cellComponent;
      var prefixCls = tableContext.prefixCls, fixedInfoList = tableContext.fixedInfoList, transformCellText = tableContext.transformCellText;
      var flattenColumns = bodyContext.flattenColumns, expandedRowClassName = bodyContext.expandedRowClassName, indentSize = bodyContext.indentSize, expandIcon = bodyContext.expandIcon, expandedRowRender = bodyContext.expandedRowRender, expandIconColumnIndex = bodyContext.expandIconColumnIndex;
      var baseRowNode = Vue.createVNode(RowComponent, _objectSpread2$1(_objectSpread2$1({}, additionalProps.value), {}, {
        "data-row-key": rowKey,
        "class": classNames(className, "".concat(prefixCls, "-row"), "".concat(prefixCls, "-row-level-").concat(indent), computeRowClassName.value, additionalProps.value.class),
        "style": _extends(_extends({}, style), parseStyleText(additionalProps.value.style)),
        "onClick": onClick2
      }), {
        default: function _default5() {
          return [flattenColumns.map(function(column, colIndex) {
            var customRender = column.customRender, dataIndex = column.dataIndex, columnClassName = column.className;
            var key2 = columnsKey[colIndex];
            var fixedInfo = fixedInfoList[colIndex];
            var additionalCellProps;
            if (column.customCell) {
              additionalCellProps = column.customCell(record, index2, column);
            }
            var appendNode = colIndex === (expandIconColumnIndex || 0) && nestExpandable.value ? Vue.createVNode(Vue.Fragment, null, [Vue.createVNode("span", {
              "style": {
                paddingLeft: "".concat(indentSize * indent, "px")
              },
              "class": "".concat(prefixCls, "-row-indent indent-level-").concat(indent)
            }, null), expandIcon({
              prefixCls,
              expanded: expanded.value,
              expandable: hasNestChildren.value,
              record,
              onExpand: onInternalTriggerExpand
            })]) : null;
            return Vue.createVNode(Cell$2, _objectSpread2$1(_objectSpread2$1({
              "cellType": "body",
              "class": columnClassName,
              "ellipsis": column.ellipsis,
              "align": column.align,
              "component": cellComponent,
              "prefixCls": prefixCls,
              "key": key2,
              "record": record,
              "index": index2,
              "renderIndex": props2.renderIndex,
              "dataIndex": dataIndex,
              "customRender": customRender
            }, fixedInfo), {}, {
              "additionalProps": additionalCellProps,
              "column": column,
              "transformCellText": transformCellText,
              "appendNode": appendNode
            }), null);
          })];
        }
      });
      var expandRowNode;
      if (rowSupportExpand.value && (expandRended.value || expanded.value)) {
        var expandContent = expandedRowRender({
          record,
          index: index2,
          indent: indent + 1,
          expanded: expanded.value
        });
        var computedExpandedRowClassName = expandedRowClassName && expandedRowClassName(record, index2, indent);
        expandRowNode = Vue.createVNode(ExpandedRow, {
          "expanded": expanded.value,
          "class": classNames("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), computedExpandedRowClassName),
          "prefixCls": prefixCls,
          "component": RowComponent,
          "cellComponent": cellComponent,
          "colSpan": flattenColumns.length,
          "isEmpty": false
        }, {
          default: function _default5() {
            return [expandContent];
          }
        });
      }
      return Vue.createVNode(Vue.Fragment, null, [baseRowNode, expandRowNode]);
    };
  }
});
function flatRecord(record, indent, childrenColumnName, expandedKeys, getRowKey, index2) {
  var arr = [];
  arr.push({
    record,
    indent,
    index: index2
  });
  var key2 = getRowKey(record);
  var expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key2);
  if (record && Array.isArray(record[childrenColumnName]) && expanded) {
    for (var i2 = 0; i2 < record[childrenColumnName].length; i2 += 1) {
      var tempArr = flatRecord(record[childrenColumnName][i2], indent + 1, childrenColumnName, expandedKeys, getRowKey, i2);
      arr.push.apply(arr, _toConsumableArray(tempArr));
    }
  }
  return arr;
}
function useFlattenRecords(dataRef, childrenColumnNameRef, expandedKeysRef, getRowKey) {
  var arr = Vue.computed(function() {
    var childrenColumnName = childrenColumnNameRef.value;
    var expandedKeys = expandedKeysRef.value;
    var data4 = dataRef.value;
    if (expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.size) {
      var temp = [];
      for (var i2 = 0; i2 < (data4 === null || data4 === void 0 ? void 0 : data4.length); i2 += 1) {
        var record = data4[i2];
        temp.push.apply(temp, _toConsumableArray(flatRecord(record, 0, childrenColumnName, expandedKeys, getRowKey.value, i2)));
      }
      return temp;
    }
    return data4 === null || data4 === void 0 ? void 0 : data4.map(function(item, index2) {
      return {
        record: item,
        indent: 0,
        index: index2
      };
    });
  });
  return arr;
}
var ResizeContextKey = Symbol("ResizeContextProps");
var useProvideResize = function useProvideResize2(props2) {
  Vue.provide(ResizeContextKey, props2);
};
var useInjectResize = function useInjectResize2() {
  return Vue.inject(ResizeContextKey, {
    onColumnResize: function onColumnResize() {
    }
  });
};
var Body = Vue.defineComponent({
  name: "Body",
  props: ["data", "getRowKey", "measureColumnWidth", "expandedKeys", "customRow", "rowExpandable", "childrenColumnName"],
  slots: ["emptyNode"],
  setup: function setup69(props2, _ref) {
    var slots = _ref.slots;
    var resizeContext = useInjectResize();
    var tableContext = useInjectTable();
    var bodyContext = useInjectBody();
    var flattenData2 = useFlattenRecords(Vue.toRef(props2, "data"), Vue.toRef(props2, "childrenColumnName"), Vue.toRef(props2, "expandedKeys"), Vue.toRef(props2, "getRowKey"));
    var startRow = Vue.ref(-1);
    var endRow = Vue.ref(-1);
    var timeoutId;
    useProvideHover({
      startRow,
      endRow,
      onHover: function onHover(start, end) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(function() {
          startRow.value = start;
          endRow.value = end;
        }, 100);
      }
    });
    return function() {
      var _a;
      var data4 = props2.data, getRowKey = props2.getRowKey, measureColumnWidth = props2.measureColumnWidth, expandedKeys = props2.expandedKeys, customRow = props2.customRow, rowExpandable = props2.rowExpandable, childrenColumnName = props2.childrenColumnName;
      var onColumnResize = resizeContext.onColumnResize;
      var prefixCls = tableContext.prefixCls, getComponent3 = tableContext.getComponent;
      var flattenColumns = bodyContext.flattenColumns;
      var WrapperComponent = getComponent3(["body", "wrapper"], "tbody");
      var trComponent = getComponent3(["body", "row"], "tr");
      var tdComponent = getComponent3(["body", "cell"], "td");
      var rows;
      if (data4.length) {
        rows = flattenData2.value.map(function(item, idx) {
          var record = item.record, indent = item.indent, renderIndex = item.index;
          var key2 = getRowKey(record, idx);
          return Vue.createVNode(BodyRow, {
            "key": key2,
            "rowKey": key2,
            "record": record,
            "recordKey": key2,
            "index": idx,
            "renderIndex": renderIndex,
            "rowComponent": trComponent,
            "cellComponent": tdComponent,
            "expandedKeys": expandedKeys,
            "customRow": customRow,
            "getRowKey": getRowKey,
            "rowExpandable": rowExpandable,
            "childrenColumnName": childrenColumnName,
            "indent": indent
          }, null);
        });
      } else {
        rows = Vue.createVNode(ExpandedRow, {
          "expanded": true,
          "class": "".concat(prefixCls, "-placeholder"),
          "prefixCls": prefixCls,
          "component": trComponent,
          "cellComponent": tdComponent,
          "colSpan": flattenColumns.length,
          "isEmpty": true
        }, {
          default: function _default5() {
            return [(_a = slots.emptyNode) === null || _a === void 0 ? void 0 : _a.call(slots)];
          }
        });
      }
      var columnsKey = getColumnsKey(flattenColumns);
      return Vue.createVNode(WrapperComponent, {
        "class": "".concat(prefixCls, "-tbody")
      }, {
        default: function _default5() {
          return [measureColumnWidth && Vue.createVNode("tr", {
            "aria-hidden": "true",
            "class": "".concat(prefixCls, "-measure-row"),
            "style": {
              height: 0,
              fontSize: 0
            }
          }, [columnsKey.map(function(columnKey) {
            return Vue.createVNode(MeasureCell, {
              "key": columnKey,
              "columnKey": columnKey,
              "onColumnResize": onColumnResize
            }, null);
          })]), rows];
        }
      });
    };
  }
});
var EXPAND_COLUMN = {};
var __rest$u = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function flatColumns(columns) {
  return columns.reduce(function(list, column) {
    var fixed = column.fixed;
    var parsedFixed = fixed === true ? "left" : fixed;
    var subColumns = column.children;
    if (subColumns && subColumns.length > 0) {
      return [].concat(_toConsumableArray(list), _toConsumableArray(flatColumns(subColumns).map(function(subColum) {
        return _extends({
          fixed: parsedFixed
        }, subColum);
      })));
    }
    return [].concat(_toConsumableArray(list), [_extends(_extends({}, column), {
      fixed: parsedFixed
    })]);
  }, []);
}
function revertForRtl(columns) {
  return columns.map(function(column) {
    var fixed = column.fixed, restProps = __rest$u(column, ["fixed"]);
    var parsedFixed = fixed;
    if (fixed === "left") {
      parsedFixed = "right";
    } else if (fixed === "right") {
      parsedFixed = "left";
    }
    return _extends({
      fixed: parsedFixed
    }, restProps);
  });
}
function useColumns$1(_ref, transformColumns) {
  var prefixCls = _ref.prefixCls, baseColumns = _ref.columns, expandable = _ref.expandable, expandedKeys = _ref.expandedKeys, getRowKey = _ref.getRowKey, onTriggerExpand = _ref.onTriggerExpand, expandIcon = _ref.expandIcon, rowExpandable = _ref.rowExpandable, expandIconColumnIndex = _ref.expandIconColumnIndex, direction = _ref.direction, expandRowByClick = _ref.expandRowByClick, expandColumnWidth = _ref.expandColumnWidth, expandFixed = _ref.expandFixed;
  var withExpandColumns = Vue.computed(function() {
    if (expandable.value) {
      var _expandColumn;
      var cloneColumns = baseColumns.value.slice();
      if (!cloneColumns.includes(EXPAND_COLUMN)) {
        var expandColIndex = expandIconColumnIndex.value || 0;
        if (expandColIndex >= 0) {
          cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
        }
      }
      var expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
      cloneColumns = cloneColumns.filter(function(column, index2) {
        return column !== EXPAND_COLUMN || index2 === expandColumnIndex;
      });
      var prevColumn = baseColumns.value[expandColumnIndex];
      var fixedColumn;
      if ((expandFixed.value === "left" || expandFixed.value) && !expandIconColumnIndex.value) {
        fixedColumn = "left";
      } else if ((expandFixed.value === "right" || expandFixed.value) && expandIconColumnIndex.value === baseColumns.value.length) {
        fixedColumn = "right";
      } else {
        fixedColumn = prevColumn ? prevColumn.fixed : null;
      }
      var expandedKeysValue = expandedKeys.value;
      var rowExpandableValue = rowExpandable.value;
      var expandIconValue = expandIcon.value;
      var prefixClsValue = prefixCls.value;
      var expandRowByClickValue = expandRowByClick.value;
      var expandColumn = (_expandColumn = {}, _defineProperty$T(_expandColumn, INTERNAL_COL_DEFINE, {
        class: "".concat(prefixCls.value, "-expand-icon-col"),
        columnType: "EXPAND_COLUMN"
      }), _defineProperty$T(_expandColumn, "title", ""), _defineProperty$T(_expandColumn, "fixed", fixedColumn), _defineProperty$T(_expandColumn, "class", "".concat(prefixCls.value, "-row-expand-icon-cell")), _defineProperty$T(_expandColumn, "width", expandColumnWidth.value), _defineProperty$T(_expandColumn, "customRender", function customRender(_ref2) {
        var record = _ref2.record, index2 = _ref2.index;
        var rowKey = getRowKey.value(record, index2);
        var expanded = expandedKeysValue.has(rowKey);
        var recordExpandable = rowExpandableValue ? rowExpandableValue(record) : true;
        var icon = expandIconValue({
          prefixCls: prefixClsValue,
          expanded,
          expandable: recordExpandable,
          record,
          onExpand: onTriggerExpand
        });
        if (expandRowByClickValue) {
          return Vue.createVNode("span", {
            "onClick": function onClick2(e2) {
              return e2.stopPropagation();
            }
          }, [icon]);
        }
        return icon;
      }), _expandColumn);
      return cloneColumns.map(function(col) {
        return col === EXPAND_COLUMN ? expandColumn : col;
      });
    }
    return baseColumns.value.filter(function(col) {
      return col !== EXPAND_COLUMN;
    });
  });
  var mergedColumns = Vue.computed(function() {
    var finalColumns = withExpandColumns.value;
    if (transformColumns.value) {
      finalColumns = transformColumns.value(finalColumns);
    }
    if (!finalColumns.length) {
      finalColumns = [{
        customRender: function customRender() {
          return null;
        }
      }];
    }
    return finalColumns;
  });
  var flattenColumns = Vue.computed(function() {
    if (direction.value === "rtl") {
      return revertForRtl(flatColumns(mergedColumns.value));
    }
    return flatColumns(mergedColumns.value);
  });
  return [mergedColumns, flattenColumns];
}
function useLayoutState(defaultState) {
  var stateRef = Vue.shallowRef(defaultState);
  var rafId;
  var updateBatchRef = Vue.shallowRef([]);
  function setFrameState(updater) {
    updateBatchRef.value.push(updater);
    wrapperRaf.cancel(rafId);
    rafId = wrapperRaf(function() {
      var prevBatch = updateBatchRef.value;
      updateBatchRef.value = [];
      prevBatch.forEach(function(batchUpdater) {
        stateRef.value = batchUpdater(stateRef.value);
      });
    });
  }
  Vue.onBeforeUnmount(function() {
    wrapperRaf.cancel(rafId);
  });
  return [stateRef, setFrameState];
}
function useTimeoutLock(defaultState) {
  var frameRef = Vue.ref(defaultState || null);
  var timeoutRef = Vue.ref();
  function cleanUp() {
    clearTimeout(timeoutRef.value);
  }
  function setState2(newState) {
    frameRef.value = newState;
    cleanUp();
    timeoutRef.value = setTimeout(function() {
      frameRef.value = null;
      timeoutRef.value = void 0;
    }, 100);
  }
  function getState() {
    return frameRef.value;
  }
  Vue.onBeforeUnmount(function() {
    cleanUp();
  });
  return [setState2, getState];
}
function useStickyOffsets(colWidthsRef, columnCountRef, directionRef) {
  var stickyOffsets = Vue.computed(function() {
    var leftOffsets = [];
    var rightOffsets = [];
    var left = 0;
    var right = 0;
    var colWidths = colWidthsRef.value;
    var columnCount = columnCountRef.value;
    var direction = directionRef.value;
    for (var start = 0; start < columnCount; start += 1) {
      if (direction === "rtl") {
        rightOffsets[start] = right;
        right += colWidths[start] || 0;
        var end = columnCount - start - 1;
        leftOffsets[end] = left;
        left += colWidths[end] || 0;
      } else {
        leftOffsets[start] = left;
        left += colWidths[start] || 0;
        var _end = columnCount - start - 1;
        rightOffsets[_end] = right;
        right += colWidths[_end] || 0;
      }
    }
    return {
      left: leftOffsets,
      right: rightOffsets
    };
  });
  return stickyOffsets;
}
var __rest$t = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function ColGroup(_ref) {
  var colWidths = _ref.colWidths, columns = _ref.columns, columCount = _ref.columCount;
  var cols = [];
  var len = columCount || columns.length;
  var mustInsert = false;
  for (var i2 = len - 1; i2 >= 0; i2 -= 1) {
    var width = colWidths[i2];
    var column = columns && columns[i2];
    var additionalProps = column && column[INTERNAL_COL_DEFINE];
    if (width || additionalProps || mustInsert) {
      var _a = additionalProps || {};
      _a.columnType;
      var restAdditionalProps = __rest$t(_a, ["columnType"]);
      cols.unshift(Vue.createVNode("col", _objectSpread2$1({
        "key": i2,
        "style": {
          width: typeof width === "number" ? "".concat(width, "px") : width
        }
      }, restAdditionalProps), null));
      mustInsert = true;
    }
  }
  return Vue.createVNode("colgroup", null, [cols]);
}
function Panel(_2, _ref) {
  var slots = _ref.slots;
  var _a;
  return Vue.createVNode("div", null, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
}
Panel.displayName = "Panel";
var indexGuid = 0;
var Summary = Vue.defineComponent({
  name: "Summary",
  props: ["fixed"],
  setup: function setup70(props2, _ref) {
    var slots = _ref.slots;
    var tableContext = useInjectTable();
    var uniKey = "table-summary-uni-key-".concat(++indexGuid);
    var fixed = Vue.computed(function() {
      return props2.fixed === "" || props2.fixed;
    });
    Vue.watchEffect(function() {
      tableContext.summaryCollect(uniKey, fixed.value);
    });
    Vue.onBeforeUnmount(function() {
      tableContext.summaryCollect(uniKey, false);
    });
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
  }
});
var Summary$1 = Summary;
var SummaryRow = Vue.defineComponent({
  name: "FooterRow",
  setup: function setup71(_props, _ref) {
    var slots = _ref.slots;
    return function() {
      var _a;
      return Vue.createVNode("tr", null, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
var SummaryContextKey = Symbol("SummaryContextProps");
var useProvideSummary = function useProvideSummary2(props2) {
  Vue.provide(SummaryContextKey, props2);
};
var useInjectSummary = function useInjectSummary2() {
  return Vue.inject(SummaryContextKey, {});
};
var SummaryCell = Vue.defineComponent({
  name: "SummaryCell",
  props: ["index", "colSpan", "rowSpan", "align"],
  setup: function setup72(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var tableContext = useInjectTable();
    var summaryContext = useInjectSummary();
    return function() {
      var index2 = props2.index, _props$colSpan = props2.colSpan, colSpan = _props$colSpan === void 0 ? 1 : _props$colSpan, rowSpan = props2.rowSpan, align = props2.align;
      var prefixCls = tableContext.prefixCls, direction = tableContext.direction;
      var scrollColumnIndex = summaryContext.scrollColumnIndex, stickyOffsets = summaryContext.stickyOffsets, flattenColumns = summaryContext.flattenColumns;
      var lastIndex = index2 + colSpan - 1;
      var mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
      var fixedInfo = getCellFixedInfo(index2, index2 + mergedColSpan - 1, flattenColumns, stickyOffsets, direction);
      return Vue.createVNode(Cell$2, _objectSpread2$1({
        "class": attrs.class,
        "index": index2,
        "component": "td",
        "prefixCls": prefixCls,
        "record": null,
        "dataIndex": null,
        "align": align,
        "colSpan": mergedColSpan,
        "rowSpan": rowSpan,
        "customRender": function customRender() {
          var _a;
          return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
        }
      }, fixedInfo), null);
    };
  }
});
var Footer = Vue.defineComponent({
  name: "Footer",
  inheritAttrs: false,
  props: ["stickyOffsets", "flattenColumns"],
  setup: function setup73(props2, _ref) {
    var slots = _ref.slots;
    var tableContext = useInjectTable();
    useProvideSummary(Vue.reactive({
      stickyOffsets: Vue.toRef(props2, "stickyOffsets"),
      flattenColumns: Vue.toRef(props2, "flattenColumns"),
      scrollColumnIndex: Vue.computed(function() {
        var lastColumnIndex = props2.flattenColumns.length - 1;
        var scrollColumn = props2.flattenColumns[lastColumnIndex];
        return (scrollColumn === null || scrollColumn === void 0 ? void 0 : scrollColumn.scrollbar) ? lastColumnIndex : null;
      })
    }));
    return function() {
      var _a;
      var prefixCls = tableContext.prefixCls;
      return Vue.createVNode("tfoot", {
        "class": "".concat(prefixCls, "-summary")
      }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
var FooterComponents = Summary$1;
function renderExpandIcon$1(_ref) {
  var _ref2;
  var prefixCls = _ref.prefixCls, record = _ref.record, onExpand = _ref.onExpand, expanded = _ref.expanded, expandable = _ref.expandable;
  var expandClassName = "".concat(prefixCls, "-row-expand-icon");
  if (!expandable) {
    return Vue.createVNode("span", {
      "class": [expandClassName, "".concat(prefixCls, "-row-spaced")]
    }, null);
  }
  var onClick2 = function onClick3(event) {
    onExpand(record, event);
    event.stopPropagation();
  };
  return Vue.createVNode("span", {
    "class": (_ref2 = {}, _defineProperty$T(_ref2, expandClassName, true), _defineProperty$T(_ref2, "".concat(prefixCls, "-row-expanded"), expanded), _defineProperty$T(_ref2, "".concat(prefixCls, "-row-collapsed"), !expanded), _ref2),
    "onClick": onClick2
  }, null);
}
function findAllChildrenKeys(data4, getRowKey, childrenColumnName) {
  var keys2 = [];
  function dig(list) {
    (list || []).forEach(function(item, index2) {
      keys2.push(getRowKey(item, index2));
      dig(item[childrenColumnName]);
    });
  }
  dig(data4);
  return keys2;
}
function getOffset(node) {
  var box = node.getBoundingClientRect();
  var docElem = document.documentElement;
  return {
    left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}
var cached;
function getScrollBarSize(fresh) {
  if (typeof document === "undefined") {
    return 0;
  }
  if (fresh || cached === void 0) {
    var inner = document.createElement("div");
    inner.style.width = "100%";
    inner.style.height = "200px";
    var outer = document.createElement("div");
    var outerStyle = outer.style;
    outerStyle.position = "absolute";
    outerStyle.top = "0";
    outerStyle.left = "0";
    outerStyle.pointerEvents = "none";
    outerStyle.visibility = "hidden";
    outerStyle.width = "200px";
    outerStyle.height = "150px";
    outerStyle.overflow = "hidden";
    outer.appendChild(inner);
    document.body.appendChild(outer);
    var widthContained = inner.offsetWidth;
    outer.style.overflow = "scroll";
    var widthScroll = inner.offsetWidth;
    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }
    document.body.removeChild(outer);
    cached = widthContained - widthScroll;
  }
  return cached;
}
function ensureSize(str) {
  var match2 = str.match(/^(.*)px$/);
  var value = Number(match2 === null || match2 === void 0 ? void 0 : match2[1]);
  return Number.isNaN(value) ? getScrollBarSize() : value;
}
function getTargetScrollBarSize(target) {
  if (typeof document === "undefined" || !target || !(target instanceof Element)) {
    return {
      width: 0,
      height: 0
    };
  }
  var _getComputedStyle2 = getComputedStyle(target, "::-webkit-scrollbar"), width = _getComputedStyle2.width, height = _getComputedStyle2.height;
  return {
    width: ensureSize(width),
    height: ensureSize(height)
  };
}
var StickyScrollBar = Vue.defineComponent({
  name: "StickyScrollBar",
  inheritAttrs: false,
  props: ["offsetScroll", "container", "scrollBodyRef", "scrollBodySizeInfo"],
  emits: ["scroll"],
  setup: function setup74(props2, _ref) {
    var emit = _ref.emit, expose = _ref.expose;
    var tableContext = useInjectTable();
    var bodyScrollWidth = Vue.ref(0);
    var bodyWidth = Vue.ref(0);
    var scrollBarWidth = Vue.ref(0);
    Vue.watchEffect(function() {
      bodyScrollWidth.value = props2.scrollBodySizeInfo.scrollWidth || 0;
      bodyWidth.value = props2.scrollBodySizeInfo.clientWidth || 0;
      scrollBarWidth.value = bodyScrollWidth.value && bodyWidth.value * (bodyWidth.value / bodyScrollWidth.value);
    }, {
      flush: "post"
    });
    var scrollBarRef = Vue.ref();
    var _useLayoutState = useLayoutState({
      scrollLeft: 0,
      isHiddenScrollBar: true
    }), _useLayoutState2 = _slicedToArray(_useLayoutState, 2), scrollState = _useLayoutState2[0], setScrollState = _useLayoutState2[1];
    var refState = Vue.ref({
      delta: 0,
      x: 0
    });
    var isActive = Vue.ref(false);
    var onMouseUp2 = function onMouseUp3() {
      isActive.value = false;
    };
    var onMouseDown2 = function onMouseDown3(event) {
      refState.value = {
        delta: event.pageX - scrollState.value.scrollLeft,
        x: 0
      };
      isActive.value = true;
      event.preventDefault();
    };
    var onMouseMove3 = function onMouseMove4(event) {
      var _ref2 = event || (window === null || window === void 0 ? void 0 : window.event), buttons = _ref2.buttons;
      if (!isActive.value || buttons === 0) {
        if (isActive.value) {
          isActive.value = false;
        }
        return;
      }
      var left = refState.value.x + event.pageX - refState.value.x - refState.value.delta;
      if (left <= 0) {
        left = 0;
      }
      if (left + scrollBarWidth.value >= bodyWidth.value) {
        left = bodyWidth.value - scrollBarWidth.value;
      }
      emit("scroll", {
        scrollLeft: left / bodyWidth.value * (bodyScrollWidth.value + 2)
      });
      refState.value.x = event.pageX;
    };
    var onContainerScroll = function onContainerScroll2() {
      if (!props2.scrollBodyRef.value) {
        return;
      }
      var tableOffsetTop = getOffset(props2.scrollBodyRef.value).top;
      var tableBottomOffset = tableOffsetTop + props2.scrollBodyRef.value.offsetHeight;
      var currentClientOffset = props2.container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(props2.container).top + props2.container.clientHeight;
      if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - props2.offsetScroll) {
        setScrollState(function(state) {
          return _extends(_extends({}, state), {
            isHiddenScrollBar: true
          });
        });
      } else {
        setScrollState(function(state) {
          return _extends(_extends({}, state), {
            isHiddenScrollBar: false
          });
        });
      }
    };
    var setScrollLeft = function setScrollLeft2(left) {
      setScrollState(function(state) {
        return _extends(_extends({}, state), {
          scrollLeft: left / bodyScrollWidth.value * bodyWidth.value || 0
        });
      });
    };
    expose({
      setScrollLeft
    });
    var onMouseUpListener = null;
    var onMouseMoveListener = null;
    var onResizeListener = null;
    var onScrollListener = null;
    Vue.onMounted(function() {
      onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp2, false);
      onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove3, false);
      onResizeListener = addEventListenerWrap(window, "resize", onContainerScroll, false);
    });
    Vue.onActivated(function() {
      Vue.nextTick(function() {
        onContainerScroll();
      });
    });
    Vue.onMounted(function() {
      setTimeout(function() {
        Vue.watch([scrollBarWidth, isActive], function() {
          onContainerScroll();
        }, {
          immediate: true,
          flush: "post"
        });
      });
    });
    Vue.watch(function() {
      return props2.container;
    }, function() {
      onScrollListener === null || onScrollListener === void 0 ? void 0 : onScrollListener.remove();
      onScrollListener = addEventListenerWrap(props2.container, "scroll", onContainerScroll, false);
    }, {
      immediate: true,
      flush: "post"
    });
    Vue.onBeforeUnmount(function() {
      onMouseUpListener === null || onMouseUpListener === void 0 ? void 0 : onMouseUpListener.remove();
      onMouseMoveListener === null || onMouseMoveListener === void 0 ? void 0 : onMouseMoveListener.remove();
      onScrollListener === null || onScrollListener === void 0 ? void 0 : onScrollListener.remove();
      onResizeListener === null || onResizeListener === void 0 ? void 0 : onResizeListener.remove();
    });
    Vue.watch(function() {
      return _extends({}, scrollState.value);
    }, function(newState, preState) {
      if (newState.isHiddenScrollBar !== (preState === null || preState === void 0 ? void 0 : preState.isHiddenScrollBar) && !newState.isHiddenScrollBar) {
        setScrollState(function(state) {
          var bodyNode = props2.scrollBodyRef.value;
          if (!bodyNode) {
            return state;
          }
          return _extends(_extends({}, state), {
            scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
          });
        });
      }
    }, {
      immediate: true
    });
    var scrollbarSize = getScrollBarSize();
    return function() {
      if (bodyScrollWidth.value <= bodyWidth.value || !scrollBarWidth.value || scrollState.value.isHiddenScrollBar) {
        return null;
      }
      var prefixCls = tableContext.prefixCls;
      return Vue.createVNode("div", {
        "style": {
          height: "".concat(scrollbarSize, "px"),
          width: "".concat(bodyWidth.value, "px"),
          bottom: "".concat(props2.offsetScroll, "px")
        },
        "class": "".concat(prefixCls, "-sticky-scroll")
      }, [Vue.createVNode("div", {
        "onMousedown": onMouseDown2,
        "ref": scrollBarRef,
        "class": classNames("".concat(prefixCls, "-sticky-scroll-bar"), _defineProperty$T({}, "".concat(prefixCls, "-sticky-scroll-bar-active"), isActive)),
        "style": {
          width: "".concat(scrollBarWidth.value, "px"),
          transform: "translate3d(".concat(scrollState.value.scrollLeft, "px, 0, 0)")
        }
      }, null)]);
    };
  }
});
var defaultContainer = canUseDom() ? window : null;
function useSticky(stickyRef, prefixClsRef) {
  return Vue.computed(function() {
    var _ref = _typeof$1(stickyRef.value) === "object" ? stickyRef.value : {}, _ref$offsetHeader = _ref.offsetHeader, offsetHeader = _ref$offsetHeader === void 0 ? 0 : _ref$offsetHeader, _ref$offsetSummary = _ref.offsetSummary, offsetSummary = _ref$offsetSummary === void 0 ? 0 : _ref$offsetSummary, _ref$offsetScroll = _ref.offsetScroll, offsetScroll = _ref$offsetScroll === void 0 ? 0 : _ref$offsetScroll, _ref$getContainer = _ref.getContainer, getContainer4 = _ref$getContainer === void 0 ? function() {
      return defaultContainer;
    } : _ref$getContainer;
    var container = getContainer4() || defaultContainer;
    var isSticky = !!stickyRef.value;
    return {
      isSticky,
      stickyClassName: isSticky ? "".concat(prefixClsRef.value, "-sticky-holder") : "",
      offsetHeader,
      offsetSummary,
      offsetScroll,
      container
    };
  });
}
function useColumnWidth(colWidthsRef, columCountRef) {
  return Vue.computed(function() {
    var cloneColumns = [];
    var colWidths = colWidthsRef.value;
    var columCount = columCountRef.value;
    for (var i2 = 0; i2 < columCount; i2 += 1) {
      var val = colWidths[i2];
      if (val !== void 0) {
        cloneColumns[i2] = val;
      } else {
        return null;
      }
    }
    return cloneColumns;
  });
}
var FixedHolder = Vue.defineComponent({
  name: "FixedHolder",
  inheritAttrs: false,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow", "noData", "maxContentScroll", "colWidths", "columCount", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName"],
  emits: ["scroll"],
  setup: function setup75(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit;
    var tableContext = useInjectTable();
    var combinationScrollBarSize = Vue.computed(function() {
      return tableContext.isSticky && !props2.fixHeader ? 0 : tableContext.scrollbarSize;
    });
    var scrollRef = Vue.ref();
    var onWheel = function onWheel2(e2) {
      var currentTarget = e2.currentTarget, deltaX = e2.deltaX;
      if (deltaX) {
        emit("scroll", {
          currentTarget,
          scrollLeft: currentTarget.scrollLeft + deltaX
        });
        e2.preventDefault();
      }
    };
    var wheelEvent = Vue.ref();
    Vue.onMounted(function() {
      Vue.nextTick(function() {
        wheelEvent.value = addEventListenerWrap(scrollRef.value, "wheel", onWheel);
      });
    });
    Vue.onBeforeUnmount(function() {
      var _a;
      (_a = wheelEvent.value) === null || _a === void 0 ? void 0 : _a.remove();
    });
    var allFlattenColumnsWithWidth = Vue.computed(function() {
      return props2.flattenColumns.every(function(column) {
        return column.width && column.width !== 0 && column.width !== "0px";
      });
    });
    var columnsWithScrollbar = Vue.ref([]);
    var flattenColumnsWithScrollbar = Vue.ref([]);
    Vue.watchEffect(function() {
      var lastColumn = props2.flattenColumns[props2.flattenColumns.length - 1];
      var ScrollBarColumn = {
        fixed: lastColumn ? lastColumn.fixed : null,
        scrollbar: true,
        customHeaderCell: function customHeaderCell() {
          return {
            class: "".concat(tableContext.prefixCls, "-cell-scrollbar")
          };
        }
      };
      columnsWithScrollbar.value = combinationScrollBarSize.value ? [].concat(_toConsumableArray(props2.columns), [ScrollBarColumn]) : props2.columns;
      flattenColumnsWithScrollbar.value = combinationScrollBarSize.value ? [].concat(_toConsumableArray(props2.flattenColumns), [ScrollBarColumn]) : props2.flattenColumns;
    });
    var headerStickyOffsets = Vue.computed(function() {
      var stickyOffsets = props2.stickyOffsets, direction = props2.direction;
      var right = stickyOffsets.right, left = stickyOffsets.left;
      return _extends(_extends({}, stickyOffsets), {
        left: direction === "rtl" ? [].concat(_toConsumableArray(left.map(function(width) {
          return width + combinationScrollBarSize.value;
        })), [0]) : left,
        right: direction === "rtl" ? right : [].concat(_toConsumableArray(right.map(function(width) {
          return width + combinationScrollBarSize.value;
        })), [0]),
        isSticky: tableContext.isSticky
      });
    });
    var mergedColumnWidth = useColumnWidth(Vue.toRef(props2, "colWidths"), Vue.toRef(props2, "columCount"));
    return function() {
      var _a;
      var noData = props2.noData, columCount = props2.columCount, stickyTopOffset = props2.stickyTopOffset, stickyBottomOffset = props2.stickyBottomOffset, stickyClassName = props2.stickyClassName, maxContentScroll = props2.maxContentScroll;
      var isSticky = tableContext.isSticky;
      return Vue.createVNode("div", {
        "style": _extends({
          overflow: "hidden"
        }, isSticky ? {
          top: "".concat(stickyTopOffset, "px"),
          bottom: "".concat(stickyBottomOffset, "px")
        } : {}),
        "ref": scrollRef,
        "class": classNames(attrs.class, _defineProperty$T({}, stickyClassName, !!stickyClassName))
      }, [Vue.createVNode("table", {
        "style": {
          tableLayout: "fixed",
          visibility: noData || mergedColumnWidth.value ? null : "hidden"
        }
      }, [(!noData || !maxContentScroll || allFlattenColumnsWithWidth.value) && Vue.createVNode(ColGroup, {
        "colWidths": mergedColumnWidth.value ? [].concat(_toConsumableArray(mergedColumnWidth.value), [combinationScrollBarSize.value]) : [],
        "columCount": columCount + 1,
        "columns": flattenColumnsWithScrollbar.value
      }, null), (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, _extends(_extends({}, props2), {
        stickyOffsets: headerStickyOffsets.value,
        columns: columnsWithScrollbar.value,
        flattenColumns: flattenColumnsWithScrollbar.value
      }))])]);
    };
  }
});
function reactivePick(obj) {
  for (var _len = arguments.length, keys2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys2[_key - 1] = arguments[_key];
  }
  return Vue.reactive(Object.fromEntries(keys2.map(function(k2) {
    return [k2, Vue.toRef(obj, k2)];
  })));
}
var EMPTY_DATA$1 = [];
var EMPTY_SCROLL_TARGET = {};
var INTERNAL_HOOKS = "rc-table-internal-hook";
var Table$2 = Vue.defineComponent({
  name: "Table",
  inheritAttrs: false,
  props: ["prefixCls", "data", "columns", "rowKey", "tableLayout", "scroll", "rowClassName", "title", "footer", "id", "showHeader", "components", "customRow", "customHeaderRow", "direction", "expandFixed", "expandColumnWidth", "expandedRowKeys", "defaultExpandedRowKeys", "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange", "defaultExpandAllRows", "indentSize", "expandIconColumnIndex", "expandedRowClassName", "childrenColumnName", "rowExpandable", "sticky", "transformColumns", "internalHooks", "internalRefs", "canExpandable", "onUpdateInternalRefs", "transformCellText"],
  slots: ["title", "footer", "summary", "emptyText"],
  emits: ["expand", "expandedRowsChange", "updateInternalRefs"],
  setup: function setup76(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit;
    var mergedData = Vue.computed(function() {
      return props2.data || EMPTY_DATA$1;
    });
    var hasData = Vue.computed(function() {
      return !!mergedData.value.length;
    });
    var mergedComponents = Vue.computed(function() {
      return mergeObject(props2.components, {});
    });
    var getComponent3 = function getComponent4(path, defaultComponent) {
      return getPathValue(mergedComponents.value, path) || defaultComponent;
    };
    var getRowKey = Vue.computed(function() {
      var rowKey = props2.rowKey;
      if (typeof rowKey === "function") {
        return rowKey;
      }
      return function(record) {
        var key2 = record && record[rowKey];
        return key2;
      };
    });
    var mergedExpandIcon = Vue.computed(function() {
      return props2.expandIcon || renderExpandIcon$1;
    });
    var mergedChildrenColumnName = Vue.computed(function() {
      return props2.childrenColumnName || "children";
    });
    var expandableType = Vue.computed(function() {
      if (props2.expandedRowRender) {
        return "row";
      }
      if (props2.canExpandable || mergedData.value.some(function(record) {
        return record && _typeof$1(record) === "object" && record[mergedChildrenColumnName.value];
      })) {
        return "nest";
      }
      return false;
    });
    var innerExpandedKeys = Vue.shallowRef([]);
    var stop = Vue.watchEffect(function() {
      if (props2.defaultExpandedRowKeys) {
        innerExpandedKeys.value = props2.defaultExpandedRowKeys;
      }
      if (props2.defaultExpandAllRows) {
        innerExpandedKeys.value = findAllChildrenKeys(mergedData.value, getRowKey.value, mergedChildrenColumnName.value);
      }
    });
    stop();
    var mergedExpandedKeys = Vue.computed(function() {
      return new Set(props2.expandedRowKeys || innerExpandedKeys.value || []);
    });
    var onTriggerExpand = function onTriggerExpand2(record) {
      var key2 = getRowKey.value(record, mergedData.value.indexOf(record));
      var newExpandedKeys;
      var hasKey = mergedExpandedKeys.value.has(key2);
      if (hasKey) {
        mergedExpandedKeys.value.delete(key2);
        newExpandedKeys = _toConsumableArray(mergedExpandedKeys.value);
      } else {
        newExpandedKeys = [].concat(_toConsumableArray(mergedExpandedKeys.value), [key2]);
      }
      innerExpandedKeys.value = newExpandedKeys;
      emit("expand", !hasKey, record);
      emit("expandedRowsChange", newExpandedKeys);
    };
    var componentWidth = Vue.ref(0);
    var _useColumns = useColumns$1(_extends(_extends({}, Vue.toRefs(props2)), {
      expandable: Vue.computed(function() {
        return !!props2.expandedRowRender;
      }),
      expandedKeys: mergedExpandedKeys,
      getRowKey,
      onTriggerExpand,
      expandIcon: mergedExpandIcon
    }), Vue.computed(function() {
      return props2.internalHooks === INTERNAL_HOOKS ? props2.transformColumns : null;
    })), _useColumns2 = _slicedToArray(_useColumns, 2), columns = _useColumns2[0], flattenColumns = _useColumns2[1];
    var columnContext = Vue.computed(function() {
      return {
        columns: columns.value,
        flattenColumns: flattenColumns.value
      };
    });
    var fullTableRef = Vue.ref();
    var scrollHeaderRef = Vue.ref();
    var scrollBodyRef = Vue.ref();
    var scrollBodySizeInfo = Vue.ref({
      scrollWidth: 0,
      clientWidth: 0
    });
    var scrollSummaryRef = Vue.ref();
    var _useState = useState(false), _useState2 = _slicedToArray(_useState, 2), pingedLeft = _useState2[0], setPingedLeft = _useState2[1];
    var _useState3 = useState(false), _useState4 = _slicedToArray(_useState3, 2), pingedRight = _useState4[0], setPingedRight = _useState4[1];
    var _useLayoutState = useLayoutState(/* @__PURE__ */ new Map()), _useLayoutState2 = _slicedToArray(_useLayoutState, 2), colsWidths = _useLayoutState2[0], updateColsWidths = _useLayoutState2[1];
    var colsKeys = Vue.computed(function() {
      return getColumnsKey(flattenColumns.value);
    });
    var colWidths = Vue.computed(function() {
      return colsKeys.value.map(function(columnKey) {
        return colsWidths.value.get(columnKey);
      });
    });
    var columnCount = Vue.computed(function() {
      return flattenColumns.value.length;
    });
    var stickyOffsets = useStickyOffsets(colWidths, columnCount, Vue.toRef(props2, "direction"));
    var fixHeader = Vue.computed(function() {
      return props2.scroll && validateValue(props2.scroll.y);
    });
    var horizonScroll = Vue.computed(function() {
      return props2.scroll && validateValue(props2.scroll.x) || Boolean(props2.expandFixed);
    });
    var fixColumn = Vue.computed(function() {
      return horizonScroll.value && flattenColumns.value.some(function(_ref2) {
        var fixed = _ref2.fixed;
        return fixed;
      });
    });
    var stickyRef = Vue.ref();
    var stickyState = useSticky(Vue.toRef(props2, "sticky"), Vue.toRef(props2, "prefixCls"));
    var summaryFixedInfos = Vue.reactive({});
    var fixFooter = Vue.computed(function() {
      var info = Object.values(summaryFixedInfos)[0];
      return (fixHeader.value || stickyState.value.isSticky) && info;
    });
    var summaryCollect = function summaryCollect2(uniKey, fixed) {
      if (fixed) {
        summaryFixedInfos[uniKey] = fixed;
      } else {
        delete summaryFixedInfos[uniKey];
      }
    };
    var scrollXStyle = Vue.ref({});
    var scrollYStyle = Vue.ref({});
    var scrollTableStyle = Vue.ref({});
    Vue.watchEffect(function() {
      if (fixHeader.value) {
        scrollYStyle.value = {
          overflowY: "scroll",
          maxHeight: toPx(props2.scroll.y)
        };
      }
      if (horizonScroll.value) {
        scrollXStyle.value = {
          overflowX: "auto"
        };
        if (!fixHeader.value) {
          scrollYStyle.value = {
            overflowY: "hidden"
          };
        }
        scrollTableStyle.value = {
          width: props2.scroll.x === true ? "auto" : toPx(props2.scroll.x),
          minWidth: "100%"
        };
      }
    });
    var onColumnResize = function onColumnResize2(columnKey, width) {
      if (isVisible(fullTableRef.value)) {
        updateColsWidths(function(widths) {
          if (widths.get(columnKey) !== width) {
            var newWidths = new Map(widths);
            newWidths.set(columnKey, width);
            return newWidths;
          }
          return widths;
        });
      }
    };
    var _useTimeoutLock = useTimeoutLock(null), _useTimeoutLock2 = _slicedToArray(_useTimeoutLock, 2), setScrollTarget = _useTimeoutLock2[0], getScrollTarget = _useTimeoutLock2[1];
    function forceScroll(scrollLeft, target) {
      if (!target) {
        return;
      }
      if (typeof target === "function") {
        target(scrollLeft);
        return;
      }
      var domTarget = target.$el || target;
      if (domTarget.scrollLeft !== scrollLeft) {
        domTarget.scrollLeft = scrollLeft;
      }
    }
    var onScroll = function onScroll2(_ref3) {
      var currentTarget = _ref3.currentTarget, scrollLeft = _ref3.scrollLeft;
      var _a;
      var isRTL = props2.direction === "rtl";
      var mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
      var compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
      if (!getScrollTarget() || getScrollTarget() === compareTarget) {
        setScrollTarget(compareTarget);
        forceScroll(mergedScrollLeft, scrollHeaderRef.value);
        forceScroll(mergedScrollLeft, scrollBodyRef.value);
        forceScroll(mergedScrollLeft, scrollSummaryRef.value);
        forceScroll(mergedScrollLeft, (_a = stickyRef.value) === null || _a === void 0 ? void 0 : _a.setScrollLeft);
      }
      if (currentTarget) {
        var scrollWidth = currentTarget.scrollWidth, clientWidth = currentTarget.clientWidth;
        if (isRTL) {
          setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
          setPingedRight(-mergedScrollLeft > 0);
        } else {
          setPingedLeft(mergedScrollLeft > 0);
          setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
        }
      }
    };
    var triggerOnScroll = function triggerOnScroll2() {
      if (horizonScroll.value && scrollBodyRef.value) {
        onScroll({
          currentTarget: scrollBodyRef.value
        });
      } else {
        setPingedLeft(false);
        setPingedRight(false);
      }
    };
    var timtout;
    var updateWidth = function updateWidth2(width) {
      if (width !== componentWidth.value) {
        triggerOnScroll();
        componentWidth.value = fullTableRef.value ? fullTableRef.value.offsetWidth : width;
      }
    };
    var onFullTableResize = function onFullTableResize2(_ref4) {
      var width = _ref4.width;
      clearTimeout(timtout);
      if (componentWidth.value === 0) {
        updateWidth(width);
        return;
      }
      timtout = setTimeout(function() {
        updateWidth(width);
      }, 100);
    };
    Vue.watch([horizonScroll, function() {
      return props2.data;
    }, function() {
      return props2.columns;
    }], function() {
      if (horizonScroll.value) {
        triggerOnScroll();
      }
    });
    var _useState5 = useState(0), _useState6 = _slicedToArray(_useState5, 2), scrollbarSize = _useState6[0], setScrollbarSize = _useState6[1];
    useProvideSticky();
    Vue.onMounted(function() {
      Vue.nextTick(function() {
        var _a, _b;
        triggerOnScroll();
        setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.value).width);
        scrollBodySizeInfo.value = {
          scrollWidth: ((_a = scrollBodyRef.value) === null || _a === void 0 ? void 0 : _a.scrollWidth) || 0,
          clientWidth: ((_b = scrollBodyRef.value) === null || _b === void 0 ? void 0 : _b.clientWidth) || 0
        };
      });
    });
    Vue.onUpdated(function() {
      Vue.nextTick(function() {
        var _a, _b;
        var scrollWidth = ((_a = scrollBodyRef.value) === null || _a === void 0 ? void 0 : _a.scrollWidth) || 0;
        var clientWidth = ((_b = scrollBodyRef.value) === null || _b === void 0 ? void 0 : _b.clientWidth) || 0;
        if (scrollBodySizeInfo.value.scrollWidth !== scrollWidth || scrollBodySizeInfo.value.clientWidth !== clientWidth) {
          scrollBodySizeInfo.value = {
            scrollWidth,
            clientWidth
          };
        }
      });
    });
    Vue.watchEffect(function() {
      if (props2.internalHooks === INTERNAL_HOOKS && props2.internalRefs) {
        props2.onUpdateInternalRefs({
          body: scrollBodyRef.value ? scrollBodyRef.value.$el || scrollBodyRef.value : null
        });
      }
    }, {
      flush: "post"
    });
    var mergedTableLayout = Vue.computed(function() {
      if (props2.tableLayout) {
        return props2.tableLayout;
      }
      if (fixColumn.value) {
        return props2.scroll.x === "max-content" ? "auto" : "fixed";
      }
      if (fixHeader.value || stickyState.value.isSticky || flattenColumns.value.some(function(_ref5) {
        var ellipsis = _ref5.ellipsis;
        return ellipsis;
      })) {
        return "fixed";
      }
      return "auto";
    });
    var emptyNode = function emptyNode2() {
      var _a;
      return hasData.value ? null : ((_a = slots.emptyText) === null || _a === void 0 ? void 0 : _a.call(slots)) || "No Data";
    };
    useProvideTable(Vue.reactive(_extends(_extends({}, Vue.toRefs(reactivePick(props2, "prefixCls", "direction", "transformCellText"))), {
      getComponent: getComponent3,
      scrollbarSize,
      fixedInfoList: Vue.computed(function() {
        return flattenColumns.value.map(function(_2, colIndex) {
          return getCellFixedInfo(colIndex, colIndex, flattenColumns.value, stickyOffsets.value, props2.direction);
        });
      }),
      isSticky: Vue.computed(function() {
        return stickyState.value.isSticky;
      }),
      summaryCollect
    })));
    useProvideBody(Vue.reactive(_extends(_extends({}, Vue.toRefs(reactivePick(props2, "rowClassName", "expandedRowClassName", "expandRowByClick", "expandedRowRender", "expandIconColumnIndex", "indentSize"))), {
      columns,
      flattenColumns,
      tableLayout: mergedTableLayout,
      expandIcon: mergedExpandIcon,
      expandableType,
      onTriggerExpand
    })));
    useProvideResize({
      onColumnResize
    });
    useProvideExpandedRow({
      componentWidth,
      fixHeader,
      fixColumn,
      horizonScroll
    });
    var bodyTable = function bodyTable2() {
      return Vue.createVNode(Body, {
        "data": mergedData.value,
        "measureColumnWidth": fixHeader.value || horizonScroll.value || stickyState.value.isSticky,
        "expandedKeys": mergedExpandedKeys.value,
        "rowExpandable": props2.rowExpandable,
        "getRowKey": getRowKey.value,
        "customRow": props2.customRow,
        "childrenColumnName": mergedChildrenColumnName.value
      }, {
        emptyNode
      });
    };
    var bodyColGroup = function bodyColGroup2() {
      return Vue.createVNode(ColGroup, {
        "colWidths": flattenColumns.value.map(function(_ref6) {
          var width = _ref6.width;
          return width;
        }),
        "columns": flattenColumns.value
      }, null);
    };
    return function() {
      var _a;
      var prefixCls = props2.prefixCls, scroll = props2.scroll, tableLayout = props2.tableLayout, direction = props2.direction, _props$title = props2.title, title = _props$title === void 0 ? slots.title : _props$title, _props$footer = props2.footer, footer = _props$footer === void 0 ? slots.footer : _props$footer, id = props2.id, showHeader = props2.showHeader, customHeaderRow = props2.customHeaderRow;
      var _stickyState$value = stickyState.value, isSticky = _stickyState$value.isSticky, offsetHeader = _stickyState$value.offsetHeader, offsetSummary = _stickyState$value.offsetSummary, offsetScroll = _stickyState$value.offsetScroll, stickyClassName = _stickyState$value.stickyClassName, container = _stickyState$value.container;
      var TableComponent = getComponent3(["table"], "table");
      var customizeScrollBody = getComponent3(["body"]);
      var summaryNode = (_a = slots.summary) === null || _a === void 0 ? void 0 : _a.call(slots, {
        pageData: mergedData.value
      });
      var groupTableNode = function groupTableNode2() {
        return null;
      };
      var headerProps = {
        colWidths: colWidths.value,
        columCount: flattenColumns.value.length,
        stickyOffsets: stickyOffsets.value,
        customHeaderRow,
        fixHeader: fixHeader.value,
        scroll
      };
      if (fixHeader.value || isSticky) {
        var bodyContent = function bodyContent2() {
          return null;
        };
        if (typeof customizeScrollBody === "function") {
          bodyContent = function bodyContent2() {
            return customizeScrollBody(mergedData.value, {
              scrollbarSize: scrollbarSize.value,
              ref: scrollBodyRef,
              onScroll
            });
          };
          headerProps.colWidths = flattenColumns.value.map(function(_ref7, index2) {
            var width = _ref7.width;
            var colWidth = index2 === columns.value.length - 1 ? width - scrollbarSize.value : width;
            if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
              return colWidth;
            }
            return 0;
          });
        } else {
          bodyContent = function bodyContent2() {
            return Vue.createVNode("div", {
              "style": _extends(_extends({}, scrollXStyle.value), scrollYStyle.value),
              "onScroll": onScroll,
              "ref": scrollBodyRef,
              "class": classNames("".concat(prefixCls, "-body"))
            }, [Vue.createVNode(TableComponent, {
              "style": _extends(_extends({}, scrollTableStyle.value), {
                tableLayout: mergedTableLayout.value
              })
            }, {
              default: function _default5() {
                return [bodyColGroup(), bodyTable(), !fixFooter.value && summaryNode && Vue.createVNode(Footer, {
                  "stickyOffsets": stickyOffsets.value,
                  "flattenColumns": flattenColumns.value
                }, {
                  default: function _default6() {
                    return [summaryNode];
                  }
                })];
              }
            })]);
          };
        }
        var fixedHolderProps = _extends(_extends(_extends({
          noData: !mergedData.value.length,
          maxContentScroll: horizonScroll.value && scroll.x === "max-content"
        }, headerProps), columnContext.value), {
          direction,
          stickyClassName,
          onScroll
        });
        groupTableNode = function groupTableNode2() {
          return Vue.createVNode(Vue.Fragment, null, [showHeader !== false && Vue.createVNode(FixedHolder, _objectSpread2$1(_objectSpread2$1({}, fixedHolderProps), {}, {
            "stickyTopOffset": offsetHeader,
            "class": "".concat(prefixCls, "-header"),
            "ref": scrollHeaderRef
          }), {
            default: function _default5(fixedHolderPassProps) {
              return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode(Header$1, fixedHolderPassProps, null), fixFooter.value === "top" && Vue.createVNode(Footer, fixedHolderPassProps, {
                default: function _default6() {
                  return [summaryNode];
                }
              })]);
            }
          }), bodyContent(), fixFooter.value && fixFooter.value !== "top" && Vue.createVNode(FixedHolder, _objectSpread2$1(_objectSpread2$1({}, fixedHolderProps), {}, {
            "stickyBottomOffset": offsetSummary,
            "class": "".concat(prefixCls, "-summary"),
            "ref": scrollSummaryRef
          }), {
            default: function _default5(fixedHolderPassProps) {
              return Vue.createVNode(Footer, fixedHolderPassProps, {
                default: function _default6() {
                  return [summaryNode];
                }
              });
            }
          }), isSticky && scrollBodyRef.value && Vue.createVNode(StickyScrollBar, {
            "ref": stickyRef,
            "offsetScroll": offsetScroll,
            "scrollBodyRef": scrollBodyRef,
            "onScroll": onScroll,
            "container": container,
            "scrollBodySizeInfo": scrollBodySizeInfo.value
          }, null)]);
        };
      } else {
        groupTableNode = function groupTableNode2() {
          return Vue.createVNode("div", {
            "style": _extends(_extends({}, scrollXStyle.value), scrollYStyle.value),
            "class": classNames("".concat(prefixCls, "-content")),
            "onScroll": onScroll,
            "ref": scrollBodyRef
          }, [Vue.createVNode(TableComponent, {
            "style": _extends(_extends({}, scrollTableStyle.value), {
              tableLayout: mergedTableLayout.value
            })
          }, {
            default: function _default5() {
              return [bodyColGroup(), showHeader !== false && Vue.createVNode(Header$1, _objectSpread2$1(_objectSpread2$1({}, headerProps), columnContext.value), null), bodyTable(), summaryNode && Vue.createVNode(Footer, {
                "stickyOffsets": stickyOffsets.value,
                "flattenColumns": flattenColumns.value
              }, {
                default: function _default6() {
                  return [summaryNode];
                }
              })];
            }
          })]);
        };
      }
      var ariaProps = pickAttrs(attrs, {
        aria: true,
        data: true
      });
      var fullTable = function fullTable2() {
        var _classNames;
        return Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({}, ariaProps), {}, {
          "class": classNames(prefixCls, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$T(_classNames, "".concat(prefixCls, "-ping-left"), pingedLeft.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-ping-right"), pingedRight.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-layout-fixed"), tableLayout === "fixed"), _defineProperty$T(_classNames, "".concat(prefixCls, "-fixed-header"), fixHeader.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-fixed-column"), fixColumn.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-scroll-horizontal"), horizonScroll.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-has-fix-left"), flattenColumns.value[0] && flattenColumns.value[0].fixed), _defineProperty$T(_classNames, "".concat(prefixCls, "-has-fix-right"), flattenColumns.value[columnCount.value - 1] && flattenColumns.value[columnCount.value - 1].fixed === "right"), _defineProperty$T(_classNames, attrs.class, attrs.class), _classNames)),
          "style": attrs.style,
          "id": id,
          "ref": fullTableRef
        }), [title && Vue.createVNode(Panel, {
          "class": "".concat(prefixCls, "-title")
        }, {
          default: function _default5() {
            return [title(mergedData.value)];
          }
        }), Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-container")
        }, [groupTableNode()]), footer && Vue.createVNode(Panel, {
          "class": "".concat(prefixCls, "-footer")
        }, {
          default: function _default5() {
            return [footer(mergedData.value)];
          }
        })]);
      };
      if (horizonScroll.value) {
        return Vue.createVNode(ResizeObserver$1, {
          "onResize": onFullTableResize
        }, {
          default: fullTable
        });
      }
      return fullTable();
    };
  }
});
function getKey$1(data4, index2) {
  var key2 = data4.key;
  var value;
  if ("value" in data4) {
    value = data4.value;
  }
  if (key2 !== null && key2 !== void 0) {
    return key2;
  }
  if (value !== void 0) {
    return value;
  }
  return "rc-index-key-".concat(index2);
}
function fillFieldNames$1(fieldNames, childrenAsData) {
  var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, options = _ref.options;
  return {
    label: label || (childrenAsData ? "children" : "label"),
    value: value || "value",
    options: options || "options"
  };
}
function flattenOptions(options) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData;
  var flattenList = [];
  var _fillFieldNames = fillFieldNames$1(fieldNames, false), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options;
  function dig(list, isGroupOption) {
    list.forEach(function(data4) {
      var label = data4[fieldLabel];
      if (isGroupOption || !(fieldOptions in data4)) {
        var value = data4[fieldValue];
        flattenList.push({
          key: getKey$1(data4, flattenList.length),
          groupOption: isGroupOption,
          data: data4,
          label,
          value
        });
      } else {
        var grpLabel = label;
        if (grpLabel === void 0 && childrenAsData) {
          grpLabel = data4.label;
        }
        flattenList.push({
          key: getKey$1(data4, flattenList.length),
          group: true,
          data: data4,
          label: grpLabel
        });
        dig(data4[fieldOptions], true);
      }
    });
  }
  dig(options, false);
  return flattenList;
}
function injectPropsWithOption(option) {
  var newOption = _extends({}, option);
  if (!("props" in newOption)) {
    Object.defineProperty(newOption, "props", {
      get: function get2() {
        return newOption;
      }
    });
  }
  return newOption;
}
function getSeparatedContent(text, tokens) {
  if (!tokens || !tokens.length) {
    return null;
  }
  var match2 = false;
  function separate(str, _ref3) {
    var _ref4 = _toArray(_ref3), token = _ref4[0], restTokens = _ref4.slice(1);
    if (!token) {
      return [str];
    }
    var list2 = str.split(token);
    match2 = match2 || list2.length > 1;
    return list2.reduce(function(prevList, unitStr) {
      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));
    }, []).filter(function(unit) {
      return unit;
    });
  }
  var list = separate(text, tokens);
  return match2 ? list : null;
}
var __rest$s = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var getBuiltInPlacements = function getBuiltInPlacements2(dropdownMatchSelectWidth) {
  var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    }
  };
};
var SelectTrigger = Vue.defineComponent({
  name: "SelectTrigger",
  inheritAttrs: false,
  props: {
    dropdownAlign: Object,
    visible: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownStyle: PropTypes$1.object,
    placement: String,
    empty: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    popupClassName: String,
    animation: String,
    transitionName: String,
    getPopupContainer: Function,
    dropdownRender: Function,
    containerWidth: Number,
    dropdownMatchSelectWidth: PropTypes$1.oneOfType([Number, Boolean]).def(true),
    popupElement: PropTypes$1.any,
    direction: String,
    getTriggerDOMNode: Function,
    onPopupVisibleChange: Function,
    onPopupMouseEnter: Function
  },
  setup: function setup77(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var builtInPlacements = Vue.computed(function() {
      var dropdownMatchSelectWidth = props2.dropdownMatchSelectWidth;
      return getBuiltInPlacements(dropdownMatchSelectWidth);
    });
    var popupRef = Vue.ref();
    expose({
      getPopupElement: function getPopupElement() {
        return popupRef.value;
      }
    });
    return function() {
      var _a = _extends(_extends({}, props2), attrs), _a$empty = _a.empty, empty2 = _a$empty === void 0 ? false : _a$empty, restProps = __rest$s(_a, ["empty"]);
      var visible = restProps.visible, dropdownAlign = restProps.dropdownAlign, prefixCls = restProps.prefixCls, popupElement = restProps.popupElement, dropdownClassName = restProps.dropdownClassName, dropdownStyle = restProps.dropdownStyle, _restProps$direction = restProps.direction, direction = _restProps$direction === void 0 ? "ltr" : _restProps$direction, placement = restProps.placement, dropdownMatchSelectWidth = restProps.dropdownMatchSelectWidth, containerWidth = restProps.containerWidth, dropdownRender = restProps.dropdownRender, animation = restProps.animation, transitionName2 = restProps.transitionName, getPopupContainer = restProps.getPopupContainer, getTriggerDOMNode = restProps.getTriggerDOMNode, onPopupVisibleChange = restProps.onPopupVisibleChange, onPopupMouseEnter = restProps.onPopupMouseEnter;
      var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
      var popupNode = popupElement;
      if (dropdownRender) {
        popupNode = dropdownRender({
          menuNode: popupElement,
          props: props2
        });
      }
      var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName2;
      var popupStyle = _extends({
        minWidth: "".concat(containerWidth, "px")
      }, dropdownStyle);
      if (typeof dropdownMatchSelectWidth === "number") {
        popupStyle.width = "".concat(dropdownMatchSelectWidth, "px");
      } else if (dropdownMatchSelectWidth) {
        popupStyle.width = "".concat(containerWidth, "px");
      }
      return Vue.createVNode(Trigger, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
        "showAction": onPopupVisibleChange ? ["click"] : [],
        "hideAction": onPopupVisibleChange ? ["click"] : [],
        "popupPlacement": placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
        "builtinPlacements": builtInPlacements.value,
        "prefixCls": dropdownPrefixCls,
        "popupTransitionName": mergedTransitionName,
        "popupAlign": dropdownAlign,
        "popupVisible": visible,
        "getPopupContainer": getPopupContainer,
        "popupClassName": classNames(dropdownClassName, _defineProperty$T({}, "".concat(dropdownPrefixCls, "-empty"), empty2)),
        "popupStyle": popupStyle,
        "getTriggerDOMNode": getTriggerDOMNode,
        "onPopupVisibleChange": onPopupVisibleChange
      }), {
        default: slots.default,
        popup: function popup() {
          return Vue.createVNode("div", {
            "ref": popupRef,
            "onMouseenter": onPopupMouseEnter
          }, [popupNode]);
        }
      });
    };
  }
});
var SelectTrigger$1 = SelectTrigger;
var TransBtn = function TransBtn2(props2, _ref) {
  var slots = _ref.slots;
  var _a;
  var className = props2.class, customizeIcon = props2.customizeIcon, customizeIconProps = props2.customizeIconProps, _onMousedown = props2.onMousedown, onClick2 = props2.onClick;
  var icon;
  if (typeof customizeIcon === "function") {
    icon = customizeIcon(customizeIconProps);
  } else {
    icon = customizeIcon;
  }
  return Vue.createVNode("span", {
    "class": className,
    "onMousedown": function onMousedown2(event) {
      event.preventDefault();
      if (_onMousedown) {
        _onMousedown(event);
      }
    },
    "style": {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    "unselectable": "on",
    "onClick": onClick2,
    "aria-hidden": true
  }, [icon !== void 0 ? icon : Vue.createVNode("span", {
    "class": className.split(/\s+/).map(function(cls) {
      return "".concat(cls, "-icon");
    })
  }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])]);
};
TransBtn.inheritAttrs = false;
TransBtn.displayName = "TransBtn";
TransBtn.props = {
  class: String,
  customizeIcon: PropTypes$1.any,
  customizeIconProps: PropTypes$1.any,
  onMousedown: Function,
  onClick: Function
};
var TransBtn$1 = TransBtn;
function onCompositionStart(e2) {
  e2.target.composing = true;
}
function onCompositionEnd(e2) {
  if (!e2.target.composing)
    return;
  e2.target.composing = false;
  trigger(e2.target, "input");
}
function trigger(el, type2) {
  var e2 = document.createEvent("HTMLEvents");
  e2.initEvent(type2, true, true);
  el.dispatchEvent(e2);
}
function addEventListener(el, event, handler2, options) {
  el.addEventListener(event, handler2, options);
}
var antInput = {
  created: function created3(el, binding) {
    if (!binding.modifiers || !binding.modifiers.lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  }
};
var antInput$1 = antInput;
var inputProps$2 = {
  inputRef: PropTypes$1.any,
  prefixCls: String,
  id: String,
  inputElement: PropTypes$1.VueNode,
  disabled: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  editable: {
    type: Boolean,
    default: void 0
  },
  activeDescendantId: String,
  value: String,
  open: {
    type: Boolean,
    default: void 0
  },
  tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  attrs: PropTypes$1.object,
  onKeydown: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPaste: {
    type: Function
  },
  onCompositionstart: {
    type: Function
  },
  onCompositionend: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  }
};
var Input$2 = Vue.defineComponent({
  name: "Input",
  inheritAttrs: false,
  props: inputProps$2,
  setup: function setup78(props2) {
    var blurTimeout = null;
    var VCSelectContainerEvent = Vue.inject("VCSelectContainerEvent");
    return function() {
      var _a;
      var prefixCls = props2.prefixCls, id = props2.id, inputElement = props2.inputElement, disabled = props2.disabled, tabindex = props2.tabindex, autofocus = props2.autofocus, autocomplete = props2.autocomplete, editable = props2.editable, activeDescendantId = props2.activeDescendantId, value = props2.value, _onKeydown = props2.onKeydown, _onMousedown = props2.onMousedown, onChange = props2.onChange, onPaste = props2.onPaste, _onCompositionstart = props2.onCompositionstart, _onCompositionend = props2.onCompositionend, _onFocus = props2.onFocus, _onBlur = props2.onBlur, open2 = props2.open, inputRef = props2.inputRef, attrs = props2.attrs;
      var inputNode = inputElement || Vue.withDirectives(Vue.createVNode("input", null, null), [[antInput$1]]);
      var inputProps3 = inputNode.props || {};
      var onOriginKeyDown = inputProps3.onKeydown, onOriginInput = inputProps3.onInput, onOriginFocus = inputProps3.onFocus, onOriginBlur = inputProps3.onBlur, onOriginMouseDown = inputProps3.onMousedown, onOriginCompositionStart = inputProps3.onCompositionstart, onOriginCompositionEnd = inputProps3.onCompositionend, style = inputProps3.style;
      inputNode = cloneElement(inputNode, _extends(_extends(_extends(_extends(_extends({
        type: "search"
      }, inputProps3), {
        id,
        ref: inputRef,
        disabled,
        tabindex,
        autocomplete: autocomplete || "off",
        autofocus,
        class: classNames("".concat(prefixCls, "-selection-search-input"), (_a = inputNode === null || inputNode === void 0 ? void 0 : inputNode.props) === null || _a === void 0 ? void 0 : _a.class),
        role: "combobox",
        "aria-expanded": open2,
        "aria-haspopup": "listbox",
        "aria-owns": "".concat(id, "_list"),
        "aria-autocomplete": "list",
        "aria-controls": "".concat(id, "_list"),
        "aria-activedescendant": activeDescendantId
      }), attrs), {
        value: editable ? value : "",
        readonly: !editable,
        unselectable: !editable ? "on" : null,
        style: _extends(_extends({}, style), {
          opacity: editable ? null : 0
        }),
        onKeydown: function onKeydown(event) {
          _onKeydown(event);
          if (onOriginKeyDown) {
            onOriginKeyDown(event);
          }
        },
        onMousedown: function onMousedown2(event) {
          _onMousedown(event);
          if (onOriginMouseDown) {
            onOriginMouseDown(event);
          }
        },
        onInput: function onInput(event) {
          onChange(event);
          if (onOriginInput) {
            onOriginInput(event);
          }
        },
        onCompositionstart: function onCompositionstart(event) {
          _onCompositionstart(event);
          if (onOriginCompositionStart) {
            onOriginCompositionStart(event);
          }
        },
        onCompositionend: function onCompositionend(event) {
          _onCompositionend(event);
          if (onOriginCompositionEnd) {
            onOriginCompositionEnd(event);
          }
        },
        onPaste,
        onFocus: function onFocus2() {
          clearTimeout(blurTimeout);
          onOriginFocus && onOriginFocus(arguments.length <= 0 ? void 0 : arguments[0]);
          _onFocus && _onFocus(arguments.length <= 0 ? void 0 : arguments[0]);
          VCSelectContainerEvent === null || VCSelectContainerEvent === void 0 ? void 0 : VCSelectContainerEvent.focus(arguments.length <= 0 ? void 0 : arguments[0]);
        },
        onBlur: function onBlur2() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          blurTimeout = setTimeout(function() {
            onOriginBlur && onOriginBlur(args[0]);
            _onBlur && _onBlur(args[0]);
            VCSelectContainerEvent === null || VCSelectContainerEvent === void 0 ? void 0 : VCSelectContainerEvent.blur(args[0]);
          }, 100);
        }
      }), inputNode.type === "textarea" ? {} : {
        type: "search"
      }), true, true);
      return inputNode;
    };
  }
});
var Input$3 = Input$2;
var TreeSelectLegacyContextPropsKey = Symbol("TreeSelectLegacyContextPropsKey");
function useInjectLegacySelectContext() {
  return Vue.inject(TreeSelectLegacyContextPropsKey, {});
}
var props$1 = {
  id: String,
  prefixCls: String,
  values: PropTypes$1.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: PropTypes$1.any,
  placeholder: PropTypes$1.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  removeIcon: PropTypes$1.any,
  choiceTransitionName: String,
  maxTagCount: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  maxTagTextLength: Number,
  maxTagPlaceholder: PropTypes$1.any.def(function() {
    return function(omittedValues) {
      return "+ ".concat(omittedValues.length, " ...");
    };
  }),
  tagRender: Function,
  onToggleOpen: {
    type: Function
  },
  onRemove: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
};
var onPreventMouseDown = function onPreventMouseDown2(event) {
  event.preventDefault();
  event.stopPropagation();
};
var SelectSelector = Vue.defineComponent({
  name: "MultipleSelectSelector",
  inheritAttrs: false,
  props: props$1,
  setup: function setup79(props2) {
    var measureRef = Vue.ref();
    var inputWidth = Vue.ref(0);
    var focused = Vue.ref(false);
    var legacyTreeSelectContext = useInjectLegacySelectContext();
    var selectionPrefixCls = Vue.computed(function() {
      return "".concat(props2.prefixCls, "-selection");
    });
    var inputValue = Vue.computed(function() {
      return props2.open || props2.mode === "tags" ? props2.searchValue : "";
    });
    var inputEditable = Vue.computed(function() {
      return props2.mode === "tags" || props2.showSearch && (props2.open || focused.value);
    });
    Vue.onMounted(function() {
      Vue.watch(inputValue, function() {
        inputWidth.value = measureRef.value.scrollWidth;
      }, {
        flush: "post",
        immediate: true
      });
    });
    function defaultRenderSelector(title, content, itemDisabled, closable, onClose) {
      return Vue.createVNode("span", {
        "class": classNames("".concat(selectionPrefixCls.value, "-item"), _defineProperty$T({}, "".concat(selectionPrefixCls.value, "-item-disabled"), itemDisabled)),
        "title": typeof title === "string" || typeof title === "number" ? title.toString() : void 0
      }, [Vue.createVNode("span", {
        "class": "".concat(selectionPrefixCls.value, "-item-content")
      }, [content]), closable && Vue.createVNode(TransBtn$1, {
        "class": "".concat(selectionPrefixCls.value, "-item-remove"),
        "onMousedown": onPreventMouseDown,
        "onClick": onClose,
        "customizeIcon": props2.removeIcon
      }, {
        default: function _default5() {
          return [Vue.createTextVNode("\xD7")];
        }
      })]);
    }
    function customizeRenderSelector(value, content, itemDisabled, closable, onClose, option) {
      var _a;
      var onMouseDown2 = function onMouseDown3(e2) {
        onPreventMouseDown(e2);
        props2.onToggleOpen(!open);
      };
      var originData = option;
      if (legacyTreeSelectContext.keyEntities) {
        originData = ((_a = legacyTreeSelectContext.keyEntities[value]) === null || _a === void 0 ? void 0 : _a.node) || {};
      }
      return Vue.createVNode("span", {
        "key": value,
        "onMousedown": onMouseDown2
      }, [props2.tagRender({
        label: content,
        value,
        disabled: itemDisabled,
        closable,
        onClose,
        option: originData
      })]);
    }
    function renderItem(valueItem) {
      var itemDisabled = valueItem.disabled, label = valueItem.label, value = valueItem.value, option = valueItem.option;
      var closable = !props2.disabled && !itemDisabled;
      var displayLabel = label;
      if (typeof props2.maxTagTextLength === "number") {
        if (typeof label === "string" || typeof label === "number") {
          var strLabel = String(displayLabel);
          if (strLabel.length > props2.maxTagTextLength) {
            displayLabel = "".concat(strLabel.slice(0, props2.maxTagTextLength), "...");
          }
        }
      }
      var onClose = function onClose2(event) {
        var _a;
        if (event)
          event.stopPropagation();
        (_a = props2.onRemove) === null || _a === void 0 ? void 0 : _a.call(props2, valueItem);
      };
      return typeof props2.tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose, option) : defaultRenderSelector(label, displayLabel, itemDisabled, closable, onClose);
    }
    function renderRest(omittedValues) {
      var _props$maxTagPlacehol = props2.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues2) {
        return "+ ".concat(omittedValues2.length, " ...");
      } : _props$maxTagPlacehol;
      var content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
      return defaultRenderSelector(content, content, false);
    }
    return function() {
      var id = props2.id, prefixCls = props2.prefixCls, values = props2.values, open2 = props2.open, inputRef = props2.inputRef, placeholder = props2.placeholder, disabled = props2.disabled, autofocus = props2.autofocus, autocomplete = props2.autocomplete, activeDescendantId = props2.activeDescendantId, tabindex = props2.tabindex, onInputChange = props2.onInputChange, onInputPaste = props2.onInputPaste, onInputKeyDown = props2.onInputKeyDown, onInputMouseDown = props2.onInputMouseDown, onInputCompositionStart = props2.onInputCompositionStart, onInputCompositionEnd = props2.onInputCompositionEnd;
      var inputNode = Vue.createVNode("div", {
        "class": "".concat(selectionPrefixCls.value, "-search"),
        "style": {
          width: inputWidth.value + "px"
        },
        "key": "input"
      }, [Vue.createVNode(Input$3, {
        "inputRef": inputRef,
        "open": open2,
        "prefixCls": prefixCls,
        "id": id,
        "inputElement": null,
        "disabled": disabled,
        "autofocus": autofocus,
        "autocomplete": autocomplete,
        "editable": inputEditable.value,
        "activeDescendantId": activeDescendantId,
        "value": inputValue.value,
        "onKeydown": onInputKeyDown,
        "onMousedown": onInputMouseDown,
        "onChange": onInputChange,
        "onPaste": onInputPaste,
        "onCompositionstart": onInputCompositionStart,
        "onCompositionend": onInputCompositionEnd,
        "tabindex": tabindex,
        "attrs": pickAttrs(props2, true),
        "onFocus": function onFocus2() {
          return focused.value = true;
        },
        "onBlur": function onBlur2() {
          return focused.value = false;
        }
      }, null), Vue.createVNode("span", {
        "ref": measureRef,
        "class": "".concat(selectionPrefixCls.value, "-search-mirror"),
        "aria-hidden": true
      }, [inputValue.value, Vue.createTextVNode("\xA0")])]);
      var selectionNode = Vue.createVNode(Overflow$1, {
        "prefixCls": "".concat(selectionPrefixCls.value, "-overflow"),
        "data": values,
        "renderItem": renderItem,
        "renderRest": renderRest,
        "suffix": inputNode,
        "itemKey": "key",
        "maxCount": props2.maxTagCount,
        "key": "overflow"
      }, null);
      return Vue.createVNode(Vue.Fragment, null, [selectionNode, !values.length && !inputValue.value && Vue.createVNode("span", {
        "class": "".concat(selectionPrefixCls.value, "-placeholder")
      }, [placeholder])]);
    };
  }
});
var MultipleSelector = SelectSelector;
var props = {
  inputElement: PropTypes$1.any,
  id: String,
  prefixCls: String,
  values: PropTypes$1.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: PropTypes$1.any,
  placeholder: PropTypes$1.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  activeValue: String,
  backfill: {
    type: Boolean,
    default: void 0
  },
  optionLabelRender: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
};
var SingleSelector = Vue.defineComponent({
  name: "SingleSelector",
  setup: function setup80(props2) {
    var inputChanged = Vue.ref(false);
    var combobox = Vue.computed(function() {
      return props2.mode === "combobox";
    });
    var inputEditable = Vue.computed(function() {
      return combobox.value || props2.showSearch;
    });
    var inputValue = Vue.computed(function() {
      var inputValue2 = props2.searchValue || "";
      if (combobox.value && props2.activeValue && !inputChanged.value) {
        inputValue2 = props2.activeValue;
      }
      return inputValue2;
    });
    var legacyTreeSelectContext = useInjectLegacySelectContext();
    Vue.watch([combobox, function() {
      return props2.activeValue;
    }], function() {
      if (combobox.value) {
        inputChanged.value = false;
      }
    }, {
      immediate: true
    });
    var hasTextInput = Vue.computed(function() {
      return props2.mode !== "combobox" && !props2.open && !props2.showSearch ? false : !!inputValue.value;
    });
    var title = Vue.computed(function() {
      var item = props2.values[0];
      return item && (typeof item.label === "string" || typeof item.label === "number") ? item.label.toString() : void 0;
    });
    var renderPlaceholder = function renderPlaceholder2() {
      if (props2.values[0]) {
        return null;
      }
      var hiddenStyle = hasTextInput.value ? {
        visibility: "hidden"
      } : void 0;
      return Vue.createVNode("span", {
        "class": "".concat(props2.prefixCls, "-selection-placeholder"),
        "style": hiddenStyle
      }, [props2.placeholder]);
    };
    return function() {
      var _a, _b, _c, _d;
      var inputElement = props2.inputElement, prefixCls = props2.prefixCls, id = props2.id, values = props2.values, inputRef = props2.inputRef, disabled = props2.disabled, autofocus = props2.autofocus, autocomplete = props2.autocomplete, activeDescendantId = props2.activeDescendantId, open2 = props2.open, tabindex = props2.tabindex, optionLabelRender = props2.optionLabelRender, onInputKeyDown = props2.onInputKeyDown, onInputMouseDown = props2.onInputMouseDown, onInputChange = props2.onInputChange, onInputPaste = props2.onInputPaste, onInputCompositionStart = props2.onInputCompositionStart, onInputCompositionEnd = props2.onInputCompositionEnd;
      var item = values[0];
      var titleNode = null;
      if (item && legacyTreeSelectContext.customSlots) {
        var key2 = (_a = item.key) !== null && _a !== void 0 ? _a : item.value;
        var originData = ((_b = legacyTreeSelectContext.keyEntities[key2]) === null || _b === void 0 ? void 0 : _b.node) || {};
        titleNode = legacyTreeSelectContext.customSlots[(_c = originData.slots) === null || _c === void 0 ? void 0 : _c.title] || legacyTreeSelectContext.customSlots.title || item.label;
        if (typeof titleNode === "function") {
          titleNode = titleNode(originData);
        }
      } else {
        titleNode = optionLabelRender && item ? optionLabelRender(item.option) : item === null || item === void 0 ? void 0 : item.label;
      }
      return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode("span", {
        "class": "".concat(prefixCls, "-selection-search")
      }, [Vue.createVNode(Input$3, {
        "inputRef": inputRef,
        "prefixCls": prefixCls,
        "id": id,
        "open": open2,
        "inputElement": inputElement,
        "disabled": disabled,
        "autofocus": autofocus,
        "autocomplete": autocomplete,
        "editable": inputEditable.value,
        "activeDescendantId": activeDescendantId,
        "value": inputValue.value,
        "onKeydown": onInputKeyDown,
        "onMousedown": onInputMouseDown,
        "onChange": function onChange(e2) {
          inputChanged.value = true;
          onInputChange(e2);
        },
        "onPaste": onInputPaste,
        "onCompositionstart": onInputCompositionStart,
        "onCompositionend": onInputCompositionEnd,
        "tabindex": tabindex,
        "attrs": pickAttrs(props2, true)
      }, null)]), !combobox.value && item && !hasTextInput.value && Vue.createVNode("span", {
        "class": "".concat(prefixCls, "-selection-item"),
        "title": title.value
      }, [Vue.createVNode(Vue.Fragment, {
        "key": (_d = item.key) !== null && _d !== void 0 ? _d : item.value
      }, [titleNode])]), renderPlaceholder()]);
    };
  }
});
SingleSelector.props = props;
SingleSelector.inheritAttrs = false;
var SingleSelector$1 = SingleSelector;
function isValidateOpenKey(currentKeyCode) {
  return ![
    KeyCode$1.ESC,
    KeyCode$1.SHIFT,
    KeyCode$1.BACKSPACE,
    KeyCode$1.TAB,
    KeyCode$1.WIN_KEY,
    KeyCode$1.ALT,
    KeyCode$1.META,
    KeyCode$1.WIN_KEY_RIGHT,
    KeyCode$1.CTRL,
    KeyCode$1.SEMICOLON,
    KeyCode$1.EQUALS,
    KeyCode$1.CAPS_LOCK,
    KeyCode$1.CONTEXT_MENU,
    KeyCode$1.F1,
    KeyCode$1.F2,
    KeyCode$1.F3,
    KeyCode$1.F4,
    KeyCode$1.F5,
    KeyCode$1.F6,
    KeyCode$1.F7,
    KeyCode$1.F8,
    KeyCode$1.F9,
    KeyCode$1.F10,
    KeyCode$1.F11,
    KeyCode$1.F12
  ].includes(currentKeyCode);
}
function useLock() {
  var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
  var lock = null;
  var timeout;
  Vue.onBeforeUnmount(function() {
    clearTimeout(timeout);
  });
  function doLock(locked) {
    if (locked || lock === null) {
      lock = locked;
    }
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      lock = null;
    }, duration);
  }
  return [function() {
    return lock;
  }, doLock];
}
function createRef() {
  var func = function func2(node) {
    func2.current = node;
  };
  return func;
}
var Selector = Vue.defineComponent({
  name: "Selector",
  inheritAttrs: false,
  props: {
    id: String,
    prefixCls: String,
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    values: PropTypes$1.array,
    multiple: {
      type: Boolean,
      default: void 0
    },
    mode: String,
    searchValue: String,
    activeValue: String,
    inputElement: PropTypes$1.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    activeDescendantId: String,
    tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: PropTypes$1.any,
    removeIcon: PropTypes$1.any,
    maxTagCount: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    maxTagTextLength: Number,
    maxTagPlaceholder: PropTypes$1.any,
    tagRender: Function,
    optionLabelRender: Function,
    tokenWithEnter: {
      type: Boolean,
      default: void 0
    },
    choiceTransitionName: String,
    onToggleOpen: {
      type: Function
    },
    onSearch: Function,
    onSearchSubmit: Function,
    onRemove: Function,
    onInputKeyDown: {
      type: Function
    },
    domRef: Function
  },
  setup: function setup81(props2, _ref) {
    var expose = _ref.expose;
    var inputRef = createRef();
    var compositionStatus = false;
    var _useLock = useLock(0), _useLock2 = _slicedToArray(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1];
    var onInternalInputKeyDown = function onInternalInputKeyDown2(event) {
      var which = event.which;
      if (which === KeyCode$1.UP || which === KeyCode$1.DOWN) {
        event.preventDefault();
      }
      if (props2.onInputKeyDown) {
        props2.onInputKeyDown(event);
      }
      if (which === KeyCode$1.ENTER && props2.mode === "tags" && !compositionStatus && !props2.open) {
        props2.onSearchSubmit(event.target.value);
      }
      if (isValidateOpenKey(which)) {
        props2.onToggleOpen(true);
      }
    };
    var onInternalInputMouseDown = function onInternalInputMouseDown2() {
      setInputMouseDown(true);
    };
    var pastedText = null;
    var triggerOnSearch = function triggerOnSearch2(value) {
      if (props2.onSearch(value, true, compositionStatus) !== false) {
        props2.onToggleOpen(true);
      }
    };
    var onInputCompositionStart = function onInputCompositionStart2() {
      compositionStatus = true;
    };
    var onInputCompositionEnd = function onInputCompositionEnd2(e2) {
      compositionStatus = false;
      if (props2.mode !== "combobox") {
        triggerOnSearch(e2.target.value);
      }
    };
    var onInputChange = function onInputChange2(event) {
      var value = event.target.value;
      if (props2.tokenWithEnter && pastedText && /[\r\n]/.test(pastedText)) {
        var replacedText = pastedText.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
        value = value.replace(replacedText, pastedText);
      }
      pastedText = null;
      triggerOnSearch(value);
    };
    var onInputPaste = function onInputPaste2(e2) {
      var clipboardData = e2.clipboardData;
      var value = clipboardData.getData("text");
      pastedText = value;
    };
    var onClick2 = function onClick3(_ref2) {
      var target = _ref2.target;
      if (target !== inputRef.current) {
        var isIE = document.body.style.msTouchAction !== void 0;
        if (isIE) {
          setTimeout(function() {
            inputRef.current.focus();
          });
        } else {
          inputRef.current.focus();
        }
      }
    };
    var onMousedown2 = function onMousedown3(event) {
      var inputMouseDown = getInputMouseDown();
      if (event.target !== inputRef.current && !inputMouseDown) {
        event.preventDefault();
      }
      if (props2.mode !== "combobox" && (!props2.showSearch || !inputMouseDown) || !props2.open) {
        if (props2.open) {
          props2.onSearch("", true, false);
        }
        props2.onToggleOpen();
      }
    };
    expose({
      focus: function focus() {
        inputRef.current.focus();
      },
      blur: function blur() {
        inputRef.current.blur();
      }
    });
    return function() {
      var prefixCls = props2.prefixCls, domRef = props2.domRef, mode = props2.mode;
      var sharedProps = {
        inputRef,
        onInputKeyDown: onInternalInputKeyDown,
        onInputMouseDown: onInternalInputMouseDown,
        onInputChange,
        onInputPaste,
        onInputCompositionStart,
        onInputCompositionEnd
      };
      var selectNode = mode === "multiple" || mode === "tags" ? Vue.createVNode(MultipleSelector, _objectSpread2$1(_objectSpread2$1({}, props2), sharedProps), null) : Vue.createVNode(SingleSelector$1, _objectSpread2$1(_objectSpread2$1({}, props2), sharedProps), null);
      return Vue.createVNode("div", {
        "ref": domRef,
        "class": "".concat(prefixCls, "-selector"),
        "onClick": onClick2,
        "onMousedown": onMousedown2
      }, [selectNode]);
    };
  }
});
var Selector$1 = Selector;
function useSelectTriggerControl(refs, open2, triggerOpen) {
  function onGlobalMouseDown(event) {
    var _a, _b, _c;
    var target = event.target;
    if (target.shadowRoot && event.composed) {
      target = event.composedPath()[0] || target;
    }
    var elements = [(_a = refs[0]) === null || _a === void 0 ? void 0 : _a.value, (_c = (_b = refs[1]) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.getPopupElement()];
    if (open2.value && elements.every(function(element) {
      return element && !element.contains(target) && element !== target;
    })) {
      triggerOpen(false);
    }
  }
  Vue.onMounted(function() {
    window.addEventListener("mousedown", onGlobalMouseDown);
  });
  Vue.onBeforeUnmount(function() {
    window.removeEventListener("mousedown", onGlobalMouseDown);
  });
}
function useDelayReset() {
  var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
  var bool = Vue.ref(false);
  var delay;
  var cancelLatest = function cancelLatest2() {
    clearTimeout(delay);
  };
  Vue.onMounted(function() {
    cancelLatest();
  });
  var delaySetBool = function delaySetBool2(value, callback) {
    cancelLatest();
    delay = setTimeout(function() {
      bool.value = value;
      if (callback) {
        callback();
      }
    }, timeout);
  };
  return [bool, delaySetBool, cancelLatest];
}
var BaseSelectContextKey = Symbol("BaseSelectContextKey");
function useProvideBaseSelectProps(props2) {
  return Vue.provide(BaseSelectContextKey, props2);
}
function useBaseProps() {
  return Vue.inject(BaseSelectContextKey, {});
}
function toReactive(objectRef) {
  if (!Vue.isRef(objectRef))
    return Vue.reactive(objectRef);
  var proxy = new Proxy({}, {
    get: function get2(_2, p2, receiver) {
      return Reflect.get(objectRef.value, p2, receiver);
    },
    set: function set(_2, p2, value) {
      objectRef.value[p2] = value;
      return true;
    },
    deleteProperty: function deleteProperty(_2, p2) {
      return Reflect.deleteProperty(objectRef.value, p2);
    },
    has: function has(_2, p2) {
      return Reflect.has(objectRef.value, p2);
    },
    ownKeys: function ownKeys2() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return Vue.reactive(proxy);
}
var __rest$r = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autofocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabindex", "OptionList", "notFoundContent"];
var baseSelectPrivateProps = function baseSelectPrivateProps2() {
  return {
    prefixCls: String,
    id: String,
    omitDomProps: Array,
    displayValues: Array,
    onDisplayValuesChange: Function,
    activeValue: String,
    activeDescendantId: String,
    onActiveValueChange: Function,
    searchValue: String,
    onSearch: Function,
    onSearchSplit: Function,
    maxLength: Number,
    OptionList: PropTypes$1.any,
    emptyOptions: Boolean
  };
};
var baseSelectPropsWithoutPrivate = function baseSelectPropsWithoutPrivate2() {
  return {
    showSearch: {
      type: Boolean,
      default: void 0
    },
    tagRender: {
      type: Function
    },
    optionLabelRender: {
      type: Function
    },
    direction: {
      type: String
    },
    tabindex: Number,
    autofocus: Boolean,
    notFoundContent: PropTypes$1.any,
    placeholder: PropTypes$1.any,
    onClear: Function,
    choiceTransitionName: String,
    mode: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    loading: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      default: void 0
    },
    onDropdownVisibleChange: {
      type: Function
    },
    getInputElement: {
      type: Function
    },
    getRawInputElement: {
      type: Function
    },
    maxTagTextLength: Number,
    maxTagCount: {
      type: [String, Number]
    },
    maxTagPlaceholder: PropTypes$1.any,
    tokenSeparators: {
      type: Array
    },
    allowClear: {
      type: Boolean,
      default: void 0
    },
    showArrow: {
      type: Boolean,
      default: void 0
    },
    inputIcon: PropTypes$1.any,
    clearIcon: PropTypes$1.any,
    removeIcon: PropTypes$1.any,
    animation: String,
    transitionName: String,
    dropdownStyle: {
      type: Object
    },
    dropdownClassName: String,
    dropdownMatchSelectWidth: {
      type: [Boolean, Number],
      default: void 0
    },
    dropdownRender: {
      type: Function
    },
    dropdownAlign: Object,
    placement: {
      type: String
    },
    getPopupContainer: {
      type: Function
    },
    showAction: {
      type: Array
    },
    onBlur: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onKeyup: Function,
    onKeydown: Function,
    onMousedown: Function,
    onPopupScroll: Function,
    onInputKeyDown: Function,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function
  };
};
var baseSelectProps = function baseSelectProps2() {
  return _extends(_extends({}, baseSelectPrivateProps()), baseSelectPropsWithoutPrivate());
};
function isMultiple(mode) {
  return mode === "tags" || mode === "multiple";
}
var BaseSelect = Vue.defineComponent({
  name: "BaseSelect",
  inheritAttrs: false,
  props: initDefaultProps$1(baseSelectProps(), {
    showAction: [],
    notFoundContent: "Not Found"
  }),
  setup: function setup82(props2, _ref) {
    var attrs = _ref.attrs, expose = _ref.expose, slots = _ref.slots;
    var multiple = Vue.computed(function() {
      return isMultiple(props2.mode);
    });
    var mergedShowSearch = Vue.computed(function() {
      return props2.showSearch !== void 0 ? props2.showSearch : multiple.value || props2.mode === "combobox";
    });
    var mobile = Vue.ref(false);
    Vue.onMounted(function() {
      mobile.value = isMobile$2();
    });
    var legacyTreeSelectContext = useInjectLegacySelectContext();
    var containerRef = Vue.ref(null);
    var selectorDomRef = createRef();
    var triggerRef = Vue.ref(null);
    var selectorRef = Vue.ref(null);
    var listRef = Vue.ref(null);
    var _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
    var focus = function focus2() {
      var _a;
      (_a = selectorRef.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    var blur = function blur2() {
      var _a;
      (_a = selectorRef.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    expose({
      focus,
      blur,
      scrollTo: function scrollTo2(arg) {
        var _a;
        return (_a = listRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg);
      }
    });
    var mergedSearchValue = Vue.computed(function() {
      var _a;
      if (props2.mode !== "combobox") {
        return props2.searchValue;
      }
      var val = (_a = props2.displayValues[0]) === null || _a === void 0 ? void 0 : _a.value;
      return typeof val === "string" || typeof val === "number" ? String(val) : "";
    });
    var initOpen = props2.open !== void 0 ? props2.open : props2.defaultOpen;
    var innerOpen = Vue.ref(initOpen);
    var mergedOpen = Vue.ref(initOpen);
    var setInnerOpen = function setInnerOpen2(val) {
      innerOpen.value = props2.open !== void 0 ? props2.open : val;
      mergedOpen.value = innerOpen.value;
    };
    Vue.watch(function() {
      return props2.open;
    }, function() {
      setInnerOpen(props2.open);
    });
    var emptyListContent = Vue.computed(function() {
      return !props2.notFoundContent && props2.emptyOptions;
    });
    Vue.watchEffect(function() {
      mergedOpen.value = innerOpen.value;
      if (props2.disabled || emptyListContent.value && mergedOpen.value && props2.mode === "combobox") {
        mergedOpen.value = false;
      }
    });
    var triggerOpen = Vue.computed(function() {
      return emptyListContent.value ? false : mergedOpen.value;
    });
    var onToggleOpen = function onToggleOpen2(newOpen) {
      var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen.value;
      if (innerOpen.value !== nextOpen && !props2.disabled) {
        setInnerOpen(nextOpen);
        if (props2.onDropdownVisibleChange) {
          props2.onDropdownVisibleChange(nextOpen);
        }
      }
    };
    var tokenWithEnter = Vue.computed(function() {
      return (props2.tokenSeparators || []).some(function(tokenSeparator) {
        return ["\n", "\r\n"].includes(tokenSeparator);
      });
    });
    var onInternalSearch = function onInternalSearch2(searchText, fromTyping, isCompositing) {
      var _a, _b;
      var ret = true;
      var newSearchText = searchText;
      (_a = props2.onActiveValueChange) === null || _a === void 0 ? void 0 : _a.call(props2, null);
      var patchLabels = isCompositing ? null : getSeparatedContent(searchText, props2.tokenSeparators);
      if (props2.mode !== "combobox" && patchLabels) {
        newSearchText = "";
        (_b = props2.onSearchSplit) === null || _b === void 0 ? void 0 : _b.call(props2, patchLabels);
        onToggleOpen(false);
        ret = false;
      }
      if (props2.onSearch && mergedSearchValue.value !== newSearchText) {
        props2.onSearch(newSearchText, {
          source: fromTyping ? "typing" : "effect"
        });
      }
      return ret;
    };
    var onInternalSearchSubmit = function onInternalSearchSubmit2(searchText) {
      var _a;
      if (!searchText || !searchText.trim()) {
        return;
      }
      (_a = props2.onSearch) === null || _a === void 0 ? void 0 : _a.call(props2, searchText, {
        source: "submit"
      });
    };
    Vue.watch(mergedOpen, function() {
      if (!mergedOpen.value && !multiple.value && props2.mode !== "combobox") {
        onInternalSearch("", false, false);
      }
    }, {
      immediate: true,
      flush: "post"
    });
    Vue.watch(function() {
      return props2.disabled;
    }, function() {
      if (innerOpen.value && !!props2.disabled) {
        setInnerOpen(false);
      }
    }, {
      immediate: true
    });
    var _useLock = useLock(), _useLock2 = _slicedToArray(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1];
    var onInternalKeyDown = function onInternalKeyDown2(event) {
      var _a2;
      var _a;
      var clearLock = getClearLock();
      var which = event.which;
      if (which === KeyCode$1.ENTER) {
        if (props2.mode !== "combobox") {
          event.preventDefault();
        }
        if (!mergedOpen.value) {
          onToggleOpen(true);
        }
      }
      setClearLock(!!mergedSearchValue.value);
      if (which === KeyCode$1.BACKSPACE && !clearLock && multiple.value && !mergedSearchValue.value && props2.displayValues.length) {
        var cloneDisplayValues = _toConsumableArray(props2.displayValues);
        var removedDisplayValue = null;
        for (var i2 = cloneDisplayValues.length - 1; i2 >= 0; i2 -= 1) {
          var current2 = cloneDisplayValues[i2];
          if (!current2.disabled) {
            cloneDisplayValues.splice(i2, 1);
            removedDisplayValue = current2;
            break;
          }
        }
        if (removedDisplayValue) {
          props2.onDisplayValuesChange(cloneDisplayValues, {
            type: "remove",
            values: [removedDisplayValue]
          });
        }
      }
      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }
      if (mergedOpen.value && listRef.value) {
        var _listRef$value;
        (_listRef$value = listRef.value).onKeydown.apply(_listRef$value, [event].concat(rest));
      }
      (_a = props2.onKeydown) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [props2, event].concat(rest));
    };
    var onInternalKeyUp = function onInternalKeyUp2(event) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        rest[_key2 - 1] = arguments[_key2];
      }
      if (mergedOpen.value && listRef.value) {
        var _listRef$value2;
        (_listRef$value2 = listRef.value).onKeyup.apply(_listRef$value2, [event].concat(rest));
      }
      if (props2.onKeyup) {
        props2.onKeyup.apply(props2, [event].concat(rest));
      }
    };
    var onSelectorRemove = function onSelectorRemove2(val) {
      var newValues = props2.displayValues.filter(function(i2) {
        return i2 !== val;
      });
      props2.onDisplayValuesChange(newValues, {
        type: "remove",
        values: [val]
      });
    };
    var focusRef = Vue.ref(false);
    var onContainerFocus = function onContainerFocus2() {
      setMockFocused(true);
      if (!props2.disabled) {
        if (props2.onFocus && !focusRef.value) {
          props2.onFocus.apply(props2, arguments);
        }
        if (props2.showAction && props2.showAction.includes("focus")) {
          onToggleOpen(true);
        }
      }
      focusRef.value = true;
    };
    var onContainerBlur = function onContainerBlur2() {
      setMockFocused(false, function() {
        focusRef.value = false;
        onToggleOpen(false);
      });
      if (props2.disabled) {
        return;
      }
      var searchVal = mergedSearchValue.value;
      if (searchVal) {
        if (props2.mode === "tags") {
          props2.onSearch(searchVal, {
            source: "submit"
          });
        } else if (props2.mode === "multiple") {
          props2.onSearch("", {
            source: "blur"
          });
        }
      }
      if (props2.onBlur) {
        props2.onBlur.apply(props2, arguments);
      }
    };
    Vue.provide("VCSelectContainerEvent", {
      focus: onContainerFocus,
      blur: onContainerBlur
    });
    var activeTimeoutIds = [];
    Vue.onMounted(function() {
      activeTimeoutIds.forEach(function(timeoutId) {
        return clearTimeout(timeoutId);
      });
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    });
    Vue.onBeforeUnmount(function() {
      activeTimeoutIds.forEach(function(timeoutId) {
        return clearTimeout(timeoutId);
      });
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    });
    var onInternalMouseDown = function onInternalMouseDown2(event) {
      var _b2;
      var _a, _b;
      var target = event.target;
      var popupElement = (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.getPopupElement();
      if (popupElement && popupElement.contains(target)) {
        var timeoutId = setTimeout(function() {
          var _a2;
          var index2 = activeTimeoutIds.indexOf(timeoutId);
          if (index2 !== -1) {
            activeTimeoutIds.splice(index2, 1);
          }
          cancelSetMockFocused();
          if (!mobile.value && !popupElement.contains(document.activeElement)) {
            (_a2 = selectorRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
          }
        });
        activeTimeoutIds.push(timeoutId);
      }
      for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        restArgs[_key3 - 1] = arguments[_key3];
      }
      (_b = props2.onMousedown) === null || _b === void 0 ? void 0 : (_b2 = _b).call.apply(_b2, [props2, event].concat(restArgs));
    };
    var containerWidth = Vue.ref(null);
    var instance = Vue.getCurrentInstance();
    var onPopupMouseEnter = function onPopupMouseEnter2() {
      instance.update();
    };
    Vue.onMounted(function() {
      Vue.watch(triggerOpen, function() {
        var _a;
        if (triggerOpen.value) {
          var newWidth = Math.ceil((_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth);
          if (containerWidth.value !== newWidth && !Number.isNaN(newWidth)) {
            containerWidth.value = newWidth;
          }
        }
      }, {
        immediate: true,
        flush: "post"
      });
    });
    useSelectTriggerControl([containerRef, triggerRef], triggerOpen, onToggleOpen);
    useProvideBaseSelectProps(toReactive(_extends(_extends({}, Vue.toRefs(props2)), {
      open: mergedOpen,
      triggerOpen,
      showSearch: mergedShowSearch,
      multiple,
      toggleOpen: onToggleOpen
    })));
    return function() {
      var _classNames2;
      var _a = _extends(_extends({}, props2), attrs), prefixCls = _a.prefixCls, id = _a.id;
      _a.open;
      _a.defaultOpen;
      var mode = _a.mode;
      _a.showSearch;
      _a.searchValue;
      _a.onSearch;
      var allowClear = _a.allowClear, clearIcon = _a.clearIcon, showArrow = _a.showArrow, inputIcon = _a.inputIcon, disabled = _a.disabled, loading = _a.loading, getInputElement = _a.getInputElement, getPopupContainer = _a.getPopupContainer, placement = _a.placement, animation = _a.animation, transitionName2 = _a.transitionName, dropdownStyle = _a.dropdownStyle, dropdownClassName = _a.dropdownClassName, dropdownMatchSelectWidth = _a.dropdownMatchSelectWidth, dropdownRender = _a.dropdownRender, dropdownAlign = _a.dropdownAlign;
      _a.showAction;
      var direction = _a.direction;
      _a.tokenSeparators;
      var tagRender = _a.tagRender, optionLabelRender = _a.optionLabelRender;
      _a.onPopupScroll;
      _a.onDropdownVisibleChange;
      _a.onFocus;
      _a.onBlur;
      _a.onKeyup;
      _a.onKeydown;
      _a.onMousedown;
      var onClear = _a.onClear, omitDomProps = _a.omitDomProps, getRawInputElement = _a.getRawInputElement, displayValues = _a.displayValues, onDisplayValuesChange = _a.onDisplayValuesChange, emptyOptions = _a.emptyOptions, activeDescendantId = _a.activeDescendantId, activeValue = _a.activeValue, OptionList2 = _a.OptionList, restProps = __rest$r(_a, ["prefixCls", "id", "open", "defaultOpen", "mode", "showSearch", "searchValue", "onSearch", "allowClear", "clearIcon", "showArrow", "inputIcon", "disabled", "loading", "getInputElement", "getPopupContainer", "placement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "direction", "tokenSeparators", "tagRender", "optionLabelRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyup", "onKeydown", "onMousedown", "onClear", "omitDomProps", "getRawInputElement", "displayValues", "onDisplayValuesChange", "emptyOptions", "activeDescendantId", "activeValue", "OptionList"]);
      var customizeInputElement = mode === "combobox" && getInputElement && getInputElement() || null;
      var customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
      var domProps = _extends({}, restProps);
      var onTriggerVisibleChange;
      if (customizeRawInputElement) {
        onTriggerVisibleChange = function onTriggerVisibleChange2(newOpen) {
          onToggleOpen(newOpen);
        };
      }
      DEFAULT_OMIT_PROPS.forEach(function(propName) {
        delete domProps[propName];
      });
      omitDomProps === null || omitDomProps === void 0 ? void 0 : omitDomProps.forEach(function(propName) {
        delete domProps[propName];
      });
      var mergedShowArrow = showArrow !== void 0 ? showArrow : loading || !multiple.value && mode !== "combobox";
      var arrowNode;
      if (mergedShowArrow) {
        arrowNode = Vue.createVNode(TransBtn$1, {
          "class": classNames("".concat(prefixCls, "-arrow"), _defineProperty$T({}, "".concat(prefixCls, "-arrow-loading"), loading)),
          "customizeIcon": inputIcon,
          "customizeIconProps": {
            loading,
            searchValue: mergedSearchValue.value,
            open: mergedOpen.value,
            focused: mockFocused.value,
            showSearch: mergedShowSearch.value
          }
        }, null);
      }
      var clearNode;
      var onClearMouseDown = function onClearMouseDown2() {
        onClear === null || onClear === void 0 ? void 0 : onClear();
        onDisplayValuesChange([], {
          type: "clear",
          values: displayValues
        });
        onInternalSearch("", false, false);
      };
      if (!disabled && allowClear && (displayValues.length || mergedSearchValue.value)) {
        clearNode = Vue.createVNode(TransBtn$1, {
          "class": "".concat(prefixCls, "-clear"),
          "onMousedown": onClearMouseDown,
          "customizeIcon": clearIcon
        }, {
          default: function _default5() {
            return [Vue.createTextVNode("\xD7")];
          }
        });
      }
      var optionList = Vue.createVNode(OptionList2, {
        "ref": listRef
      }, _extends(_extends({}, legacyTreeSelectContext.customSlots), {
        option: slots.option
      }));
      var mergedClassName = classNames(prefixCls, attrs.class, (_classNames2 = {}, _defineProperty$T(_classNames2, "".concat(prefixCls, "-focused"), mockFocused.value), _defineProperty$T(_classNames2, "".concat(prefixCls, "-multiple"), multiple.value), _defineProperty$T(_classNames2, "".concat(prefixCls, "-single"), !multiple.value), _defineProperty$T(_classNames2, "".concat(prefixCls, "-allow-clear"), allowClear), _defineProperty$T(_classNames2, "".concat(prefixCls, "-show-arrow"), mergedShowArrow), _defineProperty$T(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$T(_classNames2, "".concat(prefixCls, "-loading"), loading), _defineProperty$T(_classNames2, "".concat(prefixCls, "-open"), mergedOpen.value), _defineProperty$T(_classNames2, "".concat(prefixCls, "-customize-input"), customizeInputElement), _defineProperty$T(_classNames2, "".concat(prefixCls, "-show-search"), mergedShowSearch.value), _classNames2));
      var selectorNode = Vue.createVNode(SelectTrigger$1, {
        "ref": triggerRef,
        "disabled": disabled,
        "prefixCls": prefixCls,
        "visible": triggerOpen.value,
        "popupElement": optionList,
        "containerWidth": containerWidth.value,
        "animation": animation,
        "transitionName": transitionName2,
        "dropdownStyle": dropdownStyle,
        "dropdownClassName": dropdownClassName,
        "direction": direction,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth,
        "dropdownRender": dropdownRender,
        "dropdownAlign": dropdownAlign,
        "placement": placement,
        "getPopupContainer": getPopupContainer,
        "empty": emptyOptions,
        "getTriggerDOMNode": function getTriggerDOMNode() {
          return selectorDomRef.current;
        },
        "onPopupVisibleChange": onTriggerVisibleChange,
        "onPopupMouseEnter": onPopupMouseEnter
      }, {
        default: function _default5() {
          return customizeRawInputElement ? isValidElement(customizeRawInputElement) && cloneElement(customizeRawInputElement, {
            ref: selectorDomRef
          }, false, true) : Vue.createVNode(Selector$1, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
            "domRef": selectorDomRef,
            "prefixCls": prefixCls,
            "inputElement": customizeInputElement,
            "ref": selectorRef,
            "id": id,
            "showSearch": mergedShowSearch.value,
            "mode": mode,
            "activeDescendantId": activeDescendantId,
            "tagRender": tagRender,
            "optionLabelRender": optionLabelRender,
            "values": displayValues,
            "open": mergedOpen.value,
            "onToggleOpen": onToggleOpen,
            "activeValue": activeValue,
            "searchValue": mergedSearchValue.value,
            "onSearch": onInternalSearch,
            "onSearchSubmit": onInternalSearchSubmit,
            "onRemove": onSelectorRemove,
            "tokenWithEnter": tokenWithEnter.value
          }), null);
        }
      });
      var renderNode;
      if (customizeRawInputElement) {
        renderNode = selectorNode;
      } else {
        renderNode = Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({}, domProps), {}, {
          "class": mergedClassName,
          "ref": containerRef,
          "onMousedown": onInternalMouseDown,
          "onKeydown": onInternalKeyDown,
          "onKeyup": onInternalKeyUp
        }), [mockFocused.value && !mergedOpen.value && Vue.createVNode("span", {
          "style": {
            width: 0,
            height: 0,
            display: "flex",
            overflow: "hidden",
            opacity: 0
          },
          "aria-live": "polite"
        }, ["".concat(displayValues.map(function(_ref2) {
          var label = _ref2.label, value = _ref2.value;
          return ["number", "string"].includes(_typeof$1(label)) ? label : value;
        }).join(", "))]), selectorNode, arrowNode, clearNode]);
      }
      return renderNode;
    };
  }
});
var Filter = function Filter2(_ref, _ref2) {
  var height = _ref.height, offset3 = _ref.offset, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize;
  var slots = _ref2.slots;
  var _a;
  var outerStyle = {};
  var innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offset3 !== void 0) {
    outerStyle = {
      height: "".concat(height, "px"),
      position: "relative",
      overflow: "hidden"
    };
    innerStyle = _extends(_extends({}, innerStyle), {
      transform: "translateY(".concat(offset3, "px)"),
      position: "absolute",
      left: 0,
      right: 0,
      top: 0
    });
  }
  return Vue.createVNode("div", {
    "style": outerStyle
  }, [Vue.createVNode(ResizeObserver$1, {
    "onResize": function onResize(_ref3) {
      var offsetHeight = _ref3.offsetHeight;
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }
  }, {
    default: function _default5() {
      return [Vue.createVNode("div", {
        "style": innerStyle,
        "class": classNames(_defineProperty$T({}, "".concat(prefixCls, "-holder-inner"), prefixCls))
      }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])];
    }
  })]);
};
Filter.displayName = "Filter";
Filter.inheritAttrs = false;
Filter.props = {
  prefixCls: String,
  height: Number,
  offset: Number,
  onInnerResize: Function
};
var Filler = Filter;
var Item$1 = function Item2(_ref, _ref2) {
  var setRef = _ref.setRef;
  var slots = _ref2.slots;
  var _a;
  var children = flattenChildren((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
  return children && children.length ? Vue.cloneVNode(children[0], {
    ref: setRef
  }) : children;
};
Item$1.props = {
  setRef: {
    type: Function,
    default: function _default2() {
    }
  }
};
var Item$2 = Item$1;
var MIN_SIZE = 20;
function getPageY(e2) {
  return "touches" in e2 ? e2.touches[0].pageY : e2.pageY;
}
var ScrollBar = Vue.defineComponent({
  name: "ScrollBar",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    scrollTop: Number,
    scrollHeight: Number,
    height: Number,
    count: Number,
    onScroll: {
      type: Function
    },
    onStartMove: {
      type: Function
    },
    onStopMove: {
      type: Function
    }
  },
  setup: function setup83() {
    return {
      moveRaf: null,
      scrollbarRef: createRef(),
      thumbRef: createRef(),
      visibleTimeout: null,
      state: Vue.reactive({
        dragging: false,
        pageY: null,
        startTop: null,
        visible: false
      })
    };
  },
  watch: {
    scrollTop: {
      handler: function handler() {
        this.delayHidden();
      },
      flush: "post"
    }
  },
  mounted: function mounted3() {
    var _a, _b;
    (_a = this.scrollbarRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener("touchstart", this.onScrollbarTouchStart, supportsPassive$1 ? {
      passive: false
    } : false);
    (_b = this.thumbRef.current) === null || _b === void 0 ? void 0 : _b.addEventListener("touchstart", this.onMouseDown, supportsPassive$1 ? {
      passive: false
    } : false);
  },
  beforeUnmount: function beforeUnmount3() {
    this.removeEvents();
    clearTimeout(this.visibleTimeout);
  },
  methods: {
    delayHidden: function delayHidden() {
      var _this = this;
      clearTimeout(this.visibleTimeout);
      this.state.visible = true;
      this.visibleTimeout = setTimeout(function() {
        _this.state.visible = false;
      }, 2e3);
    },
    onScrollbarTouchStart: function onScrollbarTouchStart(e2) {
      e2.preventDefault();
    },
    onContainerMouseDown: function onContainerMouseDown(e2) {
      e2.stopPropagation();
      e2.preventDefault();
    },
    patchEvents: function patchEvents() {
      window.addEventListener("mousemove", this.onMouseMove);
      window.addEventListener("mouseup", this.onMouseUp);
      this.thumbRef.current.addEventListener("touchmove", this.onMouseMove, supportsPassive$1 ? {
        passive: false
      } : false);
      this.thumbRef.current.addEventListener("touchend", this.onMouseUp);
    },
    removeEvents: function removeEvents() {
      window.removeEventListener("mousemove", this.onMouseMove);
      window.removeEventListener("mouseup", this.onMouseUp);
      this.scrollbarRef.current.removeEventListener("touchstart", this.onScrollbarTouchStart, supportsPassive$1 ? {
        passive: false
      } : false);
      this.thumbRef.current.removeEventListener("touchstart", this.onMouseDown, supportsPassive$1 ? {
        passive: false
      } : false);
      this.thumbRef.current.removeEventListener("touchmove", this.onMouseMove, supportsPassive$1 ? {
        passive: false
      } : false);
      this.thumbRef.current.removeEventListener("touchend", this.onMouseUp);
      wrapperRaf.cancel(this.moveRaf);
    },
    onMouseDown: function onMouseDown(e2) {
      var onStartMove = this.$props.onStartMove;
      _extends(this.state, {
        dragging: true,
        pageY: getPageY(e2),
        startTop: this.getTop()
      });
      onStartMove();
      this.patchEvents();
      e2.stopPropagation();
      e2.preventDefault();
    },
    onMouseMove: function onMouseMove2(e2) {
      var _this$state = this.state, dragging = _this$state.dragging, pageY = _this$state.pageY, startTop = _this$state.startTop;
      var onScroll = this.$props.onScroll;
      wrapperRaf.cancel(this.moveRaf);
      if (dragging) {
        var offsetY = getPageY(e2) - pageY;
        var newTop = startTop + offsetY;
        var enableScrollRange = this.getEnableScrollRange();
        var enableHeightRange = this.getEnableHeightRange();
        var ptg = enableHeightRange ? newTop / enableHeightRange : 0;
        var newScrollTop = Math.ceil(ptg * enableScrollRange);
        this.moveRaf = wrapperRaf(function() {
          onScroll(newScrollTop);
        });
      }
    },
    onMouseUp: function onMouseUp() {
      var onStopMove = this.$props.onStopMove;
      this.state.dragging = false;
      onStopMove();
      this.removeEvents();
    },
    getSpinHeight: function getSpinHeight() {
      var _this$$props = this.$props, height = _this$$props.height, count = _this$$props.count;
      var baseHeight = height / count * 10;
      baseHeight = Math.max(baseHeight, MIN_SIZE);
      baseHeight = Math.min(baseHeight, height / 2);
      return Math.floor(baseHeight);
    },
    getEnableScrollRange: function getEnableScrollRange() {
      var _this$$props2 = this.$props, scrollHeight = _this$$props2.scrollHeight, height = _this$$props2.height;
      return scrollHeight - height || 0;
    },
    getEnableHeightRange: function getEnableHeightRange() {
      var height = this.$props.height;
      var spinHeight = this.getSpinHeight();
      return height - spinHeight || 0;
    },
    getTop: function getTop() {
      var scrollTop = this.$props.scrollTop;
      var enableScrollRange = this.getEnableScrollRange();
      var enableHeightRange = this.getEnableHeightRange();
      if (scrollTop === 0 || enableScrollRange === 0) {
        return 0;
      }
      var ptg = scrollTop / enableScrollRange;
      return ptg * enableHeightRange;
    },
    showScroll: function showScroll() {
      var _this$$props3 = this.$props, height = _this$$props3.height, scrollHeight = _this$$props3.scrollHeight;
      return scrollHeight > height;
    }
  },
  render: function render5() {
    var _this$state2 = this.state, dragging = _this$state2.dragging, visible = _this$state2.visible;
    var prefixCls = this.$props.prefixCls;
    var spinHeight = this.getSpinHeight() + "px";
    var top = this.getTop() + "px";
    var canScroll = this.showScroll();
    var mergedVisible = canScroll && visible;
    return Vue.createVNode("div", {
      "ref": this.scrollbarRef,
      "class": classNames("".concat(prefixCls, "-scrollbar"), _defineProperty$T({}, "".concat(prefixCls, "-scrollbar-show"), canScroll)),
      "style": {
        width: "8px",
        top: 0,
        bottom: 0,
        right: 0,
        position: "absolute",
        display: mergedVisible ? void 0 : "none"
      },
      "onMousedown": this.onContainerMouseDown,
      "onMousemove": this.delayHidden
    }, [Vue.createVNode("div", {
      "ref": this.thumbRef,
      "class": classNames("".concat(prefixCls, "-scrollbar-thumb"), _defineProperty$T({}, "".concat(prefixCls, "-scrollbar-thumb-moving"), dragging)),
      "style": {
        width: "100%",
        height: spinHeight,
        top,
        left: 0,
        position: "absolute",
        background: "rgba(0, 0, 0, 0.5)",
        borderRadius: "99px",
        cursor: "pointer",
        userSelect: "none"
      },
      "onMousedown": this.onMouseDown
    }, null)]);
  }
});
function useHeights(mergedData, getKey2, onItemAdd, onItemRemove) {
  var instance = /* @__PURE__ */ new Map();
  var heights = /* @__PURE__ */ new Map();
  var updatedMark = Vue.ref(Symbol("update"));
  Vue.watch(mergedData, function() {
    updatedMark.value = Symbol("update");
  });
  var heightUpdateId = 0;
  function collectHeight() {
    heightUpdateId += 1;
    var currentId = heightUpdateId;
    Promise.resolve().then(function() {
      if (currentId !== heightUpdateId)
        return;
      instance.forEach(function(element, key2) {
        if (element && element.offsetParent) {
          var offsetHeight = element.offsetHeight;
          if (heights.get(key2) !== offsetHeight) {
            updatedMark.value = Symbol("update");
            heights.set(key2, element.offsetHeight);
          }
        }
      });
    });
  }
  function setInstance(item, ins) {
    var key2 = getKey2(item);
    var origin = instance.get(key2);
    if (ins) {
      instance.set(key2, ins.$el || ins);
      collectHeight();
    } else {
      instance.delete(key2);
    }
    if (!origin !== !ins) {
      if (ins) {
        onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
      }
    }
  }
  return [setInstance, collectHeight, heights, updatedMark];
}
function useScrollTo(containerRef, mergedData, heights, props2, getKey2, collectHeight, syncScrollTop, triggerFlash) {
  var scroll;
  return function(arg) {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    wrapperRaf.cancel(scroll);
    var data4 = mergedData.value;
    var itemHeight = props2.itemHeight;
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && _typeof$1(arg) === "object") {
      var index2;
      var align = arg.align;
      if ("index" in arg) {
        index2 = arg.index;
      } else {
        index2 = data4.findIndex(function(item) {
          return getKey2(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset, offset3 = _arg$offset === void 0 ? 0 : _arg$offset;
      var syncScroll = function syncScroll2(times, targetAlign) {
        if (times < 0 || !containerRef.value)
          return;
        var height = containerRef.value.clientHeight;
        var needCollectHeight = false;
        var newTargetAlign = targetAlign;
        if (height) {
          var mergedAlign = targetAlign || align;
          var stackTop = 0;
          var itemTop = 0;
          var itemBottom = 0;
          var maxLen = Math.min(data4.length, index2);
          for (var i2 = 0; i2 <= maxLen; i2 += 1) {
            var key2 = getKey2(data4[i2]);
            itemTop = stackTop;
            var cacheHeight = heights.get(key2);
            itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
            stackTop = itemBottom;
            if (i2 === index2 && cacheHeight === void 0) {
              needCollectHeight = true;
            }
          }
          var scrollTop = containerRef.value.scrollTop;
          var targetTop = null;
          switch (mergedAlign) {
            case "top":
              targetTop = itemTop - offset3;
              break;
            case "bottom":
              targetTop = itemBottom - height + offset3;
              break;
            default: {
              var scrollBottom = scrollTop + height;
              if (itemTop < scrollTop) {
                newTargetAlign = "top";
              } else if (itemBottom > scrollBottom) {
                newTargetAlign = "bottom";
              }
            }
          }
          if (targetTop !== null && targetTop !== scrollTop) {
            syncScrollTop(targetTop);
          }
        }
        scroll = wrapperRaf(function() {
          if (needCollectHeight) {
            collectHeight();
          }
          syncScroll2(times - 1, newTargetAlign);
        });
      };
      syncScroll(3);
    }
  };
}
var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof$1(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
var isFF$1 = isFF;
var useOriginScroll = function(isScrollAtTop, isScrollAtBottom) {
  var lock = false;
  var lockTimeout = null;
  function lockScroll() {
    clearTimeout(lockTimeout);
    lock = true;
    lockTimeout = setTimeout(function() {
      lock = false;
    }, 50);
  }
  return function(deltaY) {
    var smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var originScroll = deltaY < 0 && isScrollAtTop.value || deltaY > 0 && isScrollAtBottom.value;
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeout);
      lock = false;
    } else if (!originScroll || lock) {
      lockScroll();
    }
    return !lock && originScroll;
  };
};
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
  var offsetRef = 0;
  var nextFrame = null;
  var wheelValue = null;
  var isMouseScroll = false;
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  function onWheel(event) {
    if (!inVirtual.value)
      return;
    wrapperRaf.cancel(nextFrame);
    var deltaY = event.deltaY;
    offsetRef += deltaY;
    wheelValue = deltaY;
    if (originScroll(deltaY))
      return;
    if (!isFF$1) {
      event.preventDefault();
    }
    nextFrame = wrapperRaf(function() {
      var patchMultiple = isMouseScroll ? 10 : 1;
      onWheelDelta(offsetRef * patchMultiple);
      offsetRef = 0;
    });
  }
  function onFireFoxScroll(event) {
    if (!inVirtual.value)
      return;
    isMouseScroll = event.detail === wheelValue;
  }
  return [onWheel, onFireFoxScroll];
}
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  var touched = false;
  var touchY = 0;
  var element = null;
  var interval = null;
  var cleanUpEvents = function cleanUpEvents2() {
    if (element) {
      element.removeEventListener("touchmove", onTouchMove);
      element.removeEventListener("touchend", onTouchEnd);
    }
  };
  var onTouchMove = function onTouchMove2(e2) {
    if (touched) {
      var currentY = Math.ceil(e2.touches[0].pageY);
      var offsetY = touchY - currentY;
      touchY = currentY;
      if (callback(offsetY)) {
        e2.preventDefault();
      }
      clearInterval(interval);
      interval = setInterval(function() {
        offsetY *= SMOOTH_PTG;
        if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          clearInterval(interval);
        }
      }, 16);
    }
  };
  var onTouchEnd = function onTouchEnd2() {
    touched = false;
    cleanUpEvents();
  };
  var onTouchStart = function onTouchStart2(e2) {
    cleanUpEvents();
    if (e2.touches.length === 1 && !touched) {
      touched = true;
      touchY = Math.ceil(e2.touches[0].pageY);
      element = e2.target;
      element.addEventListener("touchmove", onTouchMove, {
        passive: false
      });
      element.addEventListener("touchend", onTouchEnd);
    }
  };
  var noop3 = function noop4() {
  };
  Vue.onMounted(function() {
    document.addEventListener("touchmove", noop3, {
      passive: false
    });
    Vue.watch(inVirtual, function(val) {
      listRef.value.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      clearInterval(interval);
      if (val) {
        listRef.value.addEventListener("touchstart", onTouchStart, {
          passive: false
        });
      }
    }, {
      immediate: true
    });
  });
  Vue.onBeforeUnmount(function() {
    document.removeEventListener("touchmove", noop3);
  });
}
var __rest$q = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var EMPTY_DATA = [];
var ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function renderChildren(list, startIndex, endIndex, setNodeRef, renderFunc, _ref) {
  var getKey2 = _ref.getKey;
  return list.slice(startIndex, endIndex + 1).map(function(item, index2) {
    var eleIndex = startIndex + index2;
    var node = renderFunc(item, eleIndex, {});
    var key2 = getKey2(item);
    return Vue.createVNode(Item$2, {
      "key": key2,
      "setRef": function setRef(ele) {
        return setNodeRef(item, ele);
      }
    }, {
      default: function _default5() {
        return [node];
      }
    });
  });
}
var List$1 = Vue.defineComponent({
  name: "List",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    data: PropTypes$1.array,
    height: Number,
    itemHeight: Number,
    fullHeight: {
      type: Boolean,
      default: void 0
    },
    itemKey: {
      type: [String, Number, Function],
      required: true
    },
    component: {
      type: [String, Object]
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    children: Function,
    onScroll: Function,
    onMousedown: Function,
    onMouseenter: Function,
    onVisibleChange: Function
  },
  setup: function setup84(props2, _ref2) {
    var expose = _ref2.expose;
    var useVirtual = Vue.computed(function() {
      var height = props2.height, itemHeight = props2.itemHeight, virtual = props2.virtual;
      return !!(virtual !== false && height && itemHeight);
    });
    var inVirtual = Vue.computed(function() {
      var height = props2.height, itemHeight = props2.itemHeight, data5 = props2.data;
      return useVirtual.value && data5 && itemHeight * data5.length > height;
    });
    var state = Vue.reactive({
      scrollTop: 0,
      scrollMoving: false
    });
    var data4 = Vue.computed(function() {
      return props2.data || EMPTY_DATA;
    });
    var mergedData = Vue.shallowRef([]);
    Vue.watch(data4, function() {
      mergedData.value = Vue.toRaw(data4.value).slice();
    }, {
      immediate: true
    });
    var itemKey2 = Vue.shallowRef(function(_item) {
      return void 0;
    });
    Vue.watch(function() {
      return props2.itemKey;
    }, function(val) {
      if (typeof val === "function") {
        itemKey2.value = val;
      } else {
        itemKey2.value = function(item) {
          return item === null || item === void 0 ? void 0 : item[val];
        };
      }
    }, {
      immediate: true
    });
    var componentRef = Vue.ref();
    var fillerInnerRef = Vue.ref();
    var scrollBarRef = Vue.ref();
    var getKey2 = function getKey3(item) {
      return itemKey2.value(item);
    };
    var sharedConfig = {
      getKey: getKey2
    };
    function syncScrollTop(newTop) {
      var value;
      if (typeof newTop === "function") {
        value = newTop(state.scrollTop);
      } else {
        value = newTop;
      }
      var alignedTop = keepInRange(value);
      if (componentRef.value) {
        componentRef.value.scrollTop = alignedTop;
      }
      state.scrollTop = alignedTop;
    }
    var _useHeights = useHeights(mergedData, getKey2, null, null), _useHeights2 = _slicedToArray(_useHeights, 4), setInstance = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], updatedMark = _useHeights2[3];
    var calRes = Vue.reactive({
      scrollHeight: void 0,
      start: 0,
      end: 0,
      offset: void 0
    });
    var offsetHeight = Vue.ref(0);
    Vue.onMounted(function() {
      Vue.nextTick(function() {
        var _a;
        offsetHeight.value = ((_a = fillerInnerRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
      });
    });
    Vue.onUpdated(function() {
      Vue.nextTick(function() {
        var _a;
        offsetHeight.value = ((_a = fillerInnerRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
      });
    });
    Vue.watch([useVirtual, mergedData], function() {
      if (!useVirtual.value) {
        _extends(calRes, {
          scrollHeight: void 0,
          start: 0,
          end: mergedData.value.length - 1,
          offset: void 0
        });
      }
    }, {
      immediate: true
    });
    Vue.watch([useVirtual, mergedData, offsetHeight, inVirtual], function() {
      if (useVirtual.value && !inVirtual.value) {
        _extends(calRes, {
          scrollHeight: offsetHeight.value,
          start: 0,
          end: mergedData.value.length - 1,
          offset: void 0
        });
      }
    }, {
      immediate: true
    });
    Vue.watch([inVirtual, useVirtual, function() {
      return state.scrollTop;
    }, mergedData, updatedMark, function() {
      return props2.height;
    }, offsetHeight], function() {
      if (!useVirtual.value || !inVirtual.value) {
        return;
      }
      var itemTop = 0;
      var startIndex;
      var startOffset;
      var endIndex;
      var dataLen = mergedData.value.length;
      var data5 = mergedData.value;
      var scrollTop = state.scrollTop;
      var itemHeight = props2.itemHeight, height = props2.height;
      var scrollTopHeight = scrollTop + height;
      for (var i2 = 0; i2 < dataLen; i2 += 1) {
        var item = data5[i2];
        var key2 = getKey2(item);
        var cacheHeight = heights.get(key2);
        if (cacheHeight === void 0) {
          cacheHeight = itemHeight;
        }
        var currentItemBottom = itemTop + cacheHeight;
        if (startIndex === void 0 && currentItemBottom >= scrollTop) {
          startIndex = i2;
          startOffset = itemTop;
        }
        if (endIndex === void 0 && currentItemBottom > scrollTopHeight) {
          endIndex = i2;
        }
        itemTop = currentItemBottom;
      }
      if (startIndex === void 0) {
        startIndex = 0;
        startOffset = 0;
      }
      if (endIndex === void 0) {
        endIndex = dataLen - 1;
      }
      endIndex = Math.min(endIndex + 1, dataLen);
      _extends(calRes, {
        scrollHeight: itemTop,
        start: startIndex,
        end: endIndex,
        offset: startOffset
      });
    }, {
      immediate: true
    });
    var maxScrollHeight = Vue.computed(function() {
      return calRes.scrollHeight - props2.height;
    });
    function keepInRange(newScrollTop) {
      var newTop = newScrollTop;
      if (!Number.isNaN(maxScrollHeight.value)) {
        newTop = Math.min(newTop, maxScrollHeight.value);
      }
      newTop = Math.max(newTop, 0);
      return newTop;
    }
    var isScrollAtTop = Vue.computed(function() {
      return state.scrollTop <= 0;
    });
    var isScrollAtBottom = Vue.computed(function() {
      return state.scrollTop >= maxScrollHeight.value;
    });
    var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
    function onScrollBar(newScrollTop) {
      var newTop = newScrollTop;
      syncScrollTop(newTop);
    }
    function onFallbackScroll(e2) {
      var _a;
      var newScrollTop = e2.currentTarget.scrollTop;
      if (Math.abs(newScrollTop - state.scrollTop) >= 1) {
        syncScrollTop(newScrollTop);
      }
      (_a = props2.onScroll) === null || _a === void 0 ? void 0 : _a.call(props2, e2);
    }
    var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, function(offsetY) {
      syncScrollTop(function(top) {
        var newTop = top + offsetY;
        return newTop;
      });
    }), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
    useMobileTouchMove(useVirtual, componentRef, function(deltaY, smoothOffset) {
      if (originScroll(deltaY, smoothOffset)) {
        return false;
      }
      onRawWheel({
        preventDefault: function preventDefault() {
        },
        deltaY
      });
      return true;
    });
    function onMozMousePixelScroll(e2) {
      if (useVirtual.value) {
        e2.preventDefault();
      }
    }
    var removeEventListener2 = function removeEventListener3() {
      if (componentRef.value) {
        componentRef.value.removeEventListener("wheel", onRawWheel, supportsPassive$1 ? {
          passive: false
        } : false);
        componentRef.value.removeEventListener("DOMMouseScroll", onFireFoxScroll);
        componentRef.value.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
      }
    };
    Vue.watchEffect(function() {
      Vue.nextTick(function() {
        if (componentRef.value) {
          removeEventListener2();
          componentRef.value.addEventListener("wheel", onRawWheel, supportsPassive$1 ? {
            passive: false
          } : false);
          componentRef.value.addEventListener("DOMMouseScroll", onFireFoxScroll);
          componentRef.value.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
        }
      });
    });
    Vue.onBeforeUnmount(function() {
      removeEventListener2();
    });
    var scrollTo2 = useScrollTo(componentRef, mergedData, heights, props2, getKey2, collectHeight, syncScrollTop, function() {
      var _a;
      (_a = scrollBarRef.value) === null || _a === void 0 ? void 0 : _a.delayHidden();
    });
    expose({
      scrollTo: scrollTo2
    });
    var componentStyle = Vue.computed(function() {
      var cs = null;
      if (props2.height) {
        cs = _extends(_defineProperty$T({}, props2.fullHeight ? "height" : "maxHeight", props2.height + "px"), ScrollStyle);
        if (useVirtual.value) {
          cs.overflowY = "hidden";
          if (state.scrollMoving) {
            cs.pointerEvents = "none";
          }
        }
      }
      return cs;
    });
    Vue.watch([function() {
      return calRes.start;
    }, function() {
      return calRes.end;
    }, mergedData], function() {
      if (props2.onVisibleChange) {
        var renderList = mergedData.value.slice(calRes.start, calRes.end + 1);
        props2.onVisibleChange(renderList, mergedData.value);
      }
    }, {
      flush: "post"
    });
    return {
      state,
      mergedData,
      componentStyle,
      onFallbackScroll,
      onScrollBar,
      componentRef,
      useVirtual,
      calRes,
      collectHeight,
      setInstance,
      sharedConfig,
      scrollBarRef,
      fillerInnerRef
    };
  },
  render: function render6() {
    var _this = this;
    var _a = _extends(_extends({}, this.$props), this.$attrs), _a$prefixCls = _a.prefixCls, prefixCls = _a$prefixCls === void 0 ? "rc-virtual-list" : _a$prefixCls, height = _a.height;
    _a.itemHeight;
    _a.fullHeight;
    _a.data;
    _a.itemKey;
    _a.virtual;
    var _a$component = _a.component, Component = _a$component === void 0 ? "div" : _a$component;
    _a.onScroll;
    var _a$children = _a.children, children = _a$children === void 0 ? this.$slots.default : _a$children, style = _a.style, className = _a.class, restProps = __rest$q(_a, ["prefixCls", "height", "itemHeight", "fullHeight", "data", "itemKey", "virtual", "component", "onScroll", "children", "style", "class"]);
    var mergedClassName = classNames(prefixCls, className);
    var scrollTop = this.state.scrollTop;
    var _this$calRes = this.calRes, scrollHeight = _this$calRes.scrollHeight, offset3 = _this$calRes.offset, start = _this$calRes.start, end = _this$calRes.end;
    var componentStyle = this.componentStyle, onFallbackScroll = this.onFallbackScroll, onScrollBar = this.onScrollBar, useVirtual = this.useVirtual, collectHeight = this.collectHeight, sharedConfig = this.sharedConfig, setInstance = this.setInstance, mergedData = this.mergedData;
    return Vue.createVNode("div", _objectSpread2$1({
      "style": _extends(_extends({}, style), {
        position: "relative"
      }),
      "class": mergedClassName
    }, restProps), [Vue.createVNode(Component, {
      "class": "".concat(prefixCls, "-holder"),
      "style": componentStyle,
      "ref": "componentRef",
      "onScroll": onFallbackScroll
    }, {
      default: function _default5() {
        return [Vue.createVNode(Filler, {
          "prefixCls": prefixCls,
          "height": scrollHeight,
          "offset": offset3,
          "onInnerResize": collectHeight,
          "ref": "fillerInnerRef"
        }, {
          default: function _default6() {
            return renderChildren(mergedData, start, end, setInstance, children, sharedConfig);
          }
        })];
      }
    }), useVirtual && Vue.createVNode(ScrollBar, {
      "ref": "scrollBarRef",
      "prefixCls": prefixCls,
      "scrollTop": scrollTop,
      "height": height,
      "scrollHeight": scrollHeight,
      "count": mergedData.length,
      "onScroll": onScrollBar,
      "onStartMove": function onStartMove() {
        _this.state.scrollMoving = true;
      },
      "onStopMove": function onStopMove() {
        _this.state.scrollMoving = false;
      }
    }, null)]);
  }
});
var List$2 = List$1;
function useMemo(getValue2, condition, shouldUpdate) {
  var cacheRef = Vue.ref(getValue2());
  Vue.watch(condition, function(next2, pre) {
    if (shouldUpdate) {
      if (shouldUpdate(next2, pre)) {
        cacheRef.value = getValue2();
      }
    } else {
      cacheRef.value = getValue2();
    }
  });
  return cacheRef;
}
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
var SelectContextKey = Symbol("SelectContextKey");
function useProvideSelectProps(props2) {
  return Vue.provide(SelectContextKey, props2);
}
function useSelectProps() {
  return Vue.inject(SelectContextKey, {});
}
var __rest$p = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function isTitleType(content) {
  return typeof content === "string" || typeof content === "number";
}
var OptionList = Vue.defineComponent({
  name: "OptionList",
  inheritAttrs: false,
  slots: ["option"],
  setup: function setup85(_2, _ref) {
    var expose = _ref.expose, slots = _ref.slots;
    var baseProps2 = useBaseProps();
    var props2 = useSelectProps();
    var itemPrefixCls = Vue.computed(function() {
      return "".concat(baseProps2.prefixCls, "-item");
    });
    var memoFlattenOptions = useMemo(function() {
      return props2.flattenOptions;
    }, [function() {
      return baseProps2.open;
    }, function() {
      return props2.flattenOptions;
    }], function(next2) {
      return next2[0];
    });
    var listRef = createRef();
    var onListMouseDown = function onListMouseDown2(event) {
      event.preventDefault();
    };
    var scrollIntoView = function scrollIntoView2(args) {
      if (listRef.current) {
        listRef.current.scrollTo(typeof args === "number" ? {
          index: args
        } : args);
      }
    };
    var getEnabledActiveIndex = function getEnabledActiveIndex2(index2) {
      var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var len = memoFlattenOptions.value.length;
      for (var i2 = 0; i2 < len; i2 += 1) {
        var current2 = (index2 + i2 * offset3 + len) % len;
        var _memoFlattenOptions$v = memoFlattenOptions.value[current2], group = _memoFlattenOptions$v.group, data4 = _memoFlattenOptions$v.data;
        if (!group && !data4.disabled) {
          return current2;
        }
      }
      return -1;
    };
    var state = Vue.reactive({
      activeIndex: getEnabledActiveIndex(0)
    });
    var setActive = function setActive2(index2) {
      var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      state.activeIndex = index2;
      var info = {
        source: fromKeyboard ? "keyboard" : "mouse"
      };
      var flattenItem = memoFlattenOptions.value[index2];
      if (!flattenItem) {
        props2.onActiveValue(null, -1, info);
        return;
      }
      props2.onActiveValue(flattenItem.value, index2, info);
    };
    Vue.watch([function() {
      return memoFlattenOptions.value.length;
    }, function() {
      return baseProps2.searchValue;
    }], function() {
      setActive(props2.defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
    }, {
      immediate: true
    });
    var isSelected = function isSelected2(value) {
      return props2.rawValues.has(value) && baseProps2.mode !== "combobox";
    };
    Vue.watch([function() {
      return baseProps2.open;
    }, function() {
      return baseProps2.searchValue;
    }], function() {
      if (!baseProps2.multiple && baseProps2.open && props2.rawValues.size === 1) {
        var value = Array.from(props2.rawValues)[0];
        var index2 = Vue.toRaw(memoFlattenOptions.value).findIndex(function(_ref2) {
          var data4 = _ref2.data;
          return data4.value === value;
        });
        if (index2 !== -1) {
          setActive(index2);
          Vue.nextTick(function() {
            scrollIntoView(index2);
          });
        }
      }
      if (baseProps2.open) {
        Vue.nextTick(function() {
          var _a;
          (_a = listRef.current) === null || _a === void 0 ? void 0 : _a.scrollTo(void 0);
        });
      }
    }, {
      immediate: true,
      flush: "post"
    });
    var onSelectValue = function onSelectValue2(value) {
      if (value !== void 0) {
        props2.onSelect(value, {
          selected: !props2.rawValues.has(value)
        });
      }
      if (!baseProps2.multiple) {
        baseProps2.toggleOpen(false);
      }
    };
    var getLabel = function getLabel2(item) {
      return typeof item.label === "function" ? item.label() : item.label;
    };
    function renderItem(index2) {
      var item = memoFlattenOptions.value[index2];
      if (!item)
        return null;
      var itemData = item.data || {};
      var value = itemData.value;
      var group = item.group;
      var attrs = pickAttrs(itemData, true);
      var mergedLabel = getLabel(item);
      return item ? Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
      }, attrs), {}, {
        "key": index2,
        "role": group ? "presentation" : "option",
        "id": "".concat(baseProps2.id, "_list_").concat(index2),
        "aria-selected": isSelected(value)
      }), [value]) : null;
    }
    var onKeydown = function onKeydown2(event) {
      var which = event.which, ctrlKey = event.ctrlKey;
      switch (which) {
        case KeyCode$1.N:
        case KeyCode$1.P:
        case KeyCode$1.UP:
        case KeyCode$1.DOWN: {
          var offset3 = 0;
          if (which === KeyCode$1.UP) {
            offset3 = -1;
          } else if (which === KeyCode$1.DOWN) {
            offset3 = 1;
          } else if (isPlatformMac() && ctrlKey) {
            if (which === KeyCode$1.N) {
              offset3 = 1;
            } else if (which === KeyCode$1.P) {
              offset3 = -1;
            }
          }
          if (offset3 !== 0) {
            var nextActiveIndex = getEnabledActiveIndex(state.activeIndex + offset3, offset3);
            scrollIntoView(nextActiveIndex);
            setActive(nextActiveIndex, true);
          }
          break;
        }
        case KeyCode$1.ENTER: {
          var item = memoFlattenOptions.value[state.activeIndex];
          if (item && !item.data.disabled) {
            onSelectValue(item.value);
          } else {
            onSelectValue(void 0);
          }
          if (baseProps2.open) {
            event.preventDefault();
          }
          break;
        }
        case KeyCode$1.ESC: {
          baseProps2.toggleOpen(false);
          if (baseProps2.open) {
            event.stopPropagation();
          }
        }
      }
    };
    var onKeyup = function onKeyup2() {
    };
    var scrollTo2 = function scrollTo3(index2) {
      scrollIntoView(index2);
    };
    expose({
      onKeydown,
      onKeyup,
      scrollTo: scrollTo2
    });
    return function() {
      var id = baseProps2.id, notFoundContent = baseProps2.notFoundContent, onPopupScroll = baseProps2.onPopupScroll;
      var menuItemSelectedIcon = props2.menuItemSelectedIcon, fieldNames = props2.fieldNames, virtual = props2.virtual, listHeight = props2.listHeight, listItemHeight = props2.listItemHeight;
      var renderOption = slots.option;
      var activeIndex = state.activeIndex;
      var omitFieldNameList = Object.keys(fieldNames).map(function(key2) {
        return fieldNames[key2];
      });
      if (memoFlattenOptions.value.length === 0) {
        return Vue.createVNode("div", {
          "role": "listbox",
          "id": "".concat(id, "_list"),
          "class": "".concat(itemPrefixCls.value, "-empty"),
          "onMousedown": onListMouseDown
        }, [notFoundContent]);
      }
      return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode("div", {
        "role": "listbox",
        "id": "".concat(id, "_list"),
        "style": {
          height: 0,
          width: 0,
          overflow: "hidden"
        }
      }, [renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)]), Vue.createVNode(List$2, {
        "itemKey": "key",
        "ref": listRef,
        "data": memoFlattenOptions.value,
        "height": listHeight,
        "itemHeight": listItemHeight,
        "fullHeight": false,
        "onMousedown": onListMouseDown,
        "onScroll": onPopupScroll,
        "virtual": virtual
      }, {
        default: function _default5(item, itemIndex) {
          var _classNames;
          var _a;
          var group = item.group, groupOption = item.groupOption, data4 = item.data, value = item.value;
          var key2 = data4.key;
          var label = typeof item.label === "function" ? item.label() : item.label;
          if (group) {
            var groupTitle = (_a = data4.title) !== null && _a !== void 0 ? _a : isTitleType(label) && label;
            return Vue.createVNode("div", {
              "class": classNames(itemPrefixCls.value, "".concat(itemPrefixCls.value, "-group")),
              "title": groupTitle
            }, [renderOption ? renderOption(data4) : label !== void 0 ? label : key2]);
          }
          var disabled = data4.disabled, title = data4.title;
          data4.children;
          var style = data4.style, cls = data4.class, className = data4.className, otherProps = __rest$p(data4, ["disabled", "title", "children", "style", "class", "className"]);
          var passedProps = omit(otherProps, omitFieldNameList);
          var selected = isSelected(value);
          var optionPrefixCls = "".concat(itemPrefixCls.value, "-option");
          var optionClassName = classNames(itemPrefixCls.value, optionPrefixCls, cls, className, (_classNames = {}, _defineProperty$T(_classNames, "".concat(optionPrefixCls, "-grouped"), groupOption), _defineProperty$T(_classNames, "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !disabled), _defineProperty$T(_classNames, "".concat(optionPrefixCls, "-disabled"), disabled), _defineProperty$T(_classNames, "".concat(optionPrefixCls, "-selected"), selected), _classNames));
          var mergedLabel = getLabel(item);
          var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
          var content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
          var optionTitle = isTitleType(content) ? content.toString() : void 0;
          if (title !== void 0) {
            optionTitle = title;
          }
          return Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({}, passedProps), {}, {
            "aria-selected": selected,
            "class": optionClassName,
            "title": optionTitle,
            "onMousemove": function onMousemove(e2) {
              if (otherProps.onMousemove) {
                otherProps.onMousemove(e2);
              }
              if (activeIndex === itemIndex || disabled) {
                return;
              }
              setActive(itemIndex);
            },
            "onClick": function onClick2(e2) {
              if (!disabled) {
                onSelectValue(value);
              }
              if (otherProps.onClick) {
                otherProps.onClick(e2);
              }
            },
            "style": style
          }), [Vue.createVNode("div", {
            "class": "".concat(optionPrefixCls, "-content")
          }, [renderOption ? renderOption(data4) : content]), isValidElement(menuItemSelectedIcon) || selected, iconVisible && Vue.createVNode(TransBtn$1, {
            "class": "".concat(itemPrefixCls.value, "-option-state"),
            "customizeIcon": menuItemSelectedIcon,
            "customizeIconProps": {
              isSelected: selected
            }
          }, {
            default: function _default6() {
              return [selected ? "\u2713" : null];
            }
          })]);
        }
      })]);
    };
  }
});
var OptionList$1 = OptionList;
var __rest$o = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function convertNodeToOption(node) {
  var _a = node, key2 = _a.key, children = _a.children, _b = _a.props, value = _b.value, disabled = _b.disabled, restProps = __rest$o(_b, ["value", "disabled"]);
  var child = children === null || children === void 0 ? void 0 : children.default;
  return _extends({
    key: key2,
    value: value !== void 0 ? value : key2,
    children: child,
    disabled: disabled || disabled === ""
  }, restProps);
}
function convertChildrenToData(nodes) {
  var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var dd = flattenChildren(nodes).map(function(node, index2) {
    var _a;
    if (!isValidElement(node) || !node.type) {
      return null;
    }
    var isSelectOptGroup = node.type.isSelectOptGroup, key2 = node.key, children = node.children, props2 = node.props;
    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node);
    }
    var child = children && children.default ? children.default() : void 0;
    var label = (props2 === null || props2 === void 0 ? void 0 : props2.label) || ((_a = children.label) === null || _a === void 0 ? void 0 : _a.call(children)) || key2;
    return _extends(_extends({
      key: "__RC_SELECT_GRP__".concat(key2 === null ? index2 : String(key2), "__")
    }, props2), {
      label,
      options: convertChildrenToData(child || [])
    });
  }).filter(function(data4) {
    return data4;
  });
  return dd;
}
function useOptions(options, children, fieldNames) {
  var mergedOptions = Vue.shallowRef();
  var valueOptions = Vue.shallowRef();
  var labelOptions = Vue.shallowRef();
  var tempMergedOptions = Vue.shallowRef([]);
  Vue.watch([options, children], function() {
    if (options.value) {
      tempMergedOptions.value = Vue.toRaw(options.value).slice();
    } else {
      tempMergedOptions.value = convertChildrenToData(children.value);
    }
  }, {
    immediate: true,
    deep: true
  });
  Vue.watchEffect(function() {
    var newOptions = tempMergedOptions.value;
    var newValueOptions = /* @__PURE__ */ new Map();
    var newLabelOptions = /* @__PURE__ */ new Map();
    var fieldNamesValue = fieldNames.value;
    function dig(optionList) {
      var isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      for (var i2 = 0; i2 < optionList.length; i2 += 1) {
        var option = optionList[i2];
        if (!option[fieldNamesValue.options] || isChildren) {
          newValueOptions.set(option[fieldNamesValue.value], option);
          newLabelOptions.set(option[fieldNamesValue.label], option);
        } else {
          dig(option[fieldNamesValue.options], true);
        }
      }
    }
    dig(newOptions);
    mergedOptions.value = newOptions;
    valueOptions.value = newValueOptions;
    labelOptions.value = newLabelOptions;
  });
  return {
    options: mergedOptions,
    valueOptions,
    labelOptions
  };
}
var uuid$2 = 0;
var isBrowserClient = canUseDom();
function getUUID$1() {
  var retId;
  if (isBrowserClient) {
    retId = uuid$2;
    uuid$2 += 1;
  } else {
    retId = "TEST_OR_SSR";
  }
  return retId;
}
function useId() {
  var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Vue.ref("");
  var innerId = "rc_select_".concat(getUUID$1());
  return id.value || innerId;
}
function toArray$2(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value !== void 0 ? [value] : [];
}
function includes(test, search) {
  return toArray$2(test).join("").toUpperCase().includes(search);
}
var useFilterOptions = function(options, fieldNames, searchValue, filterOption, optionFilterProp) {
  return Vue.computed(function() {
    var searchValueVal = searchValue.value;
    var optionFilterPropValue = optionFilterProp === null || optionFilterProp === void 0 ? void 0 : optionFilterProp.value;
    var filterOptionValue = filterOption === null || filterOption === void 0 ? void 0 : filterOption.value;
    if (!searchValueVal || filterOptionValue === false) {
      return options.value;
    }
    var _fieldNames$value = fieldNames.value, fieldOptions = _fieldNames$value.options, fieldLabel = _fieldNames$value.label, fieldValue = _fieldNames$value.value;
    var filteredOptions = [];
    var customizeFilter = typeof filterOptionValue === "function";
    var upperSearch = searchValueVal.toUpperCase();
    var filterFunc = customizeFilter ? filterOptionValue : function(_2, option) {
      if (optionFilterPropValue) {
        return includes(option[optionFilterPropValue], upperSearch);
      }
      if (option[fieldOptions]) {
        return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
      }
      return includes(option[fieldValue], upperSearch);
    };
    var wrapOption = customizeFilter ? function(opt) {
      return injectPropsWithOption(opt);
    } : function(opt) {
      return opt;
    };
    options.value.forEach(function(item) {
      if (item[fieldOptions]) {
        var matchGroup = filterFunc(searchValueVal, wrapOption(item));
        if (matchGroup) {
          filteredOptions.push(item);
        } else {
          var subOptions = item[fieldOptions].filter(function(subItem) {
            return filterFunc(searchValueVal, wrapOption(subItem));
          });
          if (subOptions.length) {
            filteredOptions.push(_extends(_extends({}, item), _defineProperty$T({}, fieldOptions, subOptions)));
          }
        }
        return;
      }
      if (filterFunc(searchValueVal, wrapOption(item))) {
        filteredOptions.push(item);
      }
    });
    return filteredOptions;
  });
};
var useCache = function(labeledValues, valueOptions) {
  var cacheRef = Vue.shallowRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  var filledLabeledValues = Vue.computed(function() {
    var _cacheRef$value = cacheRef.value, prevValueCache = _cacheRef$value.values, prevOptionCache = _cacheRef$value.options;
    var patchedValues = labeledValues.value.map(function(item) {
      var _a;
      if (item.label === void 0) {
        return _extends(_extends({}, item), {
          label: (_a = prevValueCache.get(item.value)) === null || _a === void 0 ? void 0 : _a.label
        });
      }
      return item;
    });
    var valueCache = /* @__PURE__ */ new Map();
    var optionCache = /* @__PURE__ */ new Map();
    patchedValues.forEach(function(item) {
      valueCache.set(item.value, item);
      optionCache.set(item.value, valueOptions.value.get(item.value) || prevOptionCache.get(item.value));
    });
    cacheRef.value.values = valueCache;
    cacheRef.value.options = optionCache;
    return patchedValues;
  });
  var getOption = function getOption2(val) {
    return valueOptions.value.get(val) || cacheRef.value.options.get(val);
  };
  return [filledLabeledValues, getOption];
};
var OMIT_DOM_PROPS = ["inputValue"];
function selectProps$1() {
  return _extends(_extends({}, baseSelectPropsWithoutPrivate()), {
    prefixCls: String,
    id: String,
    backfill: {
      type: Boolean,
      default: void 0
    },
    fieldNames: Object,
    inputValue: String,
    searchValue: String,
    onSearch: Function,
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    onSelect: Function,
    onDeselect: Function,
    filterOption: {
      type: [Boolean, Function],
      default: void 0
    },
    filterSort: Function,
    optionFilterProp: String,
    optionLabelProp: String,
    options: Array,
    defaultActiveFirstOption: {
      type: Boolean,
      default: void 0
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    menuItemSelectedIcon: PropTypes$1.any,
    mode: String,
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    value: PropTypes$1.any,
    defaultValue: PropTypes$1.any,
    onChange: Function,
    children: Array
  });
}
function isRawValue(value) {
  return !value || _typeof$1(value) !== "object";
}
var Select$2 = Vue.defineComponent({
  name: "Select",
  inheritAttrs: false,
  props: initDefaultProps$1(selectProps$1(), {
    prefixCls: "vc-select",
    autoClearSearchValue: true,
    listHeight: 200,
    listItemHeight: 20,
    dropdownMatchSelectWidth: true
  }),
  setup: function setup86(props2, _ref) {
    var expose = _ref.expose, attrs = _ref.attrs, slots = _ref.slots;
    var mergedId = useId(Vue.toRef(props2, "id"));
    var multiple = Vue.computed(function() {
      return isMultiple(props2.mode);
    });
    var childrenAsData = Vue.computed(function() {
      return !!(!props2.options && props2.children);
    });
    var mergedFilterOption = Vue.computed(function() {
      if (props2.filterOption === void 0 && props2.mode === "combobox") {
        return false;
      }
      return props2.filterOption;
    });
    var mergedFieldNames = Vue.computed(function() {
      return fillFieldNames$1(props2.fieldNames, childrenAsData.value);
    });
    var _useMergedState = useMergedState("", {
      value: Vue.computed(function() {
        return props2.searchValue !== void 0 ? props2.searchValue : props2.inputValue;
      }),
      postState: function postState(search) {
        return search || "";
      }
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
    var parsedOptions = useOptions(Vue.toRef(props2, "options"), Vue.toRef(props2, "children"), mergedFieldNames);
    var valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options;
    var convert2LabelValues = function convert2LabelValues2(draftValues) {
      var valueList = toArray$2(draftValues);
      return valueList.map(function(val) {
        var _a, _b;
        var rawValue;
        var rawLabel;
        var rawKey;
        var rawDisabled;
        if (isRawValue(val)) {
          rawValue = val;
        } else {
          rawKey = val.key;
          rawLabel = val.label;
          rawValue = (_a = val.value) !== null && _a !== void 0 ? _a : rawKey;
        }
        var option = valueOptions.value.get(rawValue);
        if (option) {
          if (rawLabel === void 0)
            rawLabel = option === null || option === void 0 ? void 0 : option[props2.optionLabelProp || mergedFieldNames.value.label];
          if (rawKey === void 0)
            rawKey = (_b = option === null || option === void 0 ? void 0 : option.key) !== null && _b !== void 0 ? _b : rawValue;
          rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
        }
        return {
          label: rawLabel,
          value: rawValue,
          key: rawKey,
          disabled: rawDisabled,
          option
        };
      });
    };
    var _useMergedState3 = useMergedState(props2.defaultValue, {
      value: Vue.toRef(props2, "value")
    }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
    var rawLabeledValues = Vue.computed(function() {
      var _a;
      var values = convert2LabelValues(internalValue.value);
      if (props2.mode === "combobox" && !((_a = values[0]) === null || _a === void 0 ? void 0 : _a.value)) {
        return [];
      }
      return values;
    });
    var _useCache = useCache(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1];
    var displayValues = Vue.computed(function() {
      if (!props2.mode && mergedValues.value.length === 1) {
        var firstValue = mergedValues.value[0];
        if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
          return [];
        }
      }
      return mergedValues.value.map(function(item) {
        var _a;
        return _extends(_extends({}, item), {
          label: (_a = typeof item.label === "function" ? item.label() : item.label) !== null && _a !== void 0 ? _a : item.value
        });
      });
    });
    var rawValues = Vue.computed(function() {
      return new Set(mergedValues.value.map(function(val) {
        return val.value;
      }));
    });
    Vue.watchEffect(function() {
      var _a;
      if (props2.mode === "combobox") {
        var strValue = (_a = mergedValues.value[0]) === null || _a === void 0 ? void 0 : _a.value;
        if (strValue !== void 0 && strValue !== null) {
          setSearchValue(String(strValue));
        }
      }
    }, {
      flush: "post"
    });
    var createTagOption = function createTagOption2(val, label) {
      var _ref2;
      var mergedLabel = label !== null && label !== void 0 ? label : val;
      return _ref2 = {}, _defineProperty$T(_ref2, mergedFieldNames.value.value, val), _defineProperty$T(_ref2, mergedFieldNames.value.label, mergedLabel), _ref2;
    };
    var filledTagOptions = Vue.shallowRef();
    Vue.watchEffect(function() {
      if (props2.mode !== "tags") {
        filledTagOptions.value = mergedOptions.value;
        return;
      }
      var cloneOptions = mergedOptions.value.slice();
      var existOptions = function existOptions2(val) {
        return valueOptions.value.has(val);
      };
      _toConsumableArray(mergedValues.value).sort(function(a2, b2) {
        return a2.value < b2.value ? -1 : 1;
      }).forEach(function(item) {
        var val = item.value;
        if (!existOptions(val)) {
          cloneOptions.push(createTagOption(val, item.label));
        }
      });
      filledTagOptions.value = cloneOptions;
    });
    var filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, Vue.toRef(props2, "optionFilterProp"));
    var filledSearchOptions = Vue.computed(function() {
      if (props2.mode !== "tags" || !mergedSearchValue.value || filteredOptions.value.some(function(item) {
        return item[props2.optionFilterProp || "value"] === mergedSearchValue.value;
      })) {
        return filteredOptions.value;
      }
      return [createTagOption(mergedSearchValue.value)].concat(_toConsumableArray(filteredOptions.value));
    });
    var orderedFilteredOptions = Vue.computed(function() {
      if (!props2.filterSort) {
        return filledSearchOptions.value;
      }
      return _toConsumableArray(filledSearchOptions.value).sort(function(a2, b2) {
        return props2.filterSort(a2, b2);
      });
    });
    var displayOptions = Vue.computed(function() {
      return flattenOptions(orderedFilteredOptions.value, {
        fieldNames: mergedFieldNames.value,
        childrenAsData: childrenAsData.value
      });
    });
    var triggerChange = function triggerChange2(values) {
      var labeledValues = convert2LabelValues(values);
      setInternalValue(labeledValues);
      if (props2.onChange && (labeledValues.length !== mergedValues.value.length || labeledValues.some(function(newVal, index2) {
        var _a;
        return ((_a = mergedValues.value[index2]) === null || _a === void 0 ? void 0 : _a.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
      }))) {
        var returnValues = props2.labelInValue ? labeledValues.map(function(v2) {
          return _extends(_extends({}, v2), {
            originLabel: v2.label,
            label: typeof v2.label === "function" ? v2.label() : v2.label
          });
        }) : labeledValues.map(function(v2) {
          return v2.value;
        });
        var returnOptions = labeledValues.map(function(v2) {
          return injectPropsWithOption(getMixedOption(v2.value));
        });
        props2.onChange(multiple.value ? returnValues : returnValues[0], multiple.value ? returnOptions : returnOptions[0]);
      }
    };
    var _useState = useState(null), _useState2 = _slicedToArray(_useState, 2), activeValue = _useState2[0], setActiveValue = _useState2[1];
    var _useState3 = useState(0), _useState4 = _slicedToArray(_useState3, 2), accessibilityIndex = _useState4[0], setAccessibilityIndex = _useState4[1];
    var mergedDefaultActiveFirstOption = Vue.computed(function() {
      return props2.defaultActiveFirstOption !== void 0 ? props2.defaultActiveFirstOption : props2.mode !== "combobox";
    });
    var onActiveValue = function onActiveValue2(active, index2) {
      var _ref3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref3$source = _ref3.source, source = _ref3$source === void 0 ? "keyboard" : _ref3$source;
      setAccessibilityIndex(index2);
      if (props2.backfill && props2.mode === "combobox" && active !== null && source === "keyboard") {
        setActiveValue(String(active));
      }
    };
    var triggerSelect = function triggerSelect2(val, selected) {
      var getSelectEnt = function getSelectEnt2() {
        var _a;
        var option2 = getMixedOption(val);
        var originLabel = option2 === null || option2 === void 0 ? void 0 : option2[mergedFieldNames.value.label];
        return [props2.labelInValue ? {
          label: typeof originLabel === "function" ? originLabel() : originLabel,
          originLabel,
          value: val,
          key: (_a = option2 === null || option2 === void 0 ? void 0 : option2.key) !== null && _a !== void 0 ? _a : val
        } : val, injectPropsWithOption(option2)];
      };
      if (selected && props2.onSelect) {
        var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], option = _getSelectEnt2[1];
        props2.onSelect(wrappedValue, option);
      } else if (!selected && props2.onDeselect) {
        var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option = _getSelectEnt4[1];
        props2.onDeselect(_wrappedValue, _option);
      }
    };
    var onInternalSelect = function onInternalSelect2(val, info) {
      var cloneValues;
      var mergedSelect = multiple.value ? info.selected : true;
      if (mergedSelect) {
        cloneValues = multiple.value ? [].concat(_toConsumableArray(mergedValues.value), [val]) : [val];
      } else {
        cloneValues = mergedValues.value.filter(function(v2) {
          return v2.value !== val;
        });
      }
      triggerChange(cloneValues);
      triggerSelect(val, mergedSelect);
      if (props2.mode === "combobox") {
        setActiveValue("");
      } else if (!multiple.value || props2.autoClearSearchValue) {
        setSearchValue("");
        setActiveValue("");
      }
    };
    var onDisplayValuesChange = function onDisplayValuesChange2(nextValues, info) {
      triggerChange(nextValues);
      if (info.type === "remove" || info.type === "clear") {
        info.values.forEach(function(item) {
          triggerSelect(item.value, false);
        });
      }
    };
    var onInternalSearch = function onInternalSearch2(searchText, info) {
      var _a;
      setSearchValue(searchText);
      setActiveValue(null);
      if (info.source === "submit") {
        var formatted = (searchText || "").trim();
        if (formatted) {
          var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues.value), [formatted])));
          triggerChange(newRawValues);
          triggerSelect(formatted, true);
          setSearchValue("");
        }
        return;
      }
      if (info.source !== "blur") {
        if (props2.mode === "combobox") {
          triggerChange(searchText);
        }
        (_a = props2.onSearch) === null || _a === void 0 ? void 0 : _a.call(props2, searchText);
      }
    };
    var onInternalSearchSplit = function onInternalSearchSplit2(words) {
      var patchValues = words;
      if (props2.mode !== "tags") {
        patchValues = words.map(function(word) {
          var opt = labelOptions.value.get(word);
          return opt === null || opt === void 0 ? void 0 : opt.value;
        }).filter(function(val) {
          return val !== void 0;
        });
      }
      var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues.value), _toConsumableArray(patchValues))));
      triggerChange(newRawValues);
      newRawValues.forEach(function(newRawValue) {
        triggerSelect(newRawValue, true);
      });
    };
    var realVirtual = Vue.computed(function() {
      return props2.virtual !== false && props2.dropdownMatchSelectWidth !== false;
    });
    useProvideSelectProps(toReactive(_extends(_extends({}, parsedOptions), {
      flattenOptions: displayOptions,
      onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      onSelect: onInternalSelect,
      menuItemSelectedIcon: Vue.toRef(props2, "menuItemSelectedIcon"),
      rawValues,
      fieldNames: mergedFieldNames,
      virtual: realVirtual,
      listHeight: Vue.toRef(props2, "listHeight"),
      listItemHeight: Vue.toRef(props2, "listItemHeight"),
      childrenAsData
    })));
    var selectRef = Vue.ref();
    expose({
      focus: function focus() {
        var _a;
        (_a = selectRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      },
      blur: function blur() {
        var _a;
        (_a = selectRef.value) === null || _a === void 0 ? void 0 : _a.blur();
      },
      scrollTo: function scrollTo2(arg) {
        var _a;
        (_a = selectRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg);
      }
    });
    var pickProps = Vue.computed(function() {
      return omit(props2, [
        "id",
        "mode",
        "prefixCls",
        "backfill",
        "fieldNames",
        "inputValue",
        "searchValue",
        "onSearch",
        "autoClearSearchValue",
        "onSelect",
        "onDeselect",
        "dropdownMatchSelectWidth",
        "filterOption",
        "filterSort",
        "optionFilterProp",
        "optionLabelProp",
        "options",
        "children",
        "defaultActiveFirstOption",
        "menuItemSelectedIcon",
        "virtual",
        "listHeight",
        "listItemHeight",
        "value",
        "defaultValue",
        "labelInValue",
        "onChange"
      ]);
    });
    return function() {
      return Vue.createVNode(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickProps.value), attrs), {}, {
        "id": mergedId,
        "prefixCls": props2.prefixCls,
        "ref": selectRef,
        "omitDomProps": OMIT_DOM_PROPS,
        "mode": props2.mode,
        "displayValues": displayValues.value,
        "onDisplayValuesChange": onDisplayValuesChange,
        "searchValue": mergedSearchValue.value,
        "onSearch": onInternalSearch,
        "onSearchSplit": onInternalSearchSplit,
        "dropdownMatchSelectWidth": props2.dropdownMatchSelectWidth,
        "OptionList": OptionList$1,
        "emptyOptions": !displayOptions.value.length,
        "activeValue": activeValue.value,
        "activeDescendantId": "".concat(mergedId, "_list_").concat(accessibilityIndex.value)
      }), slots);
    };
  }
});
var Option = function Option2() {
  return null;
};
Option.isSelectOption = true;
Option.displayName = "ASelectOption";
var Option$1 = Option;
var OptGroup = function OptGroup2() {
  return null;
};
OptGroup.isSelectOptGroup = true;
OptGroup.displayName = "ASelectOptGroup";
var OptGroup$1 = OptGroup;
function getIcons(props2) {
  var slots = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var loading = props2.loading, multiple = props2.multiple, prefixCls = props2.prefixCls;
  var suffixIcon = props2.suffixIcon || slots.suffixIcon && slots.suffixIcon();
  var clearIcon = props2.clearIcon || slots.clearIcon && slots.clearIcon();
  var menuItemSelectedIcon = props2.menuItemSelectedIcon || slots.menuItemSelectedIcon && slots.menuItemSelectedIcon();
  var removeIcon = props2.removeIcon || slots.removeIcon && slots.removeIcon();
  var mergedClearIcon = clearIcon;
  if (!clearIcon) {
    mergedClearIcon = Vue.createVNode(CloseCircleFilled$1, null, null);
  }
  var mergedSuffixIcon = null;
  if (suffixIcon !== void 0) {
    mergedSuffixIcon = suffixIcon;
  } else if (loading) {
    mergedSuffixIcon = Vue.createVNode(LoadingOutlined$1, {
      "spin": true
    }, null);
  } else {
    var iconCls = "".concat(prefixCls, "-suffix");
    mergedSuffixIcon = function mergedSuffixIcon2(_ref) {
      var open2 = _ref.open, showSearch = _ref.showSearch;
      if (open2 && showSearch) {
        return Vue.createVNode(SearchOutlined$1, {
          "class": iconCls
        }, null);
      }
      return Vue.createVNode(DownOutlined$1, {
        "class": iconCls
      }, null);
    };
  }
  var mergedItemIcon = null;
  if (menuItemSelectedIcon !== void 0) {
    mergedItemIcon = menuItemSelectedIcon;
  } else if (multiple) {
    mergedItemIcon = Vue.createVNode(CheckOutlined$1, null, null);
  } else {
    mergedItemIcon = null;
  }
  var mergedRemoveIcon = null;
  if (removeIcon !== void 0) {
    mergedRemoveIcon = removeIcon;
  } else {
    mergedRemoveIcon = Vue.createVNode(CloseOutlined$1, null, null);
  }
  return {
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}
var selectProps = function selectProps2() {
  return _extends(_extends({}, omit(selectProps$1(), ["inputIcon", "mode", "getInputElement", "getRawInputElement", "backfill"])), {
    value: {
      type: [Array, Object, String, Number]
    },
    defaultValue: {
      type: [Array, Object, String, Number]
    },
    notFoundContent: PropTypes$1.any,
    suffixIcon: PropTypes$1.any,
    itemIcon: PropTypes$1.any,
    size: String,
    mode: String,
    bordered: {
      type: Boolean,
      default: true
    },
    transitionName: String,
    choiceTransitionName: {
      type: String,
      default: ""
    },
    "onUpdate:value": Function
  });
};
var SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
var Select$1 = Vue.defineComponent({
  name: "ASelect",
  Option: Option$1,
  OptGroup: OptGroup$1,
  inheritAttrs: false,
  props: initDefaultProps$1(selectProps(), {
    listHeight: 256,
    listItemHeight: 24
  }),
  SECRET_COMBOBOX_MODE_DO_NOT_USE,
  slots: [
    "notFoundContent",
    "suffixIcon",
    "itemIcon",
    "removeIcon",
    "clearIcon",
    "dropdownRender",
    "option",
    "placeholder",
    "tagRender",
    "maxTagPlaceholder",
    "optionLabel"
  ],
  setup: function setup87(props2, _ref) {
    var attrs = _ref.attrs, emit = _ref.emit, slots = _ref.slots, expose = _ref.expose;
    var selectRef = Vue.ref();
    var formItemContext = useInjectFormItemContext();
    var focus = function focus2() {
      var _a;
      (_a = selectRef.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    var blur = function blur2() {
      var _a;
      (_a = selectRef.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    var scrollTo2 = function scrollTo3(arg) {
      var _a;
      (_a = selectRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg);
    };
    var mode = Vue.computed(function() {
      var mode2 = props2.mode;
      if (mode2 === "combobox") {
        return void 0;
      }
      if (mode2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
        return "combobox";
      }
      return mode2;
    });
    var _useConfigInject = useConfigInject("select", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, configProvider = _useConfigInject.configProvider, getPrefixCls2 = _useConfigInject.getPrefixCls;
    var rootPrefixCls = Vue.computed(function() {
      return getPrefixCls2();
    });
    var transitionName2 = Vue.computed(function() {
      return getTransitionName$1(rootPrefixCls.value, "slide-up", props2.transitionName);
    });
    var mergedClassName = Vue.computed(function() {
      var _classNames;
      return classNames((_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls.value, "-lg"), props2.size === "large"), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-sm"), props2.size === "small"), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-borderless"), !props2.bordered), _classNames));
    });
    var triggerChange = function triggerChange2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      emit("update:value", args[0]);
      emit.apply(void 0, ["change"].concat(args));
      formItemContext.onFieldChange();
    };
    var handleBlur = function handleBlur2(e2) {
      emit("blur", e2);
      formItemContext.onFieldBlur();
    };
    expose({
      blur,
      focus,
      scrollTo: scrollTo2
    });
    var isMultiple2 = Vue.computed(function() {
      return mode.value === "multiple" || mode.value === "tags";
    });
    return function() {
      var _a, _b;
      var notFoundContent = props2.notFoundContent, _props$listHeight = props2.listHeight, listHeight = _props$listHeight === void 0 ? 256 : _props$listHeight, _props$listItemHeight = props2.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 24 : _props$listItemHeight, getPopupContainer = props2.getPopupContainer, dropdownClassName = props2.dropdownClassName, virtual = props2.virtual, dropdownMatchSelectWidth = props2.dropdownMatchSelectWidth, _props$id = props2.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id, _props$placeholder = props2.placeholder, placeholder = _props$placeholder === void 0 ? (_a = slots.placeholder) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$placeholder;
      var renderEmpty2 = configProvider.renderEmpty, getContextPopupContainer = configProvider.getPopupContainer;
      var mergedNotFound;
      if (notFoundContent !== void 0) {
        mergedNotFound = notFoundContent;
      } else if (slots.notFoundContent) {
        mergedNotFound = slots.notFoundContent();
      } else if (mode.value === "combobox") {
        mergedNotFound = null;
      } else {
        mergedNotFound = renderEmpty2("Select");
      }
      var _getIcons = getIcons(_extends(_extends({}, props2), {
        multiple: isMultiple2.value,
        prefixCls: prefixCls.value
      }), slots), suffixIcon = _getIcons.suffixIcon, itemIcon = _getIcons.itemIcon, removeIcon = _getIcons.removeIcon, clearIcon = _getIcons.clearIcon;
      var selectProps3 = omit(props2, ["prefixCls", "suffixIcon", "itemIcon", "removeIcon", "clearIcon", "size", "bordered"]);
      var rcSelectRtlDropDownClassName = classNames(dropdownClassName, _defineProperty$T({}, "".concat(prefixCls.value, "-dropdown-").concat(direction.value), direction.value === "rtl"));
      return Vue.createVNode(Select$2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "ref": selectRef,
        "virtual": virtual,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth
      }, selectProps3), attrs), {}, {
        "placeholder": placeholder,
        "listHeight": listHeight,
        "listItemHeight": listItemHeight,
        "mode": mode.value,
        "prefixCls": prefixCls.value,
        "direction": direction.value,
        "inputIcon": suffixIcon,
        "menuItemSelectedIcon": itemIcon,
        "removeIcon": removeIcon,
        "clearIcon": clearIcon,
        "notFoundContent": mergedNotFound,
        "class": [mergedClassName.value, attrs.class],
        "getPopupContainer": getPopupContainer || getContextPopupContainer,
        "dropdownClassName": rcSelectRtlDropDownClassName,
        "onChange": triggerChange,
        "onBlur": handleBlur,
        "id": id,
        "dropdownRender": selectProps3.dropdownRender || slots.dropdownRender,
        "transitionName": transitionName2.value,
        "children": (_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots),
        "tagRender": props2.tagRender || slots.tagRender,
        "optionLabelRender": slots.optionLabel,
        "maxTagPlaceholder": props2.maxTagPlaceholder || slots.maxTagPlaceholder
      }), {
        option: slots.option
      });
    };
  }
});
Select$1.install = function(app) {
  app.component(Select$1.name, Select$1);
  app.component(Select$1.Option.displayName, Select$1.Option);
  app.component(Select$1.OptGroup.displayName, Select$1.OptGroup);
  return app;
};
var SelectOption = Select$1.Option;
Select$1.OptGroup;
var _Select = Select$1;
var MiniSelect = Vue.defineComponent({
  inheritAttrs: false,
  props: selectProps(),
  Option: _Select.Option,
  setup: function setup88(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    return function() {
      var selelctProps = _extends(_extends(_extends({}, props2), {
        size: "small"
      }), attrs);
      return Vue.createVNode(_Select, selelctProps, slots);
    };
  }
});
var Pager = Vue.defineComponent({
  name: "Pager",
  inheritAttrs: false,
  props: {
    rootPrefixCls: String,
    page: Number,
    active: {
      type: Boolean,
      default: void 0
    },
    last: {
      type: Boolean,
      default: void 0
    },
    locale: PropTypes$1.object,
    showTitle: {
      type: Boolean,
      default: void 0
    },
    itemRender: {
      type: Function,
      default: function _default3() {
      }
    },
    onClick: {
      type: Function
    },
    onKeypress: {
      type: Function
    }
  },
  eimt: ["click", "keypress"],
  setup: function setup89(props2, _ref) {
    var emit = _ref.emit, attrs = _ref.attrs;
    var handleClick = function handleClick2() {
      emit("click", props2.page);
    };
    var handleKeyPress = function handleKeyPress2(event) {
      emit("keypress", event, handleClick, props2.page);
    };
    return function() {
      var _classNames;
      var showTitle = props2.showTitle, page = props2.page, itemRender = props2.itemRender;
      var _cls = attrs.class, style = attrs.style;
      var prefixCls = "".concat(props2.rootPrefixCls, "-item");
      var cls = classNames(prefixCls, "".concat(prefixCls, "-").concat(props2.page), (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls, "-active"), props2.active), _defineProperty$T(_classNames, "".concat(prefixCls, "-disabled"), !props2.page), _classNames), _cls);
      return Vue.createVNode("li", {
        "onClick": handleClick,
        "onKeypress": handleKeyPress,
        "title": showTitle ? String(page) : null,
        "tabindex": "0",
        "class": cls,
        "style": style
      }, [itemRender({
        page,
        type: "page",
        originalElement: Vue.createVNode("a", {
          "rel": "nofollow"
        }, [page])
      })]);
    };
  }
});
var KEYCODE = {
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
};
var Options = Vue.defineComponent({
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    changeSize: Function,
    quickGo: Function,
    selectComponentClass: PropTypes$1.any,
    current: Number,
    pageSizeOptions: PropTypes$1.array.def(["10", "20", "50", "100"]),
    pageSize: Number,
    buildOptionText: Function,
    locale: PropTypes$1.object,
    rootPrefixCls: String,
    selectPrefixCls: String,
    goButton: PropTypes$1.any
  },
  setup: function setup90(props2) {
    var goInputText = Vue.ref("");
    var validValue = Vue.computed(function() {
      return !goInputText.value || isNaN(goInputText.value) ? void 0 : Number(goInputText.value);
    });
    var defaultBuildOptionText = function defaultBuildOptionText2(opt) {
      return "".concat(opt.value, " ").concat(props2.locale.items_per_page);
    };
    var handleChange2 = function handleChange3(e2) {
      var _e$target = e2.target, value = _e$target.value, composing = _e$target.composing;
      if (e2.isComposing || composing || goInputText.value === value)
        return;
      goInputText.value = value;
    };
    var handleBlur = function handleBlur2(e2) {
      var goButton = props2.goButton, quickGo = props2.quickGo, rootPrefixCls = props2.rootPrefixCls;
      if (goButton || goInputText.value === "") {
        return;
      }
      if (e2.relatedTarget && (e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) {
        goInputText.value = "";
        return;
      } else {
        quickGo(validValue.value);
        goInputText.value = "";
      }
    };
    var go = function go2(e2) {
      if (goInputText.value === "") {
        return;
      }
      if (e2.keyCode === KEYCODE.ENTER || e2.type === "click") {
        props2.quickGo(validValue.value);
        goInputText.value = "";
      }
    };
    var pageSizeOptions = Vue.computed(function() {
      var pageSize2 = props2.pageSize, pageSizeOptions2 = props2.pageSizeOptions;
      if (pageSizeOptions2.some(function(option) {
        return option.toString() === pageSize2.toString();
      })) {
        return pageSizeOptions2;
      }
      return pageSizeOptions2.concat([pageSize2.toString()]).sort(function(a2, b2) {
        var numberA = isNaN(Number(a2)) ? 0 : Number(a2);
        var numberB = isNaN(Number(b2)) ? 0 : Number(b2);
        return numberA - numberB;
      });
    });
    return function() {
      var rootPrefixCls = props2.rootPrefixCls, locale2 = props2.locale, changeSize = props2.changeSize, quickGo = props2.quickGo, goButton = props2.goButton, Select2 = props2.selectComponentClass, selectPrefixCls = props2.selectPrefixCls, pageSize2 = props2.pageSize, disabled = props2.disabled;
      var prefixCls = "".concat(rootPrefixCls, "-options");
      var changeSelect = null;
      var goInput = null;
      var gotoButton = null;
      if (!changeSize && !quickGo) {
        return null;
      }
      if (changeSize && Select2) {
        var buildOptionText = props2.buildOptionText || defaultBuildOptionText;
        var options = pageSizeOptions.value.map(function(opt, i2) {
          return Vue.createVNode(Select2.Option, {
            "key": i2,
            "value": opt
          }, {
            default: function _default5() {
              return [buildOptionText({
                value: opt
              })];
            }
          });
        });
        changeSelect = Vue.createVNode(Select2, {
          "disabled": disabled,
          "prefixCls": selectPrefixCls,
          "showSearch": false,
          "class": "".concat(prefixCls, "-size-changer"),
          "optionLabelProp": "children",
          "value": (pageSize2 || pageSizeOptions.value[0]).toString(),
          "onChange": function onChange(value) {
            return changeSize(Number(value));
          },
          "getPopupContainer": function getPopupContainer(triggerNode) {
            return triggerNode.parentNode;
          }
        }, {
          default: function _default5() {
            return [options];
          }
        });
      }
      if (quickGo) {
        if (goButton) {
          gotoButton = typeof goButton === "boolean" ? Vue.createVNode("button", {
            "type": "button",
            "onClick": go,
            "onKeyup": go,
            "disabled": disabled,
            "class": "".concat(prefixCls, "-quick-jumper-button")
          }, [locale2.jump_to_confirm]) : Vue.createVNode("span", {
            "onClick": go,
            "onKeyup": go
          }, [goButton]);
        }
        goInput = Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-quick-jumper")
        }, [locale2.jump_to, Vue.withDirectives(Vue.createVNode("input", {
          "disabled": disabled,
          "type": "text",
          "value": goInputText.value,
          "onInput": handleChange2,
          "onChange": handleChange2,
          "onKeyup": go,
          "onBlur": handleBlur
        }, null), [[antInput$1]]), locale2.page, gotoButton]);
      }
      return Vue.createVNode("li", {
        "class": "".concat(prefixCls)
      }, [changeSelect, goInput]);
    };
  }
});
var Pagination$1 = {
  items_per_page: "\u6761/\u9875",
  jump_to: "\u8DF3\u81F3",
  jump_to_confirm: "\u786E\u5B9A",
  page: "\u9875",
  prev_page: "\u4E0A\u4E00\u9875",
  next_page: "\u4E0B\u4E00\u9875",
  prev_5: "\u5411\u524D 5 \u9875",
  next_5: "\u5411\u540E 5 \u9875",
  prev_3: "\u5411\u524D 3 \u9875",
  next_3: "\u5411\u540E 3 \u9875"
};
var __rest$n = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function isInteger(value) {
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
}
function defaultItemRender$1(_ref) {
  var originalElement = _ref.originalElement;
  return originalElement;
}
function calculatePage(p2, state, props2) {
  var pageSize2 = typeof p2 === "undefined" ? state.statePageSize : p2;
  return Math.floor((props2.total - 1) / pageSize2) + 1;
}
var VcPagination = Vue.defineComponent({
  name: "Pagination",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: PropTypes$1.string.def("rc-pagination"),
    selectPrefixCls: PropTypes$1.string.def("rc-select"),
    current: Number,
    defaultCurrent: PropTypes$1.number.def(1),
    total: PropTypes$1.number.def(0),
    pageSize: Number,
    defaultPageSize: PropTypes$1.number.def(10),
    hideOnSinglePage: {
      type: Boolean,
      default: false
    },
    showSizeChanger: {
      type: Boolean,
      default: void 0
    },
    showLessItems: {
      type: Boolean,
      default: false
    },
    selectComponentClass: PropTypes$1.any,
    showPrevNextJumpers: {
      type: Boolean,
      default: true
    },
    showQuickJumper: PropTypes$1.oneOfType([PropTypes$1.looseBool, PropTypes$1.object]).def(false),
    showTitle: {
      type: Boolean,
      default: true
    },
    pageSizeOptions: PropTypes$1.arrayOf(PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string])),
    buildOptionText: Function,
    showTotal: Function,
    simple: {
      type: Boolean,
      default: void 0
    },
    locale: PropTypes$1.object.def(Pagination$1),
    itemRender: PropTypes$1.func.def(defaultItemRender$1),
    prevIcon: PropTypes$1.any,
    nextIcon: PropTypes$1.any,
    jumpPrevIcon: PropTypes$1.any,
    jumpNextIcon: PropTypes$1.any,
    totalBoundaryShowSizeChanger: PropTypes$1.number.def(50)
  },
  data: function data3() {
    var props2 = this.$props;
    var current2 = firstNotUndefined([this.current, this.defaultCurrent]);
    var pageSize2 = firstNotUndefined([this.pageSize, this.defaultPageSize]);
    current2 = Math.min(current2, calculatePage(pageSize2, void 0, props2));
    return {
      stateCurrent: current2,
      stateCurrentInputValue: current2,
      statePageSize: pageSize2
    };
  },
  watch: {
    current: function current(val) {
      this.setState({
        stateCurrent: val,
        stateCurrentInputValue: val
      });
    },
    pageSize: function pageSize(val) {
      var newState = {};
      var current2 = this.stateCurrent;
      var newCurrent = calculatePage(val, this.$data, this.$props);
      current2 = current2 > newCurrent ? newCurrent : current2;
      if (!hasProp(this, "current")) {
        newState.stateCurrent = current2;
        newState.stateCurrentInputValue = current2;
      }
      newState.statePageSize = val;
      this.setState(newState);
    },
    stateCurrent: function stateCurrent(_val, oldValue) {
      var _this = this;
      this.$nextTick(function() {
        if (_this.$refs.paginationNode) {
          var lastCurrentNode = _this.$refs.paginationNode.querySelector(".".concat(_this.prefixCls, "-item-").concat(oldValue));
          if (lastCurrentNode && document.activeElement === lastCurrentNode) {
            lastCurrentNode.blur();
          }
        }
      });
    },
    total: function total() {
      var newState = {};
      var newCurrent = calculatePage(this.pageSize, this.$data, this.$props);
      if (hasProp(this, "current")) {
        var current2 = Math.min(this.current, newCurrent);
        newState.stateCurrent = current2;
        newState.stateCurrentInputValue = current2;
      } else {
        var _current = this.stateCurrent;
        if (_current === 0 && newCurrent > 0) {
          _current = 1;
        } else {
          _current = Math.min(this.stateCurrent, newCurrent);
        }
        newState.stateCurrent = _current;
      }
      this.setState(newState);
    }
  },
  methods: {
    getJumpPrevPage: function getJumpPrevPage() {
      return Math.max(1, this.stateCurrent - (this.showLessItems ? 3 : 5));
    },
    getJumpNextPage: function getJumpNextPage() {
      return Math.min(calculatePage(void 0, this.$data, this.$props), this.stateCurrent + (this.showLessItems ? 3 : 5));
    },
    getItemIcon: function getItemIcon(icon, label) {
      var prefixCls = this.$props.prefixCls;
      var iconNode = getComponent(this, icon, this.$props) || Vue.createVNode("button", {
        "type": "button",
        "aria-label": label,
        "class": "".concat(prefixCls, "-item-link")
      }, null);
      return iconNode;
    },
    getValidValue: function getValidValue(e2) {
      var inputValue = e2.target.value;
      var allPages = calculatePage(void 0, this.$data, this.$props);
      var stateCurrentInputValue = this.$data.stateCurrentInputValue;
      var value;
      if (inputValue === "") {
        value = inputValue;
      } else if (isNaN(Number(inputValue))) {
        value = stateCurrentInputValue;
      } else if (inputValue >= allPages) {
        value = allPages;
      } else {
        value = Number(inputValue);
      }
      return value;
    },
    isValid: function isValid3(page) {
      return isInteger(page) && page !== this.stateCurrent;
    },
    shouldDisplayQuickJumper: function shouldDisplayQuickJumper() {
      var _this$$props = this.$props, showQuickJumper = _this$$props.showQuickJumper, pageSize2 = _this$$props.pageSize, total2 = _this$$props.total;
      if (total2 <= pageSize2) {
        return false;
      }
      return showQuickJumper;
    },
    handleKeyDown: function handleKeyDown(event) {
      if (event.keyCode === KEYCODE.ARROW_UP || event.keyCode === KEYCODE.ARROW_DOWN) {
        event.preventDefault();
      }
    },
    handleKeyUp: function handleKeyUp(e2) {
      if (e2.isComposing || e2.target.composing)
        return;
      var value = this.getValidValue(e2);
      var stateCurrentInputValue = this.stateCurrentInputValue;
      if (value !== stateCurrentInputValue) {
        this.setState({
          stateCurrentInputValue: value
        });
      }
      if (e2.keyCode === KEYCODE.ENTER) {
        this.handleChange(value);
      } else if (e2.keyCode === KEYCODE.ARROW_UP) {
        this.handleChange(value - 1);
      } else if (e2.keyCode === KEYCODE.ARROW_DOWN) {
        this.handleChange(value + 1);
      }
    },
    changePageSize: function changePageSize(size) {
      var current2 = this.stateCurrent;
      var preCurrent = current2;
      var newCurrent = calculatePage(size, this.$data, this.$props);
      current2 = current2 > newCurrent ? newCurrent : current2;
      if (newCurrent === 0) {
        current2 = this.stateCurrent;
      }
      if (typeof size === "number") {
        if (!hasProp(this, "pageSize")) {
          this.setState({
            statePageSize: size
          });
        }
        if (!hasProp(this, "current")) {
          this.setState({
            stateCurrent: current2,
            stateCurrentInputValue: current2
          });
        }
      }
      this.__emit("update:pageSize", size);
      if (current2 !== preCurrent) {
        this.__emit("update:current", current2);
      }
      this.__emit("showSizeChange", current2, size);
      this.__emit("change", current2, size);
    },
    handleChange: function handleChange(p2) {
      var disabled = this.$props.disabled;
      var page = p2;
      if (this.isValid(page) && !disabled) {
        var currentPage = calculatePage(void 0, this.$data, this.$props);
        if (page > currentPage) {
          page = currentPage;
        } else if (page < 1) {
          page = 1;
        }
        if (!hasProp(this, "current")) {
          this.setState({
            stateCurrent: page,
            stateCurrentInputValue: page
          });
        }
        this.__emit("update:current", page);
        this.__emit("change", page, this.statePageSize);
        return page;
      }
      return this.stateCurrent;
    },
    prev: function prev() {
      if (this.hasPrev()) {
        this.handleChange(this.stateCurrent - 1);
      }
    },
    next: function next() {
      if (this.hasNext()) {
        this.handleChange(this.stateCurrent + 1);
      }
    },
    jumpPrev: function jumpPrev() {
      this.handleChange(this.getJumpPrevPage());
    },
    jumpNext: function jumpNext() {
      this.handleChange(this.getJumpNextPage());
    },
    hasPrev: function hasPrev() {
      return this.stateCurrent > 1;
    },
    hasNext: function hasNext() {
      return this.stateCurrent < calculatePage(void 0, this.$data, this.$props);
    },
    getShowSizeChanger: function getShowSizeChanger() {
      var _this$$props2 = this.$props, showSizeChanger = _this$$props2.showSizeChanger, total2 = _this$$props2.total, totalBoundaryShowSizeChanger = _this$$props2.totalBoundaryShowSizeChanger;
      if (typeof showSizeChanger !== "undefined") {
        return showSizeChanger;
      }
      return total2 > totalBoundaryShowSizeChanger;
    },
    runIfEnter: function runIfEnter(event, callback) {
      if (event.key === "Enter" || event.charCode === 13) {
        for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          restParams[_key - 2] = arguments[_key];
        }
        callback.apply(void 0, restParams);
      }
    },
    runIfEnterPrev: function runIfEnterPrev(event) {
      this.runIfEnter(event, this.prev);
    },
    runIfEnterNext: function runIfEnterNext(event) {
      this.runIfEnter(event, this.next);
    },
    runIfEnterJumpPrev: function runIfEnterJumpPrev(event) {
      this.runIfEnter(event, this.jumpPrev);
    },
    runIfEnterJumpNext: function runIfEnterJumpNext(event) {
      this.runIfEnter(event, this.jumpNext);
    },
    handleGoTO: function handleGoTO(event) {
      if (event.keyCode === KEYCODE.ENTER || event.type === "click") {
        this.handleChange(this.stateCurrentInputValue);
      }
    },
    renderPrev: function renderPrev(prevPage) {
      var itemRender = this.$props.itemRender;
      var prevButton = itemRender({
        page: prevPage,
        type: "prev",
        originalElement: this.getItemIcon("prevIcon", "prev page")
      });
      var disabled = !this.hasPrev();
      return isValidElement(prevButton) ? cloneElement(prevButton, disabled ? {
        disabled
      } : {}) : prevButton;
    },
    renderNext: function renderNext(nextPage) {
      var itemRender = this.$props.itemRender;
      var nextButton = itemRender({
        page: nextPage,
        type: "next",
        originalElement: this.getItemIcon("nextIcon", "next page")
      });
      var disabled = !this.hasNext();
      return isValidElement(nextButton) ? cloneElement(nextButton, disabled ? {
        disabled
      } : {}) : nextButton;
    }
  },
  render: function render7() {
    var _classNames6;
    var _this$$props3 = this.$props, prefixCls = _this$$props3.prefixCls, disabled = _this$$props3.disabled, hideOnSinglePage = _this$$props3.hideOnSinglePage, total2 = _this$$props3.total, locale2 = _this$$props3.locale, showQuickJumper = _this$$props3.showQuickJumper, showLessItems = _this$$props3.showLessItems, showTitle = _this$$props3.showTitle, showTotal = _this$$props3.showTotal, simple = _this$$props3.simple, itemRender = _this$$props3.itemRender, showPrevNextJumpers = _this$$props3.showPrevNextJumpers, jumpPrevIcon = _this$$props3.jumpPrevIcon, jumpNextIcon = _this$$props3.jumpNextIcon, selectComponentClass = _this$$props3.selectComponentClass, selectPrefixCls = _this$$props3.selectPrefixCls, pageSizeOptions = _this$$props3.pageSizeOptions;
    var stateCurrent2 = this.stateCurrent, statePageSize = this.statePageSize;
    var _a = splitAttrs(this.$attrs).extraAttrs, className = _a.class, restAttrs = __rest$n(_a, ["class"]);
    if (hideOnSinglePage === true && this.total <= statePageSize) {
      return null;
    }
    var allPages = calculatePage(void 0, this.$data, this.$props);
    var pagerList = [];
    var jumpPrev2 = null;
    var jumpNext2 = null;
    var firstPager = null;
    var lastPager = null;
    var gotoButton = null;
    var goButton = showQuickJumper && showQuickJumper.goButton;
    var pageBufferSize = showLessItems ? 1 : 2;
    var prevPage = stateCurrent2 - 1 > 0 ? stateCurrent2 - 1 : 0;
    var nextPage = stateCurrent2 + 1 < allPages ? stateCurrent2 + 1 : allPages;
    var hasPrev2 = this.hasPrev();
    var hasNext2 = this.hasNext();
    if (simple) {
      if (goButton) {
        if (typeof goButton === "boolean") {
          gotoButton = Vue.createVNode("button", {
            "type": "button",
            "onClick": this.handleGoTO,
            "onKeyup": this.handleGoTO
          }, [locale2.jump_to_confirm]);
        } else {
          gotoButton = Vue.createVNode("span", {
            "onClick": this.handleGoTO,
            "onKeyup": this.handleGoTO
          }, [goButton]);
        }
        gotoButton = Vue.createVNode("li", {
          "title": showTitle ? "".concat(locale2.jump_to).concat(stateCurrent2, "/").concat(allPages) : null,
          "class": "".concat(prefixCls, "-simple-pager")
        }, [gotoButton]);
      }
      return Vue.createVNode("ul", _objectSpread2$1({
        "class": classNames("".concat(prefixCls, " ").concat(prefixCls, "-simple"), _defineProperty$T({}, "".concat(prefixCls, "-disabled"), disabled), className)
      }, restAttrs), [Vue.createVNode("li", {
        "title": showTitle ? locale2.prev_page : null,
        "onClick": this.prev,
        "tabindex": hasPrev2 ? 0 : null,
        "onKeypress": this.runIfEnterPrev,
        "class": classNames("".concat(prefixCls, "-prev"), _defineProperty$T({}, "".concat(prefixCls, "-disabled"), !hasPrev2)),
        "aria-disabled": !hasPrev2
      }, [this.renderPrev(prevPage)]), Vue.createVNode("li", {
        "title": showTitle ? "".concat(stateCurrent2, "/").concat(allPages) : null,
        "class": "".concat(prefixCls, "-simple-pager")
      }, [Vue.withDirectives(Vue.createVNode("input", {
        "type": "text",
        "value": this.stateCurrentInputValue,
        "disabled": disabled,
        "onKeydown": this.handleKeyDown,
        "onKeyup": this.handleKeyUp,
        "onInput": this.handleKeyUp,
        "onChange": this.handleKeyUp,
        "size": "3"
      }, null), [[antInput$1]]), Vue.createVNode("span", {
        "class": "".concat(prefixCls, "-slash")
      }, [Vue.createTextVNode("\uFF0F")]), allPages]), Vue.createVNode("li", {
        "title": showTitle ? locale2.next_page : null,
        "onClick": this.next,
        "tabindex": hasNext2 ? 0 : null,
        "onKeypress": this.runIfEnterNext,
        "class": classNames("".concat(prefixCls, "-next"), _defineProperty$T({}, "".concat(prefixCls, "-disabled"), !hasNext2)),
        "aria-disabled": !hasNext2
      }, [this.renderNext(nextPage)]), gotoButton]);
    }
    if (allPages <= 3 + pageBufferSize * 2) {
      var pagerProps = {
        locale: locale2,
        rootPrefixCls: prefixCls,
        showTitle,
        itemRender,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter
      };
      if (!allPages) {
        pagerList.push(Vue.createVNode(Pager, _objectSpread2$1(_objectSpread2$1({}, pagerProps), {}, {
          "key": "noPager",
          "page": 1,
          "class": "".concat(prefixCls, "-item-disabled")
        }), null));
      }
      for (var i2 = 1; i2 <= allPages; i2 += 1) {
        var active = stateCurrent2 === i2;
        pagerList.push(Vue.createVNode(Pager, _objectSpread2$1(_objectSpread2$1({}, pagerProps), {}, {
          "key": i2,
          "page": i2,
          "active": active
        }), null));
      }
    } else {
      var prevItemTitle = showLessItems ? locale2.prev_3 : locale2.prev_5;
      var nextItemTitle = showLessItems ? locale2.next_3 : locale2.next_5;
      if (showPrevNextJumpers) {
        jumpPrev2 = Vue.createVNode("li", {
          "title": this.showTitle ? prevItemTitle : null,
          "key": "prev",
          "onClick": this.jumpPrev,
          "tabindex": "0",
          "onKeypress": this.runIfEnterJumpPrev,
          "class": classNames("".concat(prefixCls, "-jump-prev"), _defineProperty$T({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon))
        }, [itemRender({
          page: this.getJumpPrevPage(),
          type: "jump-prev",
          originalElement: this.getItemIcon("jumpPrevIcon", "prev page")
        })]);
        jumpNext2 = Vue.createVNode("li", {
          "title": this.showTitle ? nextItemTitle : null,
          "key": "next",
          "tabindex": "0",
          "onClick": this.jumpNext,
          "onKeypress": this.runIfEnterJumpNext,
          "class": classNames("".concat(prefixCls, "-jump-next"), _defineProperty$T({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon))
        }, [itemRender({
          page: this.getJumpNextPage(),
          type: "jump-next",
          originalElement: this.getItemIcon("jumpNextIcon", "next page")
        })]);
      }
      lastPager = Vue.createVNode(Pager, {
        "locale": locale2,
        "last": true,
        "rootPrefixCls": prefixCls,
        "onClick": this.handleChange,
        "onKeypress": this.runIfEnter,
        "key": allPages,
        "page": allPages,
        "active": false,
        "showTitle": showTitle,
        "itemRender": itemRender
      }, null);
      firstPager = Vue.createVNode(Pager, {
        "locale": locale2,
        "rootPrefixCls": prefixCls,
        "onClick": this.handleChange,
        "onKeypress": this.runIfEnter,
        "key": 1,
        "page": 1,
        "active": false,
        "showTitle": showTitle,
        "itemRender": itemRender
      }, null);
      var left = Math.max(1, stateCurrent2 - pageBufferSize);
      var right = Math.min(stateCurrent2 + pageBufferSize, allPages);
      if (stateCurrent2 - 1 <= pageBufferSize) {
        right = 1 + pageBufferSize * 2;
      }
      if (allPages - stateCurrent2 <= pageBufferSize) {
        left = allPages - pageBufferSize * 2;
      }
      for (var _i = left; _i <= right; _i += 1) {
        var _active = stateCurrent2 === _i;
        pagerList.push(Vue.createVNode(Pager, {
          "locale": locale2,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": _i,
          "page": _i,
          "active": _active,
          "showTitle": showTitle,
          "itemRender": itemRender
        }, null));
      }
      if (stateCurrent2 - 1 >= pageBufferSize * 2 && stateCurrent2 !== 1 + 2) {
        pagerList[0] = Vue.createVNode(Pager, {
          "locale": locale2,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": left,
          "page": left,
          "class": "".concat(prefixCls, "-item-after-jump-prev"),
          "active": false,
          "showTitle": this.showTitle,
          "itemRender": itemRender
        }, null);
        pagerList.unshift(jumpPrev2);
      }
      if (allPages - stateCurrent2 >= pageBufferSize * 2 && stateCurrent2 !== allPages - 2) {
        pagerList[pagerList.length - 1] = Vue.createVNode(Pager, {
          "locale": locale2,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": right,
          "page": right,
          "class": "".concat(prefixCls, "-item-before-jump-next"),
          "active": false,
          "showTitle": this.showTitle,
          "itemRender": itemRender
        }, null);
        pagerList.push(jumpNext2);
      }
      if (left !== 1) {
        pagerList.unshift(firstPager);
      }
      if (right !== allPages) {
        pagerList.push(lastPager);
      }
    }
    var totalText = null;
    if (showTotal) {
      totalText = Vue.createVNode("li", {
        "class": "".concat(prefixCls, "-total-text")
      }, [showTotal(total2, [total2 === 0 ? 0 : (stateCurrent2 - 1) * statePageSize + 1, stateCurrent2 * statePageSize > total2 ? total2 : stateCurrent2 * statePageSize])]);
    }
    var prevDisabled = !hasPrev2 || !allPages;
    var nextDisabled = !hasNext2 || !allPages;
    var buildOptionText = this.buildOptionText || this.$slots.buildOptionText;
    return Vue.createVNode("ul", _objectSpread2$1(_objectSpread2$1({
      "unselectable": "on",
      "ref": "paginationNode"
    }, restAttrs), {}, {
      "class": classNames((_classNames6 = {}, _defineProperty$T(_classNames6, "".concat(prefixCls), true), _defineProperty$T(_classNames6, "".concat(prefixCls, "-disabled"), disabled), _classNames6), className)
    }), [totalText, Vue.createVNode("li", {
      "title": showTitle ? locale2.prev_page : null,
      "onClick": this.prev,
      "tabindex": prevDisabled ? null : 0,
      "onKeypress": this.runIfEnterPrev,
      "class": classNames("".concat(prefixCls, "-prev"), _defineProperty$T({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
      "aria-disabled": prevDisabled
    }, [this.renderPrev(prevPage)]), pagerList, Vue.createVNode("li", {
      "title": showTitle ? locale2.next_page : null,
      "onClick": this.next,
      "tabindex": nextDisabled ? null : 0,
      "onKeypress": this.runIfEnterNext,
      "class": classNames("".concat(prefixCls, "-next"), _defineProperty$T({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
      "aria-disabled": nextDisabled
    }, [this.renderNext(nextPage)]), Vue.createVNode(Options, {
      "disabled": disabled,
      "locale": locale2,
      "rootPrefixCls": prefixCls,
      "selectComponentClass": selectComponentClass,
      "selectPrefixCls": selectPrefixCls,
      "changeSize": this.getShowSizeChanger() ? this.changePageSize : null,
      "current": stateCurrent2,
      "pageSize": statePageSize,
      "pageSizeOptions": pageSizeOptions,
      "buildOptionText": buildOptionText || null,
      "quickGo": this.shouldDisplayQuickJumper() ? this.handleChange : null,
      "goButton": goButton
    }, null)]);
  }
});
function useBreakpoint() {
  var screens2 = Vue.ref({});
  var token = null;
  Vue.onMounted(function() {
    token = ResponsiveObserve.subscribe(function(supportScreens) {
      screens2.value = supportScreens;
    });
  });
  Vue.onUnmounted(function() {
    ResponsiveObserve.unsubscribe(token);
  });
  return screens2;
}
var __rest$m = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var paginationProps = function paginationProps2() {
  return {
    total: Number,
    defaultCurrent: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    current: Number,
    defaultPageSize: Number,
    pageSize: Number,
    hideOnSinglePage: {
      type: Boolean,
      default: void 0
    },
    showSizeChanger: {
      type: Boolean,
      default: void 0
    },
    pageSizeOptions: Array,
    buildOptionText: Function,
    showQuickJumper: {
      type: [Boolean, Object],
      default: void 0
    },
    showTotal: Function,
    size: String,
    simple: {
      type: Boolean,
      default: void 0
    },
    locale: Object,
    prefixCls: String,
    selectPrefixCls: String,
    totalBoundaryShowSizeChanger: Number,
    selectComponentClass: String,
    itemRender: Function,
    role: String,
    responsive: Boolean,
    showLessItems: {
      type: Boolean,
      default: void 0
    },
    onChange: Function,
    onShowSizeChange: Function,
    "onUpdate:current": Function,
    "onUpdate:pageSize": Function
  };
};
var Pagination = Vue.defineComponent({
  name: "APagination",
  inheritAttrs: false,
  props: paginationProps(),
  setup: function setup91(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("pagination", props2), prefixCls = _useConfigInject.prefixCls, configProvider = _useConfigInject.configProvider, direction = _useConfigInject.direction;
    var selectPrefixCls = Vue.computed(function() {
      return configProvider.getPrefixCls("select", props2.selectPrefixCls);
    });
    var breakpoint = useBreakpoint();
    var _useLocaleReceiver = useLocaleReceiver("Pagination", enUS$1, Vue.toRef(props2, "locale")), _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 1), locale2 = _useLocaleReceiver2[0];
    var getIconsProps = function getIconsProps2(pre) {
      var ellipsis = Vue.createVNode("span", {
        "class": "".concat(pre, "-item-ellipsis")
      }, [Vue.createTextVNode("\u2022\u2022\u2022")]);
      var prevIcon = Vue.createVNode("button", {
        "class": "".concat(pre, "-item-link"),
        "type": "button",
        "tabindex": -1
      }, [Vue.createVNode(LeftOutlined$1, null, null)]);
      var nextIcon = Vue.createVNode("button", {
        "class": "".concat(pre, "-item-link"),
        "type": "button",
        "tabindex": -1
      }, [Vue.createVNode(RightOutlined$1, null, null)]);
      var jumpPrevIcon = Vue.createVNode("a", {
        "rel": "nofollow",
        "class": "".concat(pre, "-item-link")
      }, [Vue.createVNode("div", {
        "class": "".concat(pre, "-item-container")
      }, [Vue.createVNode(DoubleLeftOutlined$1, {
        "class": "".concat(pre, "-item-link-icon")
      }, null), ellipsis])]);
      var jumpNextIcon = Vue.createVNode("a", {
        "rel": "nofollow",
        "class": "".concat(pre, "-item-link")
      }, [Vue.createVNode("div", {
        "class": "".concat(pre, "-item-container")
      }, [Vue.createVNode(DoubleRightOutlined$1, {
        "class": "".concat(pre, "-item-link-icon")
      }, null), ellipsis])]);
      if (direction.value === "rtl") {
        var _ref2 = [nextIcon, prevIcon];
        prevIcon = _ref2[0];
        nextIcon = _ref2[1];
        var _ref3 = [jumpNextIcon, jumpPrevIcon];
        jumpPrevIcon = _ref3[0];
        jumpNextIcon = _ref3[1];
      }
      return {
        prevIcon,
        nextIcon,
        jumpPrevIcon,
        jumpNextIcon
      };
    };
    return function() {
      var _a;
      var size = props2.size, _props$itemRender = props2.itemRender, itemRender = _props$itemRender === void 0 ? slots.itemRender : _props$itemRender, _props$buildOptionTex = props2.buildOptionText, buildOptionText = _props$buildOptionTex === void 0 ? slots.buildOptionText : _props$buildOptionTex, selectComponentClass = props2.selectComponentClass, responsive = props2.responsive, restProps = __rest$m(props2, ["size", "itemRender", "buildOptionText", "selectComponentClass", "responsive"]);
      var isSmall = size === "small" || !!(((_a = breakpoint.value) === null || _a === void 0 ? void 0 : _a.xs) && !size && responsive);
      var paginationProps3 = _extends(_extends(_extends(_extends(_extends({}, restProps), getIconsProps(prefixCls.value)), {
        prefixCls: prefixCls.value,
        selectPrefixCls: selectPrefixCls.value,
        selectComponentClass: selectComponentClass || (isSmall ? MiniSelect : _Select),
        locale: locale2.value,
        buildOptionText
      }), attrs), {
        class: classNames(_defineProperty$T({
          mini: isSmall
        }, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), attrs.class),
        itemRender
      });
      return Vue.createVNode(VcPagination, paginationProps3, null);
    };
  }
});
var _Pagination = withInstall(Pagination);
var DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(pagination, mergedPagination) {
  var param = {
    current: mergedPagination.current,
    pageSize: mergedPagination.pageSize
  };
  var paginationObj = pagination && _typeof$1(pagination) === "object" ? pagination : {};
  Object.keys(paginationObj).forEach(function(pageProp) {
    var value = mergedPagination[pageProp];
    if (typeof value !== "function") {
      param[pageProp] = value;
    }
  });
  return param;
}
function extendsObject() {
  var result = {};
  for (var _len = arguments.length, list = new Array(_len), _key = 0; _key < _len; _key++) {
    list[_key] = arguments[_key];
  }
  list.forEach(function(obj) {
    if (obj) {
      Object.keys(obj).forEach(function(key2) {
        var val = obj[key2];
        if (val !== void 0) {
          result[key2] = val;
        }
      });
    }
  });
  return result;
}
function usePagination(totalRef, paginationRef, onChange) {
  var pagination = Vue.computed(function() {
    return paginationRef.value && _typeof$1(paginationRef.value) === "object" ? paginationRef.value : {};
  });
  var paginationTotal = Vue.computed(function() {
    return pagination.value.total || 0;
  });
  var _useState = useState(function() {
    return {
      current: "defaultCurrent" in pagination.value ? pagination.value.defaultCurrent : 1,
      pageSize: "defaultPageSize" in pagination.value ? pagination.value.defaultPageSize : DEFAULT_PAGE_SIZE
    };
  }), _useState2 = _slicedToArray(_useState, 2), innerPagination = _useState2[0], setInnerPagination = _useState2[1];
  var mergedPagination = Vue.computed(function() {
    var mP = extendsObject(innerPagination.value, pagination.value, {
      total: paginationTotal.value > 0 ? paginationTotal.value : totalRef.value
    });
    var maxPage = Math.ceil((paginationTotal.value || totalRef.value) / mP.pageSize);
    if (mP.current > maxPage) {
      mP.current = maxPage || 1;
    }
    return mP;
  });
  var refreshPagination = function refreshPagination2(current2, pageSize2) {
    if (pagination.value === false)
      return;
    setInnerPagination({
      current: current2 !== null && current2 !== void 0 ? current2 : 1,
      pageSize: pageSize2 || mergedPagination.value.pageSize
    });
  };
  var onInternalChange = function onInternalChange2(current2, pageSize2) {
    var _a, _b;
    if (pagination.value) {
      (_b = (_a = pagination.value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, current2, pageSize2);
    }
    refreshPagination(current2, pageSize2);
    onChange(current2, pageSize2 || mergedPagination.value.pageSize);
  };
  return [Vue.computed(function() {
    return pagination.value === false ? {} : _extends(_extends({}, mergedPagination.value), {
      onChange: onInternalChange
    });
  }), refreshPagination];
}
function useLazyKVMap(dataRef, childrenColumnNameRef, getRowKeyRef) {
  var mapCacheRef = Vue.shallowRef({});
  Vue.watch([dataRef, childrenColumnNameRef, getRowKeyRef], function() {
    var kvMap = /* @__PURE__ */ new Map();
    var getRowKey = getRowKeyRef.value;
    var childrenColumnName = childrenColumnNameRef.value;
    function dig(records) {
      records.forEach(function(record, index2) {
        var rowKey = getRowKey(record, index2);
        kvMap.set(rowKey, record);
        if (record && _typeof$1(record) === "object" && childrenColumnName in record) {
          dig(record[childrenColumnName] || []);
        }
      });
    }
    dig(dataRef.value);
    mapCacheRef.value = {
      kvMap
    };
  }, {
    deep: true,
    immediate: true
  });
  function getRecordByKey(key2) {
    return mapCacheRef.value.kvMap.get(key2);
  }
  return [getRecordByKey];
}
var TreeContextKey = Symbol("TreeContextKey");
var TreeContext = Vue.defineComponent({
  name: "TreeContext",
  props: {
    value: {
      type: Object
    }
  },
  setup: function setup92(props2, _ref) {
    var slots = _ref.slots;
    Vue.provide(TreeContextKey, Vue.computed(function() {
      return props2.value;
    }));
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
  }
});
var useInjectTreeContext = function useInjectTreeContext2() {
  return Vue.inject(TreeContextKey, Vue.computed(function() {
    return {};
  }));
};
var KeysStateKey = Symbol("KeysStateKey");
var useProvideKeysState = function useProvideKeysState2(state) {
  Vue.provide(KeysStateKey, state);
};
var useInjectKeysState = function useInjectKeysState2() {
  return Vue.inject(KeysStateKey, {
    expandedKeys: Vue.shallowRef([]),
    selectedKeys: Vue.shallowRef([]),
    loadedKeys: Vue.shallowRef([]),
    loadingKeys: Vue.shallowRef([]),
    checkedKeys: Vue.shallowRef([]),
    halfCheckedKeys: Vue.shallowRef([]),
    expandedKeysSet: Vue.computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    selectedKeysSet: Vue.computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    loadedKeysSet: Vue.computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    loadingKeysSet: Vue.computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    checkedKeysSet: Vue.computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    halfCheckedKeysSet: Vue.computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    flattenNodes: Vue.shallowRef([])
  });
};
var Indent = function Indent2(_ref) {
  var prefixCls = _ref.prefixCls, level = _ref.level, isStart = _ref.isStart, isEnd = _ref.isEnd;
  var baseClassName = "".concat(prefixCls, "-indent-unit");
  var list = [];
  for (var i2 = 0; i2 < level; i2 += 1) {
    var _ref2;
    list.push(Vue.createVNode("span", {
      "key": i2,
      "class": (_ref2 = {}, _defineProperty$T(_ref2, baseClassName, true), _defineProperty$T(_ref2, "".concat(baseClassName, "-start"), isStart[i2]), _defineProperty$T(_ref2, "".concat(baseClassName, "-end"), isEnd[i2]), _ref2)
    }, null));
  }
  return Vue.createVNode("span", {
    "aria-hidden": "true",
    "class": "".concat(prefixCls, "-indent")
  }, [list]);
};
var Indent$1 = Indent;
var __rest$l = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function getKey(key2, pos) {
  if (key2 !== null && key2 !== void 0) {
    return key2;
  }
  return pos;
}
function fillFieldNames(fieldNames) {
  var _ref = fieldNames || {}, title = _ref.title, _title = _ref._title, key2 = _ref.key, children = _ref.children;
  var mergedTitle = title || "title";
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key2 || "key",
    children: children || "children"
  };
}
function convertTreeToData(rootNodes) {
  function dig() {
    var node = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var treeNodes = filterEmpty(node);
    return treeNodes.map(function(treeNode) {
      var _a, _b, _c, _d;
      if (!isTreeNode(treeNode)) {
        return null;
      }
      var slots = treeNode.children || {};
      var key2 = treeNode.key;
      var props2 = {};
      for (var _i = 0, _Object$entries = Object.entries(treeNode.props); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), k2 = _Object$entries$_i[0], v2 = _Object$entries$_i[1];
        props2[Vue.camelize(k2)] = v2;
      }
      var isLeaf = props2.isLeaf, checkable = props2.checkable, selectable = props2.selectable, disabled = props2.disabled, disableCheckbox = props2.disableCheckbox;
      var newProps = {
        isLeaf: isLeaf || isLeaf === "" || void 0,
        checkable: checkable || checkable === "" || void 0,
        selectable: selectable || selectable === "" || void 0,
        disabled: disabled || disabled === "" || void 0,
        disableCheckbox: disableCheckbox || disableCheckbox === "" || void 0
      };
      var slotsProps = _extends(_extends({}, props2), newProps);
      var _props$title = props2.title, title = _props$title === void 0 ? (_a = slots.title) === null || _a === void 0 ? void 0 : _a.call(slots, slotsProps) : _props$title, _props$icon = props2.icon, icon = _props$icon === void 0 ? (_b = slots.icon) === null || _b === void 0 ? void 0 : _b.call(slots, slotsProps) : _props$icon, _props$switcherIcon = props2.switcherIcon, switcherIcon = _props$switcherIcon === void 0 ? (_c = slots.switcherIcon) === null || _c === void 0 ? void 0 : _c.call(slots, slotsProps) : _props$switcherIcon, rest = __rest$l(props2, ["title", "icon", "switcherIcon"]);
      var children = (_d = slots.default) === null || _d === void 0 ? void 0 : _d.call(slots);
      var dataNode = _extends(_extends(_extends({}, rest), {
        title,
        icon,
        switcherIcon,
        key: key2,
        isLeaf
      }), newProps);
      var parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    });
  }
  return dig(rootNodes);
}
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  var _fillFieldNames = fillFieldNames(fieldNames), fieldTitles = _fillFieldNames._title, fieldKey = _fillFieldNames.key, fieldChildren = _fillFieldNames.children;
  var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  var flattenList = [];
  function dig(list) {
    var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return list.map(function(treeNode, index2) {
      var pos = getPosition(parent ? parent.pos : "0", index2);
      var mergedKey = getKey(treeNode[fieldKey], pos);
      var mergedTitle;
      for (var i2 = 0; i2 < fieldTitles.length; i2 += 1) {
        var fieldTitle = fieldTitles[i2];
        if (treeNode[fieldTitle] !== void 0) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      var flattenNode = _extends(_extends({}, omit(treeNode, [].concat(_toConsumableArray(fieldTitles), [fieldKey, fieldChildren]))), {
        title: mergedTitle,
        key: mergedKey,
        parent,
        pos,
        children: null,
        data: treeNode,
        isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index2 === 0]),
        isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index2 === list.length - 1])
      });
      flattenList.push(flattenNode);
      if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
        flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
function traverseDataNodes(dataNodes, callback, config) {
  var mergedConfig = {};
  if (_typeof$1(config) === "object") {
    mergedConfig = config;
  } else {
    mergedConfig = {
      externalGetKey: config
    };
  }
  mergedConfig = mergedConfig || {};
  var _mergedConfig = mergedConfig, childrenPropName = _mergedConfig.childrenPropName, externalGetKey = _mergedConfig.externalGetKey, fieldNames = _mergedConfig.fieldNames;
  var _fillFieldNames2 = fillFieldNames(fieldNames), fieldKey = _fillFieldNames2.key, fieldChildren = _fillFieldNames2.children;
  var mergeChildrenPropName = childrenPropName || fieldChildren;
  var syntheticGetKey;
  if (externalGetKey) {
    if (typeof externalGetKey === "string") {
      syntheticGetKey = function syntheticGetKey2(node) {
        return node[externalGetKey];
      };
    } else if (typeof externalGetKey === "function") {
      syntheticGetKey = function syntheticGetKey2(node) {
        return externalGetKey(node);
      };
    }
  } else {
    syntheticGetKey = function syntheticGetKey2(node, pos) {
      return getKey(node[fieldKey], pos);
    };
  }
  function processNode(node, index2, parent, pathNodes) {
    var children = node ? node[mergeChildrenPropName] : dataNodes;
    var pos = node ? getPosition(parent.pos, index2) : "0";
    var connectNodes = node ? [].concat(_toConsumableArray(pathNodes), [node]) : [];
    if (node) {
      var key2 = syntheticGetKey(node, pos);
      var data4 = {
        node,
        index: index2,
        pos,
        key: key2,
        parentPos: parent.node ? parent.pos : null,
        level: parent.level + 1,
        nodes: connectNodes
      };
      callback(data4);
    }
    if (children) {
      children.forEach(function(subNode, subIndex) {
        processNode(subNode, subIndex, {
          node,
          pos,
          level: parent ? parent.level + 1 : -1
        }, connectNodes);
      });
    }
  }
  processNode(null);
}
function convertDataToEntities(dataNodes) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, initWrapper = _ref2.initWrapper, processEntity = _ref2.processEntity, onProcessFinished = _ref2.onProcessFinished, externalGetKey = _ref2.externalGetKey, childrenPropName = _ref2.childrenPropName, fieldNames = _ref2.fieldNames;
  var legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0;
  var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
  var posEntities = {};
  var keyEntities = {};
  var wrapper = {
    posEntities,
    keyEntities
  };
  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }
  traverseDataNodes(dataNodes, function(item) {
    var node = item.node, index2 = item.index, pos = item.pos, key2 = item.key, parentPos = item.parentPos, level = item.level, nodes = item.nodes;
    var entity = {
      node,
      nodes,
      index: index2,
      key: key2,
      pos,
      level
    };
    var mergedKey = getKey(key2, pos);
    posEntities[pos] = entity;
    keyEntities[mergedKey] = entity;
    entity.parent = posEntities[parentPos];
    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
    if (processEntity) {
      processEntity(entity, wrapper);
    }
  }, {
    externalGetKey: mergedExternalGetKey,
    childrenPropName,
    fieldNames
  });
  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }
  return wrapper;
}
function getTreeNodeProps(key2, _ref3) {
  var expandedKeysSet = _ref3.expandedKeysSet, selectedKeysSet = _ref3.selectedKeysSet, loadedKeysSet = _ref3.loadedKeysSet, loadingKeysSet = _ref3.loadingKeysSet, checkedKeysSet = _ref3.checkedKeysSet, halfCheckedKeysSet = _ref3.halfCheckedKeysSet, dragOverNodeKey = _ref3.dragOverNodeKey, dropPosition = _ref3.dropPosition, keyEntities = _ref3.keyEntities;
  var entity = keyEntities[key2];
  var treeNodeProps2 = {
    eventKey: key2,
    expanded: expandedKeysSet.has(key2),
    selected: selectedKeysSet.has(key2),
    loaded: loadedKeysSet.has(key2),
    loading: loadingKeysSet.has(key2),
    checked: checkedKeysSet.has(key2),
    halfChecked: halfCheckedKeysSet.has(key2),
    pos: String(entity ? entity.pos : ""),
    parent: entity.parent,
    dragOver: dragOverNodeKey === key2 && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key2 && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key2 && dropPosition === 1
  };
  return treeNodeProps2;
}
function convertNodePropsToEventData(props2) {
  var data4 = props2.data, expanded = props2.expanded, selected = props2.selected, checked = props2.checked, loaded = props2.loaded, loading = props2.loading, halfChecked = props2.halfChecked, dragOver = props2.dragOver, dragOverGapTop = props2.dragOverGapTop, dragOverGapBottom = props2.dragOverGapBottom, pos = props2.pos, active = props2.active, eventKey = props2.eventKey;
  var eventData = _extends(_extends({
    dataRef: data4
  }, data4), {
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    eventKey,
    key: eventKey
  });
  if (!("props" in eventData)) {
    Object.defineProperty(eventData, "props", {
      get: function get2() {
        return props2;
      }
    });
  }
  return eventData;
}
var treeNodeProps = {
  eventKey: [String, Number],
  prefixCls: String,
  title: PropTypes$1.any,
  data: {
    type: Object,
    default: void 0
  },
  parent: {
    type: Object,
    default: void 0
  },
  isStart: {
    type: Array
  },
  isEnd: {
    type: Array
  },
  active: {
    type: Boolean,
    default: void 0
  },
  onMousemove: {
    type: Function
  },
  isLeaf: {
    type: Boolean,
    default: void 0
  },
  checkable: {
    type: Boolean,
    default: void 0
  },
  selectable: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  disableCheckbox: {
    type: Boolean,
    default: void 0
  },
  icon: PropTypes$1.any,
  switcherIcon: PropTypes$1.any,
  domRef: {
    type: Function
  }
};
var nodeListProps = {
  prefixCls: {
    type: String
  },
  motion: {
    type: Object
  },
  focusable: {
    type: Boolean
  },
  activeItem: {
    type: Object
  },
  focused: {
    type: Boolean
  },
  tabindex: {
    type: Number
  },
  checkable: {
    type: Boolean
  },
  selectable: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  height: {
    type: Number
  },
  itemHeight: {
    type: Number
  },
  virtual: {
    type: Boolean
  },
  onScroll: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onActiveChange: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  onListChangeStart: {
    type: Function
  },
  onListChangeEnd: {
    type: Function
  }
};
var treeProps$1 = function treeProps2() {
  return {
    prefixCls: String,
    focusable: {
      type: Boolean,
      default: void 0
    },
    activeKey: [Number, String],
    tabindex: Number,
    children: PropTypes$1.any,
    treeData: {
      type: Array
    },
    fieldNames: {
      type: Object
    },
    showLine: {
      type: [Boolean, Object],
      default: void 0
    },
    showIcon: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes$1.any,
    selectable: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    multiple: {
      type: Boolean,
      default: void 0
    },
    checkable: {
      type: Boolean,
      default: void 0
    },
    checkStrictly: {
      type: Boolean,
      default: void 0
    },
    draggable: {
      type: [Function, Boolean]
    },
    defaultExpandParent: {
      type: Boolean,
      default: void 0
    },
    autoExpandParent: {
      type: Boolean,
      default: void 0
    },
    defaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    defaultExpandedKeys: {
      type: Array
    },
    expandedKeys: {
      type: Array
    },
    defaultCheckedKeys: {
      type: Array
    },
    checkedKeys: {
      type: [Object, Array]
    },
    defaultSelectedKeys: {
      type: Array
    },
    selectedKeys: {
      type: Array
    },
    allowDrop: {
      type: Function
    },
    dropIndicatorRender: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onContextmenu: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onDblclick: {
      type: Function
    },
    onScroll: {
      type: Function
    },
    onExpand: {
      type: Function
    },
    onCheck: {
      type: Function
    },
    onSelect: {
      type: Function
    },
    onLoad: {
      type: Function
    },
    loadData: {
      type: Function
    },
    loadedKeys: {
      type: Array
    },
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onRightClick: {
      type: Function
    },
    onDragstart: {
      type: Function
    },
    onDragenter: {
      type: Function
    },
    onDragover: {
      type: Function
    },
    onDragleave: {
      type: Function
    },
    onDragend: {
      type: Function
    },
    onDrop: {
      type: Function
    },
    onActiveChange: {
      type: Function
    },
    filterTreeNode: {
      type: Function
    },
    motion: PropTypes$1.any,
    switcherIcon: PropTypes$1.any,
    height: Number,
    itemHeight: Number,
    virtual: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String
    }
  };
};
var __rest$k = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var ICON_OPEN = "open";
var ICON_CLOSE = "close";
var defaultTitle = "---";
var VcTreeNode = Vue.defineComponent({
  name: "TreeNode",
  inheritAttrs: false,
  props: treeNodeProps,
  isTreeNode: 1,
  slots: ["title", "icon", "switcherIcon"],
  setup: function setup93(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose;
    warning$1(!("slots" in props2.data), "treeData slots is deprecated, please use ".concat(Object.keys(props2.data.slots || {}).map(function(key2) {
      return "`v-slot:" + key2 + "` ";
    }), "instead"));
    var dragNodeHighlight = Vue.ref(false);
    var context = useInjectTreeContext();
    var _useInjectKeysState = useInjectKeysState(), expandedKeysSet = _useInjectKeysState.expandedKeysSet, selectedKeysSet = _useInjectKeysState.selectedKeysSet, loadedKeysSet = _useInjectKeysState.loadedKeysSet, loadingKeysSet = _useInjectKeysState.loadingKeysSet, checkedKeysSet = _useInjectKeysState.checkedKeysSet, halfCheckedKeysSet = _useInjectKeysState.halfCheckedKeysSet;
    var _context$value = context.value, dragOverNodeKey = _context$value.dragOverNodeKey, dropPosition = _context$value.dropPosition, keyEntities = _context$value.keyEntities;
    var mergedTreeNodeProps = Vue.computed(function() {
      return getTreeNodeProps(props2.eventKey, {
        expandedKeysSet: expandedKeysSet.value,
        selectedKeysSet: selectedKeysSet.value,
        loadedKeysSet: loadedKeysSet.value,
        loadingKeysSet: loadingKeysSet.value,
        checkedKeysSet: checkedKeysSet.value,
        halfCheckedKeysSet: halfCheckedKeysSet.value,
        dragOverNodeKey,
        dropPosition,
        keyEntities
      });
    });
    var expanded = eagerComputed(function() {
      return mergedTreeNodeProps.value.expanded;
    });
    var selected = eagerComputed(function() {
      return mergedTreeNodeProps.value.selected;
    });
    var checked = eagerComputed(function() {
      return mergedTreeNodeProps.value.checked;
    });
    var loaded = eagerComputed(function() {
      return mergedTreeNodeProps.value.loaded;
    });
    var loading = eagerComputed(function() {
      return mergedTreeNodeProps.value.loading;
    });
    var halfChecked = eagerComputed(function() {
      return mergedTreeNodeProps.value.halfChecked;
    });
    var dragOver = eagerComputed(function() {
      return mergedTreeNodeProps.value.dragOver;
    });
    var dragOverGapTop = eagerComputed(function() {
      return mergedTreeNodeProps.value.dragOverGapTop;
    });
    var dragOverGapBottom = eagerComputed(function() {
      return mergedTreeNodeProps.value.dragOverGapBottom;
    });
    var pos = eagerComputed(function() {
      return mergedTreeNodeProps.value.pos;
    });
    var selectHandle = Vue.ref();
    var hasChildren = Vue.computed(function() {
      var eventKey = props2.eventKey;
      var keyEntities2 = context.value.keyEntities;
      var _ref2 = keyEntities2[eventKey] || {}, children = _ref2.children;
      return !!(children || []).length;
    });
    var isLeaf = Vue.computed(function() {
      var isLeaf2 = props2.isLeaf;
      var loadData = context.value.loadData;
      var has = hasChildren.value;
      if (isLeaf2 === false) {
        return false;
      }
      return isLeaf2 || !loadData && !has || loadData && loaded.value && !has;
    });
    var nodeState = Vue.computed(function() {
      if (isLeaf.value) {
        return null;
      }
      return expanded.value ? ICON_OPEN : ICON_CLOSE;
    });
    var isDisabled = Vue.computed(function() {
      var disabled = props2.disabled;
      var treeDisabled = context.value.disabled;
      return !!(treeDisabled || disabled);
    });
    var isCheckable = Vue.computed(function() {
      var checkable = props2.checkable;
      var treeCheckable = context.value.checkable;
      if (!treeCheckable || checkable === false)
        return false;
      return treeCheckable;
    });
    var isSelectable = Vue.computed(function() {
      var selectable = props2.selectable;
      var treeSelectable = context.value.selectable;
      if (typeof selectable === "boolean") {
        return selectable;
      }
      return treeSelectable;
    });
    var renderArgsData = Vue.computed(function() {
      var data4 = props2.data, active = props2.active, checkable = props2.checkable, disableCheckbox = props2.disableCheckbox, disabled = props2.disabled, selectable = props2.selectable;
      return _extends(_extends({
        active,
        checkable,
        disableCheckbox,
        disabled,
        selectable
      }, data4), {
        dataRef: data4,
        data: data4,
        isLeaf: isLeaf.value,
        checked: checked.value,
        expanded: expanded.value,
        loading: loading.value,
        selected: selected.value,
        halfChecked: halfChecked.value
      });
    });
    var instance = Vue.getCurrentInstance();
    var eventData = Vue.computed(function() {
      var eventKey = props2.eventKey;
      var keyEntities2 = context.value.keyEntities;
      var _ref3 = keyEntities2[eventKey] || {}, parent = _ref3.parent;
      return _extends(_extends({}, convertNodePropsToEventData(_extends({}, props2, mergedTreeNodeProps.value))), {
        parent
      });
    });
    var dragNodeEvent = Vue.reactive({
      eventData,
      eventKey: Vue.computed(function() {
        return props2.eventKey;
      }),
      selectHandle,
      pos,
      key: instance.vnode.key
    });
    expose(dragNodeEvent);
    var onSelectorDoubleClick = function onSelectorDoubleClick2(e2) {
      var onNodeDoubleClick = context.value.onNodeDoubleClick;
      onNodeDoubleClick(e2, eventData.value);
    };
    var onSelect = function onSelect2(e2) {
      if (isDisabled.value)
        return;
      var onNodeSelect = context.value.onNodeSelect;
      e2.preventDefault();
      onNodeSelect(e2, eventData.value);
    };
    var onCheck = function onCheck2(e2) {
      if (isDisabled.value)
        return;
      var disableCheckbox = props2.disableCheckbox;
      var onNodeCheck = context.value.onNodeCheck;
      if (!isCheckable.value || disableCheckbox)
        return;
      e2.preventDefault();
      var targetChecked = !checked.value;
      onNodeCheck(e2, eventData.value, targetChecked);
    };
    var onSelectorClick = function onSelectorClick2(e2) {
      var onNodeClick = context.value.onNodeClick;
      onNodeClick(e2, eventData.value);
      if (isSelectable.value) {
        onSelect(e2);
      } else {
        onCheck(e2);
      }
    };
    var onMouseEnter = function onMouseEnter2(e2) {
      var onNodeMouseEnter = context.value.onNodeMouseEnter;
      onNodeMouseEnter(e2, eventData.value);
    };
    var onMouseLeave = function onMouseLeave2(e2) {
      var onNodeMouseLeave = context.value.onNodeMouseLeave;
      onNodeMouseLeave(e2, eventData.value);
    };
    var onContextmenu2 = function onContextmenu3(e2) {
      var onNodeContextMenu = context.value.onNodeContextMenu;
      onNodeContextMenu(e2, eventData.value);
    };
    var onDragStart = function onDragStart2(e2) {
      var onNodeDragStart = context.value.onNodeDragStart;
      e2.stopPropagation();
      dragNodeHighlight.value = true;
      onNodeDragStart(e2, dragNodeEvent);
      try {
        e2.dataTransfer.setData("text/plain", "");
      } catch (error) {
      }
    };
    var onDragEnter = function onDragEnter2(e2) {
      var onNodeDragEnter = context.value.onNodeDragEnter;
      e2.preventDefault();
      e2.stopPropagation();
      onNodeDragEnter(e2, dragNodeEvent);
    };
    var onDragOver = function onDragOver2(e2) {
      var onNodeDragOver = context.value.onNodeDragOver;
      e2.preventDefault();
      e2.stopPropagation();
      onNodeDragOver(e2, dragNodeEvent);
    };
    var onDragLeave = function onDragLeave2(e2) {
      var onNodeDragLeave = context.value.onNodeDragLeave;
      e2.stopPropagation();
      onNodeDragLeave(e2, dragNodeEvent);
    };
    var onDragEnd = function onDragEnd2(e2) {
      var onNodeDragEnd = context.value.onNodeDragEnd;
      e2.stopPropagation();
      dragNodeHighlight.value = false;
      onNodeDragEnd(e2, dragNodeEvent);
    };
    var onDrop = function onDrop2(e2) {
      var onNodeDrop = context.value.onNodeDrop;
      e2.preventDefault();
      e2.stopPropagation();
      dragNodeHighlight.value = false;
      onNodeDrop(e2, dragNodeEvent);
    };
    var onExpand = function onExpand2(e2) {
      var onNodeExpand = context.value.onNodeExpand;
      if (loading.value)
        return;
      onNodeExpand(e2, eventData.value);
    };
    var isDraggable = function isDraggable2() {
      var data4 = props2.data;
      var draggable = context.value.draggable;
      return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data4)));
    };
    var renderDragHandler = function renderDragHandler2() {
      var _context$value2 = context.value, draggable = _context$value2.draggable, prefixCls = _context$value2.prefixCls;
      return (draggable === null || draggable === void 0 ? void 0 : draggable.icon) ? Vue.createVNode("span", {
        "class": "".concat(prefixCls, "-draggable-icon")
      }, [draggable.icon]) : null;
    };
    var renderSwitcherIconDom = function renderSwitcherIconDom2() {
      var _a, _b, _c;
      var _props$switcherIcon = props2.switcherIcon, switcherIconFromProps = _props$switcherIcon === void 0 ? slots.switcherIcon || ((_a = context.value.slots) === null || _a === void 0 ? void 0 : _a[(_c = (_b = props2.data) === null || _b === void 0 ? void 0 : _b.slots) === null || _c === void 0 ? void 0 : _c.switcherIcon]) : _props$switcherIcon;
      var switcherIconFromCtx = context.value.switcherIcon;
      var switcherIcon = switcherIconFromProps || switcherIconFromCtx;
      if (typeof switcherIcon === "function") {
        return switcherIcon(renderArgsData.value);
      }
      return switcherIcon;
    };
    var syncLoadData = function syncLoadData2() {
      var _context$value3 = context.value, loadData = _context$value3.loadData, onNodeLoad = _context$value3.onNodeLoad;
      if (loading.value) {
        return;
      }
      if (loadData && expanded.value && !isLeaf.value) {
        if (!hasChildren.value && !loaded.value) {
          onNodeLoad(eventData.value);
        }
      }
    };
    Vue.onMounted(function() {
      syncLoadData();
    });
    Vue.onUpdated(function() {
      syncLoadData();
    });
    var renderSwitcher = function renderSwitcher2() {
      var prefixCls = context.value.prefixCls;
      var switcherIconDom = renderSwitcherIconDom();
      if (isLeaf.value) {
        return switcherIconDom !== false ? Vue.createVNode("span", {
          "class": classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop"))
        }, [switcherIconDom]) : null;
      }
      var switcherCls = classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded.value ? ICON_OPEN : ICON_CLOSE));
      return switcherIconDom !== false ? Vue.createVNode("span", {
        "onClick": onExpand,
        "class": switcherCls
      }, [switcherIconDom]) : null;
    };
    var renderCheckbox = function renderCheckbox2() {
      var _a, _b;
      var disableCheckbox = props2.disableCheckbox;
      var prefixCls = context.value.prefixCls;
      var disabled = isDisabled.value;
      var checkable = isCheckable.value;
      if (!checkable)
        return null;
      return Vue.createVNode("span", {
        "class": classNames("".concat(prefixCls, "-checkbox"), checked.value && "".concat(prefixCls, "-checkbox-checked"), !checked.value && halfChecked.value && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
        "onClick": onCheck
      }, [(_b = (_a = context.value).customCheckable) === null || _b === void 0 ? void 0 : _b.call(_a)]);
    };
    var renderIcon3 = function renderIcon4() {
      var prefixCls = context.value.prefixCls;
      return Vue.createVNode("span", {
        "class": classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(nodeState.value || "docu"), loading.value && "".concat(prefixCls, "-icon_loading"))
      }, null);
    };
    var renderDropIndicator = function renderDropIndicator2() {
      var disabled = props2.disabled, eventKey = props2.eventKey;
      var _context$value4 = context.value, draggable = _context$value4.draggable, dropLevelOffset = _context$value4.dropLevelOffset, dropPosition2 = _context$value4.dropPosition, prefixCls = _context$value4.prefixCls, indent = _context$value4.indent, dropIndicatorRender2 = _context$value4.dropIndicatorRender, dragOverNodeKey2 = _context$value4.dragOverNodeKey, direction = _context$value4.direction;
      var rootDraggable = draggable !== false;
      var showIndicator = !disabled && rootDraggable && dragOverNodeKey2 === eventKey;
      return showIndicator ? dropIndicatorRender2({
        dropPosition: dropPosition2,
        dropLevelOffset,
        indent,
        prefixCls,
        direction
      }) : null;
    };
    var renderSelector = function renderSelector2() {
      var _a, _b, _c, _d, _e, _f;
      var _props$icon = props2.icon, icon = _props$icon === void 0 ? slots.icon : _props$icon, data4 = props2.data;
      var title = slots.title || ((_a = context.value.slots) === null || _a === void 0 ? void 0 : _a[(_c = (_b = props2.data) === null || _b === void 0 ? void 0 : _b.slots) === null || _c === void 0 ? void 0 : _c.title]) || ((_d = context.value.slots) === null || _d === void 0 ? void 0 : _d.title) || props2.title;
      var _context$value5 = context.value, prefixCls = _context$value5.prefixCls, showIcon = _context$value5.showIcon, treeIcon = _context$value5.icon, loadData = _context$value5.loadData;
      var disabled = isDisabled.value;
      var wrapClass = "".concat(prefixCls, "-node-content-wrapper");
      var $icon;
      if (showIcon) {
        var currentIcon = icon || ((_e = context.value.slots) === null || _e === void 0 ? void 0 : _e[(_f = data4 === null || data4 === void 0 ? void 0 : data4.slots) === null || _f === void 0 ? void 0 : _f.icon]) || treeIcon;
        $icon = currentIcon ? Vue.createVNode("span", {
          "class": classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize"))
        }, [typeof currentIcon === "function" ? currentIcon(renderArgsData.value) : currentIcon]) : renderIcon3();
      } else if (loadData && loading.value) {
        $icon = renderIcon3();
      }
      var titleNode;
      if (typeof title === "function") {
        titleNode = title(renderArgsData.value);
      } else {
        titleNode = title;
      }
      titleNode = titleNode === void 0 ? defaultTitle : titleNode;
      var $title = Vue.createVNode("span", {
        "class": "".concat(prefixCls, "-title")
      }, [titleNode]);
      return Vue.createVNode("span", {
        "ref": selectHandle,
        "title": typeof title === "string" ? title : "",
        "class": classNames("".concat(wrapClass), "".concat(wrapClass, "-").concat(nodeState.value || "normal"), !disabled && (selected.value || dragNodeHighlight.value) && "".concat(prefixCls, "-node-selected")),
        "onMouseenter": onMouseEnter,
        "onMouseleave": onMouseLeave,
        "onContextmenu": onContextmenu2,
        "onClick": onSelectorClick,
        "onDblclick": onSelectorDoubleClick
      }, [$icon, $title, renderDropIndicator()]);
    };
    return function() {
      var _classNames;
      var _a = _extends(_extends({}, props2), attrs), eventKey = _a.eventKey, isLeaf2 = _a.isLeaf, isStart = _a.isStart, isEnd = _a.isEnd, domRef = _a.domRef, active = _a.active;
      _a.data;
      var onMousemove = _a.onMousemove, selectable = _a.selectable, otherProps = __rest$k(_a, ["eventKey", "isLeaf", "isStart", "isEnd", "domRef", "active", "data", "onMousemove", "selectable"]);
      var _context$value6 = context.value, prefixCls = _context$value6.prefixCls, filterTreeNode = _context$value6.filterTreeNode, keyEntities2 = _context$value6.keyEntities, dropContainerKey = _context$value6.dropContainerKey, dropTargetKey = _context$value6.dropTargetKey, draggingNodeKey = _context$value6.draggingNodeKey;
      var disabled = isDisabled.value;
      var dataOrAriaAttributeProps = pickAttrs(otherProps, {
        aria: true,
        data: true
      });
      var _ref4 = keyEntities2[eventKey] || {}, level = _ref4.level;
      var isEndNode = isEnd[isEnd.length - 1];
      var mergedDraggable = isDraggable();
      var draggableWithoutDisabled = !disabled && mergedDraggable;
      var dragging = draggingNodeKey === eventKey;
      var ariaSelected = selectable !== void 0 ? {
        "aria-selected": !!selectable
      } : void 0;
      return Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "ref": domRef,
        "class": classNames(attrs.class, "".concat(prefixCls, "-treenode"), (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls, "-treenode-disabled"), disabled), _defineProperty$T(_classNames, "".concat(prefixCls, "-treenode-switcher-").concat(expanded.value ? "open" : "close"), !isLeaf2), _defineProperty$T(_classNames, "".concat(prefixCls, "-treenode-checkbox-checked"), checked.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-treenode-selected"), selected.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-treenode-loading"), loading.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-treenode-active"), active), _defineProperty$T(_classNames, "".concat(prefixCls, "-treenode-leaf-last"), isEndNode), _defineProperty$T(_classNames, "".concat(prefixCls, "-treenode-draggable"), draggableWithoutDisabled), _defineProperty$T(_classNames, "dragging", dragging), _defineProperty$T(_classNames, "drop-target", dropTargetKey === eventKey), _defineProperty$T(_classNames, "drop-container", dropContainerKey === eventKey), _defineProperty$T(_classNames, "drag-over", !disabled && dragOver.value), _defineProperty$T(_classNames, "drag-over-gap-top", !disabled && dragOverGapTop.value), _defineProperty$T(_classNames, "drag-over-gap-bottom", !disabled && dragOverGapBottom.value), _defineProperty$T(_classNames, "filter-node", filterTreeNode && filterTreeNode(eventData.value)), _classNames)),
        "style": attrs.style,
        "draggable": draggableWithoutDisabled,
        "aria-grabbed": dragging,
        "onDragstart": draggableWithoutDisabled ? onDragStart : void 0,
        "onDragenter": mergedDraggable ? onDragEnter : void 0,
        "onDragover": mergedDraggable ? onDragOver : void 0,
        "onDragleave": mergedDraggable ? onDragLeave : void 0,
        "onDrop": mergedDraggable ? onDrop : void 0,
        "onDragend": mergedDraggable ? onDragEnd : void 0,
        "onMousemove": onMousemove
      }, ariaSelected), dataOrAriaAttributeProps), [Vue.createVNode(Indent$1, {
        "prefixCls": prefixCls,
        "level": level,
        "isStart": isStart,
        "isEnd": isEnd
      }, null), renderDragHandler(), renderSwitcher(), renderCheckbox(), renderSelector()]);
    };
  }
});
globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function arrDel(list, value) {
  if (!list)
    return [];
  var clone2 = list.slice();
  var index2 = clone2.indexOf(value);
  if (index2 >= 0) {
    clone2.splice(index2, 1);
  }
  return clone2;
}
function arrAdd(list, value) {
  var clone2 = (list || []).slice();
  if (clone2.indexOf(value) === -1) {
    clone2.push(value);
  }
  return clone2;
}
function posToArr(pos) {
  return pos.split("-");
}
function getPosition(level, index2) {
  return "".concat(level, "-").concat(index2);
}
function isTreeNode(node) {
  return node && node.type && node.type.isTreeNode;
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  var dragChildrenKeys = [];
  var entity = keyEntities[dragNodeKey];
  function dig() {
    var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    list.forEach(function(_ref) {
      var key2 = _ref.key, children = _ref.children;
      dragChildrenKeys.push(key2);
      dig(children);
    });
  }
  dig(entity.children);
  return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    var posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return false;
}
function isFirstChild(treeNodeEntity) {
  var posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop2, flattenedNodes, keyEntities, expandKeysSet, direction) {
  var _a;
  var clientX = event.clientX, clientY = event.clientY;
  var _event$target$getBoun = event.target.getBoundingClientRect(), top = _event$target$getBoun.top, height = _event$target$getBoun.height;
  var horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
  var abstractDropNodeEntity = keyEntities[targetNode.eventKey];
  if (clientY < top + height / 2) {
    var nodeIndex = flattenedNodes.findIndex(function(flattenedNode) {
      return flattenedNode.key === abstractDropNodeEntity.key;
    });
    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
    var prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = keyEntities[prevNodeKey];
  }
  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
  var abstractDragOverEntity = abstractDropNodeEntity;
  var dragOverNodeKey = abstractDropNodeEntity.key;
  var dropPosition = 0;
  var dropLevelOffset = 0;
  if (!expandKeysSet.has(initialAbstractDropNodeKey)) {
    for (var i2 = 0; i2 < rawDropLevelOffset; i2 += 1) {
      if (isLastChild(abstractDropNodeEntity)) {
        abstractDropNodeEntity = abstractDropNodeEntity.parent;
        dropLevelOffset += 1;
      } else {
        break;
      }
    }
  }
  var abstractDragDataNode = dragNode.eventData;
  var abstractDropDataNode = abstractDropNodeEntity.node;
  var dropAllowed = true;
  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop2({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNode.eventKey) {
    dropPosition = -1;
  } else if ((abstractDragOverEntity.children || []).length && expandKeysSet.has(dragOverNodeKey)) {
    if (allowDrop2({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 0
    })) {
      dropPosition = 0;
    } else {
      dropAllowed = false;
    }
  } else if (dropLevelOffset === 0) {
    if (rawDropLevelOffset > -1.5) {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    } else {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
  } else {
    if (allowDrop2({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 1
    })) {
      dropPosition = 1;
    } else {
      dropAllowed = false;
    }
  }
  return {
    dropPosition,
    dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : ((_a = abstractDropNodeEntity.parent) === null || _a === void 0 ? void 0 : _a.key) || null,
    dropAllowed
  };
}
function calcSelectedKeys(selectedKeys, props2) {
  if (!selectedKeys)
    return void 0;
  var multiple = props2.multiple;
  if (multiple) {
    return selectedKeys.slice();
  }
  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }
  return selectedKeys;
}
function parseCheckedKeys(keys2) {
  if (!keys2) {
    return null;
  }
  var keyProps;
  if (Array.isArray(keys2)) {
    keyProps = {
      checkedKeys: keys2,
      halfCheckedKeys: void 0
    };
  } else if (_typeof$1(keys2) === "object") {
    keyProps = {
      checkedKeys: keys2.checked || void 0,
      halfCheckedKeys: keys2.halfChecked || void 0
    };
  } else {
    return null;
  }
  return keyProps;
}
function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = /* @__PURE__ */ new Set();
  function conductUp(key2) {
    if (expandedKeys.has(key2))
      return;
    var entity = keyEntities[key2];
    if (!entity)
      return;
    expandedKeys.add(key2);
    var parent = entity.parent, node = entity.node;
    if (node.disabled)
      return;
    if (parent) {
      conductUp(parent.key);
    }
  }
  (keyList || []).forEach(function(key2) {
    conductUp(key2);
  });
  return _toConsumableArray(expandedKeys);
}
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  var filteredKeys = /* @__PURE__ */ new Set();
  halfCheckedKeys.forEach(function(key2) {
    if (!checkedKeys.has(key2)) {
      filteredKeys.add(key2);
    }
  });
  return filteredKeys;
}
function isCheckDisabled(node) {
  var _ref = node || {}, disabled = _ref.disabled, disableCheckbox = _ref.disableCheckbox, checkable = _ref.checkable;
  return !!(disabled || disableCheckbox) || checkable === false;
}
function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys2);
  var halfCheckedKeys = /* @__PURE__ */ new Set();
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key2 = entity.key, node = entity.node, _entity$children = entity.children, children = _entity$children === void 0 ? [] : _entity$children;
      if (checkedKeys.has(key2) && !syntheticGetCheckDisabled(node)) {
        children.filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(childEntity) {
          checkedKeys.add(childEntity.key);
        });
      }
    });
  }
  var visitedKeys = /* @__PURE__ */ new Set();
  for (var _level = maxLevel; _level >= 0; _level -= 1) {
    var _entities = levelEntities.get(_level) || /* @__PURE__ */ new Set();
    _entities.forEach(function(entity) {
      var parent = entity.parent, node = entity.node;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(_ref2) {
        var key2 = _ref2.key;
        var checked = checkedKeys.has(key2);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
          partialChecked = true;
        }
      });
      if (allChecked) {
        checkedKeys.add(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys2);
  var halfCheckedKeys = new Set(halfKeys);
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key2 = entity.key, node = entity.node, _entity$children2 = entity.children, children = _entity$children2 === void 0 ? [] : _entity$children2;
      if (!checkedKeys.has(key2) && !halfCheckedKeys.has(key2) && !syntheticGetCheckDisabled(node)) {
        children.filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(childEntity) {
          checkedKeys.delete(childEntity.key);
        });
      }
    });
  }
  halfCheckedKeys = /* @__PURE__ */ new Set();
  var visitedKeys = /* @__PURE__ */ new Set();
  for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {
    var _entities2 = levelEntities.get(_level2) || /* @__PURE__ */ new Set();
    _entities2.forEach(function(entity) {
      var parent = entity.parent, node = entity.node;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(_ref3) {
        var key2 = _ref3.key;
        var checked = checkedKeys.has(key2);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
          partialChecked = true;
        }
      });
      if (!allChecked) {
        checkedKeys.delete(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function conductCheck(keyList, checked, keyEntities, maxLevel, levelEntities, getCheckDisabled) {
  var syntheticGetCheckDisabled;
  if (getCheckDisabled) {
    syntheticGetCheckDisabled = getCheckDisabled;
  } else {
    syntheticGetCheckDisabled = isCheckDisabled;
  }
  var keys2 = new Set(keyList.filter(function(key2) {
    var hasEntity = !!keyEntities[key2];
    return hasEntity;
  }));
  var result;
  if (checked === true) {
    result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled);
  } else {
    result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  }
  return result;
}
var __rest$j = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var checkboxProps$1 = {
  prefixCls: String,
  name: String,
  id: String,
  type: String,
  defaultChecked: {
    type: [Boolean, Number],
    default: void 0
  },
  checked: {
    type: [Boolean, Number],
    default: void 0
  },
  disabled: Boolean,
  tabindex: {
    type: [Number, String]
  },
  readonly: Boolean,
  autofocus: Boolean,
  value: PropTypes$1.any,
  required: Boolean
};
var VcCheckbox = Vue.defineComponent({
  name: "Checkbox",
  inheritAttrs: false,
  props: initDefaultProps$1(checkboxProps$1, {
    prefixCls: "rc-checkbox",
    type: "checkbox",
    defaultChecked: false
  }),
  emits: ["click", "change"],
  setup: function setup94(props2, _ref) {
    var attrs = _ref.attrs, emit = _ref.emit, expose = _ref.expose;
    var checked = Vue.ref(props2.checked === void 0 ? props2.defaultChecked : props2.checked);
    var inputRef = Vue.ref();
    Vue.watch(function() {
      return props2.checked;
    }, function() {
      checked.value = props2.checked;
    });
    Vue.onMounted(function() {
      Vue.nextTick(function() {
      });
    });
    expose({
      focus: function focus() {
        var _a;
        (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      },
      blur: function blur() {
        var _a;
        (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.blur();
      }
    });
    var eventShiftKey = Vue.ref();
    var handleChange2 = function handleChange3(e2) {
      if (props2.disabled) {
        return;
      }
      if (props2.checked === void 0) {
        checked.value = e2.target.checked;
      }
      e2.shiftKey = eventShiftKey.value;
      var eventObj = {
        target: _extends(_extends({}, props2), {
          checked: e2.target.checked
        }),
        stopPropagation: function stopPropagation() {
          e2.stopPropagation();
        },
        preventDefault: function preventDefault() {
          e2.preventDefault();
        },
        nativeEvent: e2
      };
      if (props2.checked !== void 0) {
        inputRef.value.checked = !!props2.checked;
      }
      emit("change", eventObj);
      eventShiftKey.value = false;
    };
    var onClick2 = function onClick3(e2) {
      emit("click", e2);
      eventShiftKey.value = e2.shiftKey;
    };
    return function() {
      var _classNames;
      var prefixCls = props2.prefixCls, name = props2.name, id = props2.id, type2 = props2.type, disabled = props2.disabled, readonly = props2.readonly, tabindex = props2.tabindex, autofocus = props2.autofocus, value = props2.value, required = props2.required, others = __rest$j(props2, ["prefixCls", "name", "id", "type", "disabled", "readonly", "tabindex", "autofocus", "value", "required"]);
      var className = attrs.class, onFocus2 = attrs.onFocus, onBlur2 = attrs.onBlur, onKeydown = attrs.onKeydown, onKeypress = attrs.onKeypress, onKeyup = attrs.onKeyup;
      var globalProps = Object.keys(_extends(_extends({}, others), attrs)).reduce(function(prev2, key2) {
        if (key2.substr(0, 5) === "aria-" || key2.substr(0, 5) === "data-" || key2 === "role") {
          prev2[key2] = others[key2];
        }
        return prev2;
      }, {});
      var classString = classNames(prefixCls, className, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls, "-checked"), checked.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
      var inputProps3 = _extends(_extends({
        name,
        id,
        type: type2,
        readonly,
        disabled,
        tabindex,
        class: "".concat(prefixCls, "-input"),
        checked: !!checked.value,
        autofocus,
        value
      }, globalProps), {
        onChange: handleChange2,
        onClick: onClick2,
        onFocus: onFocus2,
        onBlur: onBlur2,
        onKeydown,
        onKeypress,
        onKeyup,
        required
      });
      return Vue.createVNode("span", {
        "class": classString
      }, [Vue.createVNode("input", _objectSpread2$1({
        "ref": inputRef
      }, inputProps3), null), Vue.createVNode("span", {
        "class": "".concat(prefixCls, "-inner")
      }, null)]);
    };
  }
});
var abstractCheckboxGroupProps = function abstractCheckboxGroupProps2() {
  return {
    name: String,
    prefixCls: String,
    options: {
      type: Array,
      default: function _default5() {
        return [];
      }
    },
    disabled: Boolean,
    id: String
  };
};
var checkboxGroupProps = function checkboxGroupProps2() {
  return _extends(_extends({}, abstractCheckboxGroupProps()), {
    defaultValue: {
      type: Array
    },
    value: {
      type: Array
    },
    onChange: {
      type: Function
    },
    "onUpdate:value": {
      type: Function
    }
  });
};
var abstractCheckboxProps = function abstractCheckboxProps2() {
  return {
    prefixCls: String,
    defaultChecked: {
      type: Boolean,
      default: void 0
    },
    checked: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    isGroup: {
      type: Boolean,
      default: void 0
    },
    value: PropTypes$1.any,
    name: String,
    id: String,
    indeterminate: {
      type: Boolean,
      default: void 0
    },
    type: {
      type: String,
      default: "checkbox"
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    onChange: Function,
    "onUpdate:checked": Function,
    onClick: Function,
    skipGroup: {
      type: Boolean,
      default: false
    }
  };
};
var checkboxProps = function checkboxProps2() {
  return _extends(_extends({}, abstractCheckboxProps()), {
    indeterminate: {
      type: Boolean,
      default: false
    }
  });
};
var CheckboxGroupContextKey = Symbol("CheckboxGroupContext");
var __rest$i = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var Checkbox$1 = Vue.defineComponent({
  name: "ACheckbox",
  inheritAttrs: false,
  __ANT_CHECKBOX: true,
  props: checkboxProps(),
  setup: function setup95(props2, _ref) {
    var emit = _ref.emit, attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose;
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("checkbox", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var checkboxGroup = Vue.inject(CheckboxGroupContextKey, void 0);
    var uniId = Symbol("checkboxUniId");
    Vue.watchEffect(function() {
      if (!props2.skipGroup && checkboxGroup) {
        checkboxGroup.registerValue(uniId, props2.value);
      }
    });
    Vue.onBeforeUnmount(function() {
      if (checkboxGroup) {
        checkboxGroup.cancelValue(uniId);
      }
    });
    Vue.onMounted(function() {
      warning(props2.checked !== void 0 || checkboxGroup || props2.value === void 0, "Checkbox", "`value` is not validate prop, do you mean `checked`?");
    });
    var handleChange2 = function handleChange3(event) {
      var targetChecked = event.target.checked;
      emit("update:checked", targetChecked);
      emit("change", event);
    };
    var checkboxRef = Vue.ref();
    var focus = function focus2() {
      var _a;
      (_a = checkboxRef.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    var blur = function blur2() {
      var _a;
      (_a = checkboxRef.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    expose({
      focus,
      blur
    });
    return function() {
      var _classNames;
      var _a;
      var children = flattenChildren((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
      var indeterminate = props2.indeterminate, skipGroup = props2.skipGroup, _props$id = props2.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id, restProps = __rest$i(props2, ["indeterminate", "skipGroup", "id"]);
      var onMouseenter2 = attrs.onMouseenter, onMouseleave2 = attrs.onMouseleave;
      attrs.onInput;
      var className = attrs.class, style = attrs.style, restAttrs = __rest$i(attrs, ["onMouseenter", "onMouseleave", "onInput", "class", "style"]);
      var checkboxProps3 = _extends(_extends(_extends({}, restProps), {
        id,
        prefixCls: prefixCls.value
      }), restAttrs);
      if (checkboxGroup && !skipGroup) {
        checkboxProps3.onChange = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          emit.apply(void 0, ["change"].concat(args));
          checkboxGroup.toggleOption({
            label: children,
            value: props2.value
          });
        };
        checkboxProps3.name = checkboxGroup.name.value;
        checkboxProps3.checked = checkboxGroup.mergedValue.value.indexOf(props2.value) !== -1;
        checkboxProps3.disabled = props2.disabled || checkboxGroup.disabled.value;
        checkboxProps3.indeterminate = indeterminate;
      } else {
        checkboxProps3.onChange = handleChange2;
      }
      var classString = classNames((_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls.value, "-wrapper"), true), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-wrapper-checked"), checkboxProps3.checked), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-wrapper-disabled"), checkboxProps3.disabled), _classNames), className);
      var checkboxClass = classNames(_defineProperty$T({}, "".concat(prefixCls.value, "-indeterminate"), indeterminate));
      return Vue.createVNode("label", {
        "class": classString,
        "style": style,
        "onMouseenter": onMouseenter2,
        "onMouseleave": onMouseleave2
      }, [Vue.createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({}, checkboxProps3), {}, {
        "class": checkboxClass,
        "ref": checkboxRef
      }), null), children.length ? Vue.createVNode("span", null, [children]) : null]);
    };
  }
});
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (!it) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      var F2 = function F3() {
      };
      return {
        s: F2,
        n: function n2() {
          if (i2 >= o2.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o2[i2++]
          };
        },
        e: function e2(_e) {
          throw _e;
        },
        f: F2
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function s2() {
      it = it.call(o2);
    },
    n: function n2() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e2(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f2() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
var CheckboxGroup$1 = Vue.defineComponent({
  name: "ACheckboxGroup",
  props: checkboxGroupProps(),
  setup: function setup96(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("checkbox", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var mergedValue = Vue.ref((props2.value === void 0 ? props2.defaultValue : props2.value) || []);
    Vue.watch(function() {
      return props2.value;
    }, function() {
      mergedValue.value = props2.value || [];
    });
    var options = Vue.computed(function() {
      return props2.options.map(function(option) {
        if (typeof option === "string" || typeof option === "number") {
          return {
            label: option,
            value: option
          };
        }
        return option;
      });
    });
    var triggerUpdate = Vue.ref(Symbol());
    var registeredValuesMap = Vue.ref(/* @__PURE__ */ new Map());
    var cancelValue = function cancelValue2(id) {
      registeredValuesMap.value.delete(id);
      triggerUpdate.value = Symbol();
    };
    var registerValue = function registerValue2(id, value) {
      registeredValuesMap.value.set(id, value);
      triggerUpdate.value = Symbol();
    };
    var registeredValues = Vue.ref(/* @__PURE__ */ new Map());
    Vue.watch(triggerUpdate, function() {
      var valuseMap = /* @__PURE__ */ new Map();
      var _iterator = _createForOfIteratorHelper(registeredValuesMap.value.values()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var value = _step.value;
          valuseMap.set(value, true);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      registeredValues.value = valuseMap;
    });
    var toggleOption = function toggleOption2(option) {
      var optionIndex = mergedValue.value.indexOf(option.value);
      var value = _toConsumableArray(mergedValue.value);
      if (optionIndex === -1) {
        value.push(option.value);
      } else {
        value.splice(optionIndex, 1);
      }
      if (props2.value === void 0) {
        mergedValue.value = value;
      }
      var val = value.filter(function(val2) {
        return registeredValues.value.has(val2);
      }).sort(function(a2, b2) {
        var indexA = options.value.findIndex(function(opt) {
          return opt.value === a2;
        });
        var indexB = options.value.findIndex(function(opt) {
          return opt.value === b2;
        });
        return indexA - indexB;
      });
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    Vue.provide(CheckboxGroupContextKey, {
      cancelValue,
      registerValue,
      toggleOption,
      mergedValue,
      name: Vue.computed(function() {
        return props2.name;
      }),
      disabled: Vue.computed(function() {
        return props2.disabled;
      })
    });
    expose({
      mergedValue
    });
    return function() {
      var _a;
      var _props$id = props2.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id;
      var children = null;
      var groupPrefixCls = "".concat(prefixCls.value, "-group");
      if (options.value && options.value.length > 0) {
        children = options.value.map(function(option) {
          var _a2;
          return Vue.createVNode(Checkbox$1, {
            "prefixCls": prefixCls.value,
            "key": option.value.toString(),
            "disabled": "disabled" in option ? option.disabled : props2.disabled,
            "indeterminate": option.indeterminate,
            "value": option.value,
            "checked": mergedValue.value.indexOf(option.value) !== -1,
            "onChange": option.onChange,
            "class": "".concat(groupPrefixCls, "-item")
          }, {
            default: function _default5() {
              return [option.label === void 0 ? (_a2 = slots.label) === null || _a2 === void 0 ? void 0 : _a2.call(slots, option) : option.label];
            }
          });
        });
      }
      return Vue.createVNode("div", {
        "class": [groupPrefixCls, _defineProperty$T({}, "".concat(groupPrefixCls, "-rtl"), direction.value === "rtl")],
        "id": id
      }, [children || ((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots))]);
    };
  }
});
Checkbox$1.Group = CheckboxGroup$1;
Checkbox$1.install = function(app) {
  app.component(Checkbox$1.name, Checkbox$1);
  app.component(CheckboxGroup$1.name, CheckboxGroup$1);
  return app;
};
var dropdownProps = function dropdownProps2() {
  return {
    arrow: {
      type: [Boolean, Object],
      default: void 0
    },
    trigger: {
      type: [Array, String]
    },
    overlay: PropTypes$1.any,
    visible: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    align: {
      type: Object
    },
    getPopupContainer: Function,
    prefixCls: String,
    transitionName: String,
    placement: String,
    overlayClassName: String,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    forceRender: {
      type: Boolean,
      default: void 0
    },
    mouseEnterDelay: Number,
    mouseLeaveDelay: Number,
    openClassName: String,
    minOverlayWidthMatchTrigger: {
      type: Boolean,
      default: void 0
    },
    destroyPopupOnHide: {
      type: Boolean,
      default: void 0
    },
    onVisibleChange: {
      type: Function
    },
    "onUpdate:visible": {
      type: Function
    }
  };
};
var buttonTypesProps = buttonTypes();
var dropdownButtonProps = function dropdownButtonProps2() {
  return _extends(_extends({}, dropdownProps()), {
    type: buttonTypesProps.type,
    size: String,
    htmlType: buttonTypesProps.htmlType,
    href: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    icon: PropTypes$1.any,
    title: String,
    loading: buttonTypesProps.loading,
    onClick: {
      type: Function
    }
  });
};
var __rest$h = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var ButtonGroup = Button$1.Group;
var DropdownButton = Vue.defineComponent({
  name: "ADropdownButton",
  inheritAttrs: false,
  __ANT_BUTTON: true,
  props: initDefaultProps$1(dropdownButtonProps(), {
    trigger: "hover",
    placement: "bottomRight",
    type: "default"
  }),
  slots: ["icon", "leftButton", "rightButton", "overlay"],
  setup: function setup97(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
    var handleVisibleChange = function handleVisibleChange2(val) {
      emit("update:visible", val);
      emit("visibleChange", val);
    };
    var _useConfigInject = useConfigInject("dropdown-button", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer;
    return function() {
      var _a, _b;
      var _c = _extends(_extends({}, props2), attrs), _c$type = _c.type, type2 = _c$type === void 0 ? "default" : _c$type, disabled = _c.disabled, loading = _c.loading, htmlType = _c.htmlType, _c$class = _c.class, className = _c$class === void 0 ? "" : _c$class, _c$overlay = _c.overlay, _overlay = _c$overlay === void 0 ? (_a = slots.overlay) === null || _a === void 0 ? void 0 : _a.call(slots) : _c$overlay, trigger2 = _c.trigger, align = _c.align, visible = _c.visible;
      _c.onVisibleChange;
      var _c$placement = _c.placement, placement = _c$placement === void 0 ? direction.value === "rtl" ? "bottomLeft" : "bottomRight" : _c$placement, href = _c.href, title = _c.title, _c$icon = _c.icon, icon = _c$icon === void 0 ? ((_b = slots.icon) === null || _b === void 0 ? void 0 : _b.call(slots)) || Vue.createVNode(EllipsisOutlined$1, null, null) : _c$icon, mouseEnterDelay = _c.mouseEnterDelay, mouseLeaveDelay = _c.mouseLeaveDelay, overlayClassName = _c.overlayClassName, overlayStyle = _c.overlayStyle, destroyPopupOnHide = _c.destroyPopupOnHide, onClick2 = _c.onClick;
      _c["onUpdate:visible"];
      var restProps = __rest$h(_c, ["type", "disabled", "loading", "htmlType", "class", "overlay", "trigger", "align", "visible", "onVisibleChange", "placement", "href", "title", "icon", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "onClick", "onUpdate:visible"]);
      var dropdownProps3 = {
        align,
        disabled,
        trigger: disabled ? [] : trigger2,
        placement,
        getPopupContainer: getPopupContainer.value,
        onVisibleChange: handleVisibleChange,
        mouseEnterDelay,
        mouseLeaveDelay,
        visible,
        overlayClassName,
        overlayStyle,
        destroyPopupOnHide
      };
      var leftButton = Vue.createVNode(Button$1, {
        "type": type2,
        "disabled": disabled,
        "loading": loading,
        "onClick": onClick2,
        "htmlType": htmlType,
        "href": href,
        "title": title
      }, {
        default: slots.default
      });
      var rightButton = Vue.createVNode(Button$1, {
        "type": type2,
        "icon": icon
      }, null);
      return Vue.createVNode(ButtonGroup, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
        "class": classNames(prefixCls.value, className)
      }), {
        default: function _default5() {
          return [slots.leftButton ? slots.leftButton({
            button: leftButton
          }) : leftButton, Vue.createVNode(DropDown, dropdownProps3, {
            default: function _default6() {
              return [slots.rightButton ? slots.rightButton({
                button: rightButton
              }) : rightButton];
            },
            overlay: function overlay() {
              return _overlay;
            }
          })];
        }
      });
    };
  }
});
var Dropdown = Vue.defineComponent({
  name: "ADropdown",
  inheritAttrs: false,
  props: initDefaultProps$1(dropdownProps(), {
    mouseEnterDelay: 0.15,
    mouseLeaveDelay: 0.1,
    placement: "bottomLeft",
    trigger: "hover"
  }),
  slots: ["overlay"],
  setup: function setup98(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
    var _useConfigInject = useConfigInject("dropdown", props2), prefixCls = _useConfigInject.prefixCls, rootPrefixCls = _useConfigInject.rootPrefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer;
    var transitionName2 = Vue.computed(function() {
      var _props$placement = props2.placement, placement2 = _props$placement === void 0 ? "" : _props$placement, transitionName3 = props2.transitionName;
      if (transitionName3 !== void 0) {
        return transitionName3;
      }
      if (placement2.indexOf("top") >= 0) {
        return "".concat(rootPrefixCls.value, "-slide-down");
      }
      return "".concat(rootPrefixCls.value, "-slide-up");
    });
    var renderOverlay = function renderOverlay2() {
      var _a, _b, _c;
      var overlay = props2.overlay || ((_a = slots.overlay) === null || _a === void 0 ? void 0 : _a.call(slots));
      var overlayNode = Array.isArray(overlay) ? overlay[0] : overlay;
      if (!overlayNode)
        return null;
      var overlayProps = overlayNode.props || {};
      devWarning(!overlayProps.mode || overlayProps.mode === "vertical", "Dropdown", 'mode="'.concat(overlayProps.mode, `" is not supported for Dropdown's Menu.`));
      var _overlayProps$selecta = overlayProps.selectable, selectable = _overlayProps$selecta === void 0 ? false : _overlayProps$selecta, _overlayProps$expandI = overlayProps.expandIcon, expandIcon = _overlayProps$expandI === void 0 ? (_c = (_b = overlayNode.children) === null || _b === void 0 ? void 0 : _b.expandIcon) === null || _c === void 0 ? void 0 : _c.call(_b) : _overlayProps$expandI;
      var overlayNodeExpandIcon = typeof expandIcon !== "undefined" && isValidElement(expandIcon) ? expandIcon : Vue.createVNode("span", {
        "class": "".concat(prefixCls.value, "-menu-submenu-arrow")
      }, [Vue.createVNode(RightOutlined$1, {
        "class": "".concat(prefixCls.value, "-menu-submenu-arrow-icon")
      }, null)]);
      var fixedModeOverlay = isValidElement(overlayNode) ? cloneElement(overlayNode, {
        mode: "vertical",
        selectable,
        expandIcon: function expandIcon2() {
          return overlayNodeExpandIcon;
        }
      }) : overlayNode;
      return fixedModeOverlay;
    };
    var placement = Vue.computed(function() {
      var placement2 = props2.placement;
      if (!placement2) {
        return direction.value === "rtl" ? "bottomRight" : "bottomLeft";
      }
      if (placement2.includes("Center")) {
        var newPlacement = placement2.slice(0, placement2.indexOf("Center"));
        devWarning(!placement2.includes("Center"), "Dropdown", "You are using '".concat(placement2, "' placement in Dropdown, which is deprecated. Try to use '").concat(newPlacement, "' instead."));
        return newPlacement;
      }
      return placement2;
    });
    var handleVisibleChange = function handleVisibleChange2(val) {
      emit("update:visible", val);
      emit("visibleChange", val);
    };
    return function() {
      var _a, _b;
      var arrow = props2.arrow, trigger2 = props2.trigger, disabled = props2.disabled, overlayClassName = props2.overlayClassName;
      var child = (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)[0];
      var dropdownTrigger = cloneElement(child, _extends({
        class: classNames((_b = child === null || child === void 0 ? void 0 : child.props) === null || _b === void 0 ? void 0 : _b.class, _defineProperty$T({}, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), "".concat(prefixCls.value, "-trigger"))
      }, disabled ? {
        disabled
      } : {}));
      var overlayClassNameCustomized = classNames(overlayClassName, _defineProperty$T({}, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"));
      var triggerActions = disabled ? [] : trigger2;
      var alignPoint2;
      if (triggerActions && triggerActions.indexOf("contextmenu") !== -1) {
        alignPoint2 = true;
      }
      var builtinPlacements = getPlacements({
        arrowPointAtCenter: _typeof$1(arrow) === "object" && arrow.pointAtCenter,
        autoAdjustOverflow: true
      });
      var dropdownProps3 = omit(_extends(_extends(_extends({}, props2), attrs), {
        builtinPlacements,
        overlayClassName: overlayClassNameCustomized,
        arrow,
        alignPoint: alignPoint2,
        prefixCls: prefixCls.value,
        getPopupContainer: getPopupContainer.value,
        transitionName: transitionName2.value,
        trigger: triggerActions,
        onVisibleChange: handleVisibleChange,
        placement: placement.value
      }), ["overlay", "onUpdate:visible"]);
      return Vue.createVNode(Dropdown$1, dropdownProps3, {
        default: function _default5() {
          return [dropdownTrigger];
        },
        overlay: renderOverlay
      });
    };
  }
});
Dropdown.Button = DropdownButton;
var DropDown = Dropdown;
DropDown.Button = DropdownButton;
DropDown.install = function(app) {
  app.component(DropDown.name, DropDown);
  app.component(DropdownButton.name, DropdownButton);
  return app;
};
var __rest$g = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var radioProps = function radioProps2() {
  return {
    prefixCls: String,
    checked: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    isGroup: {
      type: Boolean,
      default: void 0
    },
    value: PropTypes$1.any,
    name: String,
    id: String,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    onChange: Function,
    onFocus: Function,
    onBlur: Function,
    onClick: Function,
    "onUpdate:checked": Function,
    "onUpdate:value": Function
  };
};
var Radio = Vue.defineComponent({
  name: "ARadio",
  props: radioProps(),
  setup: function setup99(props2, _ref) {
    var emit = _ref.emit, expose = _ref.expose, slots = _ref.slots;
    var formItemContext = useInjectFormItemContext();
    var vcCheckbox = Vue.ref();
    var radioGroupContext = Vue.inject("radioGroupContext", void 0);
    var _useConfigInject = useConfigInject("radio", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var focus = function focus2() {
      vcCheckbox.value.focus();
    };
    var blur = function blur2() {
      vcCheckbox.value.blur();
    };
    expose({
      focus,
      blur
    });
    var handleChange2 = function handleChange3(event) {
      var targetChecked = event.target.checked;
      emit("update:checked", targetChecked);
      emit("update:value", targetChecked);
      emit("change", event);
      formItemContext.onFieldChange();
    };
    var onChange = function onChange2(e2) {
      emit("change", e2);
      if (radioGroupContext && radioGroupContext.onRadioChange) {
        radioGroupContext.onRadioChange(e2);
      }
    };
    return function() {
      var _classNames;
      var radioGroup = radioGroupContext;
      props2.prefixCls;
      var _props$id = props2.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id, restProps = __rest$g(props2, ["prefixCls", "id"]);
      var rProps = _extends({
        prefixCls: prefixCls.value,
        id
      }, omit(restProps, ["onUpdate:checked", "onUpdate:value"]));
      if (radioGroup) {
        rProps.name = radioGroup.props.name;
        rProps.onChange = onChange;
        rProps.checked = props2.value === radioGroup.stateValue.value;
        rProps.disabled = props2.disabled || radioGroup.props.disabled;
      } else {
        rProps.onChange = handleChange2;
      }
      var wrapperClassString = classNames((_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls.value, "-wrapper"), true), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-wrapper-checked"), rProps.checked), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-wrapper-disabled"), rProps.disabled), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-wrapper-rtl"), direction.value === "rtl"), _classNames));
      return Vue.createVNode("label", {
        "class": wrapperClassString
      }, [Vue.createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({}, rProps), {}, {
        "type": "radio",
        "ref": vcCheckbox
      }), null), slots.default && Vue.createVNode("span", null, [slots.default()])]);
    };
  }
});
var RadioGroupSizeTypes = tuple$1("large", "default", "small");
var radioGroupProps = function radioGroupProps2() {
  return {
    prefixCls: String,
    value: PropTypes$1.any,
    size: PropTypes$1.oneOf(RadioGroupSizeTypes).def("default"),
    options: {
      type: Array
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    name: String,
    buttonStyle: {
      type: String,
      default: "outline"
    },
    id: String,
    optionType: {
      type: String,
      default: "default"
    },
    onChange: Function,
    "onUpdate:value": Function
  };
};
var RadioGroup$1 = Vue.defineComponent({
  name: "ARadioGroup",
  props: radioGroupProps(),
  setup: function setup100(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit;
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("radio", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, size = _useConfigInject.size;
    var stateValue = Vue.ref(props2.value);
    var updatingValue = Vue.ref(false);
    Vue.watch(function() {
      return props2.value;
    }, function(val) {
      stateValue.value = val;
      updatingValue.value = false;
    });
    var onRadioChange = function onRadioChange2(ev) {
      var lastValue = stateValue.value;
      var value = ev.target.value;
      if (!("value" in props2)) {
        stateValue.value = value;
      }
      if (!updatingValue.value && value !== lastValue) {
        updatingValue.value = true;
        emit("update:value", value);
        emit("change", ev);
        formItemContext.onFieldChange();
      }
      Vue.nextTick(function() {
        updatingValue.value = false;
      });
    };
    Vue.provide("radioGroupContext", {
      onRadioChange,
      stateValue,
      props: props2
    });
    return function() {
      var _classNames;
      var _a;
      var options = props2.options, optionType = props2.optionType, buttonStyle = props2.buttonStyle, _props$id = props2.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id;
      var groupPrefixCls = "".concat(prefixCls.value, "-group");
      var classString = classNames(groupPrefixCls, "".concat(groupPrefixCls, "-").concat(buttonStyle), (_classNames = {}, _defineProperty$T(_classNames, "".concat(groupPrefixCls, "-").concat(size.value), size.value), _defineProperty$T(_classNames, "".concat(groupPrefixCls, "-rtl"), direction.value === "rtl"), _classNames));
      var children = null;
      if (options && options.length > 0) {
        var optionsPrefixCls = optionType === "button" ? "".concat(prefixCls.value, "-button") : prefixCls.value;
        children = options.map(function(option) {
          if (typeof option === "string" || typeof option === "number") {
            return Vue.createVNode(Radio, {
              "key": option,
              "prefixCls": optionsPrefixCls,
              "disabled": props2.disabled,
              "value": option,
              "checked": stateValue.value === option
            }, {
              default: function _default5() {
                return [option];
              }
            });
          }
          var value = option.value, disabled = option.disabled, label = option.label;
          return Vue.createVNode(Radio, {
            "key": "radio-group-value-options-".concat(value),
            "prefixCls": optionsPrefixCls,
            "disabled": disabled || props2.disabled,
            "value": value,
            "checked": stateValue.value === value
          }, {
            default: function _default5() {
              return [label];
            }
          });
        });
      } else {
        children = (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
      }
      return Vue.createVNode("div", {
        "class": classString,
        "id": id
      }, [children]);
    };
  }
});
var Button = Vue.defineComponent({
  name: "ARadioButton",
  props: radioProps(),
  setup: function setup101(props2, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("radio-button", props2), prefixCls = _useConfigInject.prefixCls;
    var radioGroupContext = Vue.inject("radioGroupContext", void 0);
    return function() {
      var _a;
      var rProps = _extends(_extends({}, props2), {
        prefixCls: prefixCls.value
      });
      if (radioGroupContext) {
        rProps.onChange = radioGroupContext.onRadioChange;
        rProps.checked = rProps.value === radioGroupContext.stateValue.value;
        rProps.disabled = rProps.disabled || radioGroupContext.props.disabled;
      }
      return Vue.createVNode(Radio, rProps, {
        default: function _default5() {
          return [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)];
        }
      });
    };
  }
});
Radio.Group = RadioGroup$1;
Radio.Button = Button;
Radio.install = function(app) {
  app.component(Radio.name, Radio);
  app.component(Radio.Group.name, Radio.Group);
  app.component(Radio.Button.name, Radio.Button);
  return app;
};
function useMaxLevel(keyEntities) {
  var maxLevel = Vue.ref(0);
  var levelEntities = Vue.shallowRef();
  Vue.watchEffect(function() {
    var newLevelEntities = /* @__PURE__ */ new Map();
    var newMaxLevel = 0;
    var keyEntitiesValue = keyEntities.value || {};
    for (var key2 in keyEntitiesValue) {
      if (Object.prototype.hasOwnProperty.call(keyEntitiesValue, key2)) {
        var entity = keyEntitiesValue[key2];
        var level = entity.level;
        var levelSet = newLevelEntities.get(level);
        if (!levelSet) {
          levelSet = /* @__PURE__ */ new Set();
          newLevelEntities.set(level, levelSet);
        }
        levelSet.add(entity);
        newMaxLevel = Math.max(newMaxLevel, level);
      }
    }
    maxLevel.value = newMaxLevel;
    levelEntities.value = newLevelEntities;
  });
  return {
    maxLevel,
    levelEntities
  };
}
var SELECTION_COLUMN = {};
var SELECTION_ALL = "SELECT_ALL";
var SELECTION_INVERT = "SELECT_INVERT";
var SELECTION_NONE = "SELECT_NONE";
var EMPTY_LIST$1 = [];
function flattenData(data4, childrenColumnName) {
  var list = [];
  (data4 || []).forEach(function(record) {
    list.push(record);
    if (record && _typeof$1(record) === "object" && childrenColumnName in record) {
      list = [].concat(_toConsumableArray(list), _toConsumableArray(flattenData(record[childrenColumnName], childrenColumnName)));
    }
  });
  return list;
}
function useSelection(rowSelectionRef, configRef) {
  var mergedRowSelection = Vue.computed(function() {
    var temp = rowSelectionRef.value || {};
    var _temp$checkStrictly = temp.checkStrictly, checkStrictly = _temp$checkStrictly === void 0 ? true : _temp$checkStrictly;
    return _extends(_extends({}, temp), {
      checkStrictly
    });
  });
  var _useMergedState = useMergedState(mergedRowSelection.value.selectedRowKeys || mergedRowSelection.value.defaultSelectedRowKeys || EMPTY_LIST$1, {
    value: Vue.computed(function() {
      return mergedRowSelection.value.selectedRowKeys;
    })
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedSelectedKeys = _useMergedState2[0], setMergedSelectedKeys = _useMergedState2[1];
  var preserveRecordsRef = Vue.shallowRef(/* @__PURE__ */ new Map());
  var updatePreserveRecordsCache = function updatePreserveRecordsCache2(keys2) {
    if (mergedRowSelection.value.preserveSelectedRowKeys) {
      var newCache = /* @__PURE__ */ new Map();
      keys2.forEach(function(key2) {
        var record = configRef.getRecordByKey(key2);
        if (!record && preserveRecordsRef.value.has(key2)) {
          record = preserveRecordsRef.value.get(key2);
        }
        newCache.set(key2, record);
      });
      preserveRecordsRef.value = newCache;
    }
  };
  Vue.watchEffect(function() {
    updatePreserveRecordsCache(mergedSelectedKeys.value);
  });
  var keyEntities = Vue.computed(function() {
    return mergedRowSelection.value.checkStrictly ? null : convertDataToEntities(configRef.data.value, {
      externalGetKey: configRef.getRowKey.value,
      childrenPropName: configRef.childrenColumnName.value
    }).keyEntities;
  });
  var flattedData = Vue.computed(function() {
    return flattenData(configRef.pageData.value, configRef.childrenColumnName.value);
  });
  var checkboxPropsMap = Vue.computed(function() {
    var map = /* @__PURE__ */ new Map();
    var getRowKey = configRef.getRowKey.value;
    var getCheckboxProps = mergedRowSelection.value.getCheckboxProps;
    flattedData.value.forEach(function(record, index2) {
      var key2 = getRowKey(record, index2);
      var checkboxProps3 = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
      map.set(key2, checkboxProps3);
    });
    return map;
  });
  var _useMaxLevel = useMaxLevel(keyEntities), maxLevel = _useMaxLevel.maxLevel, levelEntities = _useMaxLevel.levelEntities;
  var isCheckboxDisabled = function isCheckboxDisabled2(r2) {
    var _a;
    return !!((_a = checkboxPropsMap.value.get(configRef.getRowKey.value(r2))) === null || _a === void 0 ? void 0 : _a.disabled);
  };
  var selectKeysState = Vue.computed(function() {
    if (mergedRowSelection.value.checkStrictly) {
      return [mergedSelectedKeys.value || [], []];
    }
    var _conductCheck = conductCheck(mergedSelectedKeys.value, true, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled), checkedKeys = _conductCheck.checkedKeys, halfCheckedKeys = _conductCheck.halfCheckedKeys;
    return [checkedKeys || [], halfCheckedKeys];
  });
  var derivedSelectedKeys = Vue.computed(function() {
    return selectKeysState.value[0];
  });
  var derivedHalfSelectedKeys = Vue.computed(function() {
    return selectKeysState.value[1];
  });
  var derivedSelectedKeySet = Vue.computed(function() {
    var keys2 = mergedRowSelection.value.type === "radio" ? derivedSelectedKeys.value.slice(0, 1) : derivedSelectedKeys.value;
    return new Set(keys2);
  });
  var derivedHalfSelectedKeySet = Vue.computed(function() {
    return mergedRowSelection.value.type === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys.value);
  });
  var _useState = useState(null), _useState2 = _slicedToArray(_useState, 2), lastSelectedKey = _useState2[0], setLastSelectedKey = _useState2[1];
  var setSelectedKeys = function setSelectedKeys2(keys2) {
    var availableKeys;
    var records;
    updatePreserveRecordsCache(keys2);
    var _mergedRowSelection$v = mergedRowSelection.value, preserveSelectedRowKeys = _mergedRowSelection$v.preserveSelectedRowKeys, onSelectionChange = _mergedRowSelection$v.onChange;
    var getRecordByKey = configRef.getRecordByKey;
    if (preserveSelectedRowKeys) {
      availableKeys = keys2;
      records = keys2.map(function(key2) {
        return preserveRecordsRef.value.get(key2);
      });
    } else {
      availableKeys = [];
      records = [];
      keys2.forEach(function(key2) {
        var record = getRecordByKey(key2);
        if (record !== void 0) {
          availableKeys.push(key2);
          records.push(record);
        }
      });
    }
    setMergedSelectedKeys(availableKeys);
    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(availableKeys, records);
  };
  var triggerSingleSelection = function triggerSingleSelection2(key2, selected, keys2, event) {
    var onSelect = mergedRowSelection.value.onSelect;
    var _ref = configRef || {}, getRecordByKey = _ref.getRecordByKey;
    if (onSelect) {
      var rows = keys2.map(function(k2) {
        return getRecordByKey(k2);
      });
      onSelect(getRecordByKey(key2), selected, rows, event);
    }
    setSelectedKeys(keys2);
  };
  var mergedSelections = Vue.computed(function() {
    var _mergedRowSelection$v2 = mergedRowSelection.value, onSelectInvert = _mergedRowSelection$v2.onSelectInvert, onSelectNone = _mergedRowSelection$v2.onSelectNone, selections = _mergedRowSelection$v2.selections, hideSelectAll = _mergedRowSelection$v2.hideSelectAll;
    var data4 = configRef.data, pageData = configRef.pageData, getRowKey = configRef.getRowKey, tableLocale = configRef.locale;
    if (!selections || hideSelectAll) {
      return null;
    }
    var selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
    return selectionList.map(function(selection) {
      if (selection === SELECTION_ALL) {
        return {
          key: "all",
          text: tableLocale.value.selectionAll,
          onSelect: function onSelect() {
            setSelectedKeys(data4.value.map(function(record, index2) {
              return getRowKey.value(record, index2);
            }).filter(function(key2) {
              var checkProps = checkboxPropsMap.value.get(key2);
              return !(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled) || derivedSelectedKeySet.value.has(key2);
            }));
          }
        };
      }
      if (selection === SELECTION_INVERT) {
        return {
          key: "invert",
          text: tableLocale.value.selectInvert,
          onSelect: function onSelect() {
            var keySet = new Set(derivedSelectedKeySet.value);
            pageData.value.forEach(function(record, index2) {
              var key2 = getRowKey.value(record, index2);
              var checkProps = checkboxPropsMap.value.get(key2);
              if (!(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled)) {
                if (keySet.has(key2)) {
                  keySet.delete(key2);
                } else {
                  keySet.add(key2);
                }
              }
            });
            var keys2 = Array.from(keySet);
            if (onSelectInvert) {
              devWarning(false, "Table", "`onSelectInvert` will be removed in future. Please use `onChange` instead.");
              onSelectInvert(keys2);
            }
            setSelectedKeys(keys2);
          }
        };
      }
      if (selection === SELECTION_NONE) {
        return {
          key: "none",
          text: tableLocale.value.selectNone,
          onSelect: function onSelect() {
            onSelectNone === null || onSelectNone === void 0 ? void 0 : onSelectNone();
            setSelectedKeys(Array.from(derivedSelectedKeySet.value).filter(function(key2) {
              var checkProps = checkboxPropsMap.value.get(key2);
              return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
            }));
          }
        };
      }
      return selection;
    });
  });
  var flattedDataLength = Vue.computed(function() {
    return flattedData.value.length;
  });
  var transformColumns = function transformColumns2(columns) {
    var _a;
    var _mergedRowSelection$v3 = mergedRowSelection.value, onSelectAll = _mergedRowSelection$v3.onSelectAll, onSelectMultiple = _mergedRowSelection$v3.onSelectMultiple, selectionColWidth = _mergedRowSelection$v3.columnWidth, selectionType = _mergedRowSelection$v3.type, fixed = _mergedRowSelection$v3.fixed, customizeRenderCell = _mergedRowSelection$v3.renderCell, hideSelectAll = _mergedRowSelection$v3.hideSelectAll, checkStrictly = _mergedRowSelection$v3.checkStrictly;
    var prefixCls = configRef.prefixCls, getRecordByKey = configRef.getRecordByKey, getRowKey = configRef.getRowKey, expandType = configRef.expandType, getPopupContainer = configRef.getPopupContainer;
    if (!rowSelectionRef.value) {
      return columns.filter(function(col) {
        return col !== SELECTION_COLUMN;
      });
    }
    var cloneColumns = columns.slice();
    var keySet = new Set(derivedSelectedKeySet.value);
    var recordKeys = flattedData.value.map(getRowKey.value).filter(function(key2) {
      return !checkboxPropsMap.value.get(key2).disabled;
    });
    var checkedCurrentAll = recordKeys.every(function(key2) {
      return keySet.has(key2);
    });
    var checkedCurrentSome = recordKeys.some(function(key2) {
      return keySet.has(key2);
    });
    var onSelectAllChange = function onSelectAllChange2() {
      var changeKeys = [];
      if (checkedCurrentAll) {
        recordKeys.forEach(function(key2) {
          keySet.delete(key2);
          changeKeys.push(key2);
        });
      } else {
        recordKeys.forEach(function(key2) {
          if (!keySet.has(key2)) {
            keySet.add(key2);
            changeKeys.push(key2);
          }
        });
      }
      var keys2 = Array.from(keySet);
      onSelectAll === null || onSelectAll === void 0 ? void 0 : onSelectAll(!checkedCurrentAll, keys2.map(function(k2) {
        return getRecordByKey(k2);
      }), changeKeys.map(function(k2) {
        return getRecordByKey(k2);
      }));
      setSelectedKeys(keys2);
    };
    var title;
    if (selectionType !== "radio") {
      var customizeSelections;
      if (mergedSelections.value) {
        var menu = Vue.createVNode(Menu, {
          "getPopupContainer": getPopupContainer.value
        }, {
          default: function _default5() {
            return [mergedSelections.value.map(function(selection, index2) {
              var key2 = selection.key, text = selection.text, onSelectionClick = selection.onSelect;
              return Vue.createVNode(Menu.Item, {
                "key": key2 || index2,
                "onClick": function onClick2() {
                  onSelectionClick === null || onSelectionClick === void 0 ? void 0 : onSelectionClick(recordKeys);
                }
              }, {
                default: function _default6() {
                  return [text];
                }
              });
            })];
          }
        });
        customizeSelections = Vue.createVNode("div", {
          "class": "".concat(prefixCls.value, "-selection-extra")
        }, [Vue.createVNode(DropDown, {
          "overlay": menu,
          "getPopupContainer": getPopupContainer.value
        }, {
          default: function _default5() {
            return [Vue.createVNode("span", null, [Vue.createVNode(DownOutlined$1, null, null)])];
          }
        })]);
      }
      var allDisabledData = flattedData.value.map(function(record, index2) {
        var key2 = getRowKey.value(record, index2);
        var checkboxProps3 = checkboxPropsMap.value.get(key2) || {};
        return _extends({
          checked: keySet.has(key2)
        }, checkboxProps3);
      }).filter(function(_ref2) {
        var disabled = _ref2.disabled;
        return disabled;
      });
      var allDisabled = !!allDisabledData.length && allDisabledData.length === flattedDataLength.value;
      var allDisabledAndChecked = allDisabled && allDisabledData.every(function(_ref3) {
        var checked = _ref3.checked;
        return checked;
      });
      var allDisabledSomeChecked = allDisabled && allDisabledData.some(function(_ref4) {
        var checked = _ref4.checked;
        return checked;
      });
      title = !hideSelectAll && Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-selection")
      }, [Vue.createVNode(Checkbox$1, {
        "checked": !allDisabled ? !!flattedDataLength.value && checkedCurrentAll : allDisabledAndChecked,
        "indeterminate": !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
        "onChange": onSelectAllChange,
        "disabled": flattedDataLength.value === 0 || allDisabled,
        "skipGroup": true
      }, null), customizeSelections]);
    }
    var renderCell;
    if (selectionType === "radio") {
      renderCell = function renderCell2(_ref5) {
        var record = _ref5.record, index2 = _ref5.index;
        var key2 = getRowKey.value(record, index2);
        var checked = keySet.has(key2);
        return {
          node: Vue.createVNode(Radio, _objectSpread2$1(_objectSpread2$1({}, checkboxPropsMap.value.get(key2)), {}, {
            "checked": checked,
            "onClick": function onClick2(e2) {
              return e2.stopPropagation();
            },
            "onChange": function onChange(event) {
              if (!keySet.has(key2)) {
                triggerSingleSelection(key2, true, [key2], event.nativeEvent);
              }
            }
          }), null),
          checked
        };
      };
    } else {
      renderCell = function renderCell2(_ref6) {
        var record = _ref6.record, index2 = _ref6.index;
        var _a2;
        var key2 = getRowKey.value(record, index2);
        var checked = keySet.has(key2);
        var indeterminate = derivedHalfSelectedKeySet.value.has(key2);
        var checkboxProps3 = checkboxPropsMap.value.get(key2);
        var mergedIndeterminate;
        if (expandType.value === "nest") {
          mergedIndeterminate = indeterminate;
          devWarning(typeof (checkboxProps3 === null || checkboxProps3 === void 0 ? void 0 : checkboxProps3.indeterminate) !== "boolean", "Table", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.");
        } else {
          mergedIndeterminate = (_a2 = checkboxProps3 === null || checkboxProps3 === void 0 ? void 0 : checkboxProps3.indeterminate) !== null && _a2 !== void 0 ? _a2 : indeterminate;
        }
        return {
          node: Vue.createVNode(Checkbox$1, _objectSpread2$1(_objectSpread2$1({}, checkboxProps3), {}, {
            "indeterminate": mergedIndeterminate,
            "checked": checked,
            "skipGroup": true,
            "onClick": function onClick2(e2) {
              return e2.stopPropagation();
            },
            "onChange": function onChange(_ref7) {
              var nativeEvent = _ref7.nativeEvent;
              var shiftKey = nativeEvent.shiftKey;
              var startIndex = -1;
              var endIndex = -1;
              if (shiftKey && checkStrictly) {
                var pointKeys = /* @__PURE__ */ new Set([lastSelectedKey.value, key2]);
                recordKeys.some(function(recordKey, recordIndex) {
                  if (pointKeys.has(recordKey)) {
                    if (startIndex === -1) {
                      startIndex = recordIndex;
                    } else {
                      endIndex = recordIndex;
                      return true;
                    }
                  }
                  return false;
                });
              }
              if (endIndex !== -1 && startIndex !== endIndex && checkStrictly) {
                var rangeKeys = recordKeys.slice(startIndex, endIndex + 1);
                var changedKeys = [];
                if (checked) {
                  rangeKeys.forEach(function(recordKey) {
                    if (keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet.delete(recordKey);
                    }
                  });
                } else {
                  rangeKeys.forEach(function(recordKey) {
                    if (!keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet.add(recordKey);
                    }
                  });
                }
                var keys2 = Array.from(keySet);
                onSelectMultiple === null || onSelectMultiple === void 0 ? void 0 : onSelectMultiple(!checked, keys2.map(function(recordKey) {
                  return getRecordByKey(recordKey);
                }), changedKeys.map(function(recordKey) {
                  return getRecordByKey(recordKey);
                }));
                setSelectedKeys(keys2);
              } else {
                var originCheckedKeys = derivedSelectedKeys.value;
                if (checkStrictly) {
                  var checkedKeys = checked ? arrDel(originCheckedKeys, key2) : arrAdd(originCheckedKeys, key2);
                  triggerSingleSelection(key2, !checked, checkedKeys, nativeEvent);
                } else {
                  var result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key2]), true, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled);
                  var _checkedKeys = result.checkedKeys, halfCheckedKeys = result.halfCheckedKeys;
                  var nextCheckedKeys = _checkedKeys;
                  if (checked) {
                    var tempKeySet = new Set(_checkedKeys);
                    tempKeySet.delete(key2);
                    nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                      checked: false,
                      halfCheckedKeys
                    }, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled).checkedKeys;
                  }
                  triggerSingleSelection(key2, !checked, nextCheckedKeys, nativeEvent);
                }
              }
              setLastSelectedKey(key2);
            }
          }), null),
          checked
        };
      };
    }
    var renderSelectionCell = function renderSelectionCell2(_ref8) {
      var record = _ref8.record, index2 = _ref8.index;
      var _renderCell = renderCell({
        record,
        index: index2
      }), node = _renderCell.node, checked = _renderCell.checked;
      if (customizeRenderCell) {
        return customizeRenderCell(checked, record, index2, node);
      }
      return node;
    };
    if (!cloneColumns.includes(SELECTION_COLUMN)) {
      if (cloneColumns.findIndex(function(col) {
        var _a2;
        return ((_a2 = col[INTERNAL_COL_DEFINE]) === null || _a2 === void 0 ? void 0 : _a2.columnType) === "EXPAND_COLUMN";
      }) === 0) {
        var _cloneColumns = cloneColumns, _cloneColumns2 = _toArray(_cloneColumns), expandColumn = _cloneColumns2[0], restColumns = _cloneColumns2.slice(1);
        cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
      } else {
        cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
      }
    }
    var selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
    cloneColumns = cloneColumns.filter(function(column, index2) {
      return column !== SELECTION_COLUMN || index2 === selectionColumnIndex;
    });
    var prevCol = cloneColumns[selectionColumnIndex - 1];
    var nextCol = cloneColumns[selectionColumnIndex + 1];
    var mergedFixed = fixed;
    if (mergedFixed === void 0) {
      if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== void 0) {
        mergedFixed = nextCol.fixed;
      } else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== void 0) {
        mergedFixed = prevCol.fixed;
      }
    }
    if (mergedFixed && prevCol && ((_a = prevCol[INTERNAL_COL_DEFINE]) === null || _a === void 0 ? void 0 : _a.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
      prevCol.fixed = mergedFixed;
    }
    var selectionColumn = _defineProperty$T({
      fixed: mergedFixed,
      width: selectionColWidth,
      className: "".concat(prefixCls.value, "-selection-column"),
      title: mergedRowSelection.value.columnTitle || title,
      customRender: renderSelectionCell
    }, INTERNAL_COL_DEFINE, {
      class: "".concat(prefixCls.value, "-selection-col")
    });
    return cloneColumns.map(function(col) {
      return col === SELECTION_COLUMN ? selectionColumn : col;
    });
  };
  return [transformColumns, derivedSelectedKeySet];
}
var __rest$f = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function getColumnKey(column, defaultKey) {
  if ("key" in column && column.key !== void 0 && column.key !== null) {
    return column.key;
  }
  if (column.dataIndex) {
    return Array.isArray(column.dataIndex) ? column.dataIndex.join(".") : column.dataIndex;
  }
  return defaultKey;
}
function getColumnPos(index2, pos) {
  return pos ? "".concat(pos, "-").concat(index2) : "".concat(index2);
}
function renderColumnTitle(title, props2) {
  if (typeof title === "function") {
    return title(props2);
  }
  return title;
}
function convertChildrenToColumns() {
  var elements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var flattenElements = flattenChildren(elements);
  var columns = [];
  flattenElements.forEach(function(element) {
    var _a, _b, _c, _d;
    if (!element) {
      return;
    }
    var key2 = element.key;
    var style = ((_a = element.props) === null || _a === void 0 ? void 0 : _a.style) || {};
    var cls = ((_b = element.props) === null || _b === void 0 ? void 0 : _b.class) || "";
    var props2 = element.props || {};
    for (var _i = 0, _Object$entries = Object.entries(props2); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), k2 = _Object$entries$_i[0], v2 = _Object$entries$_i[1];
      props2[Vue.camelize(k2)] = v2;
    }
    var _e = element.children || {}, children = _e.default, restSlots = __rest$f(_e, ["default"]);
    var column = _extends(_extends(_extends({}, restSlots), props2), {
      style,
      class: cls
    });
    if (key2) {
      column.key = key2;
    }
    if ((_c = element.type) === null || _c === void 0 ? void 0 : _c.__ANT_TABLE_COLUMN_GROUP) {
      column.children = convertChildrenToColumns(typeof children === "function" ? children() : children);
    } else {
      var customRender = (_d = element.children) === null || _d === void 0 ? void 0 : _d.default;
      column.customRender = column.customRender || customRender;
    }
    columns.push(column);
  });
  return columns;
}
var ASCEND = "ascend";
var DESCEND = "descend";
function getMultiplePriority(column) {
  if (_typeof$1(column.sorter) === "object" && typeof column.sorter.multiple === "number") {
    return column.sorter.multiple;
  }
  return false;
}
function getSortFunction(sorter) {
  if (typeof sorter === "function") {
    return sorter;
  }
  if (sorter && _typeof$1(sorter) === "object" && sorter.compare) {
    return sorter.compare;
  }
  return false;
}
function nextSortDirection(sortDirections, current2) {
  if (!current2) {
    return sortDirections[0];
  }
  return sortDirections[sortDirections.indexOf(current2) + 1];
}
function collectSortStates(columns, init, pos) {
  var sortStates = [];
  function pushState(column, columnPos) {
    sortStates.push({
      column,
      key: getColumnKey(column, columnPos),
      multiplePriority: getMultiplePriority(column),
      sortOrder: column.sortOrder
    });
  }
  (columns || []).forEach(function(column, index2) {
    var columnPos = getColumnPos(index2, pos);
    if (column.children) {
      if ("sortOrder" in column) {
        pushState(column, columnPos);
      }
      sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column.children, init, columnPos)));
    } else if (column.sorter) {
      if ("sortOrder" in column) {
        pushState(column, columnPos);
      } else if (init && column.defaultSortOrder) {
        sortStates.push({
          column,
          key: getColumnKey(column, columnPos),
          multiplePriority: getMultiplePriority(column),
          sortOrder: column.defaultSortOrder
        });
      }
    }
  });
  return sortStates;
}
function injectSorter(prefixCls, columns, sorterSates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) {
  return (columns || []).map(function(column, index2) {
    var columnPos = getColumnPos(index2, pos);
    var newColumn = column;
    if (newColumn.sorter) {
      var sortDirections = newColumn.sortDirections || defaultSortDirections;
      var showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
      var columnKey = getColumnKey(newColumn, columnPos);
      var sorterState = sorterSates.find(function(_ref) {
        var key2 = _ref.key;
        return key2 === columnKey;
      });
      var sorterOrder = sorterState ? sorterState.sortOrder : null;
      var nextSortOrder = nextSortDirection(sortDirections, sorterOrder);
      var upNode = sortDirections.includes(ASCEND) && Vue.createVNode(CaretUpOutlined$1, {
        "class": classNames("".concat(prefixCls, "-column-sorter-up"), {
          active: sorterOrder === ASCEND
        })
      }, null);
      var downNode = sortDirections.includes(DESCEND) && Vue.createVNode(CaretDownOutlined$1, {
        "class": classNames("".concat(prefixCls, "-column-sorter-down"), {
          active: sorterOrder === DESCEND
        })
      }, null);
      var _ref2 = tableLocale || {}, cancelSort = _ref2.cancelSort, triggerAsc = _ref2.triggerAsc, triggerDesc = _ref2.triggerDesc;
      var sortTip = cancelSort;
      if (nextSortOrder === DESCEND) {
        sortTip = triggerDesc;
      } else if (nextSortOrder === ASCEND) {
        sortTip = triggerAsc;
      }
      var tooltipProps3 = _typeof$1(showSorterTooltip) === "object" ? showSorterTooltip : {
        title: sortTip
      };
      newColumn = _extends(_extends({}, newColumn), {
        className: classNames(newColumn.className, _defineProperty$T({}, "".concat(prefixCls, "-column-sort"), sorterOrder)),
        title: function title(renderProps) {
          var renderSortTitle = Vue.createVNode("div", {
            "class": "".concat(prefixCls, "-column-sorters")
          }, [Vue.createVNode("span", {
            "class": "".concat(prefixCls, "-column-title")
          }, [renderColumnTitle(column.title, renderProps)]), Vue.createVNode("span", {
            "class": classNames("".concat(prefixCls, "-column-sorter"), _defineProperty$T({}, "".concat(prefixCls, "-column-sorter-full"), !!(upNode && downNode)))
          }, [Vue.createVNode("span", {
            "class": "".concat(prefixCls, "-column-sorter-inner")
          }, [upNode, downNode])])]);
          return showSorterTooltip ? Vue.createVNode(_Tooltip, tooltipProps3, {
            default: function _default5() {
              return [renderSortTitle];
            }
          }) : renderSortTitle;
        },
        customHeaderCell: function customHeaderCell(col) {
          var cell = column.customHeaderCell && column.customHeaderCell(col) || {};
          var originOnClick = cell.onClick;
          cell.onClick = function(event) {
            triggerSorter({
              column,
              key: columnKey,
              sortOrder: nextSortOrder,
              multiplePriority: getMultiplePriority(column)
            });
            if (originOnClick) {
              originOnClick(event);
            }
          };
          cell.class = classNames(cell.class, "".concat(prefixCls, "-column-has-sorters"));
          return cell;
        }
      });
    }
    if ("children" in newColumn) {
      newColumn = _extends(_extends({}, newColumn), {
        children: injectSorter(prefixCls, newColumn.children, sorterSates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos)
      });
    }
    return newColumn;
  });
}
function stateToInfo(sorterStates) {
  var column = sorterStates.column, sortOrder = sorterStates.sortOrder;
  return {
    column,
    order: sortOrder,
    field: column.dataIndex,
    columnKey: column.key
  };
}
function generateSorterInfo(sorterStates) {
  var list = sorterStates.filter(function(_ref3) {
    var sortOrder = _ref3.sortOrder;
    return sortOrder;
  }).map(stateToInfo);
  if (list.length === 0 && sorterStates.length) {
    return _extends(_extends({}, stateToInfo(sorterStates[sorterStates.length - 1])), {
      column: void 0
    });
  }
  if (list.length <= 1) {
    return list[0] || {};
  }
  return list;
}
function getSortData(data4, sortStates, childrenColumnName) {
  var innerSorterStates = sortStates.slice().sort(function(a2, b2) {
    return b2.multiplePriority - a2.multiplePriority;
  });
  var cloneData = data4.slice();
  var runningSorters = innerSorterStates.filter(function(_ref4) {
    var sorter = _ref4.column.sorter, sortOrder = _ref4.sortOrder;
    return getSortFunction(sorter) && sortOrder;
  });
  if (!runningSorters.length) {
    return cloneData;
  }
  return cloneData.sort(function(record1, record2) {
    for (var i2 = 0; i2 < runningSorters.length; i2 += 1) {
      var sorterState = runningSorters[i2];
      var sorter = sorterState.column.sorter, sortOrder = sorterState.sortOrder;
      var compareFn = getSortFunction(sorter);
      if (compareFn && sortOrder) {
        var compareResult = compareFn(record1, record2, sortOrder);
        if (compareResult !== 0) {
          return sortOrder === ASCEND ? compareResult : -compareResult;
        }
      }
    }
    return 0;
  }).map(function(record) {
    var subRecords = record[childrenColumnName];
    if (subRecords) {
      return _extends(_extends({}, record), _defineProperty$T({}, childrenColumnName, getSortData(subRecords, sortStates, childrenColumnName)));
    }
    return record;
  });
}
function useFilterSorter(_ref5) {
  var prefixCls = _ref5.prefixCls, mergedColumns = _ref5.mergedColumns, onSorterChange = _ref5.onSorterChange, sortDirections = _ref5.sortDirections, tableLocale = _ref5.tableLocale, showSorterTooltip = _ref5.showSorterTooltip;
  var _useState = useState(collectSortStates(mergedColumns.value, true)), _useState2 = _slicedToArray(_useState, 2), sortStates = _useState2[0], setSortStates = _useState2[1];
  var mergedSorterStates = Vue.computed(function() {
    var validate = true;
    var collectedStates = collectSortStates(mergedColumns.value, false);
    if (!collectedStates.length) {
      return sortStates.value;
    }
    var validateStates = [];
    function patchStates(state) {
      if (validate) {
        validateStates.push(state);
      } else {
        validateStates.push(_extends(_extends({}, state), {
          sortOrder: null
        }));
      }
    }
    var multipleMode = null;
    collectedStates.forEach(function(state) {
      if (multipleMode === null) {
        patchStates(state);
        if (state.sortOrder) {
          if (state.multiplePriority === false) {
            validate = false;
          } else {
            multipleMode = true;
          }
        }
      } else if (multipleMode && state.multiplePriority !== false) {
        patchStates(state);
      } else {
        validate = false;
        patchStates(state);
      }
    });
    return validateStates;
  });
  var columnTitleSorterProps = Vue.computed(function() {
    var sortColumns = mergedSorterStates.value.map(function(_ref6) {
      var column = _ref6.column, sortOrder = _ref6.sortOrder;
      return {
        column,
        order: sortOrder
      };
    });
    return {
      sortColumns,
      sortColumn: sortColumns[0] && sortColumns[0].column,
      sortOrder: sortColumns[0] && sortColumns[0].order
    };
  });
  function triggerSorter(sortState) {
    var newSorterStates;
    if (sortState.multiplePriority === false || !mergedSorterStates.value.length || mergedSorterStates.value[0].multiplePriority === false) {
      newSorterStates = [sortState];
    } else {
      newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.value.filter(function(_ref7) {
        var key2 = _ref7.key;
        return key2 !== sortState.key;
      })), [sortState]);
    }
    setSortStates(newSorterStates);
    onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
  }
  var transformColumns = function transformColumns2(innerColumns) {
    return injectSorter(prefixCls.value, innerColumns, mergedSorterStates.value, triggerSorter, sortDirections.value, tableLocale.value, showSorterTooltip.value);
  };
  var sorters = Vue.computed(function() {
    return generateSorterInfo(mergedSorterStates.value);
  });
  return [transformColumns, mergedSorterStates, columnTitleSorterProps, sorters];
}
var FilterDropdownMenuWrapper = function FilterDropdownMenuWrapper2(_props, _ref) {
  var slots = _ref.slots;
  var _a;
  return Vue.createVNode("div", {
    "onClick": function onClick2(e2) {
      return e2.stopPropagation();
    }
  }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
};
var FilterDropdownMenuWrapper$1 = FilterDropdownMenuWrapper;
var inputProps = function inputProps2() {
  return {
    id: String,
    prefixCls: String,
    inputPrefixCls: String,
    defaultValue: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
    value: {
      type: [String, Number, Symbol],
      default: void 0
    },
    placeholder: {
      type: [String, Number]
    },
    autocomplete: String,
    type: {
      type: String,
      default: "text"
    },
    name: String,
    size: {
      type: String
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    readonly: {
      type: Boolean,
      default: void 0
    },
    addonBefore: PropTypes$1.any,
    addonAfter: PropTypes$1.any,
    prefix: PropTypes$1.any,
    suffix: PropTypes$1.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    allowClear: {
      type: Boolean,
      default: void 0
    },
    lazy: {
      type: Boolean,
      default: true
    },
    maxlength: Number,
    loading: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: void 0
    },
    showCount: {
      type: [Boolean, Object]
    },
    htmlSize: Number,
    onPressEnter: Function,
    onKeydown: Function,
    onKeyup: Function,
    onFocus: Function,
    onBlur: Function,
    onChange: Function,
    onInput: Function,
    "onUpdate:value": Function,
    valueModifiers: Object,
    hidden: Boolean
  };
};
var inputProps$1 = inputProps;
var textAreaProps = function textAreaProps2() {
  return _extends(_extends({}, omit(inputProps(), ["prefix", "addonBefore", "addonAfter", "suffix"])), {
    rows: Number,
    autosize: {
      type: [Boolean, Object],
      default: void 0
    },
    autoSize: {
      type: [Boolean, Object],
      default: void 0
    },
    onResize: {
      type: Function
    },
    onCompositionstart: Function,
    onCompositionend: Function,
    valueModifiers: Object
  });
};
function getInputClassName(prefixCls, bordered, size, disabled, direction) {
  var _classNames;
  return classNames(prefixCls, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls, "-sm"), size === "small"), _defineProperty$T(_classNames, "".concat(prefixCls, "-lg"), size === "large"), _defineProperty$T(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$T(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$T(_classNames, "".concat(prefixCls, "-borderless"), !bordered), _classNames));
}
var isValid = function isValid4(value) {
  return value !== void 0 && value !== null && (Array.isArray(value) ? filterEmpty(value).length : true);
};
function hasPrefixSuffix(propsAndSlots) {
  return isValid(propsAndSlots.prefix) || isValid(propsAndSlots.suffix) || isValid(propsAndSlots.allowClear);
}
function hasAddon(propsAndSlots) {
  return isValid(propsAndSlots.addonBefore) || isValid(propsAndSlots.addonAfter);
}
var ClearableInputType = ["text", "input"];
var ClearableLabeledInput = Vue.defineComponent({
  name: "ClearableLabeledInput",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    inputType: PropTypes$1.oneOf(tuple$1("text", "input")),
    value: PropTypes$1.any,
    defaultValue: PropTypes$1.any,
    allowClear: {
      type: Boolean,
      default: void 0
    },
    element: PropTypes$1.any,
    handleReset: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String
    },
    size: {
      type: String
    },
    suffix: PropTypes$1.any,
    prefix: PropTypes$1.any,
    addonBefore: PropTypes$1.any,
    addonAfter: PropTypes$1.any,
    readonly: {
      type: Boolean,
      default: void 0
    },
    focused: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: true
    },
    triggerFocus: {
      type: Function
    },
    hidden: Boolean
  },
  setup: function setup102(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var containerRef = Vue.ref();
    var onInputMouseUp = function onInputMouseUp2(e2) {
      var _a;
      if ((_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.contains(e2.target)) {
        var triggerFocus2 = props2.triggerFocus;
        triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
      }
    };
    var renderClearIcon = function renderClearIcon2(prefixCls) {
      var _classNames;
      var allowClear = props2.allowClear, value = props2.value, disabled = props2.disabled, readonly = props2.readonly, handleReset = props2.handleReset, _props$suffix = props2.suffix, suffix = _props$suffix === void 0 ? slots.suffix : _props$suffix;
      if (!allowClear) {
        return null;
      }
      var needClear = !disabled && !readonly && value;
      var className = "".concat(prefixCls, "-clear-icon");
      return Vue.createVNode(CloseCircleFilled$1, {
        "onClick": handleReset,
        "onMousedown": function onMousedown2(e2) {
          return e2.preventDefault();
        },
        "class": classNames((_classNames = {}, _defineProperty$T(_classNames, "".concat(className, "-hidden"), !needClear), _defineProperty$T(_classNames, "".concat(className, "-has-suffix"), !!suffix), _classNames), className),
        "role": "button"
      }, null);
    };
    var renderSuffix = function renderSuffix2(prefixCls) {
      var _a;
      var _props$suffix2 = props2.suffix, suffix = _props$suffix2 === void 0 ? (_a = slots.suffix) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$suffix2, allowClear = props2.allowClear;
      if (suffix || allowClear) {
        return Vue.createVNode("span", {
          "class": "".concat(prefixCls, "-suffix")
        }, [renderClearIcon(prefixCls), suffix]);
      }
      return null;
    };
    var renderLabeledIcon = function renderLabeledIcon2(prefixCls, element) {
      var _classNames2;
      var _a, _b;
      var focused = props2.focused, value = props2.value, _props$prefix = props2.prefix, prefix = _props$prefix === void 0 ? (_a = slots.prefix) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$prefix, size = props2.size, _props$suffix3 = props2.suffix, suffix = _props$suffix3 === void 0 ? (_b = slots.suffix) === null || _b === void 0 ? void 0 : _b.call(slots) : _props$suffix3, disabled = props2.disabled, allowClear = props2.allowClear, direction = props2.direction, readonly = props2.readonly, bordered = props2.bordered, hidden = props2.hidden, _props$addonAfter = props2.addonAfter, addonAfter = _props$addonAfter === void 0 ? slots.addonAfter : _props$addonAfter, _props$addonBefore = props2.addonBefore, addonBefore = _props$addonBefore === void 0 ? slots.addonBefore : _props$addonBefore;
      var suffixNode = renderSuffix(prefixCls);
      if (!hasPrefixSuffix({
        prefix,
        suffix,
        allowClear
      })) {
        return cloneElement(element, {
          value
        });
      }
      var prefixNode = prefix ? Vue.createVNode("span", {
        "class": "".concat(prefixCls, "-prefix")
      }, [prefix]) : null;
      var affixWrapperCls = classNames("".concat(prefixCls, "-affix-wrapper"), (_classNames2 = {}, _defineProperty$T(_classNames2, "".concat(prefixCls, "-affix-wrapper-focused"), focused), _defineProperty$T(_classNames2, "".concat(prefixCls, "-affix-wrapper-disabled"), disabled), _defineProperty$T(_classNames2, "".concat(prefixCls, "-affix-wrapper-sm"), size === "small"), _defineProperty$T(_classNames2, "".concat(prefixCls, "-affix-wrapper-lg"), size === "large"), _defineProperty$T(_classNames2, "".concat(prefixCls, "-affix-wrapper-input-with-clear-btn"), suffix && allowClear && value), _defineProperty$T(_classNames2, "".concat(prefixCls, "-affix-wrapper-rtl"), direction === "rtl"), _defineProperty$T(_classNames2, "".concat(prefixCls, "-affix-wrapper-readonly"), readonly), _defineProperty$T(_classNames2, "".concat(prefixCls, "-affix-wrapper-borderless"), !bordered), _defineProperty$T(_classNames2, "".concat(attrs.class), !hasAddon({
        addonAfter,
        addonBefore
      }) && attrs.class), _classNames2));
      return Vue.createVNode("span", {
        "ref": containerRef,
        "class": affixWrapperCls,
        "style": attrs.style,
        "onMouseup": onInputMouseUp,
        "hidden": hidden
      }, [prefixNode, cloneElement(element, {
        style: null,
        value,
        class: getInputClassName(prefixCls, bordered, size, disabled)
      }), suffixNode]);
    };
    var renderInputWithLabel = function renderInputWithLabel2(prefixCls, labeledElement) {
      var _classNames4;
      var _a, _b;
      var _props$addonBefore2 = props2.addonBefore, addonBefore = _props$addonBefore2 === void 0 ? (_a = slots.addonBefore) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$addonBefore2, _props$addonAfter2 = props2.addonAfter, addonAfter = _props$addonAfter2 === void 0 ? (_b = slots.addonAfter) === null || _b === void 0 ? void 0 : _b.call(slots) : _props$addonAfter2, size = props2.size, direction = props2.direction, hidden = props2.hidden;
      if (!hasAddon({
        addonBefore,
        addonAfter
      })) {
        return labeledElement;
      }
      var wrapperClassName = "".concat(prefixCls, "-group");
      var addonClassName = "".concat(wrapperClassName, "-addon");
      var addonBeforeNode = addonBefore ? Vue.createVNode("span", {
        "class": addonClassName
      }, [addonBefore]) : null;
      var addonAfterNode = addonAfter ? Vue.createVNode("span", {
        "class": addonClassName
      }, [addonAfter]) : null;
      var mergedWrapperClassName = classNames("".concat(prefixCls, "-wrapper"), wrapperClassName, _defineProperty$T({}, "".concat(wrapperClassName, "-rtl"), direction === "rtl"));
      var mergedGroupClassName = classNames("".concat(prefixCls, "-group-wrapper"), (_classNames4 = {}, _defineProperty$T(_classNames4, "".concat(prefixCls, "-group-wrapper-sm"), size === "small"), _defineProperty$T(_classNames4, "".concat(prefixCls, "-group-wrapper-lg"), size === "large"), _defineProperty$T(_classNames4, "".concat(prefixCls, "-group-wrapper-rtl"), direction === "rtl"), _classNames4), attrs.class);
      return Vue.createVNode("span", {
        "class": mergedGroupClassName,
        "style": attrs.style,
        "hidden": hidden
      }, [Vue.createVNode("span", {
        "class": mergedWrapperClassName
      }, [addonBeforeNode, cloneElement(labeledElement, {
        style: null
      }), addonAfterNode])]);
    };
    var renderTextAreaWithClearIcon = function renderTextAreaWithClearIcon2(prefixCls, element) {
      var _classNames5;
      var value = props2.value, allowClear = props2.allowClear, direction = props2.direction, bordered = props2.bordered, hidden = props2.hidden, _props$addonAfter3 = props2.addonAfter, addonAfter = _props$addonAfter3 === void 0 ? slots.addonAfter : _props$addonAfter3, _props$addonBefore3 = props2.addonBefore, addonBefore = _props$addonBefore3 === void 0 ? slots.addonBefore : _props$addonBefore3;
      if (!allowClear) {
        return cloneElement(element, {
          value
        });
      }
      var affixWrapperCls = classNames("".concat(prefixCls, "-affix-wrapper"), "".concat(prefixCls, "-affix-wrapper-textarea-with-clear-btn"), (_classNames5 = {}, _defineProperty$T(_classNames5, "".concat(prefixCls, "-affix-wrapper-rtl"), direction === "rtl"), _defineProperty$T(_classNames5, "".concat(prefixCls, "-affix-wrapper-borderless"), !bordered), _defineProperty$T(_classNames5, "".concat(attrs.class), !hasAddon({
        addonAfter,
        addonBefore
      }) && attrs.class), _classNames5));
      return Vue.createVNode("span", {
        "class": affixWrapperCls,
        "style": attrs.style,
        "hidden": hidden
      }, [cloneElement(element, {
        style: null,
        value
      }), renderClearIcon(prefixCls)]);
    };
    return function() {
      var _a;
      var prefixCls = props2.prefixCls, inputType = props2.inputType, _props$element = props2.element, element = _props$element === void 0 ? (_a = slots.element) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$element;
      if (inputType === ClearableInputType[0]) {
        return renderTextAreaWithClearIcon(prefixCls, element);
      }
      return renderInputWithLabel(prefixCls, renderLabeledIcon(prefixCls, element));
    };
  }
});
function fixControlledValue(value) {
  if (typeof value === "undefined" || value === null) {
    return "";
  }
  return String(value);
}
function resolveOnChange(target, e2, onChange, targetValue) {
  if (!onChange) {
    return;
  }
  var event = e2;
  if (e2.type === "click") {
    Object.defineProperty(event, "target", {
      writable: true
    });
    Object.defineProperty(event, "currentTarget", {
      writable: true
    });
    var currentTarget = target.cloneNode(true);
    event.target = currentTarget;
    event.currentTarget = currentTarget;
    currentTarget.value = "";
    onChange(event);
    return;
  }
  if (targetValue !== void 0) {
    Object.defineProperty(event, "target", {
      writable: true
    });
    Object.defineProperty(event, "currentTarget", {
      writable: true
    });
    event.target = target;
    event.currentTarget = target;
    target.value = targetValue;
    onChange(event);
    return;
  }
  onChange(event);
}
function triggerFocus(element, option) {
  if (!element)
    return;
  element.focus(option);
  var _ref = option || {}, cursor = _ref.cursor;
  if (cursor) {
    var len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}
var Input$1 = Vue.defineComponent({
  name: "AInput",
  inheritAttrs: false,
  props: inputProps$1(),
  setup: function setup103(props2, _ref2) {
    var slots = _ref2.slots, attrs = _ref2.attrs, expose = _ref2.expose, emit = _ref2.emit;
    var inputRef = Vue.ref();
    var clearableInputRef = Vue.ref();
    var removePasswordTimeout;
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("input", props2), direction = _useConfigInject.direction, prefixCls = _useConfigInject.prefixCls, size = _useConfigInject.size, autocomplete = _useConfigInject.autocomplete;
    var stateValue = Vue.ref(props2.value === void 0 ? props2.defaultValue : props2.value);
    var focused = Vue.ref(false);
    Vue.watch(function() {
      return props2.value;
    }, function() {
      stateValue.value = props2.value;
    });
    Vue.watch(function() {
      return props2.disabled;
    }, function() {
      if (props2.value !== void 0) {
        stateValue.value = props2.value;
      }
      if (props2.disabled) {
        focused.value = false;
      }
    });
    var clearPasswordValueAttribute = function clearPasswordValueAttribute2() {
      removePasswordTimeout = setTimeout(function() {
        var _a;
        if (((_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.getAttribute("type")) === "password" && inputRef.value.hasAttribute("value")) {
          inputRef.value.removeAttribute("value");
        }
      });
    };
    var focus = function focus2(option) {
      triggerFocus(inputRef.value, option);
    };
    var blur = function blur2() {
      var _a;
      (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    var setSelectionRange = function setSelectionRange2(start, end, direction2) {
      var _a;
      (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.setSelectionRange(start, end, direction2);
    };
    var select = function select2() {
      var _a;
      (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.select();
    };
    expose({
      focus,
      blur,
      input: inputRef,
      stateValue,
      setSelectionRange,
      select
    });
    var onFocus2 = function onFocus3(e2) {
      var onFocus4 = props2.onFocus;
      focused.value = true;
      onFocus4 === null || onFocus4 === void 0 ? void 0 : onFocus4(e2);
      Vue.nextTick(function() {
        clearPasswordValueAttribute();
      });
    };
    var onBlur2 = function onBlur3(e2) {
      var onBlur4 = props2.onBlur;
      focused.value = false;
      onBlur4 === null || onBlur4 === void 0 ? void 0 : onBlur4(e2);
      formItemContext.onFieldBlur();
      Vue.nextTick(function() {
        clearPasswordValueAttribute();
      });
    };
    var triggerChange = function triggerChange2(e2) {
      emit("update:value", e2.target.value);
      emit("change", e2);
      emit("input", e2);
      formItemContext.onFieldChange();
    };
    var instance = Vue.getCurrentInstance();
    var setValue = function setValue2(value, callback) {
      if (stateValue.value === value) {
        return;
      }
      if (props2.value === void 0) {
        stateValue.value = value;
      } else {
        Vue.nextTick(function() {
          if (inputRef.value.value !== stateValue.value) {
            instance.update();
          }
        });
      }
      Vue.nextTick(function() {
        callback && callback();
      });
    };
    var handleReset = function handleReset2(e2) {
      resolveOnChange(inputRef.value, e2, triggerChange);
      setValue("", function() {
        focus();
      });
    };
    var handleChange2 = function handleChange3(e2) {
      var _e$target = e2.target, value = _e$target.value, composing = _e$target.composing;
      if ((e2.isComposing || composing) && props2.lazy || stateValue.value === value)
        return;
      var newVal = e2.target.value;
      resolveOnChange(inputRef.value, e2, triggerChange);
      setValue(newVal, function() {
        clearPasswordValueAttribute();
      });
    };
    var handleKeyDown2 = function handleKeyDown3(e2) {
      if (e2.keyCode === 13) {
        emit("pressEnter", e2);
      }
      emit("keydown", e2);
    };
    Vue.onMounted(function() {
      clearPasswordValueAttribute();
    });
    Vue.onBeforeUnmount(function() {
      clearTimeout(removePasswordTimeout);
    });
    var renderInput = function renderInput2() {
      var _a;
      var _props$addonBefore = props2.addonBefore, addonBefore = _props$addonBefore === void 0 ? slots.addonBefore : _props$addonBefore, _props$addonAfter = props2.addonAfter, addonAfter = _props$addonAfter === void 0 ? slots.addonAfter : _props$addonAfter, disabled = props2.disabled, _props$bordered = props2.bordered, bordered = _props$bordered === void 0 ? true : _props$bordered, _props$valueModifiers = props2.valueModifiers, valueModifiers = _props$valueModifiers === void 0 ? {} : _props$valueModifiers, htmlSize = props2.htmlSize;
      var otherProps = omit(props2, [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",
        "defaultValue",
        "size",
        "bordered",
        "htmlSize",
        "lazy",
        "showCount",
        "valueModifiers"
      ]);
      var inputProps3 = _extends(_extends(_extends({}, otherProps), attrs), {
        autocomplete: autocomplete.value,
        onChange: handleChange2,
        onInput: handleChange2,
        onFocus: onFocus2,
        onBlur: onBlur2,
        onKeydown: handleKeyDown2,
        class: classNames(getInputClassName(prefixCls.value, bordered, size.value, disabled, direction.value), _defineProperty$T({}, attrs.class, attrs.class && !addonBefore && !addonAfter)),
        ref: inputRef,
        key: "ant-input",
        size: htmlSize,
        id: (_a = otherProps.id) !== null && _a !== void 0 ? _a : formItemContext.id.value
      });
      if (valueModifiers.lazy) {
        delete inputProps3.onInput;
      }
      if (!inputProps3.autofocus) {
        delete inputProps3.autofocus;
      }
      var inputNode = Vue.createVNode("input", omit(inputProps3, ["size"]), null);
      return Vue.withDirectives(inputNode, [[antInput$1]]);
    };
    var renderShowCountSuffix = function renderShowCountSuffix2() {
      var _a;
      var value = stateValue.value;
      var maxlength = props2.maxlength, _props$suffix = props2.suffix, suffix = _props$suffix === void 0 ? (_a = slots.suffix) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$suffix, showCount = props2.showCount;
      var hasMaxLength = Number(maxlength) > 0;
      if (suffix || showCount) {
        var valueLength = _toConsumableArray(fixControlledValue(value)).length;
        var dataCount = null;
        if (_typeof$1(showCount) === "object") {
          dataCount = showCount.formatter({
            count: valueLength,
            maxlength
          });
        } else {
          dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxlength) : "");
        }
        return Vue.createVNode(Vue.Fragment, null, [!!showCount && Vue.createVNode("span", {
          "class": classNames("".concat(prefixCls.value, "-show-count-suffix"), _defineProperty$T({}, "".concat(prefixCls.value, "-show-count-has-suffix"), !!suffix))
        }, [dataCount]), suffix]);
      }
      return null;
    };
    return function() {
      var inputProps3 = _extends(_extends(_extends({}, attrs), props2), {
        prefixCls: prefixCls.value,
        inputType: "input",
        value: fixControlledValue(stateValue.value),
        handleReset,
        focused: focused.value && !props2.disabled
      });
      return Vue.createVNode(ClearableLabeledInput, _objectSpread2$1(_objectSpread2$1({}, omit(inputProps3, ["element", "valueModifiers", "suffix", "showCount"])), {}, {
        "ref": clearableInputRef
      }), _extends(_extends({}, slots), {
        element: renderInput,
        suffix: renderShowCountSuffix
      }));
    };
  }
});
var Group$2 = Vue.defineComponent({
  name: "AInputGroup",
  props: {
    prefixCls: String,
    size: {
      type: String
    },
    compact: {
      type: Boolean,
      default: void 0
    },
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    }
  },
  setup: function setup104(props2, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("input-group", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var cls = Vue.computed(function() {
      var _ref2;
      var pre = prefixCls.value;
      return _ref2 = {}, _defineProperty$T(_ref2, "".concat(pre), true), _defineProperty$T(_ref2, "".concat(pre, "-lg"), props2.size === "large"), _defineProperty$T(_ref2, "".concat(pre, "-sm"), props2.size === "small"), _defineProperty$T(_ref2, "".concat(pre, "-compact"), props2.compact), _defineProperty$T(_ref2, "".concat(pre, "-rtl"), direction.value === "rtl"), _ref2;
    });
    return function() {
      var _a;
      return Vue.createVNode("span", {
        "class": cls.value,
        "onMouseenter": props2.onMouseEnter,
        "onMouseleave": props2.onMouseLeave,
        "onFocus": props2.onFocus,
        "onBlur": props2.onBlur
      }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
var applePhone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /\bAndroid(?:.+)SD4930UR\b/i;
var amazonTablet = /\bAndroid(?:.+)(?:KF[A-Z]{2,4})\b/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackberry = /BlackBerry/i;
var otherBlackberry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
function match(regex, userAgent) {
  return regex.test(userAgent);
}
function isMobile(userAgent) {
  var ua = userAgent || (typeof navigator !== "undefined" ? navigator.userAgent : "");
  var tmp = ua.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    var _tmp = tmp;
    var _tmp2 = _slicedToArray(_tmp, 1);
    ua = _tmp2[0];
  }
  tmp = ua.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    var _tmp3 = tmp;
    var _tmp4 = _slicedToArray(_tmp3, 1);
    ua = _tmp4[0];
  }
  var result = {
    apple: {
      phone: match(applePhone, ua) && !match(windowsPhone, ua),
      ipod: match(appleIpod, ua),
      tablet: !match(applePhone, ua) && match(appleTablet, ua) && !match(windowsPhone, ua),
      device: (match(applePhone, ua) || match(appleIpod, ua) || match(appleTablet, ua)) && !match(windowsPhone, ua)
    },
    amazon: {
      phone: match(amazonPhone, ua),
      tablet: !match(amazonPhone, ua) && match(amazonTablet, ua),
      device: match(amazonPhone, ua) || match(amazonTablet, ua)
    },
    android: {
      phone: !match(windowsPhone, ua) && match(amazonPhone, ua) || !match(windowsPhone, ua) && match(androidPhone, ua),
      tablet: !match(windowsPhone, ua) && !match(amazonPhone, ua) && !match(androidPhone, ua) && (match(amazonTablet, ua) || match(androidTablet, ua)),
      device: !match(windowsPhone, ua) && (match(amazonPhone, ua) || match(amazonTablet, ua) || match(androidPhone, ua) || match(androidTablet, ua)) || match(/\bokhttp\b/i, ua)
    },
    windows: {
      phone: match(windowsPhone, ua),
      tablet: match(windowsTablet, ua),
      device: match(windowsPhone, ua) || match(windowsTablet, ua)
    },
    other: {
      blackberry: match(otherBlackberry, ua),
      blackberry10: match(otherBlackberry10, ua),
      opera: match(otherOpera, ua),
      firefox: match(otherFirefox, ua),
      chrome: match(otherChrome, ua),
      device: match(otherBlackberry, ua) || match(otherBlackberry10, ua) || match(otherOpera, ua) || match(otherFirefox, ua) || match(otherChrome, ua)
    },
    any: null,
    phone: null,
    tablet: null
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
var defaultResult = _extends(_extends({}, isMobile()), {
  isMobile
});
var isMobile$1 = defaultResult;
var __rest$e = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var Search = Vue.defineComponent({
  name: "AInputSearch",
  inheritAttrs: false,
  props: _extends(_extends({}, inputProps$1()), {
    inputPrefixCls: String,
    enterButton: PropTypes$1.any,
    onSearch: {
      type: Function
    }
  }),
  setup: function setup105(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose, emit = _ref.emit;
    var inputRef = Vue.ref();
    var focus = function focus2() {
      var _a;
      (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    var blur = function blur2() {
      var _a;
      (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    expose({
      focus,
      blur
    });
    var onChange = function onChange2(e2) {
      emit("update:value", e2.target.value);
      if (e2 && e2.target && e2.type === "click") {
        emit("search", e2.target.value, e2);
      }
      emit("change", e2);
    };
    var onMousedown2 = function onMousedown3(e2) {
      var _a;
      if (document.activeElement === ((_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.input)) {
        e2.preventDefault();
      }
    };
    var onSearch = function onSearch2(e2) {
      var _a;
      emit("search", (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.stateValue, e2);
      if (!isMobile$1.tablet) {
        inputRef.value.focus();
      }
    };
    var _useConfigInject = useConfigInject("input-search", props2), prefixCls = _useConfigInject.prefixCls, getPrefixCls2 = _useConfigInject.getPrefixCls, direction = _useConfigInject.direction, size = _useConfigInject.size;
    var inputPrefixCls = Vue.computed(function() {
      return getPrefixCls2("input", props2.inputPrefixCls);
    });
    return function() {
      var _classNames;
      var _a, _b, _c, _d;
      var disabled = props2.disabled, loading = props2.loading, _props$addonAfter = props2.addonAfter, addonAfter = _props$addonAfter === void 0 ? (_a = slots.addonAfter) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$addonAfter, _props$suffix = props2.suffix, suffix = _props$suffix === void 0 ? (_b = slots.suffix) === null || _b === void 0 ? void 0 : _b.call(slots) : _props$suffix, restProps = __rest$e(props2, ["disabled", "loading", "addonAfter", "suffix"]);
      var _props$enterButton = props2.enterButton, enterButton = _props$enterButton === void 0 ? (_d = (_c = slots.enterButton) === null || _c === void 0 ? void 0 : _c.call(slots)) !== null && _d !== void 0 ? _d : false : _props$enterButton;
      enterButton = enterButton || enterButton === "";
      var searchIcon = typeof enterButton === "boolean" ? Vue.createVNode(SearchOutlined$1, null, null) : null;
      var btnClassName = "".concat(prefixCls.value, "-button");
      var enterButtonAsElement = Array.isArray(enterButton) ? enterButton[0] : enterButton;
      var button;
      var isAntdButton = enterButtonAsElement.type && isPlainObject(enterButtonAsElement.type) && enterButtonAsElement.type.__ANT_BUTTON;
      if (isAntdButton || enterButtonAsElement.tagName === "button") {
        button = cloneElement(enterButtonAsElement, _extends({
          onMousedown: onMousedown2,
          onClick: onSearch,
          key: "enterButton"
        }, isAntdButton ? {
          class: btnClassName,
          size: size.value
        } : {}), false);
      } else {
        var iconOnly = searchIcon && !enterButton;
        button = Vue.createVNode(Button$1, {
          "class": btnClassName,
          "type": enterButton ? "primary" : void 0,
          "size": size.value,
          "disabled": disabled,
          "key": "enterButton",
          "onMousedown": onMousedown2,
          "onClick": onSearch,
          "loading": loading,
          "icon": iconOnly ? searchIcon : null
        }, {
          default: function _default5() {
            return [iconOnly ? null : searchIcon || enterButton];
          }
        });
      }
      if (addonAfter) {
        button = [button, addonAfter];
      }
      var cls = classNames(prefixCls.value, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-").concat(size.value), !!size.value), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-with-button"), !!enterButton), _classNames), attrs.class);
      return Vue.createVNode(Input$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "ref": inputRef
      }, omit(restProps, ["onUpdate:value", "onSearch", "enterButton"])), attrs), {}, {
        "onPressEnter": onSearch,
        "size": size.value,
        "prefixCls": inputPrefixCls.value,
        "addonAfter": button,
        "suffix": suffix,
        "onChange": onChange,
        "class": cls,
        "disabled": disabled
      }), slots);
    };
  }
});
var HIDDEN_TEXTAREA_STYLE = "\n min-height:0 !important;\n max-height:none !important;\n height:0 !important;\n visibility:hidden !important;\n overflow:hidden !important;\n position:absolute !important;\n z-index:-1000 !important;\n top:0 !important;\n right:0 !important\n";
var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break"];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node) {
  var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var nodeRef = node.getAttribute("id") || node.getAttribute("data-reactid") || node.getAttribute("name");
  if (useCache2 && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }
  var style = window.getComputedStyle(node);
  var boxSizing = style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing");
  var paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
  var borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
  var sizingStyle = SIZING_STYLE.map(function(name) {
    return "".concat(name, ":").concat(style.getPropertyValue(name));
  }).join(";");
  var nodeInfo = {
    sizingStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
  if (useCache2 && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }
  return nodeInfo;
}
function calculateNodeHeight(uiTextNode) {
  var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tab-index", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    document.body.appendChild(hiddenTextarea);
  }
  if (uiTextNode.getAttribute("wrap")) {
    hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
  } else {
    hiddenTextarea.removeAttribute("wrap");
  }
  var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache2), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
  hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
  var minHeight = Number.MIN_SAFE_INTEGER;
  var maxHeight = Number.MAX_SAFE_INTEGER;
  var height = hiddenTextarea.scrollHeight;
  var overflowY;
  if (boxSizing === "border-box") {
    height += borderSize;
  } else if (boxSizing === "content-box") {
    height -= paddingSize;
  }
  if (minRows !== null || maxRows !== null) {
    hiddenTextarea.value = " ";
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;
      if (boxSizing === "border-box") {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
    }
    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;
      if (boxSizing === "border-box") {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      overflowY = height > maxHeight ? "" : "hidden";
      height = Math.min(maxHeight, height);
    }
  }
  return {
    height: "".concat(height, "px"),
    minHeight: "".concat(minHeight, "px"),
    maxHeight: "".concat(maxHeight, "px"),
    overflowY,
    resize: "none"
  };
}
var RESIZE_STATUS_NONE = 0;
var RESIZE_STATUS_RESIZING = 1;
var RESIZE_STATUS_RESIZED = 2;
var ResizableTextArea = Vue.defineComponent({
  name: "ResizableTextArea",
  inheritAttrs: false,
  props: textAreaProps(),
  setup: function setup106(props2, _ref) {
    var attrs = _ref.attrs, emit = _ref.emit, expose = _ref.expose;
    var nextFrameActionId;
    var resizeFrameId;
    var textAreaRef = Vue.ref();
    var textareaStyles = Vue.ref({});
    var resizeStatus = Vue.ref(RESIZE_STATUS_NONE);
    Vue.onBeforeUnmount(function() {
      wrapperRaf.cancel(nextFrameActionId);
      wrapperRaf.cancel(resizeFrameId);
    });
    var fixFirefoxAutoScroll = function fixFirefoxAutoScroll2() {
      try {
        if (document.activeElement === textAreaRef.value) {
          var currentStart = textAreaRef.value.selectionStart;
          var currentEnd = textAreaRef.value.selectionEnd;
          textAreaRef.value.setSelectionRange(currentStart, currentEnd);
        }
      } catch (e2) {
      }
    };
    var resizeTextarea = function resizeTextarea2() {
      var autoSize = props2.autoSize || props2.autosize;
      if (!autoSize || !textAreaRef.value) {
        return;
      }
      var minRows = autoSize.minRows, maxRows = autoSize.maxRows;
      textareaStyles.value = calculateNodeHeight(textAreaRef.value, false, minRows, maxRows);
      resizeStatus.value = RESIZE_STATUS_RESIZING;
      wrapperRaf.cancel(resizeFrameId);
      resizeFrameId = wrapperRaf(function() {
        resizeStatus.value = RESIZE_STATUS_RESIZED;
        resizeFrameId = wrapperRaf(function() {
          resizeStatus.value = RESIZE_STATUS_NONE;
          fixFirefoxAutoScroll();
        });
      });
    };
    var resizeOnNextFrame = function resizeOnNextFrame2() {
      wrapperRaf.cancel(nextFrameActionId);
      nextFrameActionId = wrapperRaf(resizeTextarea);
    };
    var handleResize = function handleResize2(size) {
      if (resizeStatus.value !== RESIZE_STATUS_NONE) {
        return;
      }
      emit("resize", size);
      var autoSize = props2.autoSize || props2.autosize;
      if (autoSize) {
        resizeOnNextFrame();
      }
    };
    warning(props2.autosize === void 0, "Input.TextArea", "autosize is deprecated, please use autoSize instead.");
    var renderTextArea = function renderTextArea2() {
      var prefixCls = props2.prefixCls, autoSize = props2.autoSize, autosize = props2.autosize, disabled = props2.disabled;
      var otherProps = omit(props2, ["prefixCls", "onPressEnter", "autoSize", "autosize", "defaultValue", "allowClear", "type", "lazy", "maxlength", "valueModifiers"]);
      var cls = classNames(prefixCls, attrs.class, _defineProperty$T({}, "".concat(prefixCls, "-disabled"), disabled));
      var style = [attrs.style, textareaStyles.value, resizeStatus.value === RESIZE_STATUS_RESIZING ? {
        overflowX: "hidden",
        overflowY: "hidden"
      } : null];
      var textareaProps = _extends(_extends(_extends({}, otherProps), attrs), {
        style,
        class: cls
      });
      if (!textareaProps.autofocus) {
        delete textareaProps.autofocus;
      }
      return Vue.createVNode(ResizeObserver$1, {
        "onResize": handleResize,
        "disabled": !(autoSize || autosize)
      }, {
        default: function _default5() {
          return [Vue.withDirectives(Vue.createVNode("textarea", _objectSpread2$1(_objectSpread2$1({}, textareaProps), {}, {
            "ref": textAreaRef
          }), null), [[antInput$1]])];
        }
      });
    };
    Vue.watch(function() {
      return props2.value;
    }, function() {
      Vue.nextTick(function() {
        resizeTextarea();
      });
    });
    Vue.onMounted(function() {
      Vue.nextTick(function() {
        resizeTextarea();
      });
    });
    var instance = Vue.getCurrentInstance();
    expose({
      resizeTextarea,
      textArea: textAreaRef,
      instance
    });
    return function() {
      return renderTextArea();
    };
  }
});
var ResizableTextArea$1 = ResizableTextArea;
function fixEmojiLength(value, maxLength) {
  return _toConsumableArray(value || "").slice(0, maxLength).join("");
}
function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
  var newTriggerValue = triggerValue;
  if (isCursorInEnd) {
    newTriggerValue = fixEmojiLength(triggerValue, maxLength);
  } else if (_toConsumableArray(preValue || "").length < triggerValue.length && _toConsumableArray(triggerValue || "").length > maxLength) {
    newTriggerValue = preValue;
  }
  return newTriggerValue;
}
var Textarea = Vue.defineComponent({
  name: "ATextarea",
  inheritAttrs: false,
  props: textAreaProps(),
  setup: function setup107(props2, _ref) {
    var attrs = _ref.attrs, expose = _ref.expose, emit = _ref.emit;
    var formItemContext = useInjectFormItemContext();
    var stateValue = Vue.ref(props2.value === void 0 ? props2.defaultValue : props2.value);
    var resizableTextArea = Vue.ref();
    var mergedValue = Vue.ref("");
    var _useConfigInject = useConfigInject("input", props2), prefixCls = _useConfigInject.prefixCls, size = _useConfigInject.size, direction = _useConfigInject.direction;
    var showCount = Vue.computed(function() {
      return props2.showCount === "" || props2.showCount || false;
    });
    var hasMaxLength = Vue.computed(function() {
      return Number(props2.maxlength) > 0;
    });
    var compositing = Vue.ref(false);
    var oldCompositionValueRef = Vue.ref();
    var oldSelectionStartRef = Vue.ref(0);
    var onInternalCompositionStart = function onInternalCompositionStart2(e2) {
      compositing.value = true;
      oldCompositionValueRef.value = mergedValue.value;
      oldSelectionStartRef.value = e2.currentTarget.selectionStart;
      emit("compositionstart", e2);
    };
    var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
      var _a;
      compositing.value = false;
      var triggerValue = e2.currentTarget.value;
      if (hasMaxLength.value) {
        var isCursorInEnd = oldSelectionStartRef.value >= props2.maxlength + 1 || oldSelectionStartRef.value === ((_a = oldCompositionValueRef.value) === null || _a === void 0 ? void 0 : _a.length);
        triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.value, triggerValue, props2.maxlength);
      }
      if (triggerValue !== mergedValue.value) {
        setValue(triggerValue);
        resolveOnChange(e2.currentTarget, e2, triggerChange, triggerValue);
      }
      emit("compositionend", e2);
    };
    var instance = Vue.getCurrentInstance();
    Vue.watch(function() {
      return props2.value;
    }, function() {
      var _a;
      if ("value" in instance.vnode.props || {}) {
        stateValue.value = (_a = props2.value) !== null && _a !== void 0 ? _a : "";
      }
    });
    var focus = function focus2(option) {
      var _a;
      triggerFocus((_a = resizableTextArea.value) === null || _a === void 0 ? void 0 : _a.textArea, option);
    };
    var blur = function blur2() {
      var _a, _b;
      (_b = (_a = resizableTextArea.value) === null || _a === void 0 ? void 0 : _a.textArea) === null || _b === void 0 ? void 0 : _b.blur();
    };
    var setValue = function setValue2(value, callback) {
      if (stateValue.value === value) {
        return;
      }
      if (props2.value === void 0) {
        stateValue.value = value;
      } else {
        Vue.nextTick(function() {
          var _a, _b, _c;
          if (resizableTextArea.value.textArea.value !== mergedValue.value) {
            (_c = (_a = resizableTextArea.value) === null || _a === void 0 ? void 0 : (_b = _a.instance).update) === null || _c === void 0 ? void 0 : _c.call(_b);
          }
        });
      }
      Vue.nextTick(function() {
        callback && callback();
      });
    };
    var handleKeyDown2 = function handleKeyDown3(e2) {
      if (e2.keyCode === 13) {
        emit("pressEnter", e2);
      }
      emit("keydown", e2);
    };
    var onBlur2 = function onBlur3(e2) {
      var onBlur4 = props2.onBlur;
      onBlur4 === null || onBlur4 === void 0 ? void 0 : onBlur4(e2);
      formItemContext.onFieldBlur();
    };
    var triggerChange = function triggerChange2(e2) {
      emit("update:value", e2.target.value);
      emit("change", e2);
      emit("input", e2);
      formItemContext.onFieldChange();
    };
    var handleReset = function handleReset2(e2) {
      resolveOnChange(resizableTextArea.value.textArea, e2, triggerChange);
      setValue("", function() {
        focus();
      });
    };
    var handleChange2 = function handleChange3(e2) {
      var composing = e2.target.composing;
      var triggerValue = e2.target.value;
      compositing.value = !!(e2.isComposing || composing);
      if (compositing.value && props2.lazy || stateValue.value === triggerValue)
        return;
      if (hasMaxLength.value) {
        var target = e2.target;
        var isCursorInEnd = target.selectionStart >= props2.maxlength + 1 || target.selectionStart === triggerValue.length || !target.selectionStart;
        triggerValue = setTriggerValue(isCursorInEnd, mergedValue.value, triggerValue, props2.maxlength);
      }
      resolveOnChange(e2.currentTarget, e2, triggerChange, triggerValue);
      setValue(triggerValue);
    };
    var renderTextArea = function renderTextArea2() {
      var _class;
      var _a, _b;
      var style = attrs.style, customClass = attrs.class;
      var _props$bordered = props2.bordered, bordered = _props$bordered === void 0 ? true : _props$bordered;
      var resizeProps = _extends(_extends(_extends({}, omit(props2, ["allowClear"])), attrs), {
        style: showCount.value ? {} : style,
        class: (_class = {}, _defineProperty$T(_class, "".concat(prefixCls.value, "-borderless"), !bordered), _defineProperty$T(_class, "".concat(customClass), customClass && !showCount.value), _defineProperty$T(_class, "".concat(prefixCls.value, "-sm"), size.value === "small"), _defineProperty$T(_class, "".concat(prefixCls.value, "-lg"), size.value === "large"), _class),
        showCount: null,
        prefixCls: prefixCls.value,
        onInput: handleChange2,
        onChange: handleChange2,
        onBlur: onBlur2,
        onKeydown: handleKeyDown2,
        onCompositionstart: onInternalCompositionStart,
        onCompositionend: onInternalCompositionEnd
      });
      if ((_a = props2.valueModifiers) === null || _a === void 0 ? void 0 : _a.lazy) {
        delete resizeProps.onInput;
      }
      return Vue.createVNode(ResizableTextArea$1, _objectSpread2$1(_objectSpread2$1({}, resizeProps), {}, {
        "id": (_b = resizeProps.id) !== null && _b !== void 0 ? _b : formItemContext.id.value,
        "ref": resizableTextArea,
        "maxlength": props2.maxlength
      }), null);
    };
    Vue.onMounted(function() {
    });
    expose({
      focus,
      blur,
      resizableTextArea
    });
    Vue.watchEffect(function() {
      var val = fixControlledValue(stateValue.value);
      if (!compositing.value && hasMaxLength.value && (props2.value === null || props2.value === void 0)) {
        val = fixEmojiLength(val, props2.maxlength);
      }
      mergedValue.value = val;
    });
    return function() {
      var maxlength = props2.maxlength, _props$bordered2 = props2.bordered, bordered = _props$bordered2 === void 0 ? true : _props$bordered2, hidden = props2.hidden;
      var style = attrs.style, customClass = attrs.class;
      var inputProps3 = _extends(_extends(_extends({}, props2), attrs), {
        prefixCls: prefixCls.value,
        inputType: "text",
        handleReset,
        direction: direction.value,
        bordered,
        style: showCount.value ? void 0 : style
      });
      var textareaNode = Vue.createVNode(ClearableLabeledInput, _objectSpread2$1(_objectSpread2$1({}, inputProps3), {}, {
        "value": mergedValue.value
      }), {
        element: renderTextArea
      });
      if (showCount.value) {
        var valueLength = _toConsumableArray(mergedValue.value).length;
        var dataCount = "";
        if (_typeof$1(showCount.value) === "object") {
          dataCount = showCount.value.formatter({
            count: valueLength,
            maxlength
          });
        } else {
          dataCount = "".concat(valueLength).concat(hasMaxLength.value ? " / ".concat(maxlength) : "");
        }
        textareaNode = Vue.createVNode("div", {
          "hidden": hidden,
          "class": classNames("".concat(prefixCls.value, "-textarea"), _defineProperty$T({}, "".concat(prefixCls.value, "-textarea-rtl"), direction.value === "rtl"), "".concat(prefixCls.value, "-textarea-show-count"), customClass),
          "style": style,
          "data-count": _typeof$1(dataCount) !== "object" ? dataCount : void 0
        }, [textareaNode]);
      }
      return textareaNode;
    };
  }
});
var __rest$d = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var ActionMap = {
  click: "onClick",
  hover: "onMouseover"
};
var defaultIconRender = function defaultIconRender2(visible) {
  return visible ? Vue.createVNode(EyeOutlined$1, null, null) : Vue.createVNode(EyeInvisibleOutlined$1, null, null);
};
var InputPassword = Vue.defineComponent({
  name: "AInputPassword",
  inheritAttrs: false,
  props: _extends(_extends({}, inputProps$1()), {
    prefixCls: String,
    inputPrefixCls: String,
    action: {
      type: String,
      default: "click"
    },
    visibilityToggle: {
      type: Boolean,
      default: true
    },
    iconRender: Function
  }),
  setup: function setup108(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var visible = Vue.ref(false);
    var onVisibleChange = function onVisibleChange2() {
      var disabled = props2.disabled;
      if (disabled) {
        return;
      }
      visible.value = !visible.value;
    };
    var inputRef = Vue.ref();
    var focus = function focus2() {
      var _a;
      (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    var blur = function blur2() {
      var _a;
      (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    expose({
      focus,
      blur
    });
    var getIcon2 = function getIcon3(prefixCls2) {
      var _iconProps;
      var action = props2.action, _props$iconRender = props2.iconRender, iconRender = _props$iconRender === void 0 ? slots.iconRender || defaultIconRender : _props$iconRender;
      var iconTrigger = ActionMap[action] || "";
      var icon = iconRender(visible.value);
      var iconProps = (_iconProps = {}, _defineProperty$T(_iconProps, iconTrigger, onVisibleChange), _defineProperty$T(_iconProps, "class", "".concat(prefixCls2, "-icon")), _defineProperty$T(_iconProps, "key", "passwordIcon"), _defineProperty$T(_iconProps, "onMousedown", function onMousedown2(e2) {
        e2.preventDefault();
      }), _defineProperty$T(_iconProps, "onMouseup", function onMouseup(e2) {
        e2.preventDefault();
      }), _iconProps);
      return cloneElement(isValidElement(icon) ? icon : Vue.createVNode("span", null, [icon]), iconProps);
    };
    var _useConfigInject = useConfigInject("input-password", props2), prefixCls = _useConfigInject.prefixCls, getPrefixCls2 = _useConfigInject.getPrefixCls;
    var inputPrefixCls = Vue.computed(function() {
      return getPrefixCls2("input", props2.inputPrefixCls);
    });
    var renderPassword = function renderPassword2() {
      var size = props2.size, visibilityToggle = props2.visibilityToggle, restProps = __rest$d(props2, ["size", "visibilityToggle"]);
      var suffixIcon = visibilityToggle && getIcon2(prefixCls.value);
      var inputClassName = classNames(prefixCls.value, attrs.class, _defineProperty$T({}, "".concat(prefixCls.value, "-").concat(size), !!size));
      var omittedProps = _extends(_extends(_extends({}, omit(restProps, ["suffix", "iconRender", "action"])), attrs), {
        type: visible.value ? "text" : "password",
        class: inputClassName,
        prefixCls: inputPrefixCls.value,
        suffix: suffixIcon
      });
      if (size) {
        omittedProps.size = size;
      }
      return Vue.createVNode(Input$1, _objectSpread2$1({
        "ref": inputRef
      }, omittedProps), slots);
    };
    return function() {
      return renderPassword();
    };
  }
});
Input$1.Group = Group$2;
Input$1.Search = Search;
Input$1.TextArea = Textarea;
Input$1.Password = InputPassword;
Input$1.install = function(app) {
  app.component(Input$1.name, Input$1);
  app.component(Input$1.Group.name, Input$1.Group);
  app.component(Input$1.Search.name, Input$1.Search);
  app.component(Input$1.TextArea.name, Input$1.TextArea);
  app.component(Input$1.Password.name, Input$1.Password);
  return app;
};
var FilterSearch = Vue.defineComponent({
  name: "FilterSearch",
  inheritAttrs: false,
  props: {
    value: String,
    onChange: Function,
    filterSearch: Boolean,
    tablePrefixCls: String,
    locale: {
      type: Object,
      default: void 0
    }
  },
  setup: function setup109(props2) {
    return function() {
      var value = props2.value, onChange = props2.onChange, filterSearch = props2.filterSearch, tablePrefixCls = props2.tablePrefixCls, locale2 = props2.locale;
      if (!filterSearch) {
        return null;
      }
      return Vue.createVNode("div", {
        "class": "".concat(tablePrefixCls, "-filter-dropdown-search")
      }, [Vue.createVNode(Input$1, {
        "placeholder": locale2.filterSearchPlaceholder,
        "onChange": onChange,
        "value": value,
        "htmlSize": 1,
        "class": "".concat(tablePrefixCls, "-filter-dropdown-search-input")
      }, {
        prefix: function prefix() {
          return Vue.createVNode(SearchOutlined$1, null, null);
        }
      })]);
    };
  }
});
var __rest$c = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var MotionTreeNode = Vue.defineComponent({
  name: "MotionTreeNode",
  inheritAttrs: false,
  props: _extends(_extends({}, treeNodeProps), {
    active: Boolean,
    motion: Object,
    motionNodes: {
      type: Array
    },
    onMotionStart: Function,
    onMotionEnd: Function,
    motionType: String
  }),
  slots: ["title", "icon", "switcherIcon", "checkable"],
  setup: function setup110(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var visible = Vue.ref(true);
    var context = useInjectTreeContext();
    var motionedRef = Vue.ref(false);
    var transitionProps = Vue.computed(function() {
      if (props2.motion) {
        return props2.motion;
      } else {
        return collapseMotion$1();
      }
    });
    var onMotionEnd = function onMotionEnd2(node, type2) {
      var _a, _b, _c, _d;
      if (type2 === "appear") {
        (_b = (_a = transitionProps.value) === null || _a === void 0 ? void 0 : _a.onAfterEnter) === null || _b === void 0 ? void 0 : _b.call(_a, node);
      } else if (type2 === "leave") {
        (_d = (_c = transitionProps.value) === null || _c === void 0 ? void 0 : _c.onAfterLeave) === null || _d === void 0 ? void 0 : _d.call(_c, node);
      }
      if (!motionedRef.value) {
        props2.onMotionEnd();
      }
      motionedRef.value = true;
    };
    Vue.watch(function() {
      return props2.motionNodes;
    }, function() {
      if (props2.motionNodes && props2.motionType === "hide" && visible.value) {
        Vue.nextTick(function() {
          visible.value = false;
        });
      }
    }, {
      immediate: true,
      flush: "post"
    });
    Vue.onMounted(function() {
      props2.motionNodes && props2.onMotionStart();
    });
    Vue.onBeforeUnmount(function() {
      props2.motionNodes && onMotionEnd();
    });
    return function() {
      props2.motion;
      var motionNodes = props2.motionNodes, motionType = props2.motionType, active = props2.active, eventKey = props2.eventKey, otherProps = __rest$c(props2, ["motion", "motionNodes", "motionType", "active", "eventKey"]);
      if (motionNodes) {
        return Vue.createVNode(Vue.Transition, _objectSpread2$1(_objectSpread2$1({}, transitionProps.value), {}, {
          "appear": motionType === "show",
          "onAfterAppear": function onAfterAppear(node) {
            return onMotionEnd(node, "appear");
          },
          "onAfterLeave": function onAfterLeave(node) {
            return onMotionEnd(node, "leave");
          }
        }), {
          default: function _default5() {
            return [Vue.withDirectives(Vue.createVNode("div", {
              "class": "".concat(context.value.prefixCls, "-treenode-motion")
            }, [motionNodes.map(function(treeNode) {
              var restProps = __rest$c(treeNode.data, []), title = treeNode.title, key2 = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
              delete restProps.children;
              return Vue.createVNode(VcTreeNode, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
                "title": title,
                "active": active,
                "data": treeNode.data,
                "key": key2,
                "eventKey": key2,
                "isStart": isStart,
                "isEnd": isEnd
              }), slots);
            })]), [[Vue.vShow, visible.value]])];
          }
        });
      }
      return Vue.createVNode(VcTreeNode, _objectSpread2$1(_objectSpread2$1({
        "domRef": Vue.ref,
        "class": attrs.class,
        "style": attrs.style
      }, otherProps), {}, {
        "active": active,
        "eventKey": eventKey
      }), slots);
    };
  }
});
function findExpandedKeys() {
  var prev2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var next2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var prevLen = prev2.length;
  var nextLen = next2.length;
  if (Math.abs(prevLen - nextLen) !== 1) {
    return {
      add: false,
      key: null
    };
  }
  function find(shorter, longer) {
    var cache2 = /* @__PURE__ */ new Map();
    shorter.forEach(function(key2) {
      cache2.set(key2, true);
    });
    var keys2 = longer.filter(function(key2) {
      return !cache2.has(key2);
    });
    return keys2.length === 1 ? keys2[0] : null;
  }
  if (prevLen < nextLen) {
    return {
      add: true,
      key: find(prev2, next2)
    };
  }
  return {
    add: false,
    key: find(next2, prev2)
  };
}
function getExpandRange(shorter, longer, key2) {
  var shorterStartIndex = shorter.findIndex(function(item) {
    return item.key === key2;
  });
  var shorterEndNode = shorter[shorterStartIndex + 1];
  var longerStartIndex = longer.findIndex(function(item) {
    return item.key === key2;
  });
  if (shorterEndNode) {
    var longerEndIndex = longer.findIndex(function(item) {
      return item.key === shorterEndNode.key;
    });
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}
var __rest$b = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var HIDDEN_STYLE$1 = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var noop = function noop2() {
};
var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
var MotionNode = {
  key: MOTION_KEY
};
var MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: "0",
  node: MotionNode,
  nodes: [MotionNode]
};
var MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  isStart: [],
  isEnd: []
};
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
  if (virtual === false || !height) {
    return list;
  }
  return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
  var key2 = item.key, pos = item.pos;
  return getKey(key2, pos);
}
function getAccessibilityPath(item) {
  var path = String(item.key);
  var current2 = item;
  while (current2.parent) {
    current2 = current2.parent;
    path = "".concat(current2.key, " > ").concat(path);
  }
  return path;
}
var NodeList = Vue.defineComponent({
  name: "NodeList",
  inheritAttrs: false,
  props: nodeListProps,
  setup: function setup111(props2, _ref) {
    var expose = _ref.expose, attrs = _ref.attrs;
    var listRef = Vue.ref();
    var indentMeasurerRef = Vue.ref();
    var _useInjectKeysState = useInjectKeysState(), expandedKeys = _useInjectKeysState.expandedKeys, flattenNodes = _useInjectKeysState.flattenNodes;
    expose({
      scrollTo: function scrollTo2(scroll) {
        listRef.value.scrollTo(scroll);
      },
      getIndentWidth: function getIndentWidth() {
        return indentMeasurerRef.value.offsetWidth;
      }
    });
    var transitionData = Vue.shallowRef(flattenNodes.value);
    var transitionRange = Vue.shallowRef([]);
    var motionType = Vue.ref(null);
    function onMotionEnd() {
      transitionData.value = flattenNodes.value;
      transitionRange.value = [];
      motionType.value = null;
      props2.onListChangeEnd();
    }
    var context = useInjectTreeContext();
    Vue.watch([function() {
      return expandedKeys.value.slice();
    }, flattenNodes], function(_ref2, _ref3) {
      var _ref4 = _slicedToArray(_ref2, 2), expandedKeys2 = _ref4[0], data4 = _ref4[1];
      var _ref5 = _slicedToArray(_ref3, 2), prevExpandedKeys = _ref5[0], prevData = _ref5[1];
      var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys2);
      if (diffExpanded.key !== null) {
        var virtual = props2.virtual, height = props2.height, itemHeight = props2.itemHeight;
        if (diffExpanded.add) {
          var keyIndex = prevData.findIndex(function(_ref6) {
            var key2 = _ref6.key;
            return key2 === diffExpanded.key;
          });
          var rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data4, diffExpanded.key), virtual, height, itemHeight);
          var newTransitionData = prevData.slice();
          newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
          transitionData.value = newTransitionData;
          transitionRange.value = rangeNodes;
          motionType.value = "show";
        } else {
          var _keyIndex = data4.findIndex(function(_ref7) {
            var key2 = _ref7.key;
            return key2 === diffExpanded.key;
          });
          var _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data4, prevData, diffExpanded.key), virtual, height, itemHeight);
          var _newTransitionData = data4.slice();
          _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
          transitionData.value = _newTransitionData;
          transitionRange.value = _rangeNodes;
          motionType.value = "hide";
        }
      } else if (prevData !== data4) {
        transitionData.value = data4;
      }
    });
    Vue.watch(function() {
      return context.value.dragging;
    }, function(dragging) {
      if (!dragging) {
        onMotionEnd();
      }
    });
    var mergedData = Vue.computed(function() {
      return props2.motion === void 0 ? transitionData.value : flattenNodes.value;
    });
    var onActiveChange = function onActiveChange2() {
      props2.onActiveChange(null);
    };
    return function() {
      var _a = _extends(_extends({}, props2), attrs), prefixCls = _a.prefixCls;
      _a.selectable;
      _a.checkable;
      var disabled = _a.disabled, motion = _a.motion, height = _a.height, itemHeight = _a.itemHeight, virtual = _a.virtual, focusable = _a.focusable, activeItem = _a.activeItem, focused = _a.focused, tabindex = _a.tabindex, onKeydown = _a.onKeydown, onFocus2 = _a.onFocus, onBlur2 = _a.onBlur, onListChangeStart = _a.onListChangeStart;
      _a.onListChangeEnd;
      var domProps = __rest$b(_a, ["prefixCls", "selectable", "checkable", "disabled", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabindex", "onKeydown", "onFocus", "onBlur", "onListChangeStart", "onListChangeEnd"]);
      return Vue.createVNode(Vue.Fragment, null, [focused && activeItem && Vue.createVNode("span", {
        "style": HIDDEN_STYLE$1,
        "aria-live": "assertive"
      }, [getAccessibilityPath(activeItem)]), Vue.createVNode("div", null, [Vue.createVNode("input", {
        "style": HIDDEN_STYLE$1,
        "disabled": focusable === false || disabled,
        "tabindex": focusable !== false ? tabindex : null,
        "onKeydown": onKeydown,
        "onFocus": onFocus2,
        "onBlur": onBlur2,
        "value": "",
        "onChange": noop,
        "aria-label": "for screen reader"
      }, null)]), Vue.createVNode("div", {
        "class": "".concat(prefixCls, "-treenode"),
        "aria-hidden": true,
        "style": {
          position: "absolute",
          pointerEvents: "none",
          visibility: "hidden",
          height: 0,
          overflow: "hidden"
        }
      }, [Vue.createVNode("div", {
        "class": "".concat(prefixCls, "-indent")
      }, [Vue.createVNode("div", {
        "ref": indentMeasurerRef,
        "class": "".concat(prefixCls, "-indent-unit")
      }, null)])]), Vue.createVNode(List$2, _objectSpread2$1(_objectSpread2$1({}, omit(domProps, ["onActiveChange"])), {}, {
        "data": mergedData.value,
        "itemKey": itemKey,
        "height": height,
        "fullHeight": false,
        "virtual": virtual,
        "itemHeight": itemHeight,
        "prefixCls": "".concat(prefixCls, "-list"),
        "ref": listRef,
        "onVisibleChange": function onVisibleChange(originList, fullList) {
          var originSet = new Set(originList);
          var restList = fullList.filter(function(item) {
            return !originSet.has(item);
          });
          if (restList.some(function(item) {
            return itemKey(item) === MOTION_KEY;
          })) {
            onMotionEnd();
          }
        }
      }), {
        default: function _default5(treeNode) {
          var pos = treeNode.pos, restProps = __rest$b(treeNode.data, []), title = treeNode.title, key2 = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
          var mergedKey = getKey(key2, pos);
          delete restProps.key;
          delete restProps.children;
          return Vue.createVNode(MotionTreeNode, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
            "eventKey": mergedKey,
            "title": title,
            "active": !!activeItem && key2 === activeItem.key,
            "data": treeNode.data,
            "isStart": isStart,
            "isEnd": isEnd,
            "motion": motion,
            "motionNodes": key2 === MOTION_KEY ? transitionRange.value : null,
            "motionType": motionType.value,
            "onMotionStart": onListChangeStart,
            "onMotionEnd": onMotionEnd,
            "onMousemove": onActiveChange
          }), null);
        }
      })]);
    };
  }
});
function DropIndicator(_ref) {
  var dropPosition = _ref.dropPosition, dropLevelOffset = _ref.dropLevelOffset, indent = _ref.indent;
  var style = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: "".concat(2, "px")
  };
  switch (dropPosition) {
    case -1:
      style.top = 0;
      style.left = "".concat(-dropLevelOffset * indent, "px");
      break;
    case 1:
      style.bottom = 0;
      style.left = "".concat(-dropLevelOffset * indent, "px");
      break;
    case 0:
      style.bottom = 0;
      style.left = "".concat(indent);
      break;
  }
  return Vue.createVNode("div", {
    "style": style
  }, null);
}
var MAX_RETRY_TIMES = 10;
var Tree$2 = Vue.defineComponent({
  name: "Tree",
  inheritAttrs: false,
  slots: ["checkable", "title", "icon", "titleRender"],
  props: initDefaultProps$1(treeProps$1(), {
    prefixCls: "vc-tree",
    showLine: false,
    showIcon: true,
    selectable: true,
    multiple: false,
    checkable: false,
    disabled: false,
    checkStrictly: false,
    draggable: false,
    defaultExpandParent: true,
    autoExpandParent: false,
    defaultExpandAll: false,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    dropIndicatorRender: DropIndicator,
    allowDrop: function allowDrop() {
      return true;
    }
  }),
  setup: function setup112(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose;
    var destroyed = Vue.ref(false);
    var delayedDragEnterLogic = {};
    var indent = Vue.ref();
    var selectedKeys = Vue.shallowRef([]);
    var checkedKeys = Vue.shallowRef([]);
    var halfCheckedKeys = Vue.shallowRef([]);
    var loadedKeys = Vue.shallowRef([]);
    var loadingKeys = Vue.shallowRef([]);
    var expandedKeys = Vue.shallowRef([]);
    var loadingRetryTimes = {};
    var dragState = Vue.reactive({
      draggingNodeKey: null,
      dragChildrenKeys: [],
      dropTargetKey: null,
      dropPosition: null,
      dropContainerKey: null,
      dropLevelOffset: null,
      dropTargetPos: null,
      dropAllowed: true,
      dragOverNodeKey: null
    });
    var treeData = Vue.shallowRef([]);
    Vue.watch([function() {
      return props2.treeData;
    }, function() {
      return props2.children;
    }], function() {
      treeData.value = props2.treeData !== void 0 ? Vue.toRaw(props2.treeData).slice() : convertTreeToData(Vue.toRaw(props2.children));
    }, {
      immediate: true,
      deep: true
    });
    var keyEntities = Vue.shallowRef({});
    var focused = Vue.ref(false);
    var activeKey = Vue.ref(null);
    var listChanging = Vue.ref(false);
    var fieldNames = Vue.computed(function() {
      return fillFieldNames(props2.fieldNames);
    });
    var listRef = Vue.ref();
    var dragStartMousePosition = null;
    var dragNode = null;
    var currentMouseOverDroppableNodeKey = null;
    var treeNodeRequiredProps = Vue.computed(function() {
      return {
        expandedKeysSet: expandedKeysSet.value,
        selectedKeysSet: selectedKeysSet.value,
        loadedKeysSet: loadedKeysSet.value,
        loadingKeysSet: loadingKeysSet.value,
        checkedKeysSet: checkedKeysSet.value,
        halfCheckedKeysSet: halfCheckedKeysSet.value,
        dragOverNodeKey: dragState.dragOverNodeKey,
        dropPosition: dragState.dropPosition,
        keyEntities: keyEntities.value
      };
    });
    var expandedKeysSet = Vue.computed(function() {
      return new Set(expandedKeys.value);
    });
    var selectedKeysSet = Vue.computed(function() {
      return new Set(selectedKeys.value);
    });
    var loadedKeysSet = Vue.computed(function() {
      return new Set(loadedKeys.value);
    });
    var loadingKeysSet = Vue.computed(function() {
      return new Set(loadingKeys.value);
    });
    var checkedKeysSet = Vue.computed(function() {
      return new Set(checkedKeys.value);
    });
    var halfCheckedKeysSet = Vue.computed(function() {
      return new Set(halfCheckedKeys.value);
    });
    Vue.watchEffect(function() {
      if (treeData.value) {
        var entitiesMap = convertDataToEntities(treeData.value, {
          fieldNames: fieldNames.value
        });
        keyEntities.value = _extends(_defineProperty$T({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities);
      }
    });
    var init = false;
    Vue.watch([function() {
      return props2.expandedKeys;
    }, function() {
      return props2.autoExpandParent;
    }, keyEntities], function(_ref2, _ref3) {
      var _ref4 = _slicedToArray(_ref2, 2);
      _ref4[0];
      var newAutoExpandParent = _ref4[1];
      var _ref5 = _slicedToArray(_ref3, 2);
      _ref5[0];
      var oldAutoExpandParent = _ref5[1];
      var keys2 = expandedKeys.value;
      if (props2.expandedKeys !== void 0 || init && newAutoExpandParent !== oldAutoExpandParent) {
        keys2 = props2.autoExpandParent || !init && props2.defaultExpandParent ? conductExpandParent(props2.expandedKeys, keyEntities.value) : props2.expandedKeys;
      } else if (!init && props2.defaultExpandAll) {
        var cloneKeyEntities = _extends({}, keyEntities.value);
        delete cloneKeyEntities[MOTION_KEY];
        keys2 = Object.keys(cloneKeyEntities).map(function(key2) {
          return cloneKeyEntities[key2].key;
        });
      } else if (!init && props2.defaultExpandedKeys) {
        keys2 = props2.autoExpandParent || props2.defaultExpandParent ? conductExpandParent(props2.defaultExpandedKeys, keyEntities.value) : props2.defaultExpandedKeys;
      }
      if (keys2) {
        expandedKeys.value = keys2;
      }
      init = true;
    }, {
      immediate: true
    });
    var flattenNodes = Vue.shallowRef([]);
    Vue.watchEffect(function() {
      flattenNodes.value = flattenTreeData(treeData.value, expandedKeys.value, fieldNames.value);
    });
    Vue.watchEffect(function() {
      if (props2.selectable) {
        if (props2.selectedKeys !== void 0) {
          selectedKeys.value = calcSelectedKeys(props2.selectedKeys, props2);
        } else if (!init && props2.defaultSelectedKeys) {
          selectedKeys.value = calcSelectedKeys(props2.defaultSelectedKeys, props2);
        }
      }
    });
    var _useMaxLevel = useMaxLevel(keyEntities), maxLevel = _useMaxLevel.maxLevel, levelEntities = _useMaxLevel.levelEntities;
    Vue.watchEffect(function() {
      if (props2.checkable) {
        var checkedKeyEntity;
        if (props2.checkedKeys !== void 0) {
          checkedKeyEntity = parseCheckedKeys(props2.checkedKeys) || {};
        } else if (!init && props2.defaultCheckedKeys) {
          checkedKeyEntity = parseCheckedKeys(props2.defaultCheckedKeys) || {};
        } else if (treeData.value) {
          checkedKeyEntity = parseCheckedKeys(props2.checkedKeys) || {
            checkedKeys: checkedKeys.value,
            halfCheckedKeys: halfCheckedKeys.value
          };
        }
        if (checkedKeyEntity) {
          var _checkedKeyEntity = checkedKeyEntity, _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys, newCheckedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che, _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys, newHalfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
          if (!props2.checkStrictly) {
            var conductKeys = conductCheck(newCheckedKeys, true, keyEntities.value, maxLevel.value, levelEntities.value);
            newCheckedKeys = conductKeys.checkedKeys;
            newHalfCheckedKeys = conductKeys.halfCheckedKeys;
          }
          checkedKeys.value = newCheckedKeys;
          halfCheckedKeys.value = newHalfCheckedKeys;
        }
      }
    });
    Vue.watchEffect(function() {
      if (props2.loadedKeys) {
        loadedKeys.value = props2.loadedKeys;
      }
    });
    var resetDragState = function resetDragState2() {
      _extends(dragState, {
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: false
      });
    };
    var scrollTo2 = function scrollTo3(scroll) {
      listRef.value.scrollTo(scroll);
    };
    Vue.watch(function() {
      return props2.activeKey;
    }, function() {
      if (props2.activeKey !== void 0) {
        activeKey.value = props2.activeKey;
      }
    }, {
      immediate: true
    });
    Vue.watch(activeKey, function(val) {
      Vue.nextTick(function() {
        if (val !== null) {
          scrollTo2({
            key: val
          });
        }
      });
    }, {
      immediate: true,
      flush: "post"
    });
    var setExpandedKeys = function setExpandedKeys2(keys2) {
      if (props2.expandedKeys === void 0) {
        expandedKeys.value = keys2;
      }
    };
    var cleanDragState = function cleanDragState2() {
      if (dragState.draggingNodeKey !== null) {
        _extends(dragState, {
          draggingNodeKey: null,
          dropPosition: null,
          dropContainerKey: null,
          dropTargetKey: null,
          dropLevelOffset: null,
          dropAllowed: true,
          dragOverNodeKey: null
        });
      }
      dragStartMousePosition = null;
      currentMouseOverDroppableNodeKey = null;
    };
    var onNodeDragEnd = function onNodeDragEnd2(event, node) {
      var onDragend = props2.onDragend;
      dragState.dragOverNodeKey = null;
      cleanDragState();
      onDragend === null || onDragend === void 0 ? void 0 : onDragend({
        event,
        node: node.eventData
      });
      dragNode = null;
    };
    var onWindowDragEnd = function onWindowDragEnd2(event) {
      onNodeDragEnd(event, null);
      window.removeEventListener("dragend", onWindowDragEnd2);
    };
    var onNodeDragStart = function onNodeDragStart2(event, node) {
      var onDragstart = props2.onDragstart;
      var eventKey = node.eventKey, eventData = node.eventData;
      dragNode = node;
      dragStartMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
      var newExpandedKeys = arrDel(expandedKeys.value, eventKey);
      dragState.draggingNodeKey = eventKey;
      dragState.dragChildrenKeys = getDragChildrenKeys(eventKey, keyEntities.value);
      indent.value = listRef.value.getIndentWidth();
      setExpandedKeys(newExpandedKeys);
      window.addEventListener("dragend", onWindowDragEnd);
      if (onDragstart) {
        onDragstart({
          event,
          node: eventData
        });
      }
    };
    var onNodeDragEnter = function onNodeDragEnter2(event, node) {
      var onDragenter = props2.onDragenter, onExpand = props2.onExpand, allowDrop2 = props2.allowDrop, direction = props2.direction;
      var pos = node.pos, eventKey = node.eventKey;
      if (currentMouseOverDroppableNodeKey !== eventKey) {
        currentMouseOverDroppableNodeKey = eventKey;
      }
      if (!dragNode) {
        resetDragState();
        return;
      }
      var _calcDropPosition = calcDropPosition(event, dragNode, node, indent.value, dragStartMousePosition, allowDrop2, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction), dropPosition = _calcDropPosition.dropPosition, dropLevelOffset = _calcDropPosition.dropLevelOffset, dropTargetKey = _calcDropPosition.dropTargetKey, dropContainerKey = _calcDropPosition.dropContainerKey, dropTargetPos = _calcDropPosition.dropTargetPos, dropAllowed = _calcDropPosition.dropAllowed, dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
      if (dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        resetDragState();
        return;
      }
      if (!delayedDragEnterLogic) {
        delayedDragEnterLogic = {};
      }
      Object.keys(delayedDragEnterLogic).forEach(function(key2) {
        clearTimeout(delayedDragEnterLogic[key2]);
      });
      if (dragNode.eventKey !== node.eventKey) {
        delayedDragEnterLogic[pos] = window.setTimeout(function() {
          if (dragState.draggingNodeKey === null)
            return;
          var newExpandedKeys = expandedKeys.value.slice();
          var entity = keyEntities.value[node.eventKey];
          if (entity && (entity.children || []).length) {
            newExpandedKeys = arrAdd(expandedKeys.value, node.eventKey);
          }
          setExpandedKeys(newExpandedKeys);
          if (onExpand) {
            onExpand(newExpandedKeys, {
              node: node.eventData,
              expanded: true,
              nativeEvent: event
            });
          }
        }, 800);
      }
      if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {
        resetDragState();
        return;
      }
      _extends(dragState, {
        dragOverNodeKey,
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed
      });
      if (onDragenter) {
        onDragenter({
          event,
          node: node.eventData,
          expandedKeys: expandedKeys.value
        });
      }
    };
    var onNodeDragOver = function onNodeDragOver2(event, node) {
      var onDragover = props2.onDragover, allowDrop2 = props2.allowDrop, direction = props2.direction;
      if (!dragNode) {
        return;
      }
      var _calcDropPosition2 = calcDropPosition(event, dragNode, node, indent.value, dragStartMousePosition, allowDrop2, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction), dropPosition = _calcDropPosition2.dropPosition, dropLevelOffset = _calcDropPosition2.dropLevelOffset, dropTargetKey = _calcDropPosition2.dropTargetKey, dropContainerKey = _calcDropPosition2.dropContainerKey, dropAllowed = _calcDropPosition2.dropAllowed, dropTargetPos = _calcDropPosition2.dropTargetPos, dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
      if (dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        return;
      }
      if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {
        if (!(dragState.dropPosition === null && dragState.dropLevelOffset === null && dragState.dropTargetKey === null && dragState.dropContainerKey === null && dragState.dropTargetPos === null && dragState.dropAllowed === false && dragState.dragOverNodeKey === null)) {
          resetDragState();
        }
      } else if (!(dropPosition === dragState.dropPosition && dropLevelOffset === dragState.dropLevelOffset && dropTargetKey === dragState.dropTargetKey && dropContainerKey === dragState.dropContainerKey && dropTargetPos === dragState.dropTargetPos && dropAllowed === dragState.dropAllowed && dragOverNodeKey === dragState.dragOverNodeKey)) {
        _extends(dragState, {
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropTargetPos,
          dropAllowed,
          dragOverNodeKey
        });
      }
      if (onDragover) {
        onDragover({
          event,
          node: node.eventData
        });
      }
    };
    var onNodeDragLeave = function onNodeDragLeave2(event, node) {
      if (currentMouseOverDroppableNodeKey === node.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
        resetDragState();
        currentMouseOverDroppableNodeKey = null;
      }
      var onDragleave = props2.onDragleave;
      if (onDragleave) {
        onDragleave({
          event,
          node: node.eventData
        });
      }
    };
    var onNodeDrop = function onNodeDrop2(event, _node) {
      var outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var _a;
      var dragChildrenKeys = dragState.dragChildrenKeys, dropPosition = dragState.dropPosition, dropTargetKey = dragState.dropTargetKey, dropTargetPos = dragState.dropTargetPos, dropAllowed = dragState.dropAllowed;
      if (!dropAllowed)
        return;
      var onDrop = props2.onDrop;
      dragState.dragOverNodeKey = null;
      cleanDragState();
      if (dropTargetKey === null)
        return;
      var abstractDropNodeProps = _extends(_extends({}, getTreeNodeProps(dropTargetKey, Vue.toRaw(treeNodeRequiredProps.value))), {
        active: ((_a = activeItem.value) === null || _a === void 0 ? void 0 : _a.key) === dropTargetKey,
        data: keyEntities.value[dropTargetKey].node
      });
      dragChildrenKeys.indexOf(dropTargetKey) !== -1;
      var posArr = posToArr(dropTargetPos);
      var dropResult = {
        event,
        node: convertNodePropsToEventData(abstractDropNodeProps),
        dragNode: dragNode ? dragNode.eventData : null,
        dragNodesKeys: [dragNode.eventKey].concat(dragChildrenKeys),
        dropToGap: dropPosition !== 0,
        dropPosition: dropPosition + Number(posArr[posArr.length - 1])
      };
      if (!outsideTree) {
        onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);
      }
      dragNode = null;
    };
    var onNodeClick = function onNodeClick2(e2, treeNode) {
      var onClick2 = props2.onClick;
      if (onClick2) {
        onClick2(e2, treeNode);
      }
    };
    var onNodeDoubleClick = function onNodeDoubleClick2(e2, treeNode) {
      var onDblclick = props2.onDblclick;
      if (onDblclick) {
        onDblclick(e2, treeNode);
      }
    };
    var onNodeSelect = function onNodeSelect2(e2, treeNode) {
      var newSelectedKeys = selectedKeys.value;
      var onSelect = props2.onSelect, multiple = props2.multiple;
      var selected = treeNode.selected;
      var key2 = treeNode[fieldNames.value.key];
      var targetSelected = !selected;
      if (!targetSelected) {
        newSelectedKeys = arrDel(newSelectedKeys, key2);
      } else if (!multiple) {
        newSelectedKeys = [key2];
      } else {
        newSelectedKeys = arrAdd(newSelectedKeys, key2);
      }
      var keyEntitiesValue = keyEntities.value;
      var selectedNodes = newSelectedKeys.map(function(selectedKey) {
        var entity = keyEntitiesValue[selectedKey];
        if (!entity)
          return null;
        return entity.node;
      }).filter(function(node) {
        return node;
      });
      if (props2.selectedKeys === void 0) {
        selectedKeys.value = newSelectedKeys;
      }
      if (onSelect) {
        onSelect(newSelectedKeys, {
          event: "select",
          selected: targetSelected,
          node: treeNode,
          selectedNodes,
          nativeEvent: e2
        });
      }
    };
    var onNodeCheck = function onNodeCheck2(e2, treeNode, checked) {
      var checkStrictly = props2.checkStrictly, onCheck = props2.onCheck;
      var key2 = treeNode[fieldNames.value.key];
      var checkedObj;
      var eventObj = {
        event: "check",
        node: treeNode,
        checked,
        nativeEvent: e2
      };
      var keyEntitiesValue = keyEntities.value;
      if (checkStrictly) {
        var newCheckedKeys = checked ? arrAdd(checkedKeys.value, key2) : arrDel(checkedKeys.value, key2);
        var newHalfCheckedKeys = arrDel(halfCheckedKeys.value, key2);
        checkedObj = {
          checked: newCheckedKeys,
          halfChecked: newHalfCheckedKeys
        };
        eventObj.checkedNodes = newCheckedKeys.map(function(checkedKey) {
          return keyEntitiesValue[checkedKey];
        }).filter(function(entity) {
          return entity;
        }).map(function(entity) {
          return entity.node;
        });
        if (props2.checkedKeys === void 0) {
          checkedKeys.value = newCheckedKeys;
        }
      } else {
        var _conductCheck = conductCheck([].concat(_toConsumableArray(checkedKeys.value), [key2]), true, keyEntitiesValue, maxLevel.value, levelEntities.value), _newCheckedKeys = _conductCheck.checkedKeys, _newHalfCheckedKeys = _conductCheck.halfCheckedKeys;
        if (!checked) {
          var keySet = new Set(_newCheckedKeys);
          keySet.delete(key2);
          var _conductCheck2 = conductCheck(Array.from(keySet), {
            checked: false,
            halfCheckedKeys: _newHalfCheckedKeys
          }, keyEntitiesValue, maxLevel.value, levelEntities.value);
          _newCheckedKeys = _conductCheck2.checkedKeys;
          _newHalfCheckedKeys = _conductCheck2.halfCheckedKeys;
        }
        checkedObj = _newCheckedKeys;
        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = [];
        eventObj.halfCheckedKeys = _newHalfCheckedKeys;
        _newCheckedKeys.forEach(function(checkedKey) {
          var entity = keyEntitiesValue[checkedKey];
          if (!entity)
            return;
          var node = entity.node, pos = entity.pos;
          eventObj.checkedNodes.push(node);
          eventObj.checkedNodesPositions.push({
            node,
            pos
          });
        });
        if (props2.checkedKeys === void 0) {
          checkedKeys.value = _newCheckedKeys;
          halfCheckedKeys.value = _newHalfCheckedKeys;
        }
      }
      if (onCheck) {
        onCheck(checkedObj, eventObj);
      }
    };
    var onNodeLoad = function onNodeLoad2(treeNode) {
      var key2 = treeNode[fieldNames.value.key];
      var loadPromise = new Promise(function(resolve, reject) {
        var loadData = props2.loadData, onLoad = props2.onLoad;
        if (!loadData || loadedKeysSet.value.has(key2) || loadingKeysSet.value.has(key2)) {
          return null;
        }
        var promise = loadData(treeNode);
        promise.then(function() {
          var newLoadedKeys = arrAdd(loadedKeys.value, key2);
          var newLoadingKeys = arrDel(loadingKeys.value, key2);
          if (onLoad) {
            onLoad(newLoadedKeys, {
              event: "load",
              node: treeNode
            });
          }
          if (props2.loadedKeys === void 0) {
            loadedKeys.value = newLoadedKeys;
          }
          loadingKeys.value = newLoadingKeys;
          resolve();
        }).catch(function(e2) {
          var newLoadingKeys = arrDel(loadingKeys.value, key2);
          loadingKeys.value = newLoadingKeys;
          loadingRetryTimes[key2] = (loadingRetryTimes[key2] || 0) + 1;
          if (loadingRetryTimes[key2] >= MAX_RETRY_TIMES) {
            var newLoadedKeys = arrAdd(loadedKeys.value, key2);
            if (props2.loadedKeys === void 0) {
              loadedKeys.value = newLoadedKeys;
            }
            resolve();
          }
          reject(e2);
        });
        loadingKeys.value = arrAdd(loadingKeys.value, key2);
      });
      loadPromise.catch(function() {
      });
      return loadPromise;
    };
    var onNodeMouseEnter = function onNodeMouseEnter2(event, node) {
      var onMouseenter2 = props2.onMouseenter;
      if (onMouseenter2) {
        onMouseenter2({
          event,
          node
        });
      }
    };
    var onNodeMouseLeave = function onNodeMouseLeave2(event, node) {
      var onMouseleave2 = props2.onMouseleave;
      if (onMouseleave2) {
        onMouseleave2({
          event,
          node
        });
      }
    };
    var onNodeContextMenu = function onNodeContextMenu2(event, node) {
      var onRightClick = props2.onRightClick;
      if (onRightClick) {
        event.preventDefault();
        onRightClick({
          event,
          node
        });
      }
    };
    var onFocus2 = function onFocus3(e2) {
      var onFocus4 = props2.onFocus;
      focused.value = true;
      if (onFocus4) {
        onFocus4(e2);
      }
    };
    var onBlur2 = function onBlur3(e2) {
      var onBlur4 = props2.onBlur;
      focused.value = false;
      onActiveChange(null);
      if (onBlur4) {
        onBlur4(e2);
      }
    };
    var onNodeExpand = function onNodeExpand2(e2, treeNode) {
      var newExpandedKeys = expandedKeys.value;
      var onExpand = props2.onExpand, loadData = props2.loadData;
      var expanded = treeNode.expanded;
      var key2 = treeNode[fieldNames.value.key];
      if (listChanging.value) {
        return;
      }
      newExpandedKeys.indexOf(key2);
      var targetExpanded = !expanded;
      if (targetExpanded) {
        newExpandedKeys = arrAdd(newExpandedKeys, key2);
      } else {
        newExpandedKeys = arrDel(newExpandedKeys, key2);
      }
      setExpandedKeys(newExpandedKeys);
      if (onExpand) {
        onExpand(newExpandedKeys, {
          node: treeNode,
          expanded: targetExpanded,
          nativeEvent: e2
        });
      }
      if (targetExpanded && loadData) {
        var loadPromise = onNodeLoad(treeNode);
        if (loadPromise) {
          loadPromise.then(function() {
          }).catch(function(e3) {
            var expandedKeysToRestore = arrDel(expandedKeys.value, key2);
            setExpandedKeys(expandedKeysToRestore);
            Promise.reject(e3);
          });
        }
      }
    };
    var onListChangeStart = function onListChangeStart2() {
      listChanging.value = true;
    };
    var onListChangeEnd = function onListChangeEnd2() {
      setTimeout(function() {
        listChanging.value = false;
      });
    };
    var onActiveChange = function onActiveChange2(newActiveKey) {
      var onActiveChange3 = props2.onActiveChange;
      if (activeKey.value === newActiveKey) {
        return;
      }
      if (props2.activeKey !== void 0) {
        activeKey.value = newActiveKey;
      }
      if (newActiveKey !== null) {
        scrollTo2({
          key: newActiveKey
        });
      }
      if (onActiveChange3) {
        onActiveChange3(newActiveKey);
      }
    };
    var activeItem = Vue.computed(function() {
      if (activeKey.value === null) {
        return null;
      }
      return flattenNodes.value.find(function(_ref6) {
        var key2 = _ref6.key;
        return key2 === activeKey.value;
      }) || null;
    });
    var offsetActiveKey = function offsetActiveKey2(offset3) {
      var index2 = flattenNodes.value.findIndex(function(_ref7) {
        var key3 = _ref7.key;
        return key3 === activeKey.value;
      });
      if (index2 === -1 && offset3 < 0) {
        index2 = flattenNodes.value.length;
      }
      index2 = (index2 + offset3 + flattenNodes.value.length) % flattenNodes.value.length;
      var item = flattenNodes.value[index2];
      if (item) {
        var key2 = item.key;
        onActiveChange(key2);
      } else {
        onActiveChange(null);
      }
    };
    var activeItemEventNode = Vue.computed(function() {
      return convertNodePropsToEventData(_extends(_extends({}, getTreeNodeProps(activeKey.value, treeNodeRequiredProps.value)), {
        data: activeItem.value.data,
        active: true
      }));
    });
    var onKeydown = function onKeydown2(event) {
      var onKeydown3 = props2.onKeydown, checkable = props2.checkable, selectable = props2.selectable;
      switch (event.which) {
        case KeyCode$1.UP: {
          offsetActiveKey(-1);
          event.preventDefault();
          break;
        }
        case KeyCode$1.DOWN: {
          offsetActiveKey(1);
          event.preventDefault();
          break;
        }
      }
      var item = activeItem.value;
      if (item && item.data) {
        var expandable = item.data.isLeaf === false || !!(item.data.children || []).length;
        var eventNode = activeItemEventNode.value;
        switch (event.which) {
          case KeyCode$1.LEFT: {
            if (expandable && expandedKeysSet.value.has(activeKey.value)) {
              onNodeExpand({}, eventNode);
            } else if (item.parent) {
              onActiveChange(item.parent.key);
            }
            event.preventDefault();
            break;
          }
          case KeyCode$1.RIGHT: {
            if (expandable && !expandedKeysSet.value.has(activeKey.value)) {
              onNodeExpand({}, eventNode);
            } else if (item.children && item.children.length) {
              onActiveChange(item.children[0].key);
            }
            event.preventDefault();
            break;
          }
          case KeyCode$1.ENTER:
          case KeyCode$1.SPACE: {
            if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
              onNodeCheck({}, eventNode, !checkedKeysSet.value.has(activeKey.value));
            } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
              onNodeSelect({}, eventNode);
            }
            break;
          }
        }
      }
      if (onKeydown3) {
        onKeydown3(event);
      }
    };
    expose({
      onNodeExpand,
      scrollTo: scrollTo2,
      onKeydown,
      selectedKeys: Vue.computed(function() {
        return selectedKeys.value;
      }),
      checkedKeys: Vue.computed(function() {
        return checkedKeys.value;
      }),
      halfCheckedKeys: Vue.computed(function() {
        return halfCheckedKeys.value;
      }),
      loadedKeys: Vue.computed(function() {
        return loadedKeys.value;
      }),
      loadingKeys: Vue.computed(function() {
        return loadingKeys.value;
      }),
      expandedKeys: Vue.computed(function() {
        return expandedKeys.value;
      })
    });
    Vue.onUnmounted(function() {
      window.removeEventListener("dragend", onWindowDragEnd);
      destroyed.value = true;
    });
    useProvideKeysState({
      expandedKeys,
      selectedKeys,
      loadedKeys,
      loadingKeys,
      checkedKeys,
      halfCheckedKeys,
      expandedKeysSet,
      selectedKeysSet,
      loadedKeysSet,
      loadingKeysSet,
      checkedKeysSet,
      halfCheckedKeysSet,
      flattenNodes
    });
    return function() {
      var _classNames;
      var draggingNodeKey = dragState.draggingNodeKey, dropLevelOffset = dragState.dropLevelOffset, dropContainerKey = dragState.dropContainerKey, dropTargetKey = dragState.dropTargetKey, dropPosition = dragState.dropPosition, dragOverNodeKey = dragState.dragOverNodeKey;
      var prefixCls = props2.prefixCls, showLine = props2.showLine, focusable = props2.focusable, _props$tabindex = props2.tabindex, tabindex = _props$tabindex === void 0 ? 0 : _props$tabindex, selectable = props2.selectable, showIcon = props2.showIcon, _props$icon = props2.icon, icon = _props$icon === void 0 ? slots.icon : _props$icon, switcherIcon = props2.switcherIcon, draggable = props2.draggable, checkable = props2.checkable, checkStrictly = props2.checkStrictly, disabled = props2.disabled, motion = props2.motion, loadData = props2.loadData, filterTreeNode = props2.filterTreeNode, height = props2.height, itemHeight = props2.itemHeight, virtual = props2.virtual, dropIndicatorRender2 = props2.dropIndicatorRender, onContextmenu2 = props2.onContextmenu, onScroll = props2.onScroll, direction = props2.direction;
      var className = attrs.class, style = attrs.style;
      var domProps = pickAttrs(_extends(_extends({}, props2), attrs), {
        aria: true,
        data: true
      });
      var draggableConfig;
      if (draggable) {
        if (_typeof$1(draggable) === "object") {
          draggableConfig = draggable;
        } else if (typeof draggable === "function") {
          draggableConfig = {
            nodeDraggable: draggable
          };
        } else {
          draggableConfig = {};
        }
      }
      return Vue.createVNode(TreeContext, {
        "value": {
          prefixCls,
          selectable,
          showIcon,
          icon,
          switcherIcon,
          draggable: draggableConfig,
          draggingNodeKey,
          checkable,
          customCheckable: slots.checkable,
          checkStrictly,
          disabled,
          keyEntities: keyEntities.value,
          dropLevelOffset,
          dropContainerKey,
          dropTargetKey,
          dropPosition,
          dragOverNodeKey,
          dragging: draggingNodeKey !== null,
          indent: indent.value,
          direction,
          dropIndicatorRender: dropIndicatorRender2,
          loadData,
          filterTreeNode,
          onNodeClick,
          onNodeDoubleClick,
          onNodeExpand,
          onNodeSelect,
          onNodeCheck,
          onNodeLoad,
          onNodeMouseEnter,
          onNodeMouseLeave,
          onNodeContextMenu,
          onNodeDragStart,
          onNodeDragEnter,
          onNodeDragOver,
          onNodeDragLeave,
          onNodeDragEnd,
          onNodeDrop,
          slots
        }
      }, {
        default: function _default5() {
          return [Vue.createVNode("div", {
            "role": "tree",
            "class": classNames(prefixCls, className, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls, "-show-line"), showLine), _defineProperty$T(_classNames, "".concat(prefixCls, "-focused"), focused.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-active-focused"), activeKey.value !== null), _classNames))
          }, [Vue.createVNode(NodeList, _objectSpread2$1({
            "ref": listRef,
            "prefixCls": prefixCls,
            "style": style,
            "disabled": disabled,
            "selectable": selectable,
            "checkable": !!checkable,
            "motion": motion,
            "height": height,
            "itemHeight": itemHeight,
            "virtual": virtual,
            "focusable": focusable,
            "focused": focused.value,
            "tabindex": tabindex,
            "activeItem": activeItem.value,
            "onFocus": onFocus2,
            "onBlur": onBlur2,
            "onKeydown": onKeydown,
            "onActiveChange": onActiveChange,
            "onListChangeStart": onListChangeStart,
            "onListChangeEnd": onListChangeEnd,
            "onContextmenu": onContextmenu2,
            "onScroll": onScroll
          }, domProps), null)])];
        }
      });
    };
  }
});
function renderSwitcherIcon(prefixCls, switcherIcon, showLine, props2) {
  var isLeaf = props2.isLeaf, expanded = props2.expanded, loading = props2.loading;
  var icon = switcherIcon;
  if (loading) {
    return Vue.createVNode(LoadingOutlined$1, {
      "class": "".concat(prefixCls, "-switcher-loading-icon")
    }, null);
  }
  var showLeafIcon;
  if (showLine && _typeof$1(showLine) === "object") {
    showLeafIcon = showLine.showLeafIcon;
  }
  var defaultIcon = null;
  var switcherCls = "".concat(prefixCls, "-switcher-icon");
  if (isLeaf) {
    if (showLine) {
      if (_typeof$1(showLine) === "object" && !showLeafIcon) {
        defaultIcon = Vue.createVNode("span", {
          "class": "".concat(prefixCls, "-switcher-leaf-line")
        }, null);
      } else {
        defaultIcon = Vue.createVNode(FileOutlined$1, {
          "class": "".concat(prefixCls, "-switcher-line-icon")
        }, null);
      }
    }
    return defaultIcon;
  } else {
    defaultIcon = Vue.createVNode(CaretDownFilled$1, {
      "class": switcherCls
    }, null);
    if (showLine) {
      defaultIcon = expanded ? Vue.createVNode(MinusSquareOutlined$1, {
        "class": "".concat(prefixCls, "-switcher-line-icon")
      }, null) : Vue.createVNode(PlusSquareOutlined$1, {
        "class": "".concat(prefixCls, "-switcher-line-icon")
      }, null);
    }
  }
  if (typeof switcherIcon === "function") {
    icon = switcherIcon(_extends(_extends({}, props2), {
      defaultIcon,
      switcherCls
    }));
  } else if (isValidElement(icon)) {
    icon = Vue.cloneVNode(icon, {
      class: switcherCls
    });
  }
  return icon || defaultIcon;
}
var offset$1 = 4;
function dropIndicatorRender(props2) {
  var _style;
  var dropPosition = props2.dropPosition, dropLevelOffset = props2.dropLevelOffset, prefixCls = props2.prefixCls, indent = props2.indent, _props$direction = props2.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction;
  var startPosition = direction === "ltr" ? "left" : "right";
  var endPosition = direction === "ltr" ? "right" : "left";
  var style = (_style = {}, _defineProperty$T(_style, startPosition, "".concat(-dropLevelOffset * indent + offset$1, "px")), _defineProperty$T(_style, endPosition, 0), _style);
  switch (dropPosition) {
    case -1:
      style.top = "".concat(-3, "px");
      break;
    case 1:
      style.bottom = "".concat(-3, "px");
      break;
    default:
      style.bottom = "".concat(-3, "px");
      style[startPosition] = "".concat(indent + offset$1, "px");
      break;
  }
  return Vue.createVNode("div", {
    "style": style,
    "class": "".concat(prefixCls, "-drop-indicator")
  }, null);
}
var treeProps = function treeProps3() {
  var baseTreeProps = treeProps$1();
  return _extends(_extends({}, baseTreeProps), {
    showLine: {
      type: [Boolean, Object],
      default: void 0
    },
    multiple: {
      type: Boolean,
      default: void 0
    },
    autoExpandParent: {
      type: Boolean,
      default: void 0
    },
    checkStrictly: {
      type: Boolean,
      default: void 0
    },
    checkable: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    defaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    defaultExpandParent: {
      type: Boolean,
      default: void 0
    },
    defaultExpandedKeys: {
      type: Array
    },
    expandedKeys: {
      type: Array
    },
    checkedKeys: {
      type: [Array, Object]
    },
    defaultCheckedKeys: {
      type: Array
    },
    selectedKeys: {
      type: Array
    },
    defaultSelectedKeys: {
      type: Array
    },
    selectable: {
      type: Boolean,
      default: void 0
    },
    loadedKeys: {
      type: Array
    },
    draggable: {
      type: Boolean,
      default: void 0
    },
    showIcon: {
      type: Boolean,
      default: void 0
    },
    icon: {
      type: Function
    },
    switcherIcon: PropTypes$1.any,
    prefixCls: String,
    replaceFields: {
      type: Object
    },
    blockNode: {
      type: Boolean,
      default: void 0
    },
    openAnimation: PropTypes$1.any,
    onDoubleclick: baseTreeProps.onDblclick,
    "onUpdate:selectedKeys": Function,
    "onUpdate:checkedKeys": Function,
    "onUpdate:expandedKeys": Function
  });
};
var Tree$1 = Vue.defineComponent({
  name: "ATree",
  inheritAttrs: false,
  props: initDefaultProps$1(treeProps(), {
    checkable: false,
    selectable: true,
    showIcon: false,
    blockNode: false
  }),
  slots: ["icon", "title", "switcherIcon", "titleRender"],
  setup: function setup113(props2, _ref) {
    var attrs = _ref.attrs, expose = _ref.expose, emit = _ref.emit, slots = _ref.slots;
    warning$1(!(props2.treeData === void 0 && slots.default));
    var _useConfigInject = useConfigInject("tree", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, virtual = _useConfigInject.virtual;
    var treeRef = Vue.ref();
    expose({
      treeRef,
      onNodeExpand: function onNodeExpand() {
        var _a2;
        var _a;
        (_a = treeRef.value) === null || _a === void 0 ? void 0 : (_a2 = _a).onNodeExpand.apply(_a2, arguments);
      },
      selectedKeys: Vue.computed(function() {
        var _a;
        return (_a = treeRef.value) === null || _a === void 0 ? void 0 : _a.selectedKeys;
      }),
      checkedKeys: Vue.computed(function() {
        var _a;
        return (_a = treeRef.value) === null || _a === void 0 ? void 0 : _a.checkedKeys;
      }),
      halfCheckedKeys: Vue.computed(function() {
        var _a;
        return (_a = treeRef.value) === null || _a === void 0 ? void 0 : _a.halfCheckedKeys;
      }),
      loadedKeys: Vue.computed(function() {
        var _a;
        return (_a = treeRef.value) === null || _a === void 0 ? void 0 : _a.loadedKeys;
      }),
      loadingKeys: Vue.computed(function() {
        var _a;
        return (_a = treeRef.value) === null || _a === void 0 ? void 0 : _a.loadingKeys;
      }),
      expandedKeys: Vue.computed(function() {
        var _a;
        return (_a = treeRef.value) === null || _a === void 0 ? void 0 : _a.expandedKeys;
      })
    });
    Vue.watchEffect(function() {
      devWarning(props2.replaceFields === void 0, "Tree", "`replaceFields` is deprecated, please use fieldNames instead");
    });
    var handleCheck = function handleCheck2(checkedObjOrKeys, eventObj) {
      emit("update:checkedKeys", checkedObjOrKeys);
      emit("check", checkedObjOrKeys, eventObj);
    };
    var handleExpand = function handleExpand2(expandedKeys, eventObj) {
      emit("update:expandedKeys", expandedKeys);
      emit("expand", expandedKeys, eventObj);
    };
    var handleSelect = function handleSelect2(selectedKeys, eventObj) {
      emit("update:selectedKeys", selectedKeys);
      emit("select", selectedKeys, eventObj);
    };
    return function() {
      var _classNames;
      var showIcon = props2.showIcon, showLine = props2.showLine, _props$switcherIcon = props2.switcherIcon, _switcherIcon = _props$switcherIcon === void 0 ? slots.switcherIcon : _props$switcherIcon, _props$icon = props2.icon, icon = _props$icon === void 0 ? slots.icon : _props$icon, blockNode = props2.blockNode, checkable = props2.checkable, selectable = props2.selectable, _props$fieldNames = props2.fieldNames, fieldNames = _props$fieldNames === void 0 ? props2.replaceFields : _props$fieldNames, _props$motion = props2.motion, motion = _props$motion === void 0 ? props2.openAnimation : _props$motion, _props$itemHeight = props2.itemHeight, itemHeight = _props$itemHeight === void 0 ? 28 : _props$itemHeight, onDoubleclick = props2.onDoubleclick, onDblclick = props2.onDblclick;
      var newProps = _extends(_extends(_extends({}, attrs), omit(props2, ["onUpdate:checkedKeys", "onUpdate:expandedKeys", "onUpdate:selectedKeys", "onDoubleclick"])), {
        showLine: Boolean(showLine),
        dropIndicatorRender,
        fieldNames,
        icon,
        itemHeight
      });
      var children = slots.default ? filterEmpty(slots.default()) : void 0;
      return Vue.createVNode(Tree$2, _objectSpread2$1(_objectSpread2$1({}, newProps), {}, {
        "virtual": virtual.value,
        "motion": motion,
        "ref": treeRef,
        "prefixCls": prefixCls.value,
        "class": classNames((_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls.value, "-icon-hide"), !showIcon), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-block-node"), blockNode), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-unselectable"), !selectable), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames), attrs.class),
        "direction": direction.value,
        "checkable": checkable,
        "selectable": selectable,
        "switcherIcon": function switcherIcon(nodeProps) {
          return renderSwitcherIcon(prefixCls.value, _switcherIcon, showLine, nodeProps);
        },
        "onCheck": handleCheck,
        "onExpand": handleExpand,
        "onSelect": handleSelect,
        "onDblclick": onDblclick || onDoubleclick,
        "children": children
      }), _extends(_extends({}, slots), {
        checkable: function checkable2() {
          return Vue.createVNode("span", {
            "class": "".concat(prefixCls.value, "-checkbox-inner")
          }, null);
        }
      }));
    };
  }
});
var Record;
(function(Record2) {
  Record2[Record2["None"] = 0] = "None";
  Record2[Record2["Start"] = 1] = "Start";
  Record2[Record2["End"] = 2] = "End";
})(Record || (Record = {}));
function traverseNodesKey(treeData, fieldNames, callback) {
  function processNode(dataNode) {
    var key2 = dataNode[fieldNames.key];
    var children = dataNode[fieldNames.children];
    if (callback(key2, dataNode) !== false) {
      traverseNodesKey(children || [], fieldNames, callback);
    }
  }
  treeData.forEach(processNode);
}
function calcRangeKeys(_ref) {
  var treeData = _ref.treeData, expandedKeys = _ref.expandedKeys, startKey = _ref.startKey, endKey = _ref.endKey, _ref$fieldNames = _ref.fieldNames, fieldNames = _ref$fieldNames === void 0 ? {
    title: "title",
    key: "key",
    children: "children"
  } : _ref$fieldNames;
  var keys2 = [];
  var record = Record.None;
  if (startKey && startKey === endKey) {
    return [startKey];
  }
  if (!startKey || !endKey) {
    return [];
  }
  function matchKey(key2) {
    return key2 === startKey || key2 === endKey;
  }
  traverseNodesKey(treeData, fieldNames, function(key2) {
    if (record === Record.End) {
      return false;
    }
    if (matchKey(key2)) {
      keys2.push(key2);
      if (record === Record.None) {
        record = Record.Start;
      } else if (record === Record.Start) {
        record = Record.End;
        return false;
      }
    } else if (record === Record.Start) {
      keys2.push(key2);
    }
    if (expandedKeys.indexOf(key2) === -1) {
      return false;
    }
    return true;
  });
  return keys2;
}
function convertDirectoryKeysToNodes(treeData, keys2, fieldNames) {
  var restKeys = _toConsumableArray(keys2);
  var nodes = [];
  traverseNodesKey(treeData, fieldNames, function(key2, node) {
    var index2 = restKeys.indexOf(key2);
    if (index2 !== -1) {
      nodes.push(node);
      restKeys.splice(index2, 1);
    }
    return !!restKeys.length;
  });
  return nodes;
}
var __rest$a = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var directoryTreeProps = function directoryTreeProps2() {
  return _extends(_extends({}, treeProps()), {
    expandAction: {
      type: [Boolean, String]
    }
  });
};
function getIcon(props2) {
  var isLeaf = props2.isLeaf, expanded = props2.expanded;
  if (isLeaf) {
    return Vue.createVNode(FileOutlined$1, null, null);
  }
  return expanded ? Vue.createVNode(FolderOpenOutlined$1, null, null) : Vue.createVNode(FolderOutlined$1, null, null);
}
var DirectoryTree = Vue.defineComponent({
  name: "ADirectoryTree",
  inheritAttrs: false,
  props: initDefaultProps$1(directoryTreeProps(), {
    showIcon: true,
    expandAction: "click"
  }),
  slots: ["icon", "title", "switcherIcon", "titleRender"],
  setup: function setup114(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    var _a;
    var treeData = Vue.ref(props2.treeData || convertTreeToData(filterEmpty((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots))));
    Vue.watch(function() {
      return props2.treeData;
    }, function() {
      treeData.value = props2.treeData;
    });
    Vue.onUpdated(function() {
      Vue.nextTick(function() {
        var _a2;
        if (props2.treeData === void 0 && slots.default) {
          treeData.value = convertTreeToData(filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)));
        }
      });
    });
    var lastSelectedKey = Vue.ref();
    var cachedSelectedKeys = Vue.ref();
    var treeRef = Vue.ref();
    expose({
      selectedKeys: Vue.computed(function() {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.selectedKeys;
      }),
      checkedKeys: Vue.computed(function() {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.checkedKeys;
      }),
      halfCheckedKeys: Vue.computed(function() {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.halfCheckedKeys;
      }),
      loadedKeys: Vue.computed(function() {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.loadedKeys;
      }),
      loadingKeys: Vue.computed(function() {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.loadingKeys;
      }),
      expandedKeys: Vue.computed(function() {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.expandedKeys;
      })
    });
    var getInitExpandedKeys = function getInitExpandedKeys2() {
      var _convertDataToEntitie = convertDataToEntities(treeData.value), keyEntities = _convertDataToEntitie.keyEntities;
      var initExpandedKeys;
      if (props2.defaultExpandAll) {
        initExpandedKeys = Object.keys(keyEntities);
      } else if (props2.defaultExpandParent) {
        initExpandedKeys = conductExpandParent(props2.expandedKeys || props2.defaultExpandedKeys || [], keyEntities);
      } else {
        initExpandedKeys = props2.expandedKeys || props2.defaultExpandedKeys;
      }
      return initExpandedKeys;
    };
    var selectedKeys = Vue.ref(props2.selectedKeys || props2.defaultSelectedKeys || []);
    var expandedKeys = Vue.ref(getInitExpandedKeys());
    Vue.watch(function() {
      return props2.selectedKeys;
    }, function() {
      if (props2.selectedKeys !== void 0) {
        selectedKeys.value = props2.selectedKeys;
      }
    }, {
      immediate: true
    });
    Vue.watch(function() {
      return props2.expandedKeys;
    }, function() {
      if (props2.expandedKeys !== void 0) {
        expandedKeys.value = props2.expandedKeys;
      }
    }, {
      immediate: true
    });
    var expandFolderNode = function expandFolderNode2(event, node) {
      var isLeaf = node.isLeaf;
      if (isLeaf || event.shiftKey || event.metaKey || event.ctrlKey) {
        return;
      }
      treeRef.value.onNodeExpand(event, node);
    };
    var onDebounceExpand = debounce(expandFolderNode, 200, {
      leading: true
    });
    var onExpand = function onExpand2(keys2, info) {
      if (props2.expandedKeys === void 0) {
        expandedKeys.value = keys2;
      }
      emit("update:expandedKeys", keys2);
      emit("expand", keys2, info);
    };
    var onClick2 = function onClick3(event, node) {
      var expandAction = props2.expandAction;
      if (expandAction === "click") {
        onDebounceExpand(event, node);
      }
      emit("click", event, node);
    };
    var onDoubleClick = function onDoubleClick2(event, node) {
      var expandAction = props2.expandAction;
      if (expandAction === "dblclick" || expandAction === "doubleclick") {
        onDebounceExpand(event, node);
      }
      emit("doubleclick", event, node);
      emit("dblclick", event, node);
    };
    var fieldNames = Vue.computed(function() {
      return fillFieldNames(props2.fieldNames);
    });
    var onSelect = function onSelect2(keys2, event) {
      var multiple = props2.multiple;
      var node = event.node, nativeEvent = event.nativeEvent;
      var key2 = node[fieldNames.value.key];
      var newEvent = _extends(_extends({}, event), {
        selected: true
      });
      var ctrlPick = (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.ctrlKey) || (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.metaKey);
      var shiftPick = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.shiftKey;
      var newSelectedKeys;
      if (multiple && ctrlPick) {
        newSelectedKeys = keys2;
        lastSelectedKey.value = key2;
        cachedSelectedKeys.value = newSelectedKeys;
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
      } else if (multiple && shiftPick) {
        newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.value || []), _toConsumableArray(calcRangeKeys({
          treeData: treeData.value,
          expandedKeys: expandedKeys.value,
          startKey: key2,
          endKey: lastSelectedKey.value,
          fieldNames: fieldNames.value
        })))));
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
      } else {
        newSelectedKeys = keys2;
        lastSelectedKey.value = key2;
        cachedSelectedKeys.value = newSelectedKeys;
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
      }
      emit("update:selectedKeys", newSelectedKeys);
      emit("select", newSelectedKeys, newEvent);
      if (props2.selectedKeys === void 0) {
        selectedKeys.value = newSelectedKeys;
      }
    };
    var onCheck = function onCheck2(checkedObjOrKeys, eventObj) {
      emit("update:checkedKeys", checkedObjOrKeys);
      emit("check", checkedObjOrKeys, eventObj);
    };
    var _useConfigInject = useConfigInject("tree", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    return function() {
      var connectClassName = classNames("".concat(prefixCls.value, "-directory"), _defineProperty$T({}, "".concat(prefixCls.value, "-directory-rtl"), direction.value === "rtl"), attrs.class);
      var _props$icon = props2.icon, icon = _props$icon === void 0 ? slots.icon : _props$icon, _props$blockNode = props2.blockNode, blockNode = _props$blockNode === void 0 ? true : _props$blockNode, otherProps = __rest$a(props2, ["icon", "blockNode"]);
      return Vue.createVNode(Tree$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "icon": icon || getIcon,
        "ref": treeRef,
        "blockNode": blockNode
      }, otherProps), {}, {
        "prefixCls": prefixCls.value,
        "class": connectClassName,
        "expandedKeys": expandedKeys.value,
        "selectedKeys": selectedKeys.value,
        "onSelect": onSelect,
        "onClick": onClick2,
        "onDblclick": onDoubleClick,
        "onExpand": onExpand,
        "onCheck": onCheck
      }), slots);
    };
  }
});
var TreeNode = Vue.defineComponent(_extends(_extends({}, VcTreeNode), {
  name: "ATreeNode",
  props: treeNodeProps
}));
var Tree = _extends(Tree$1, {
  DirectoryTree,
  TreeNode,
  install: function install3(app) {
    app.component(Tree$1.name, Tree$1);
    app.component(TreeNode.name, TreeNode);
    app.component(DirectoryTree.name, DirectoryTree);
    return app;
  }
});
var SubMenu = Menu.SubMenu, MenuItem = Menu.Item;
function hasSubMenu(filters) {
  return filters.some(function(_ref) {
    var children = _ref.children;
    return children && children.length > 0;
  });
}
function searchValueMatched(searchValue, text) {
  if (typeof text === "string" || typeof text === "number") {
    return text === null || text === void 0 ? void 0 : text.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
  }
  return false;
}
function renderFilterItems(_ref2) {
  var filters = _ref2.filters, prefixCls = _ref2.prefixCls, filteredKeys = _ref2.filteredKeys, filterMultiple = _ref2.filterMultiple, searchValue = _ref2.searchValue, filterSearch = _ref2.filterSearch;
  return filters.map(function(filter, index2) {
    var key2 = String(filter.value);
    if (filter.children) {
      return Vue.createVNode(SubMenu, {
        "key": key2 || index2,
        "title": filter.text,
        "popupClassName": "".concat(prefixCls, "-dropdown-submenu")
      }, {
        default: function _default5() {
          return [renderFilterItems({
            filters: filter.children,
            prefixCls,
            filteredKeys,
            filterMultiple,
            searchValue,
            filterSearch
          })];
        }
      });
    }
    var Component = filterMultiple ? Checkbox$1 : Radio;
    var item = Vue.createVNode(MenuItem, {
      "key": filter.value !== void 0 ? key2 : index2
    }, {
      default: function _default5() {
        return [Vue.createVNode(Component, {
          "checked": filteredKeys.includes(key2)
        }, null), Vue.createVNode("span", null, [filter.text])];
      }
    });
    if (searchValue.trim()) {
      if (typeof filterSearch === "function") {
        return filterSearch(searchValue, filter) ? item : void 0;
      }
      return searchValueMatched(searchValue, filter.text) ? item : void 0;
    }
    return item;
  });
}
var FilterDropdown = Vue.defineComponent({
  name: "FilterDropdown",
  props: ["tablePrefixCls", "prefixCls", "dropdownPrefixCls", "column", "filterState", "filterMultiple", "filterMode", "filterSearch", "columnKey", "triggerFilter", "locale", "getPopupContainer"],
  setup: function setup115(props2, _ref3) {
    var slots = _ref3.slots;
    var contextSlots = useInjectSlots();
    var filterMode = Vue.computed(function() {
      var _a;
      return (_a = props2.filterMode) !== null && _a !== void 0 ? _a : "menu";
    });
    var filterSearch = Vue.computed(function() {
      var _a;
      return (_a = props2.filterSearch) !== null && _a !== void 0 ? _a : false;
    });
    var filterDropdownVisible = Vue.computed(function() {
      return props2.column.filterDropdownVisible;
    });
    var visible = Vue.ref(false);
    var filtered = Vue.computed(function() {
      var _a;
      return !!(props2.filterState && (((_a = props2.filterState.filteredKeys) === null || _a === void 0 ? void 0 : _a.length) || props2.filterState.forceFiltered));
    });
    var filterFlattenKeys = Vue.computed(function() {
      var _a;
      return flattenKeys((_a = props2.column) === null || _a === void 0 ? void 0 : _a.filters);
    });
    var filterDropdownRef = Vue.computed(function() {
      var _props$column = props2.column, filterDropdown = _props$column.filterDropdown, _props$column$slots = _props$column.slots, slots2 = _props$column$slots === void 0 ? {} : _props$column$slots, customFilterDropdown = _props$column.customFilterDropdown;
      return filterDropdown || slots2.filterDropdown && contextSlots.value[slots2.filterDropdown] || customFilterDropdown && contextSlots.value.customFilterDropdown;
    });
    var filterIconRef = Vue.computed(function() {
      var _props$column2 = props2.column, filterIcon = _props$column2.filterIcon, _props$column2$slots = _props$column2.slots, slots2 = _props$column2$slots === void 0 ? {} : _props$column2$slots;
      return filterIcon || slots2.filterIcon && contextSlots.value[slots2.filterIcon] || contextSlots.value.customFilterIcon;
    });
    var triggerVisible = function triggerVisible2(newVisible) {
      var _a, _b;
      visible.value = newVisible;
      (_b = (_a = props2.column).onFilterDropdownVisibleChange) === null || _b === void 0 ? void 0 : _b.call(_a, newVisible);
    };
    var mergedVisible = Vue.computed(function() {
      return typeof filterDropdownVisible.value === "boolean" ? filterDropdownVisible.value : visible.value;
    });
    var propFilteredKeys = Vue.computed(function() {
      var _a;
      return (_a = props2.filterState) === null || _a === void 0 ? void 0 : _a.filteredKeys;
    });
    var filteredKeys = Vue.shallowRef([]);
    var onSelectKeys = function onSelectKeys2(_ref4) {
      var selectedKeys = _ref4.selectedKeys;
      filteredKeys.value = selectedKeys;
    };
    var onCheck = function onCheck2(keys2, _ref5) {
      var node = _ref5.node, checked = _ref5.checked;
      if (!props2.filterMultiple) {
        onSelectKeys({
          selectedKeys: checked && node.key ? [node.key] : []
        });
      } else {
        onSelectKeys({
          selectedKeys: keys2
        });
      }
    };
    Vue.watch(propFilteredKeys, function() {
      if (!visible.value) {
        return;
      }
      onSelectKeys({
        selectedKeys: propFilteredKeys.value || []
      });
    }, {
      immediate: true
    });
    var openKeys = Vue.shallowRef([]);
    var openRef = Vue.ref();
    var onOpenChange = function onOpenChange2(keys2) {
      openRef.value = setTimeout(function() {
        openKeys.value = keys2;
      });
    };
    var onMenuClick = function onMenuClick2() {
      clearTimeout(openRef.value);
    };
    Vue.onBeforeUnmount(function() {
      clearTimeout(openRef.value);
    });
    var searchValue = Vue.ref("");
    var onSearch = function onSearch2(e2) {
      var value = e2.target.value;
      searchValue.value = value;
    };
    Vue.watch(visible, function() {
      if (!visible.value) {
        searchValue.value = "";
      }
    });
    var internalTriggerFilter = function internalTriggerFilter2(keys2) {
      var column = props2.column, columnKey = props2.columnKey, filterState = props2.filterState;
      var mergedKeys = keys2 && keys2.length ? keys2 : null;
      if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
        return null;
      }
      if (isEqual$1(mergedKeys, filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys)) {
        return null;
      }
      props2.triggerFilter({
        column,
        key: columnKey,
        filteredKeys: mergedKeys
      });
    };
    var onConfirm = function onConfirm2() {
      triggerVisible(false);
      internalTriggerFilter(filteredKeys.value);
    };
    var onReset = function onReset2() {
      var _ref6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        confirm: false,
        closeDropdown: false
      }, confirm3 = _ref6.confirm, closeDropdown = _ref6.closeDropdown;
      if (confirm3) {
        internalTriggerFilter([]);
      }
      if (closeDropdown) {
        triggerVisible(false);
      }
      searchValue.value = "";
      filteredKeys.value = [];
    };
    var doFilter = function doFilter2() {
      var _ref7 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        closeDropdown: true
      }, closeDropdown = _ref7.closeDropdown;
      if (closeDropdown) {
        triggerVisible(false);
      }
      internalTriggerFilter(filteredKeys.value);
    };
    var onVisibleChange = function onVisibleChange2(newVisible) {
      if (newVisible && propFilteredKeys.value !== void 0) {
        filteredKeys.value = propFilteredKeys.value || [];
      }
      triggerVisible(newVisible);
      if (!newVisible && !filterDropdownRef.value) {
        onConfirm();
      }
    };
    var _useConfigInject = useConfigInject("", props2), direction = _useConfigInject.direction;
    var onCheckAll = function onCheckAll2(e2) {
      if (e2.target.checked) {
        var allFilterKeys = filterFlattenKeys.value;
        filteredKeys.value = allFilterKeys;
      } else {
        filteredKeys.value = [];
      }
    };
    var getTreeData = function getTreeData2(_ref8) {
      var filters = _ref8.filters;
      return (filters || []).map(function(filter, index2) {
        var key2 = String(filter.value);
        var item = {
          title: filter.text,
          key: filter.value !== void 0 ? key2 : index2
        };
        if (filter.children) {
          item.children = getTreeData2({
            filters: filter.children
          });
        }
        return item;
      });
    };
    var treeData = Vue.computed(function() {
      return getTreeData({
        filters: props2.column.filters
      });
    });
    var dropdownMenuClass = Vue.computed(function() {
      return classNames(_defineProperty$T({}, "".concat(props2.dropdownPrefixCls, "-menu-without-submenu"), !hasSubMenu(props2.column.filters || [])));
    });
    var getFilterComponent = function getFilterComponent2() {
      var selectedKeys = filteredKeys.value;
      var column = props2.column, locale2 = props2.locale, tablePrefixCls = props2.tablePrefixCls, filterMultiple = props2.filterMultiple, dropdownPrefixCls = props2.dropdownPrefixCls, getPopupContainer = props2.getPopupContainer, prefixCls = props2.prefixCls;
      if ((column.filters || []).length === 0) {
        return Vue.createVNode(Empty$1, {
          "image": Empty$1.PRESENTED_IMAGE_SIMPLE,
          "description": locale2.filterEmptyText,
          "imageStyle": {
            height: 24
          },
          "style": {
            margin: 0,
            padding: "16px 0"
          }
        }, null);
      }
      if (filterMode.value === "tree") {
        return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode(FilterSearch, {
          "filterSearch": filterSearch.value,
          "value": searchValue.value,
          "onChange": onSearch,
          "tablePrefixCls": tablePrefixCls,
          "locale": locale2
        }, null), Vue.createVNode("div", {
          "class": "".concat(tablePrefixCls, "-filter-dropdown-tree")
        }, [filterMultiple ? Vue.createVNode(Checkbox$1, {
          "class": "".concat(tablePrefixCls, "-filter-dropdown-checkall"),
          "onChange": onCheckAll,
          "checked": selectedKeys.length === filterFlattenKeys.value.length,
          "indeterminate": selectedKeys.length > 0 && selectedKeys.length < filterFlattenKeys.value.length
        }, {
          default: function _default5() {
            return [locale2.filterCheckall];
          }
        }) : null, Vue.createVNode(Tree, {
          "checkable": true,
          "selectable": false,
          "blockNode": true,
          "multiple": filterMultiple,
          "checkStrictly": !filterMultiple,
          "class": "".concat(dropdownPrefixCls, "-menu"),
          "onCheck": onCheck,
          "checkedKeys": selectedKeys,
          "selectedKeys": selectedKeys,
          "showIcon": false,
          "treeData": treeData.value,
          "autoExpandParent": true,
          "defaultExpandAll": true,
          "filterTreeNode": searchValue.value.trim() ? function(node) {
            return searchValueMatched(searchValue.value, node.title);
          } : void 0
        }, null)])]);
      }
      return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode(FilterSearch, {
        "filterSearch": filterSearch.value,
        "value": searchValue.value,
        "onChange": onSearch,
        "tablePrefixCls": tablePrefixCls,
        "locale": locale2
      }, null), Vue.createVNode(Menu, {
        "multiple": filterMultiple,
        "prefixCls": "".concat(dropdownPrefixCls, "-menu"),
        "class": dropdownMenuClass.value,
        "onClick": onMenuClick,
        "onSelect": onSelectKeys,
        "onDeselect": onSelectKeys,
        "selectedKeys": selectedKeys,
        "getPopupContainer": getPopupContainer,
        "openKeys": openKeys.value,
        "onOpenChange": onOpenChange
      }, {
        default: function _default5() {
          return renderFilterItems({
            filters: column.filters || [],
            filterSearch: filterSearch.value,
            prefixCls,
            filteredKeys: filteredKeys.value,
            filterMultiple,
            searchValue: searchValue.value
          });
        }
      })]);
    };
    return function() {
      var _a;
      var tablePrefixCls = props2.tablePrefixCls, prefixCls = props2.prefixCls, column = props2.column, dropdownPrefixCls = props2.dropdownPrefixCls, locale2 = props2.locale, getPopupContainer = props2.getPopupContainer;
      var dropdownContent;
      if (typeof filterDropdownRef.value === "function") {
        dropdownContent = filterDropdownRef.value({
          prefixCls: "".concat(dropdownPrefixCls, "-custom"),
          setSelectedKeys: function setSelectedKeys(selectedKeys2) {
            return onSelectKeys({
              selectedKeys: selectedKeys2
            });
          },
          selectedKeys: filteredKeys.value,
          confirm: doFilter,
          clearFilters: onReset,
          filters: column.filters,
          visible: mergedVisible.value,
          column: column.__originColumn__
        });
      } else if (filterDropdownRef.value) {
        dropdownContent = filterDropdownRef.value;
      } else {
        var selectedKeys = filteredKeys.value;
        dropdownContent = Vue.createVNode(Vue.Fragment, null, [getFilterComponent(), Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-dropdown-btns")
        }, [Vue.createVNode(Button$1, {
          "type": "link",
          "size": "small",
          "disabled": selectedKeys.length === 0,
          "onClick": function onClick2() {
            return onReset();
          }
        }, {
          default: function _default5() {
            return [locale2.filterReset];
          }
        }), Vue.createVNode(Button$1, {
          "type": "primary",
          "size": "small",
          "onClick": onConfirm
        }, {
          default: function _default5() {
            return [locale2.filterConfirm];
          }
        })])]);
      }
      var menu = Vue.createVNode(FilterDropdownMenuWrapper$1, {
        "class": "".concat(prefixCls, "-dropdown")
      }, {
        default: function _default5() {
          return [dropdownContent];
        }
      });
      var filterIcon;
      if (typeof filterIconRef.value === "function") {
        filterIcon = filterIconRef.value({
          filtered: filtered.value,
          column: column.__originColumn__
        });
      } else if (filterIconRef.value) {
        filterIcon = filterIconRef.value;
      } else {
        filterIcon = Vue.createVNode(FilterFilled$1, null, null);
      }
      return Vue.createVNode("div", {
        "class": "".concat(prefixCls, "-column")
      }, [Vue.createVNode("span", {
        "class": "".concat(tablePrefixCls, "-column-title")
      }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]), Vue.createVNode(DropDown, {
        "overlay": menu,
        "trigger": ["click"],
        "visible": mergedVisible.value,
        "onVisibleChange": onVisibleChange,
        "getPopupContainer": getPopupContainer,
        "placement": direction.value === "rtl" ? "bottomLeft" : "bottomRight"
      }, {
        default: function _default5() {
          return [Vue.createVNode("span", {
            "role": "button",
            "tabindex": -1,
            "class": classNames("".concat(prefixCls, "-trigger"), {
              active: filtered.value
            }),
            "onClick": function onClick2(e2) {
              e2.stopPropagation();
            }
          }, [filterIcon])];
        }
      })]);
    };
  }
});
function collectFilterStates(columns, init, pos) {
  var filterStates = [];
  (columns || []).forEach(function(column, index2) {
    var _a, _b;
    var columnPos = getColumnPos(index2, pos);
    var hasFilterDropdown = column.filterDropdown || ((_a = column === null || column === void 0 ? void 0 : column.slots) === null || _a === void 0 ? void 0 : _a.filterDropdown) || column.customFilterDropdown;
    if (column.filters || hasFilterDropdown || "onFilter" in column) {
      if ("filteredValue" in column) {
        var filteredValues = column.filteredValue;
        if (!hasFilterDropdown) {
          filteredValues = (_b = filteredValues === null || filteredValues === void 0 ? void 0 : filteredValues.map(String)) !== null && _b !== void 0 ? _b : filteredValues;
        }
        filterStates.push({
          column,
          key: getColumnKey(column, columnPos),
          filteredKeys: filteredValues,
          forceFiltered: column.filtered
        });
      } else {
        filterStates.push({
          column,
          key: getColumnKey(column, columnPos),
          filteredKeys: init && column.defaultFilteredValue ? column.defaultFilteredValue : void 0,
          forceFiltered: column.filtered
        });
      }
    }
    if ("children" in column) {
      filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column.children, init, columnPos)));
    }
  });
  return filterStates;
}
function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, triggerFilter, getPopupContainer, locale2, pos) {
  return columns.map(function(column, index2) {
    var _a;
    var columnPos = getColumnPos(index2, pos);
    var _column$filterMultipl = column.filterMultiple, filterMultiple = _column$filterMultipl === void 0 ? true : _column$filterMultipl, filterMode = column.filterMode, filterSearch = column.filterSearch;
    var newColumn = column;
    var hasFilterDropdown = column.filterDropdown || ((_a = column === null || column === void 0 ? void 0 : column.slots) === null || _a === void 0 ? void 0 : _a.filterDropdown) || column.customFilterDropdown;
    if (newColumn.filters || hasFilterDropdown) {
      var columnKey = getColumnKey(newColumn, columnPos);
      var filterState = filterStates.find(function(_ref) {
        var key2 = _ref.key;
        return columnKey === key2;
      });
      newColumn = _extends(_extends({}, newColumn), {
        title: function title(renderProps) {
          return Vue.createVNode(FilterDropdown, {
            "tablePrefixCls": prefixCls,
            "prefixCls": "".concat(prefixCls, "-filter"),
            "dropdownPrefixCls": dropdownPrefixCls,
            "column": newColumn,
            "columnKey": columnKey,
            "filterState": filterState,
            "filterMultiple": filterMultiple,
            "filterMode": filterMode,
            "filterSearch": filterSearch,
            "triggerFilter": triggerFilter,
            "locale": locale2,
            "getPopupContainer": getPopupContainer
          }, {
            default: function _default5() {
              return [renderColumnTitle(column.title, renderProps)];
            }
          });
        }
      });
    }
    if ("children" in newColumn) {
      newColumn = _extends(_extends({}, newColumn), {
        children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, triggerFilter, getPopupContainer, locale2, columnPos)
      });
    }
    return newColumn;
  });
}
function flattenKeys(filters) {
  var keys2 = [];
  (filters || []).forEach(function(_ref2) {
    var value = _ref2.value, children = _ref2.children;
    keys2.push(value);
    if (children) {
      keys2 = [].concat(_toConsumableArray(keys2), _toConsumableArray(flattenKeys(children)));
    }
  });
  return keys2;
}
function generateFilterInfo(filterStates) {
  var currentFilters = {};
  filterStates.forEach(function(_ref3) {
    var key2 = _ref3.key, filteredKeys = _ref3.filteredKeys, column = _ref3.column;
    var _a;
    var hasFilterDropdown = column.filterDropdown || ((_a = column === null || column === void 0 ? void 0 : column.slots) === null || _a === void 0 ? void 0 : _a.filterDropdown) || column.customFilterDropdown;
    var filters = column.filters;
    if (hasFilterDropdown) {
      currentFilters[key2] = filteredKeys || null;
    } else if (Array.isArray(filteredKeys)) {
      var keys2 = flattenKeys(filters);
      currentFilters[key2] = keys2.filter(function(originKey) {
        return filteredKeys.includes(String(originKey));
      });
    } else {
      currentFilters[key2] = null;
    }
  });
  return currentFilters;
}
function getFilterData(data4, filterStates) {
  return filterStates.reduce(function(currentData, filterState) {
    var _filterState$column = filterState.column, onFilter = _filterState$column.onFilter, filters = _filterState$column.filters, filteredKeys = filterState.filteredKeys;
    if (onFilter && filteredKeys && filteredKeys.length) {
      return currentData.filter(function(record) {
        return filteredKeys.some(function(key2) {
          var keys2 = flattenKeys(filters);
          var keyIndex = keys2.findIndex(function(k2) {
            return String(k2) === String(key2);
          });
          var realKey = keyIndex !== -1 ? keys2[keyIndex] : key2;
          return onFilter(realKey, record);
        });
      });
    }
    return currentData;
  }, data4);
}
function useFilter(_ref4) {
  var prefixCls = _ref4.prefixCls, dropdownPrefixCls = _ref4.dropdownPrefixCls, mergedColumns = _ref4.mergedColumns, locale2 = _ref4.locale, onFilterChange = _ref4.onFilterChange, getPopupContainer = _ref4.getPopupContainer;
  var _useState = useState(collectFilterStates(mergedColumns.value, true)), _useState2 = _slicedToArray(_useState, 2), filterStates = _useState2[0], setFilterStates = _useState2[1];
  var mergedFilterStates = Vue.computed(function() {
    var collectedStates = collectFilterStates(mergedColumns.value, false);
    var filteredKeysIsNotControlled = collectedStates.every(function(_ref5) {
      var filteredKeys = _ref5.filteredKeys;
      return filteredKeys === void 0;
    });
    if (filteredKeysIsNotControlled) {
      return filterStates.value;
    }
    var filteredKeysIsAllControlled = collectedStates.every(function(_ref6) {
      var filteredKeys = _ref6.filteredKeys;
      return filteredKeys !== void 0;
    });
    devWarning(filteredKeysIsNotControlled || filteredKeysIsAllControlled, "Table", "`FilteredKeys` should all be controlled or not controlled.");
    return collectedStates;
  });
  var filters = Vue.computed(function() {
    return generateFilterInfo(mergedFilterStates.value);
  });
  var triggerFilter = function triggerFilter2(filterState) {
    var newFilterStates = mergedFilterStates.value.filter(function(_ref7) {
      var key2 = _ref7.key;
      return key2 !== filterState.key;
    });
    newFilterStates.push(filterState);
    setFilterStates(newFilterStates);
    onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
  };
  var transformColumns = function transformColumns2(innerColumns) {
    return injectFilter(prefixCls.value, dropdownPrefixCls.value, innerColumns, mergedFilterStates.value, triggerFilter, getPopupContainer.value, locale2.value);
  };
  return [transformColumns, mergedFilterStates, filters];
}
function fillTitle(columns, columnTitleProps) {
  return columns.map(function(column) {
    var cloneColumn = _extends({}, column);
    cloneColumn.title = renderColumnTitle(cloneColumn.title, columnTitleProps);
    if ("children" in cloneColumn) {
      cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
    }
    return cloneColumn;
  });
}
function useTitleColumns(columnTitleProps) {
  var filledColumns = function filledColumns2(columns) {
    return fillTitle(columns, columnTitleProps.value);
  };
  return [filledColumns];
}
function renderExpandIcon(locale2) {
  return function expandIcon(_ref) {
    var _classNames;
    var prefixCls = _ref.prefixCls, onExpand = _ref.onExpand, record = _ref.record, expanded = _ref.expanded, expandable = _ref.expandable;
    var iconPrefix = "".concat(prefixCls, "-row-expand-icon");
    return Vue.createVNode("button", {
      "type": "button",
      "onClick": function onClick2(e2) {
        onExpand(record, e2);
        e2.stopPropagation();
      },
      "class": classNames(iconPrefix, (_classNames = {}, _defineProperty$T(_classNames, "".concat(iconPrefix, "-spaced"), !expandable), _defineProperty$T(_classNames, "".concat(iconPrefix, "-expanded"), expandable && expanded), _defineProperty$T(_classNames, "".concat(iconPrefix, "-collapsed"), expandable && !expanded), _classNames)),
      "aria-label": expanded ? locale2.collapse : locale2.expand
    }, null);
  };
}
function isWindow(obj) {
  return obj !== null && obj !== void 0 && obj === obj.window;
}
function getScroll$1(target, top) {
  var _a;
  if (typeof window === "undefined") {
    return 0;
  }
  var method = top ? "scrollTop" : "scrollLeft";
  var result = 0;
  if (isWindow(target)) {
    result = target[top ? "pageYOffset" : "pageXOffset"];
  } else if (target instanceof Document) {
    result = target.documentElement[method];
  } else if (target) {
    result = target[method];
  }
  if (target && !isWindow(target) && typeof result !== "number") {
    result = (_a = (target.ownerDocument || target).documentElement) === null || _a === void 0 ? void 0 : _a[method];
  }
  return result;
}
function easeInOutCubic(t2, b2, c2, d2) {
  var cc = c2 - b2;
  t2 /= d2 / 2;
  if (t2 < 1) {
    return cc / 2 * t2 * t2 * t2 + b2;
  }
  return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
}
function scrollTo$1(y2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _options$getContainer = options.getContainer, getContainer4 = _options$getContainer === void 0 ? function() {
    return window;
  } : _options$getContainer, callback = options.callback, _options$duration = options.duration, duration = _options$duration === void 0 ? 450 : _options$duration;
  var container = getContainer4();
  var scrollTop = getScroll$1(container, true);
  var startTime = Date.now();
  var frameFunc = function frameFunc2() {
    var timestamp = Date.now();
    var time = timestamp - startTime;
    var nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y2, duration);
    if (isWindow(container)) {
      container.scrollTo(window.pageXOffset, nextScrollTop);
    } else if (container instanceof HTMLDocument || container.constructor.name === "HTMLDocument") {
      container.documentElement.scrollTop = nextScrollTop;
    } else {
      container.scrollTop = nextScrollTop;
    }
    if (time < duration) {
      wrapperRaf(frameFunc2);
    } else if (typeof callback === "function") {
      callback();
    }
  };
  wrapperRaf(frameFunc);
}
function fillSlots(columns, contextSlots) {
  var $slots = contextSlots.value;
  return columns.map(function(column) {
    var _a;
    if (column === SELECTION_COLUMN || column === EXPAND_COLUMN)
      return column;
    var cloneColumn = _extends({}, column);
    var _cloneColumn$slots = cloneColumn.slots, slots = _cloneColumn$slots === void 0 ? {} : _cloneColumn$slots;
    cloneColumn.__originColumn__ = column;
    devWarning(!("slots" in cloneColumn), "Table", "`column.slots` is deprecated. Please use `v-slot:headerCell` `v-slot:bodyCell` instead.");
    Object.keys(slots).forEach(function(key2) {
      var name = slots[key2];
      if (cloneColumn[key2] === void 0 && $slots[name]) {
        cloneColumn[key2] = $slots[name];
      }
    });
    if (contextSlots.value.headerCell && !((_a = column.slots) === null || _a === void 0 ? void 0 : _a.title)) {
      cloneColumn.title = Vue.renderSlot(contextSlots.value, "headerCell", {
        title: column.title,
        column
      }, function() {
        return [column.title];
      });
    }
    if ("children" in cloneColumn) {
      cloneColumn.children = fillSlots(cloneColumn.children, contextSlots);
    }
    return cloneColumn;
  });
}
function useColumns(contextSlots) {
  var filledColumns = function filledColumns2(columns) {
    return fillSlots(columns, contextSlots);
  };
  return [filledColumns];
}
var EMPTY_LIST = [];
var tableProps = function tableProps2() {
  return {
    prefixCls: {
      type: String,
      default: void 0
    },
    columns: {
      type: Array,
      default: void 0
    },
    rowKey: {
      type: [String, Function],
      default: void 0
    },
    tableLayout: {
      type: String,
      default: void 0
    },
    rowClassName: {
      type: [String, Function],
      default: void 0
    },
    title: {
      type: Function,
      default: void 0
    },
    footer: {
      type: Function,
      default: void 0
    },
    id: {
      type: String,
      default: void 0
    },
    showHeader: {
      type: Boolean,
      default: void 0
    },
    components: {
      type: Object,
      default: void 0
    },
    customRow: {
      type: Function,
      default: void 0
    },
    customHeaderRow: {
      type: Function,
      default: void 0
    },
    direction: {
      type: String,
      default: void 0
    },
    expandFixed: {
      type: [Boolean, String],
      default: void 0
    },
    expandColumnWidth: {
      type: Number,
      default: void 0
    },
    expandedRowKeys: {
      type: Array,
      default: void 0
    },
    defaultExpandedRowKeys: {
      type: Array,
      default: void 0
    },
    expandedRowRender: {
      type: Function,
      default: void 0
    },
    expandRowByClick: {
      type: Boolean,
      default: void 0
    },
    expandIcon: {
      type: Function,
      default: void 0
    },
    onExpand: {
      type: Function,
      default: void 0
    },
    onExpandedRowsChange: {
      type: Function,
      default: void 0
    },
    defaultExpandAllRows: {
      type: Boolean,
      default: void 0
    },
    indentSize: {
      type: Number,
      default: void 0
    },
    expandIconColumnIndex: {
      type: Number,
      default: void 0
    },
    showExpandColumn: {
      type: Boolean,
      default: void 0
    },
    expandedRowClassName: {
      type: Function,
      default: void 0
    },
    childrenColumnName: {
      type: String,
      default: void 0
    },
    rowExpandable: {
      type: Function,
      default: void 0
    },
    sticky: {
      type: [Boolean, Object],
      default: void 0
    },
    dropdownPrefixCls: String,
    dataSource: {
      type: Array,
      default: void 0
    },
    pagination: {
      type: [Boolean, Object],
      default: void 0
    },
    loading: {
      type: [Boolean, Object],
      default: void 0
    },
    size: {
      type: String,
      default: void 0
    },
    bordered: Boolean,
    locale: {
      type: Object,
      default: void 0
    },
    onChange: {
      type: Function,
      default: void 0
    },
    onResizeColumn: {
      type: Function,
      default: void 0
    },
    rowSelection: {
      type: Object,
      default: void 0
    },
    getPopupContainer: {
      type: Function,
      default: void 0
    },
    scroll: {
      type: Object,
      default: void 0
    },
    sortDirections: {
      type: Array,
      default: void 0
    },
    showSorterTooltip: {
      type: [Boolean, Object],
      default: true
    },
    contextSlots: {
      type: Object
    },
    transformCellText: {
      type: Function
    }
  };
};
var InteralTable = Vue.defineComponent({
  name: "InteralTable",
  inheritAttrs: false,
  props: initDefaultProps$1(tableProps(), {
    rowKey: "key"
  }),
  slots: ["emptyText", "expandIcon", "title", "footer", "summary", "expandedRowRender", "bodyCell", "headerCell", "customFilterIcon", "customFilterDropdown"],
  setup: function setup116(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose, emit = _ref.emit;
    devWarning(!(typeof props2.rowKey === "function" && props2.rowKey.length > 1), "Table", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected.");
    useProvideSlots(Vue.computed(function() {
      return props2.contextSlots;
    }));
    useProvideTableContext({
      onResizeColumn: function onResizeColumn(w2, col) {
        emit("resizeColumn", w2, col);
      }
    });
    var screens2 = useBreakpoint();
    var mergedColumns = Vue.computed(function() {
      var matched = new Set(Object.keys(screens2.value).filter(function(m2) {
        return screens2.value[m2];
      }));
      return props2.columns.filter(function(c2) {
        return !c2.responsive || c2.responsive.some(function(r2) {
          return matched.has(r2);
        });
      });
    });
    var _useConfigInject = useConfigInject("table", props2), mergedSize = _useConfigInject.size, renderEmpty2 = _useConfigInject.renderEmpty, direction = _useConfigInject.direction, prefixCls = _useConfigInject.prefixCls, configProvider = _useConfigInject.configProvider;
    var transformCellText = Vue.computed(function() {
      return props2.transformCellText || configProvider.transformCellText;
    });
    var _useLocaleReceiver = useLocaleReceiver("Table", defaultLocale.Table, Vue.toRef(props2, "locale")), _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 1), tableLocale = _useLocaleReceiver2[0];
    var rawData = Vue.computed(function() {
      return props2.dataSource || EMPTY_LIST;
    });
    var dropdownPrefixCls = Vue.computed(function() {
      return configProvider.getPrefixCls("dropdown", props2.dropdownPrefixCls);
    });
    var childrenColumnName = Vue.computed(function() {
      return props2.childrenColumnName || "children";
    });
    var expandType = Vue.computed(function() {
      if (rawData.value.some(function(item) {
        var _a;
        return (_a = item) === null || _a === void 0 ? void 0 : _a[childrenColumnName.value];
      })) {
        return "nest";
      }
      if (props2.expandedRowRender) {
        return "row";
      }
      return null;
    });
    var internalRefs = Vue.reactive({
      body: null
    });
    var updateInternalRefs = function updateInternalRefs2(refs) {
      _extends(internalRefs, refs);
    };
    var getRowKey = Vue.computed(function() {
      if (typeof props2.rowKey === "function") {
        return props2.rowKey;
      }
      return function(record) {
        var _a;
        return (_a = record) === null || _a === void 0 ? void 0 : _a[props2.rowKey];
      };
    });
    var _useLazyKVMap = useLazyKVMap(rawData, childrenColumnName, getRowKey), _useLazyKVMap2 = _slicedToArray(_useLazyKVMap, 1), getRecordByKey = _useLazyKVMap2[0];
    var changeEventInfo = {};
    var triggerOnChange = function triggerOnChange2(info, action) {
      var reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var pagination = props2.pagination, scroll = props2.scroll, onChange = props2.onChange;
      var changeInfo = _extends(_extends({}, changeEventInfo), info);
      if (reset) {
        changeEventInfo.resetPagination();
        if (changeInfo.pagination.current) {
          changeInfo.pagination.current = 1;
        }
        if (pagination && pagination.onChange) {
          pagination.onChange(1, changeInfo.pagination.pageSize);
        }
      }
      if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body) {
        scrollTo$1(0, {
          getContainer: function getContainer4() {
            return internalRefs.body;
          }
        });
      }
      onChange === null || onChange === void 0 ? void 0 : onChange(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
        currentDataSource: getFilterData(getSortData(rawData.value, changeInfo.sorterStates, childrenColumnName.value), changeInfo.filterStates),
        action
      });
    };
    var onSorterChange = function onSorterChange2(sorter, sorterStates) {
      triggerOnChange({
        sorter,
        sorterStates
      }, "sort", false);
    };
    var _useSorter = useFilterSorter({
      prefixCls,
      mergedColumns,
      onSorterChange,
      sortDirections: Vue.computed(function() {
        return props2.sortDirections || ["ascend", "descend"];
      }),
      tableLocale,
      showSorterTooltip: Vue.toRef(props2, "showSorterTooltip")
    }), _useSorter2 = _slicedToArray(_useSorter, 4), transformSorterColumns = _useSorter2[0], sortStates = _useSorter2[1], sorterTitleProps = _useSorter2[2], sorters = _useSorter2[3];
    var sortedData = Vue.computed(function() {
      return getSortData(rawData.value, sortStates.value, childrenColumnName.value);
    });
    var onFilterChange = function onFilterChange2(filters2, filterStates2) {
      triggerOnChange({
        filters: filters2,
        filterStates: filterStates2
      }, "filter", true);
    };
    var _useFilter = useFilter({
      prefixCls,
      locale: tableLocale,
      dropdownPrefixCls,
      mergedColumns,
      onFilterChange,
      getPopupContainer: Vue.toRef(props2, "getPopupContainer")
    }), _useFilter2 = _slicedToArray(_useFilter, 3), transformFilterColumns = _useFilter2[0], filterStates = _useFilter2[1], filters = _useFilter2[2];
    var mergedData = Vue.computed(function() {
      return getFilterData(sortedData.value, filterStates.value);
    });
    var _useColumns = useColumns(Vue.toRef(props2, "contextSlots")), _useColumns2 = _slicedToArray(_useColumns, 1), transformBasicColumns = _useColumns2[0];
    var columnTitleProps = Vue.computed(function() {
      return _extends({}, sorterTitleProps.value);
    });
    var _useTitleColumns = useTitleColumns(columnTitleProps), _useTitleColumns2 = _slicedToArray(_useTitleColumns, 1), transformTitleColumns = _useTitleColumns2[0];
    var onPaginationChange = function onPaginationChange2(current2, pageSize2) {
      triggerOnChange({
        pagination: _extends(_extends({}, changeEventInfo.pagination), {
          current: current2,
          pageSize: pageSize2
        })
      }, "paginate");
    };
    var _usePagination = usePagination(Vue.computed(function() {
      return mergedData.value.length;
    }), Vue.toRef(props2, "pagination"), onPaginationChange), _usePagination2 = _slicedToArray(_usePagination, 2), mergedPagination = _usePagination2[0], resetPagination = _usePagination2[1];
    Vue.watchEffect(function() {
      changeEventInfo.sorter = sorters.value;
      changeEventInfo.sorterStates = sortStates.value;
      changeEventInfo.filters = filters.value;
      changeEventInfo.filterStates = filterStates.value;
      changeEventInfo.pagination = props2.pagination === false ? {} : getPaginationParam(props2.pagination, mergedPagination.value);
      changeEventInfo.resetPagination = resetPagination;
    });
    var pageData = Vue.computed(function() {
      if (props2.pagination === false || !mergedPagination.value.pageSize) {
        return mergedData.value;
      }
      var _mergedPagination$val = mergedPagination.value, _mergedPagination$val2 = _mergedPagination$val.current, current2 = _mergedPagination$val2 === void 0 ? 1 : _mergedPagination$val2, total2 = _mergedPagination$val.total, _mergedPagination$val3 = _mergedPagination$val.pageSize, pageSize2 = _mergedPagination$val3 === void 0 ? DEFAULT_PAGE_SIZE : _mergedPagination$val3;
      devWarning(current2 > 0, "Table", "`current` should be positive number.");
      if (mergedData.value.length < total2) {
        if (mergedData.value.length > pageSize2) {
          return mergedData.value.slice((current2 - 1) * pageSize2, current2 * pageSize2);
        }
        return mergedData.value;
      }
      return mergedData.value.slice((current2 - 1) * pageSize2, current2 * pageSize2);
    });
    Vue.watchEffect(function() {
      Vue.nextTick(function() {
        var _mergedPagination$val4 = mergedPagination.value, total2 = _mergedPagination$val4.total, _mergedPagination$val5 = _mergedPagination$val4.pageSize, pageSize2 = _mergedPagination$val5 === void 0 ? DEFAULT_PAGE_SIZE : _mergedPagination$val5;
        if (mergedData.value.length < total2) {
          if (mergedData.value.length > pageSize2) {
            devWarning(false, "Table", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.");
          }
        }
      });
    }, {
      flush: "post"
    });
    var expandIconColumnIndex = Vue.computed(function() {
      if (props2.showExpandColumn === false)
        return -1;
      if (expandType.value === "nest" && props2.expandIconColumnIndex === void 0) {
        return props2.rowSelection ? 1 : 0;
      } else if (props2.expandIconColumnIndex > 0 && props2.rowSelection) {
        return props2.expandIconColumnIndex - 1;
      }
      return props2.expandIconColumnIndex;
    });
    var rowSelection = Vue.ref();
    Vue.watch(function() {
      return props2.rowSelection;
    }, function() {
      rowSelection.value = props2.rowSelection ? _extends({}, props2.rowSelection) : props2.rowSelection;
    }, {
      deep: true,
      immediate: true
    });
    var _useSelection = useSelection(rowSelection, {
      prefixCls,
      data: mergedData,
      pageData,
      getRowKey,
      getRecordByKey,
      expandType,
      childrenColumnName,
      locale: tableLocale,
      getPopupContainer: Vue.computed(function() {
        return props2.getPopupContainer;
      })
    }), _useSelection2 = _slicedToArray(_useSelection, 2), transformSelectionColumns = _useSelection2[0], selectedKeySet = _useSelection2[1];
    var internalRowClassName = function internalRowClassName2(record, index2, indent) {
      var mergedRowClassName;
      var rowClassName = props2.rowClassName;
      if (typeof rowClassName === "function") {
        mergedRowClassName = classNames(rowClassName(record, index2, indent));
      } else {
        mergedRowClassName = classNames(rowClassName);
      }
      return classNames(_defineProperty$T({}, "".concat(prefixCls.value, "-row-selected"), selectedKeySet.value.has(getRowKey.value(record, index2))), mergedRowClassName);
    };
    expose({
      selectedKeySet
    });
    var indentSize = Vue.computed(function() {
      return typeof props2.indentSize === "number" ? props2.indentSize : 15;
    });
    var transformColumns = function transformColumns2(innerColumns) {
      var res = transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(transformBasicColumns(innerColumns)))));
      return res;
    };
    return function() {
      var _classNames3;
      var _a;
      var _props$expandIcon = props2.expandIcon, expandIcon = _props$expandIcon === void 0 ? slots.expandIcon || renderExpandIcon(tableLocale.value) : _props$expandIcon, pagination = props2.pagination, loading = props2.loading, bordered = props2.bordered;
      var topPaginationNode;
      var bottomPaginationNode;
      if (pagination !== false && ((_a = mergedPagination.value) === null || _a === void 0 ? void 0 : _a.total)) {
        var paginationSize;
        if (mergedPagination.value.size) {
          paginationSize = mergedPagination.value.size;
        } else {
          paginationSize = mergedSize.value === "small" || mergedSize.value === "middle" ? "small" : void 0;
        }
        var renderPagination = function renderPagination2(position2) {
          return Vue.createVNode(_Pagination, _objectSpread2$1(_objectSpread2$1({}, mergedPagination.value), {}, {
            "class": ["".concat(prefixCls.value, "-pagination ").concat(prefixCls.value, "-pagination-").concat(position2), mergedPagination.value.class],
            "size": paginationSize
          }), null);
        };
        var defaultPosition = direction.value === "rtl" ? "left" : "right";
        var position = mergedPagination.value.position;
        if (position !== null && Array.isArray(position)) {
          var topPos = position.find(function(p2) {
            return p2.indexOf("top") !== -1;
          });
          var bottomPos = position.find(function(p2) {
            return p2.indexOf("bottom") !== -1;
          });
          var isDisable = position.every(function(p2) {
            return "".concat(p2) === "none";
          });
          if (!topPos && !bottomPos && !isDisable) {
            bottomPaginationNode = renderPagination(defaultPosition);
          }
          if (topPos) {
            topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""));
          }
          if (bottomPos) {
            bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", ""));
          }
        } else {
          bottomPaginationNode = renderPagination(defaultPosition);
        }
      }
      var spinProps3;
      if (typeof loading === "boolean") {
        spinProps3 = {
          spinning: loading
        };
      } else if (_typeof$1(loading) === "object") {
        spinProps3 = _extends({
          spinning: true
        }, loading);
      }
      var wrapperClassNames = classNames("".concat(prefixCls.value, "-wrapper"), _defineProperty$T({}, "".concat(prefixCls.value, "-wrapper-rtl"), direction.value === "rtl"), attrs.class);
      var tableProps3 = omit(props2, ["columns"]);
      return Vue.createVNode("div", {
        "class": wrapperClassNames,
        "style": attrs.style
      }, [Vue.createVNode(Spin, _objectSpread2$1({
        "spinning": false
      }, spinProps3), {
        default: function _default5() {
          return [topPaginationNode, Vue.createVNode(Table$2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), tableProps3), {}, {
            "expandedRowKeys": props2.expandedRowKeys,
            "defaultExpandedRowKeys": props2.defaultExpandedRowKeys,
            "expandIconColumnIndex": expandIconColumnIndex.value,
            "indentSize": indentSize.value,
            "expandIcon": expandIcon,
            "columns": mergedColumns.value,
            "direction": direction.value,
            "prefixCls": prefixCls.value,
            "class": classNames((_classNames3 = {}, _defineProperty$T(_classNames3, "".concat(prefixCls.value, "-middle"), mergedSize.value === "middle"), _defineProperty$T(_classNames3, "".concat(prefixCls.value, "-small"), mergedSize.value === "small"), _defineProperty$T(_classNames3, "".concat(prefixCls.value, "-bordered"), bordered), _defineProperty$T(_classNames3, "".concat(prefixCls.value, "-empty"), rawData.value.length === 0), _classNames3)),
            "data": pageData.value,
            "rowKey": getRowKey.value,
            "rowClassName": internalRowClassName,
            "internalHooks": INTERNAL_HOOKS,
            "internalRefs": internalRefs,
            "onUpdateInternalRefs": updateInternalRefs,
            "transformColumns": transformColumns,
            "transformCellText": transformCellText.value
          }), _extends(_extends({}, slots), {
            emptyText: function emptyText() {
              var _a2, _b;
              return ((_a2 = slots.emptyText) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || ((_b = props2.locale) === null || _b === void 0 ? void 0 : _b.emptyText) || renderEmpty2.value("Table");
            }
          })), bottomPaginationNode];
        }
      })]);
    };
  }
});
var Table = Vue.defineComponent({
  name: "ATable",
  inheritAttrs: false,
  setup: function setup117(_props, _ref2) {
    var attrs = _ref2.attrs, slots = _ref2.slots, expose = _ref2.expose;
    var table = Vue.ref();
    expose({
      table
    });
    return function() {
      var _a;
      var props2 = attrs;
      var columns = props2.columns || convertChildrenToColumns((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
      return Vue.createVNode(InteralTable, _objectSpread2$1(_objectSpread2$1({
        "ref": table
      }, attrs), {}, {
        "columns": columns || [],
        "expandedRowRender": slots.expandedRowRender,
        "contextSlots": _extends({}, slots)
      }), slots);
    };
  }
});
var Table$1 = Table;
var Column = Vue.defineComponent({
  name: "ATableColumn",
  slots: ["title", "filterIcon"],
  render: function render8() {
    return null;
  }
});
var ColumnGroup = Vue.defineComponent({
  name: "ATableColumnGroup",
  slots: ["title"],
  __ANT_TABLE_COLUMN_GROUP: true,
  render: function render9() {
    return null;
  }
});
var TableSummaryRow = Vue.defineComponent(_extends(_extends({}, SummaryRow), {
  name: "ATableSummaryRow"
}));
var TableSummaryCell = Vue.defineComponent(_extends(_extends({}, SummaryCell), {
  name: "ATableSummaryCell"
}));
var TableSummary = _extends(FooterComponents, {
  Cell: TableSummaryCell,
  Row: TableSummaryRow,
  name: "ATableSummary"
});
var _Table = _extends(Table$1, {
  SELECTION_ALL,
  SELECTION_INVERT,
  SELECTION_NONE,
  SELECTION_COLUMN,
  EXPAND_COLUMN,
  Column,
  ColumnGroup,
  Summary: TableSummary,
  install: function install4(app) {
    app.component(TableSummary.name, TableSummary);
    app.component(TableSummaryCell.name, TableSummaryCell);
    app.component(TableSummaryRow.name, TableSummaryRow);
    app.component(Table$1.name, Table$1);
    app.component(Column.name, Column);
    app.component(ColumnGroup.name, ColumnGroup);
    return app;
  }
});
var index$j = "";
var NoFound = function NoFound2() {
  return Vue.createVNode("svg", {
    "width": "252",
    "height": "294"
  }, [Vue.createVNode("defs", null, [Vue.createVNode("path", {
    "d": "M0 .387h251.772v251.772H0z"
  }, null)]), Vue.createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [Vue.createVNode("g", {
    "transform": "translate(0 .012)"
  }, [Vue.createVNode("mask", {
    "fill": "#fff"
  }, null), Vue.createVNode("path", {
    "d": "M0 127.32v-2.095C0 56.279 55.892.387 124.838.387h2.096c68.946 0 124.838 55.892 124.838 124.838v2.096c0 68.946-55.892 124.838-124.838 124.838h-2.096C55.892 252.16 0 196.267 0 127.321",
    "fill": "#E4EBF7",
    "mask": "url(#b)"
  }, null)]), Vue.createVNode("path", {
    "d": "M39.755 130.84a8.276 8.276 0 1 1-16.468-1.66 8.276 8.276 0 0 1 16.468 1.66",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M36.975 134.297l10.482 5.943M48.373 146.508l-12.648 10.788",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), Vue.createVNode("path", {
    "d": "M39.875 159.352a5.667 5.667 0 1 1-11.277-1.136 5.667 5.667 0 0 1 11.277 1.136M57.588 143.247a5.708 5.708 0 1 1-11.358-1.145 5.708 5.708 0 0 1 11.358 1.145M99.018 26.875l29.82-.014a4.587 4.587 0 1 0-.003-9.175l-29.82.013a4.587 4.587 0 1 0 .003 9.176M110.424 45.211l29.82-.013a4.588 4.588 0 0 0-.004-9.175l-29.82.013a4.587 4.587 0 1 0 .004 9.175",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M112.798 26.861v-.002l15.784-.006a4.588 4.588 0 1 0 .003 9.175l-15.783.007v-.002a4.586 4.586 0 0 0-.004-9.172M184.523 135.668c-.553 5.485-5.447 9.483-10.931 8.93-5.485-.553-9.483-5.448-8.93-10.932.552-5.485 5.447-9.483 10.932-8.93 5.485.553 9.483 5.447 8.93 10.932",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M179.26 141.75l12.64 7.167M193.006 156.477l-15.255 13.011",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), Vue.createVNode("path", {
    "d": "M184.668 170.057a6.835 6.835 0 1 1-13.6-1.372 6.835 6.835 0 0 1 13.6 1.372M203.34 153.325a6.885 6.885 0 1 1-13.7-1.382 6.885 6.885 0 0 1 13.7 1.382",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M151.931 192.324a2.222 2.222 0 1 1-4.444 0 2.222 2.222 0 0 1 4.444 0zM225.27 116.056a2.222 2.222 0 1 1-4.445 0 2.222 2.222 0 0 1 4.444 0zM216.38 151.08a2.223 2.223 0 1 1-4.446-.001 2.223 2.223 0 0 1 4.446 0zM176.917 107.636a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM195.291 92.165a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM202.058 180.711a2.223 2.223 0 1 1-4.446 0 2.223 2.223 0 0 1 4.446 0z",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), Vue.createVNode("path", {
    "stroke": "#FFF",
    "stroke-width": "2",
    "d": "M214.404 153.302l-1.912 20.184-10.928 5.99M173.661 174.792l-6.356 9.814h-11.36l-4.508 6.484M174.941 125.168v-15.804M220.824 117.25l-12.84 7.901-15.31-7.902V94.39"
  }, null), Vue.createVNode("path", {
    "d": "M166.588 65.936h-3.951a4.756 4.756 0 0 1-4.743-4.742 4.756 4.756 0 0 1 4.743-4.743h3.951a4.756 4.756 0 0 1 4.743 4.743 4.756 4.756 0 0 1-4.743 4.742",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M174.823 30.03c0-16.281 13.198-29.48 29.48-29.48 16.28 0 29.48 13.199 29.48 29.48 0 16.28-13.2 29.48-29.48 29.48-16.282 0-29.48-13.2-29.48-29.48",
    "fill": "#1890FF"
  }, null), Vue.createVNode("path", {
    "d": "M205.952 38.387c.5.5.785 1.142.785 1.928s-.286 1.465-.785 1.964c-.572.5-1.214.75-2 .75-.785 0-1.429-.285-1.929-.785-.572-.5-.82-1.143-.82-1.929s.248-1.428.82-1.928c.5-.5 1.144-.75 1.93-.75.785 0 1.462.25 1.999.75m4.285-19.463c1.428 1.249 2.143 2.963 2.143 5.142 0 1.712-.427 3.13-1.219 4.25-.067.096-.137.18-.218.265-.416.429-1.41 1.346-2.956 2.699a5.07 5.07 0 0 0-1.428 1.75 5.207 5.207 0 0 0-.536 2.357v.5h-4.107v-.5c0-1.357.215-2.536.714-3.5.464-.964 1.857-2.464 4.178-4.536l.43-.5c.643-.785.964-1.643.964-2.535 0-1.18-.358-2.108-1-2.785-.678-.68-1.643-1.001-2.858-1.001-1.536 0-2.642.464-3.357 1.43-.37.5-.621 1.135-.76 1.904a1.999 1.999 0 0 1-1.971 1.63h-.004c-1.277 0-2.257-1.183-1.98-2.43.337-1.518 1.02-2.78 2.073-3.784 1.536-1.5 3.607-2.25 6.25-2.25 2.32 0 4.214.607 5.642 1.894",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M52.04 76.131s21.81 5.36 27.307 15.945c5.575 10.74-6.352 9.26-15.73 4.935-10.86-5.008-24.7-11.822-11.577-20.88",
    "fill": "#FFB594"
  }, null), Vue.createVNode("path", {
    "d": "M90.483 67.504l-.449 2.893c-.753.49-4.748-2.663-4.748-2.663l-1.645.748-1.346-5.684s6.815-4.589 8.917-5.018c2.452-.501 9.884.94 10.7 2.278 0 0 1.32.486-2.227.69-3.548.203-5.043.447-6.79 3.132-1.747 2.686-2.412 3.624-2.412 3.624",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M128.055 111.367c-2.627-7.724-6.15-13.18-8.917-15.478-3.5-2.906-9.34-2.225-11.366-4.187-1.27-1.231-3.215-1.197-3.215-1.197s-14.98-3.158-16.828-3.479c-2.37-.41-2.124-.714-6.054-1.405-1.57-1.907-2.917-1.122-2.917-1.122l-7.11-1.383c-.853-1.472-2.423-1.023-2.423-1.023l-2.468-.897c-1.645 9.976-7.74 13.796-7.74 13.796 1.795 1.122 15.703 8.3 15.703 8.3l5.107 37.11s-3.321 5.694 1.346 9.109c0 0 19.883-3.743 34.921-.329 0 0 3.047-2.546.972-8.806.523-3.01 1.394-8.263 1.736-11.622.385.772 2.019 1.918 3.14 3.477 0 0 9.407-7.365 11.052-14.012-.832-.723-1.598-1.585-2.267-2.453-.567-.736-.358-2.056-.765-2.717-.669-1.084-1.804-1.378-1.907-1.682",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M101.09 289.998s4.295 2.041 7.354 1.021c2.821-.94 4.53.668 7.08 1.178 2.55.51 6.874 1.1 11.686-1.26-.103-5.51-6.889-3.98-11.96-6.713-2.563-1.38-3.784-4.722-3.598-8.799h-9.402s-1.392 10.52-1.16 14.573",
    "fill": "#CBD1D1"
  }, null), Vue.createVNode("path", {
    "d": "M101.067 289.826s2.428 1.271 6.759.653c3.058-.437 3.712.481 7.423 1.031 3.712.55 10.724-.069 11.823-.894.413 1.1-.343 2.063-.343 2.063s-1.512.603-4.812.824c-2.03.136-5.8.291-7.607-.503-1.787-1.375-5.247-1.903-5.728-.241-3.918.95-7.355-.286-7.355-.286l-.16-2.647z",
    "fill": "#2B0849"
  }, null), Vue.createVNode("path", {
    "d": "M108.341 276.044h3.094s-.103 6.702 4.536 8.558c-4.64.618-8.558-2.303-7.63-8.558",
    "fill": "#A4AABA"
  }, null), Vue.createVNode("path", {
    "d": "M57.542 272.401s-2.107 7.416-4.485 12.306c-1.798 3.695-4.225 7.492 5.465 7.492 6.648 0 8.953-.48 7.423-6.599-1.53-6.12.266-13.199.266-13.199h-8.669z",
    "fill": "#CBD1D1"
  }, null), Vue.createVNode("path", {
    "d": "M51.476 289.793s2.097 1.169 6.633 1.169c6.083 0 8.249-1.65 8.249-1.65s.602 1.114-.619 2.165c-.993.855-3.597 1.591-7.39 1.546-4.145-.048-5.832-.566-6.736-1.168-.825-.55-.687-1.58-.137-2.062",
    "fill": "#2B0849"
  }, null), Vue.createVNode("path", {
    "d": "M58.419 274.304s.033 1.519-.314 2.93c-.349 1.42-1.078 3.104-1.13 4.139-.058 1.151 4.537 1.58 5.155.034.62-1.547 1.294-6.427 1.913-7.252.619-.825-4.903-2.119-5.624.15",
    "fill": "#A4AABA"
  }, null), Vue.createVNode("path", {
    "d": "M99.66 278.514l13.378.092s1.298-54.52 1.853-64.403c.554-9.882 3.776-43.364 1.002-63.128l-12.547-.644-22.849.78s-.434 3.966-1.195 9.976c-.063.496-.682.843-.749 1.365-.075.585.423 1.354.32 1.966-2.364 14.08-6.377 33.104-8.744 46.677-.116.666-1.234 1.009-1.458 2.691-.04.302.211 1.525.112 1.795-6.873 18.744-10.949 47.842-14.277 61.885l14.607-.014s2.197-8.57 4.03-16.97c2.811-12.886 23.111-85.01 23.111-85.01l3.016-.521 1.043 46.35s-.224 1.234.337 2.02c.56.785-.56 1.123-.392 2.244l.392 1.794s-.449 7.178-.898 11.89c-.448 4.71-.092 39.165-.092 39.165",
    "fill": "#7BB2F9"
  }, null), Vue.createVNode("path", {
    "d": "M76.085 221.626c1.153.094 4.038-2.019 6.955-4.935M106.36 225.142s2.774-1.11 6.103-3.883",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M107.275 222.1s2.773-1.11 6.102-3.884",
    "stroke": "#648BD8",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M74.74 224.767s2.622-.591 6.505-3.365M86.03 151.634c-.27 3.106.3 8.525-4.336 9.123M103.625 149.88s.11 14.012-1.293 15.065c-2.219 1.664-2.99 1.944-2.99 1.944M99.79 150.438s.035 12.88-1.196 24.377M93.673 175.911s7.212-1.664 9.431-1.664M74.31 205.861a212.013 212.013 0 0 1-.979 4.56s-1.458 1.832-1.009 3.776c.449 1.944-.947 2.045-4.985 15.355-1.696 5.59-4.49 18.591-6.348 27.597l-.231 1.12M75.689 197.807a320.934 320.934 0 0 1-.882 4.754M82.591 152.233L81.395 162.7s-1.097.15-.5 2.244c.113 1.346-2.674 15.775-5.18 30.43M56.12 274.418h13.31",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M116.241 148.22s-17.047-3.104-35.893.2c.158 2.514-.003 4.15-.003 4.15s14.687-2.818 35.67-.312c.252-2.355.226-4.038.226-4.038",
    "fill": "#192064"
  }, null), Vue.createVNode("path", {
    "d": "M106.322 151.165l.003-4.911a.81.81 0 0 0-.778-.815c-2.44-.091-5.066-.108-7.836-.014a.818.818 0 0 0-.789.815l-.003 4.906a.81.81 0 0 0 .831.813c2.385-.06 4.973-.064 7.73.017a.815.815 0 0 0 .842-.81",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M105.207 150.233l.002-3.076a.642.642 0 0 0-.619-.646 94.321 94.321 0 0 0-5.866-.01.65.65 0 0 0-.63.647v3.072a.64.64 0 0 0 .654.644 121.12 121.12 0 0 1 5.794.011c.362.01.665-.28.665-.642",
    "fill": "#192064"
  }, null), Vue.createVNode("path", {
    "d": "M100.263 275.415h12.338M101.436 270.53c.006 3.387.042 5.79.111 6.506M101.451 264.548a915.75 915.75 0 0 0-.015 4.337M100.986 174.965l.898 44.642s.673 1.57-.225 2.692c-.897 1.122 2.468.673.898 2.243-1.57 1.57.897 1.122 0 3.365-.596 1.489-.994 21.1-1.096 35.146",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M46.876 83.427s-.516 6.045 7.223 5.552c11.2-.712 9.218-9.345 31.54-21.655-.786-2.708-2.447-4.744-2.447-4.744s-11.068 3.11-22.584 8.046c-6.766 2.9-13.395 6.352-13.732 12.801M104.46 91.057l.941-5.372-8.884-11.43-5.037 5.372-1.74 7.834a.321.321 0 0 0 .108.32c.965.8 6.5 5.013 14.347 3.544a.332.332 0 0 0 .264-.268",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M93.942 79.387s-4.533-2.853-2.432-6.855c1.623-3.09 4.513 1.133 4.513 1.133s.52-3.642 3.121-3.642c.52-1.04 1.561-4.162 1.561-4.162s11.445 2.601 13.526 3.121c0 5.203-2.304 19.424-7.84 19.861-8.892.703-12.449-9.456-12.449-9.456",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M113.874 73.446c2.601-2.081 3.47-9.722 3.47-9.722s-2.479-.49-6.64-2.05c-4.683-2.081-12.798-4.747-17.48.976-9.668 3.223-2.05 19.823-2.05 19.823l2.713-3.021s-3.935-3.287-2.08-6.243c2.17-3.462 3.92 1.073 3.92 1.073s.637-2.387 3.581-3.342c.355-.71 1.036-2.674 1.432-3.85a1.073 1.073 0 0 1 1.263-.704c2.4.558 8.677 2.019 11.356 2.662.522.125.871.615.82 1.15l-.305 3.248z",
    "fill": "#520038"
  }, null), Vue.createVNode("path", {
    "d": "M104.977 76.064c-.103.61-.582 1.038-1.07.956-.489-.083-.801-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.644.698 1.254M112.132 77.694c-.103.61-.582 1.038-1.07.956-.488-.083-.8-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.643.698 1.254",
    "fill": "#552950"
  }, null), Vue.createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M110.13 74.84l-.896 1.61-.298 4.357h-2.228"
  }, null), Vue.createVNode("path", {
    "d": "M110.846 74.481s1.79-.716 2.506.537",
    "stroke": "#5C2552",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M92.386 74.282s.477-1.114 1.113-.716c.637.398 1.274 1.433.558 1.99-.717.556.159 1.67.159 1.67",
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M103.287 72.93s1.83 1.113 4.137.954",
    "stroke": "#5C2552",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M103.685 81.762s2.227 1.193 4.376 1.193M104.64 84.308s.954.398 1.511.318M94.693 81.205s2.308 7.4 10.424 7.639",
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M81.45 89.384s.45 5.647-4.935 12.787M69 82.654s-.726 9.282-8.204 14.206",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M129.405 122.865s-5.272 7.403-9.422 10.768",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M119.306 107.329s.452 4.366-2.127 32.062",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M150.028 151.232h-49.837a1.01 1.01 0 0 1-1.01-1.01v-31.688c0-.557.452-1.01 1.01-1.01h49.837c.558 0 1.01.453 1.01 1.01v31.688a1.01 1.01 0 0 1-1.01 1.01",
    "fill": "#F2D7AD"
  }, null), Vue.createVNode("path", {
    "d": "M150.29 151.232h-19.863v-33.707h20.784v32.786a.92.92 0 0 1-.92.92",
    "fill": "#F4D19D"
  }, null), Vue.createVNode("path", {
    "d": "M123.554 127.896H92.917a.518.518 0 0 1-.425-.816l6.38-9.113c.193-.277.51-.442.85-.442h31.092l-7.26 10.371z",
    "fill": "#F2D7AD"
  }, null), Vue.createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M123.689 128.447H99.25v-.519h24.169l7.183-10.26.424.298z"
  }, null), Vue.createVNode("path", {
    "d": "M158.298 127.896h-18.669a2.073 2.073 0 0 1-1.659-.83l-7.156-9.541h19.965c.49 0 .95.23 1.244.622l6.69 8.92a.519.519 0 0 1-.415.83",
    "fill": "#F4D19D"
  }, null), Vue.createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M157.847 128.479h-19.384l-7.857-10.475.415-.31 7.7 10.266h19.126zM130.554 150.685l-.032-8.177.519-.002.032 8.177z"
  }, null), Vue.createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M130.511 139.783l-.08-21.414.519-.002.08 21.414zM111.876 140.932l-.498-.143 1.479-5.167.498.143zM108.437 141.06l-2.679-2.935 2.665-3.434.41.318-2.397 3.089 2.384 2.612zM116.607 141.06l-.383-.35 2.383-2.612-2.397-3.089.41-.318 2.665 3.434z"
  }, null), Vue.createVNode("path", {
    "d": "M154.316 131.892l-3.114-1.96.038 3.514-1.043.092c-1.682.115-3.634.23-4.789.23-1.902 0-2.693 2.258 2.23 2.648l-2.645-.596s-2.168 1.317.504 2.3c0 0-1.58 1.217.561 2.58-.584 3.504 5.247 4.058 7.122 3.59 1.876-.47 4.233-2.359 4.487-5.16.28-3.085-.89-5.432-3.35-7.238",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M153.686 133.577s-6.522.47-8.36.372c-1.836-.098-1.904 2.19 2.359 2.264 3.739.15 5.451-.044 5.451-.044",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M145.16 135.877c-1.85 1.346.561 2.355.561 2.355s3.478.898 6.73.617",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M151.89 141.71s-6.28.111-6.73-2.132c-.223-1.346.45-1.402.45-1.402M146.114 140.868s-1.103 3.16 5.44 3.533M151.202 129.932v3.477M52.838 89.286c3.533-.337 8.423-1.248 13.582-7.754",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M168.567 248.318a6.647 6.647 0 0 1-6.647-6.647v-66.466a6.647 6.647 0 1 1 13.294 0v66.466a6.647 6.647 0 0 1-6.647 6.647",
    "fill": "#5BA02E"
  }, null), Vue.createVNode("path", {
    "d": "M176.543 247.653a6.647 6.647 0 0 1-6.646-6.647v-33.232a6.647 6.647 0 1 1 13.293 0v33.232a6.647 6.647 0 0 1-6.647 6.647",
    "fill": "#92C110"
  }, null), Vue.createVNode("path", {
    "d": "M186.443 293.613H158.92a3.187 3.187 0 0 1-3.187-3.187v-46.134a3.187 3.187 0 0 1 3.187-3.187h27.524a3.187 3.187 0 0 1 3.187 3.187v46.134a3.187 3.187 0 0 1-3.187 3.187",
    "fill": "#F2D7AD"
  }, null), Vue.createVNode("path", {
    "d": "M88.979 89.48s7.776 5.384 16.6 2.842",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null)])]);
};
var noFound = NoFound;
var ServerError = function ServerError2() {
  return Vue.createVNode("svg", {
    "width": "254",
    "height": "294"
  }, [Vue.createVNode("defs", null, [Vue.createVNode("path", {
    "d": "M0 .335h253.49v253.49H0z"
  }, null), Vue.createVNode("path", {
    "d": "M0 293.665h253.49V.401H0z"
  }, null)]), Vue.createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [Vue.createVNode("g", {
    "transform": "translate(0 .067)"
  }, [Vue.createVNode("mask", {
    "fill": "#fff"
  }, null), Vue.createVNode("path", {
    "d": "M0 128.134v-2.11C0 56.608 56.273.334 125.69.334h2.11c69.416 0 125.69 56.274 125.69 125.69v2.11c0 69.417-56.274 125.69-125.69 125.69h-2.11C56.273 253.824 0 197.551 0 128.134",
    "fill": "#E4EBF7",
    "mask": "url(#b)"
  }, null)]), Vue.createVNode("path", {
    "d": "M39.989 132.108a8.332 8.332 0 1 1-16.581-1.671 8.332 8.332 0 0 1 16.58 1.671",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M37.19 135.59l10.553 5.983M48.665 147.884l-12.734 10.861",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), Vue.createVNode("path", {
    "d": "M40.11 160.816a5.706 5.706 0 1 1-11.354-1.145 5.706 5.706 0 0 1 11.354 1.145M57.943 144.6a5.747 5.747 0 1 1-11.436-1.152 5.747 5.747 0 0 1 11.436 1.153M99.656 27.434l30.024-.013a4.619 4.619 0 1 0-.004-9.238l-30.024.013a4.62 4.62 0 0 0 .004 9.238M111.14 45.896l30.023-.013a4.62 4.62 0 1 0-.004-9.238l-30.024.013a4.619 4.619 0 1 0 .004 9.238",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M113.53 27.421v-.002l15.89-.007a4.619 4.619 0 1 0 .005 9.238l-15.892.007v-.002a4.618 4.618 0 0 0-.004-9.234M150.167 70.091h-3.979a4.789 4.789 0 0 1-4.774-4.775 4.788 4.788 0 0 1 4.774-4.774h3.979a4.789 4.789 0 0 1 4.775 4.774 4.789 4.789 0 0 1-4.775 4.775",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M171.687 30.234c0-16.392 13.289-29.68 29.681-29.68 16.392 0 29.68 13.288 29.68 29.68 0 16.393-13.288 29.681-29.68 29.681s-29.68-13.288-29.68-29.68",
    "fill": "#FF603B"
  }, null), Vue.createVNode("path", {
    "d": "M203.557 19.435l-.676 15.035a1.514 1.514 0 0 1-3.026 0l-.675-15.035a2.19 2.19 0 1 1 4.377 0m-.264 19.378c.513.477.77 1.1.77 1.87s-.257 1.393-.77 1.907c-.55.476-1.21.733-1.943.733a2.545 2.545 0 0 1-1.87-.77c-.55-.514-.806-1.136-.806-1.87 0-.77.256-1.393.806-1.87.513-.513 1.137-.733 1.87-.733.77 0 1.43.22 1.943.733",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M119.3 133.275c4.426-.598 3.612-1.204 4.079-4.778.675-5.18-3.108-16.935-8.262-25.118-1.088-10.72-12.598-11.24-12.598-11.24s4.312 4.895 4.196 16.199c1.398 5.243.804 14.45.804 14.45s5.255 11.369 11.78 10.487",
    "fill": "#FFB594"
  }, null), Vue.createVNode("path", {
    "d": "M100.944 91.61s1.463-.583 3.211.582c8.08 1.398 10.368 6.706 11.3 11.368 1.864 1.282 1.864 2.33 1.864 3.496.365.777 1.515 3.03 1.515 3.03s-7.225 1.748-10.954 6.758c-1.399-6.41-6.936-25.235-6.936-25.235",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M94.008 90.5l1.019-5.815-9.23-11.874-5.233 5.581-2.593 9.863s8.39 5.128 16.037 2.246",
    "fill": "#FFB594"
  }, null), Vue.createVNode("path", {
    "d": "M82.931 78.216s-4.557-2.868-2.445-6.892c1.632-3.107 4.537 1.139 4.537 1.139s.524-3.662 3.139-3.662c.523-1.046 1.569-4.184 1.569-4.184s11.507 2.615 13.6 3.138c-.001 5.23-2.317 19.529-7.884 19.969-8.94.706-12.516-9.508-12.516-9.508",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M102.971 72.243c2.616-2.093 3.489-9.775 3.489-9.775s-2.492-.492-6.676-2.062c-4.708-2.092-12.867-4.771-17.575.982-9.54 4.41-2.062 19.93-2.062 19.93l2.729-3.037s-3.956-3.304-2.092-6.277c2.183-3.48 3.943 1.08 3.943 1.08s.64-2.4 3.6-3.36c.356-.714 1.04-2.69 1.44-3.872a1.08 1.08 0 0 1 1.27-.707c2.41.56 8.723 2.03 11.417 2.676.524.126.876.619.825 1.156l-.308 3.266z",
    "fill": "#520038"
  }, null), Vue.createVNode("path", {
    "d": "M101.22 76.514c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.961.491.083.805.647.702 1.26M94.26 75.074c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.96.491.082.805.646.702 1.26",
    "fill": "#552950"
  }, null), Vue.createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.063",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M99.206 73.644l-.9 1.62-.3 4.38h-2.24"
  }, null), Vue.createVNode("path", {
    "d": "M99.926 73.284s1.8-.72 2.52.54",
    "stroke": "#5C2552",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M81.367 73.084s.48-1.12 1.12-.72c.64.4 1.28 1.44.56 2s.16 1.68.16 1.68",
    "stroke": "#DB836E",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M92.326 71.724s1.84 1.12 4.16.96",
    "stroke": "#5C2552",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M92.726 80.604s2.24 1.2 4.4 1.2M93.686 83.164s.96.4 1.52.32M83.687 80.044s1.786 6.547 9.262 7.954",
    "stroke": "#DB836E",
    "stroke-width": "1.063",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M95.548 91.663s-1.068 2.821-8.298 2.105c-7.23-.717-10.29-5.044-10.29-5.044",
    "stroke": "#E4EBF7",
    "stroke-width": "1.136",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M78.126 87.478s6.526 4.972 16.47 2.486c0 0 9.577 1.02 11.536 5.322 5.36 11.77.543 36.835 0 39.962 3.496 4.055-.466 8.483-.466 8.483-15.624-3.548-35.81-.6-35.81-.6-4.849-3.546-1.223-9.044-1.223-9.044L62.38 110.32c-2.485-15.227.833-19.803 3.549-20.743 3.03-1.049 8.04-1.282 8.04-1.282.496-.058 1.08-.076 1.37-.233 2.36-1.282 2.787-.583 2.787-.583",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M65.828 89.81s-6.875.465-7.59 8.156c-.466 8.857 3.03 10.954 3.03 10.954s6.075 22.102 16.796 22.957c8.39-2.176 4.758-6.702 4.661-11.42-.233-11.304-7.108-16.897-7.108-16.897s-4.212-13.75-9.789-13.75",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M71.716 124.225s.855 11.264 9.828 6.486c4.765-2.536 7.581-13.828 9.789-22.568 1.456-5.768 2.58-12.197 2.58-12.197l-4.973-1.709s-2.408 5.516-7.769 12.275c-4.335 5.467-9.144 11.11-9.455 17.713",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M108.463 105.191s1.747 2.724-2.331 30.535c2.376 2.216 1.053 6.012-.233 7.51",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M123.262 131.527s-.427 2.732-11.77 1.981c-15.187-1.006-25.326-3.25-25.326-3.25l.933-5.8s.723.215 9.71-.068c11.887-.373 18.714-6.07 24.964-1.022 4.039 3.263 1.489 8.16 1.489 8.16",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M70.24 90.974s-5.593-4.739-11.054 2.68c-3.318 7.223.517 15.284 2.664 19.578-.31 3.729 2.33 4.311 2.33 4.311s.108.895 1.516 2.68c4.078-7.03 6.72-9.166 13.711-12.546-.328-.656-1.877-3.265-1.825-3.767.175-1.69-1.282-2.623-1.282-2.623s-.286-.156-1.165-2.738c-.788-2.313-2.036-5.177-4.895-7.575",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M90.232 288.027s4.855 2.308 8.313 1.155c3.188-1.063 5.12.755 8.002 1.331 2.881.577 7.769 1.243 13.207-1.424-.117-6.228-7.786-4.499-13.518-7.588-2.895-1.56-4.276-5.336-4.066-9.944H91.544s-1.573 11.89-1.312 16.47",
    "fill": "#CBD1D1"
  }, null), Vue.createVNode("path", {
    "d": "M90.207 287.833s2.745 1.437 7.639.738c3.456-.494 3.223.66 7.418 1.282 4.195.621 13.092-.194 14.334-1.126.466 1.242-.388 2.33-.388 2.33s-1.709.682-5.438.932c-2.295.154-8.098.276-10.14-.621-2.02-1.554-4.894-1.515-6.06-.234-4.427 1.075-7.184-.31-7.184-.31l-.181-2.991z",
    "fill": "#2B0849"
  }, null), Vue.createVNode("path", {
    "d": "M98.429 272.257h3.496s-.117 7.574 5.127 9.671c-5.244.7-9.672-2.602-8.623-9.671",
    "fill": "#A4AABA"
  }, null), Vue.createVNode("path", {
    "d": "M44.425 272.046s-2.208 7.774-4.702 12.899c-1.884 3.874-4.428 7.854 5.729 7.854 6.97 0 9.385-.503 7.782-6.917-1.604-6.415.279-13.836.279-13.836h-9.088z",
    "fill": "#CBD1D1"
  }, null), Vue.createVNode("path", {
    "d": "M38.066 290.277s2.198 1.225 6.954 1.225c6.376 0 8.646-1.73 8.646-1.73s.63 1.168-.649 2.27c-1.04.897-3.77 1.668-7.745 1.621-4.347-.05-6.115-.593-7.062-1.224-.864-.577-.72-1.657-.144-2.162",
    "fill": "#2B0849"
  }, null), Vue.createVNode("path", {
    "d": "M45.344 274.041s.035 1.592-.329 3.07c-.365 1.49-1.13 3.255-1.184 4.34-.061 1.206 4.755 1.657 5.403.036.65-1.622 1.357-6.737 2.006-7.602.648-.865-5.14-2.222-5.896.156",
    "fill": "#A4AABA"
  }, null), Vue.createVNode("path", {
    "d": "M89.476 277.57l13.899.095s1.349-56.643 1.925-66.909c.576-10.267 3.923-45.052 1.042-65.585l-13.037-.669-23.737.81s-.452 4.12-1.243 10.365c-.065.515-.708.874-.777 1.417-.078.608.439 1.407.332 2.044-2.455 14.627-5.797 32.736-8.256 46.837-.121.693-1.282 1.048-1.515 2.796-.042.314.22 1.584.116 1.865-7.14 19.473-12.202 52.601-15.66 67.19l15.176-.015s2.282-10.145 4.185-18.871c2.922-13.389 24.012-88.32 24.012-88.32l3.133-.954-.158 48.568s-.233 1.282.35 2.098c.583.815-.581 1.167-.408 2.331l.408 1.864s-.466 7.458-.932 12.352c-.467 4.895 1.145 40.69 1.145 40.69",
    "fill": "#7BB2F9"
  }, null), Vue.createVNode("path", {
    "d": "M64.57 218.881c1.197.099 4.195-2.097 7.225-5.127M96.024 222.534s2.881-1.152 6.34-4.034",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M96.973 219.373s2.882-1.153 6.34-4.034",
    "stroke": "#648BD8",
    "stroke-width": "1.032",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M63.172 222.144s2.724-.614 6.759-3.496M74.903 146.166c-.281 3.226.31 8.856-4.506 9.478M93.182 144.344s.115 14.557-1.344 15.65c-2.305 1.73-3.107 2.02-3.107 2.02M89.197 144.923s.269 13.144-1.01 25.088M83.525 170.71s6.81-1.051 9.116-1.051M46.026 270.045l-.892 4.538M46.937 263.289l-.815 4.157M62.725 202.503c-.33 1.618-.102 1.904-.449 3.438 0 0-2.756 1.903-2.29 3.923.466 2.02-.31 3.424-4.505 17.252-1.762 5.807-4.233 18.922-6.165 28.278-.03.144-.521 2.646-1.14 5.8M64.158 194.136c-.295 1.658-.6 3.31-.917 4.938M71.33 146.787l-1.244 10.877s-1.14.155-.519 2.33c.117 1.399-2.778 16.39-5.382 31.615M44.242 273.727H58.07",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M106.18 142.117c-3.028-.489-18.825-2.744-36.219.2a.625.625 0 0 0-.518.644c.063 1.307.044 2.343.015 2.995a.617.617 0 0 0 .716.636c3.303-.534 17.037-2.412 35.664-.266.347.04.66-.214.692-.56.124-1.347.16-2.425.17-3.029a.616.616 0 0 0-.52-.62",
    "fill": "#192064"
  }, null), Vue.createVNode("path", {
    "d": "M96.398 145.264l.003-5.102a.843.843 0 0 0-.809-.847 114.104 114.104 0 0 0-8.141-.014.85.85 0 0 0-.82.847l-.003 5.097c0 .476.388.857.864.845 2.478-.064 5.166-.067 8.03.017a.848.848 0 0 0 .876-.843",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M95.239 144.296l.002-3.195a.667.667 0 0 0-.643-.672c-1.9-.061-3.941-.073-6.094-.01a.675.675 0 0 0-.654.672l-.002 3.192c0 .376.305.677.68.669 1.859-.042 3.874-.043 6.02.012.376.01.69-.291.691-.668",
    "fill": "#192064"
  }, null), Vue.createVNode("path", {
    "d": "M90.102 273.522h12.819M91.216 269.761c.006 3.519-.072 5.55 0 6.292M90.923 263.474c-.009 1.599-.016 2.558-.016 4.505M90.44 170.404l.932 46.38s.7 1.631-.233 2.796c-.932 1.166 2.564.7.932 2.33-1.63 1.633.933 1.166 0 3.497-.618 1.546-1.031 21.921-1.138 36.513",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M73.736 98.665l2.214 4.312s2.098.816 1.865 2.68l.816 2.214M64.297 116.611c.233-.932 2.176-7.147 12.585-10.488M77.598 90.042s7.691 6.137 16.547 2.72",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M91.974 86.954s5.476-.816 7.574-4.545c1.297-.345.72 2.212-.33 3.671-.7.971-1.01 1.554-1.01 1.554s.194.31.155.816c-.053.697-.175.653-.272 1.048-.081.335.108.657 0 1.049-.046.17-.198.5-.382.878-.12.249-.072.687-.2.948-.231.469-1.562 1.87-2.622 2.855-3.826 3.554-5.018 1.644-6.001-.408-.894-1.865-.661-5.127-.874-6.875-.35-2.914-2.622-3.03-1.923-4.429.343-.685 2.87.69 3.263 1.748.757 2.04 2.952 1.807 2.622 1.69",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M99.8 82.429c-.465.077-.35.272-.97 1.243-.622.971-4.817 2.932-6.39 3.224-2.589.48-2.278-1.56-4.254-2.855-1.69-1.107-3.562-.638-1.398 1.398.99.932.932 1.107 1.398 3.205.335 1.506-.64 3.67.7 5.593",
    "stroke": "#DB836E",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M79.543 108.673c-2.1 2.926-4.266 6.175-5.557 8.762",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M87.72 124.768s-2.098-1.942-5.127-2.719c-3.03-.777-3.574-.155-5.516.078-1.942.233-3.885-.932-3.652.7.233 1.63 5.05 1.01 5.206 2.097.155 1.087-6.37 2.796-8.313 2.175-.777.777.466 1.864 2.02 2.175.233 1.554 2.253 1.554 2.253 1.554s.699 1.01 2.641 1.088c2.486 1.32 8.934-.7 10.954-1.554 2.02-.855-.466-5.594-.466-5.594",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M73.425 122.826s.66 1.127 3.167 1.418c2.315.27 2.563.583 2.563.583s-2.545 2.894-9.07 2.272M72.416 129.274s3.826.097 4.933-.718M74.98 130.75s1.961.136 3.36-.505M77.232 131.916s1.748.019 2.914-.505M73.328 122.321s-.595-1.032 1.262-.427c1.671.544 2.833.055 5.128.155 1.389.061 3.067-.297 3.982.15 1.606.784 3.632 2.181 3.632 2.181s10.526 1.204 19.033-1.127M78.864 108.104s-8.39 2.758-13.168 12.12",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M109.278 112.533s3.38-3.613 7.575-4.662",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M107.375 123.006s9.697-2.745 11.445-.88",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M194.605 83.656l3.971-3.886M187.166 90.933l3.736-3.655M191.752 84.207l-4.462-4.56M198.453 91.057l-4.133-4.225M129.256 163.074l3.718-3.718M122.291 170.039l3.498-3.498M126.561 163.626l-4.27-4.27M132.975 170.039l-3.955-3.955",
    "stroke": "#BFCDDD",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M190.156 211.779h-1.604a4.023 4.023 0 0 1-4.011-4.011V175.68a4.023 4.023 0 0 1 4.01-4.01h1.605a4.023 4.023 0 0 1 4.011 4.01v32.088a4.023 4.023 0 0 1-4.01 4.01",
    "fill": "#A3B4C6"
  }, null), Vue.createVNode("path", {
    "d": "M237.824 212.977a4.813 4.813 0 0 1-4.813 4.813h-86.636a4.813 4.813 0 0 1 0-9.626h86.636a4.813 4.813 0 0 1 4.813 4.813",
    "fill": "#A3B4C6"
  }, null), Vue.createVNode("mask", {
    "fill": "#fff"
  }, null), Vue.createVNode("path", {
    "fill": "#A3B4C6",
    "mask": "url(#d)",
    "d": "M154.098 190.096h70.513v-84.617h-70.513z"
  }, null), Vue.createVNode("path", {
    "d": "M224.928 190.096H153.78a3.219 3.219 0 0 1-3.208-3.209V167.92a3.219 3.219 0 0 1 3.208-3.21h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.219 3.219 0 0 1-3.21 3.209M224.928 130.832H153.78a3.218 3.218 0 0 1-3.208-3.208v-18.968a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.218 3.218 0 0 1-3.21 3.208",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), Vue.createVNode("path", {
    "d": "M159.563 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 120.546h-22.461a.802.802 0 0 1-.802-.802v-3.208c0-.443.359-.803.802-.803h22.46c.444 0 .803.36.803.803v3.208c0 .443-.36.802-.802.802",
    "fill": "#FFF",
    "mask": "url(#d)"
  }, null), Vue.createVNode("path", {
    "d": "M224.928 160.464H153.78a3.218 3.218 0 0 1-3.208-3.209v-18.967a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.209v18.967a3.218 3.218 0 0 1-3.21 3.209",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), Vue.createVNode("path", {
    "d": "M173.455 130.832h49.301M164.984 130.832h6.089M155.952 130.832h6.75M173.837 160.613h49.3M165.365 160.613h6.089M155.57 160.613h6.751",
    "stroke": "#7C90A5",
    "stroke-width": "1.124",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "mask": "url(#d)"
  }, null), Vue.createVNode("path", {
    "d": "M159.563 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M166.98 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M174.397 151.038a2.407 2.407 0 1 1 .001-4.814 2.407 2.407 0 0 1 0 4.814M222.539 151.038h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802M159.563 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 179.987h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802",
    "fill": "#FFF",
    "mask": "url(#d)"
  }, null), Vue.createVNode("path", {
    "d": "M203.04 221.108h-27.372a2.413 2.413 0 0 1-2.406-2.407v-11.448a2.414 2.414 0 0 1 2.406-2.407h27.372a2.414 2.414 0 0 1 2.407 2.407V218.7a2.413 2.413 0 0 1-2.407 2.407",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), Vue.createVNode("path", {
    "d": "M177.259 207.217v11.52M201.05 207.217v11.52",
    "stroke": "#A3B4C6",
    "stroke-width": "1.124",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "mask": "url(#d)"
  }, null), Vue.createVNode("path", {
    "d": "M162.873 267.894a9.422 9.422 0 0 1-9.422-9.422v-14.82a9.423 9.423 0 0 1 18.845 0v14.82a9.423 9.423 0 0 1-9.423 9.422",
    "fill": "#5BA02E",
    "mask": "url(#d)"
  }, null), Vue.createVNode("path", {
    "d": "M171.22 267.83a9.422 9.422 0 0 1-9.422-9.423v-3.438a9.423 9.423 0 0 1 18.845 0v3.438a9.423 9.423 0 0 1-9.422 9.423",
    "fill": "#92C110",
    "mask": "url(#d)"
  }, null), Vue.createVNode("path", {
    "d": "M181.31 293.666h-27.712a3.209 3.209 0 0 1-3.209-3.21V269.79a3.209 3.209 0 0 1 3.209-3.21h27.711a3.209 3.209 0 0 1 3.209 3.21v20.668a3.209 3.209 0 0 1-3.209 3.209",
    "fill": "#F2D7AD",
    "mask": "url(#d)"
  }, null)])]);
};
var serverError = ServerError;
var Unauthorized = function Unauthorized2() {
  return Vue.createVNode("svg", {
    "width": "251",
    "height": "294"
  }, [Vue.createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [Vue.createVNode("path", {
    "d": "M0 129.023v-2.084C0 58.364 55.591 2.774 124.165 2.774h2.085c68.574 0 124.165 55.59 124.165 124.165v2.084c0 68.575-55.59 124.166-124.165 124.166h-2.085C55.591 253.189 0 197.598 0 129.023",
    "fill": "#E4EBF7"
  }, null), Vue.createVNode("path", {
    "d": "M41.417 132.92a8.231 8.231 0 1 1-16.38-1.65 8.231 8.231 0 0 1 16.38 1.65",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M38.652 136.36l10.425 5.91M49.989 148.505l-12.58 10.73",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), Vue.createVNode("path", {
    "d": "M41.536 161.28a5.636 5.636 0 1 1-11.216-1.13 5.636 5.636 0 0 1 11.216 1.13M59.154 145.261a5.677 5.677 0 1 1-11.297-1.138 5.677 5.677 0 0 1 11.297 1.138M100.36 29.516l29.66-.013a4.562 4.562 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 0 0 .005 9.126M111.705 47.754l29.659-.013a4.563 4.563 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 1 0 .005 9.126",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M114.066 29.503V29.5l15.698-.007a4.563 4.563 0 1 0 .004 9.126l-15.698.007v-.002a4.562 4.562 0 0 0-.004-9.122M185.405 137.723c-.55 5.455-5.418 9.432-10.873 8.882-5.456-.55-9.432-5.418-8.882-10.873.55-5.455 5.418-9.432 10.873-8.882 5.455.55 9.432 5.418 8.882 10.873",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M180.17 143.772l12.572 7.129M193.841 158.42L178.67 171.36",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), Vue.createVNode("path", {
    "d": "M185.55 171.926a6.798 6.798 0 1 1-13.528-1.363 6.798 6.798 0 0 1 13.527 1.363M204.12 155.285a6.848 6.848 0 1 1-13.627-1.375 6.848 6.848 0 0 1 13.626 1.375",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M152.988 194.074a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0zM225.931 118.217a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM217.09 153.051a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.42 0zM177.84 109.842a2.21 2.21 0 1 1-4.422 0 2.21 2.21 0 0 1 4.421 0zM196.114 94.454a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM202.844 182.523a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0z",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), Vue.createVNode("path", {
    "stroke": "#FFF",
    "stroke-width": "2",
    "d": "M215.125 155.262l-1.902 20.075-10.87 5.958M174.601 176.636l-6.322 9.761H156.98l-4.484 6.449M175.874 127.28V111.56M221.51 119.404l-12.77 7.859-15.228-7.86V96.668"
  }, null), Vue.createVNode("path", {
    "d": "M180.68 29.32C180.68 13.128 193.806 0 210 0c16.193 0 29.32 13.127 29.32 29.32 0 16.194-13.127 29.322-29.32 29.322-16.193 0-29.32-13.128-29.32-29.321",
    "fill": "#A26EF4"
  }, null), Vue.createVNode("path", {
    "d": "M221.45 41.706l-21.563-.125a1.744 1.744 0 0 1-1.734-1.754l.071-12.23a1.744 1.744 0 0 1 1.754-1.734l21.562.125c.964.006 1.74.791 1.735 1.755l-.071 12.229a1.744 1.744 0 0 1-1.754 1.734",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M215.106 29.192c-.015 2.577-2.049 4.654-4.543 4.64-2.494-.014-4.504-2.115-4.489-4.693l.04-6.925c.016-2.577 2.05-4.654 4.543-4.64 2.494.015 4.504 2.116 4.49 4.693l-.04 6.925zm-4.53-14.074a6.877 6.877 0 0 0-6.916 6.837l-.043 7.368a6.877 6.877 0 0 0 13.754.08l.042-7.368a6.878 6.878 0 0 0-6.837-6.917zM167.566 68.367h-3.93a4.73 4.73 0 0 1-4.717-4.717 4.73 4.73 0 0 1 4.717-4.717h3.93a4.73 4.73 0 0 1 4.717 4.717 4.73 4.73 0 0 1-4.717 4.717",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M168.214 248.838a6.611 6.611 0 0 1-6.61-6.611v-66.108a6.611 6.611 0 0 1 13.221 0v66.108a6.611 6.611 0 0 1-6.61 6.61",
    "fill": "#5BA02E"
  }, null), Vue.createVNode("path", {
    "d": "M176.147 248.176a6.611 6.611 0 0 1-6.61-6.61v-33.054a6.611 6.611 0 1 1 13.221 0v33.053a6.611 6.611 0 0 1-6.61 6.611",
    "fill": "#92C110"
  }, null), Vue.createVNode("path", {
    "d": "M185.994 293.89h-27.376a3.17 3.17 0 0 1-3.17-3.17v-45.887a3.17 3.17 0 0 1 3.17-3.17h27.376a3.17 3.17 0 0 1 3.17 3.17v45.886a3.17 3.17 0 0 1-3.17 3.17",
    "fill": "#F2D7AD"
  }, null), Vue.createVNode("path", {
    "d": "M81.972 147.673s6.377-.927 17.566-1.28c11.729-.371 17.57 1.086 17.57 1.086s3.697-3.855.968-8.424c1.278-12.077 5.982-32.827.335-48.273-1.116-1.339-3.743-1.512-7.536-.62-1.337.315-7.147-.149-7.983-.1l-15.311-.347s-3.487-.17-8.035-.508c-1.512-.113-4.227-1.683-5.458-.338-.406.443-2.425 5.669-1.97 16.077l8.635 35.642s-3.141 3.61 1.219 7.085",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M75.768 73.325l-.9-6.397 11.982-6.52s7.302-.118 8.038 1.205c.737 1.324-5.616.993-5.616.993s-1.836 1.388-2.615 2.5c-1.654 2.363-.986 6.471-8.318 5.986-1.708.284-2.57 2.233-2.57 2.233",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M52.44 77.672s14.217 9.406 24.973 14.444c1.061.497-2.094 16.183-11.892 11.811-7.436-3.318-20.162-8.44-21.482-14.496-.71-3.258 2.543-7.643 8.401-11.76M141.862 80.113s-6.693 2.999-13.844 6.876c-3.894 2.11-10.137 4.704-12.33 7.988-6.224 9.314 3.536 11.22 12.947 7.503 6.71-2.651 28.999-12.127 13.227-22.367",
    "fill": "#FFB594"
  }, null), Vue.createVNode("path", {
    "d": "M76.166 66.36l3.06 3.881s-2.783 2.67-6.31 5.747c-7.103 6.195-12.803 14.296-15.995 16.44-3.966 2.662-9.754 3.314-12.177-.118-3.553-5.032.464-14.628 31.422-25.95",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M64.674 85.116s-2.34 8.413-8.912 14.447c.652.548 18.586 10.51 22.144 10.056 5.238-.669 6.417-18.968 1.145-20.531-.702-.208-5.901-1.286-8.853-2.167-.87-.26-1.611-1.71-3.545-.936l-1.98-.869zM128.362 85.826s5.318 1.956 7.325 13.734c-.546.274-17.55 12.35-21.829 7.805-6.534-6.94-.766-17.393 4.275-18.61 4.646-1.121 5.03-1.37 10.23-2.929",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M78.18 94.656s.911 7.41-4.914 13.078",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M87.397 94.68s3.124 2.572 10.263 2.572c7.14 0 9.074-3.437 9.074-3.437",
    "stroke": "#E4EBF7",
    "stroke-width": ".932",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M117.184 68.639l-6.781-6.177s-5.355-4.314-9.223-.893c-3.867 3.422 4.463 2.083 5.653 4.165 1.19 2.082.848 1.143-2.083.446-5.603-1.331-2.082.893 2.975 5.355 2.091 1.845 6.992.955 6.992.955l2.467-3.851z",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M105.282 91.315l-.297-10.937-15.918-.027-.53 10.45c-.026.403.17.788.515.999 2.049 1.251 9.387 5.093 15.799.424.287-.21.443-.554.431-.91",
    "fill": "#FFB594"
  }, null), Vue.createVNode("path", {
    "d": "M107.573 74.24c.817-1.147.982-9.118 1.015-11.928a1.046 1.046 0 0 0-.965-1.055l-4.62-.365c-7.71-1.044-17.071.624-18.253 6.346-5.482 5.813-.421 13.244-.421 13.244s1.963 3.566 4.305 6.791c.756 1.041.398-3.731 3.04-5.929 5.524-4.594 15.899-7.103 15.899-7.103",
    "fill": "#5C2552"
  }, null), Vue.createVNode("path", {
    "d": "M88.426 83.206s2.685 6.202 11.602 6.522c7.82.28 8.973-7.008 7.434-17.505l-.909-5.483c-6.118-2.897-15.478.54-15.478.54s-.576 2.044-.19 5.504c-2.276 2.066-1.824 5.618-1.824 5.618s-.905-1.922-1.98-2.321c-.86-.32-1.897.089-2.322 1.98-1.04 4.632 3.667 5.145 3.667 5.145",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M100.843 77.099l1.701-.928-1.015-4.324.674-1.406"
  }, null), Vue.createVNode("path", {
    "d": "M105.546 74.092c-.022.713-.452 1.279-.96 1.263-.51-.016-.904-.607-.882-1.32.021-.713.452-1.278.96-1.263.51.016.904.607.882 1.32M97.592 74.349c-.022.713-.452 1.278-.961 1.263-.509-.016-.904-.607-.882-1.32.022-.713.452-1.279.961-1.263.51.016.904.606.882 1.32",
    "fill": "#552950"
  }, null), Vue.createVNode("path", {
    "d": "M91.132 86.786s5.269 4.957 12.679 2.327",
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M99.776 81.903s-3.592.232-1.44-2.79c1.59-1.496 4.897-.46 4.897-.46s1.156 3.906-3.457 3.25",
    "fill": "#DB836E"
  }, null), Vue.createVNode("path", {
    "d": "M102.88 70.6s2.483.84 3.402.715M93.883 71.975s2.492-1.144 4.778-1.073",
    "stroke": "#5C2552",
    "stroke-width": "1.526",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M86.32 77.374s.961.879 1.458 2.106c-.377.48-1.033 1.152-.236 1.809M99.337 83.719s1.911.151 2.509-.254",
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M87.782 115.821l15.73-3.012M100.165 115.821l10.04-2.008",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M66.508 86.763s-1.598 8.83-6.697 14.078",
    "stroke": "#E4EBF7",
    "stroke-width": "1.114",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M128.31 87.934s3.013 4.121 4.06 11.785",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M64.09 84.816s-6.03 9.912-13.607 9.903",
    "stroke": "#DB836E",
    "stroke-width": ".795",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M112.366 65.909l-.142 5.32s5.993 4.472 11.945 9.202c4.482 3.562 8.888 7.455 10.985 8.662 4.804 2.766 8.9 3.355 11.076 1.808 4.071-2.894 4.373-9.878-8.136-15.263-4.271-1.838-16.144-6.36-25.728-9.73",
    "fill": "#FFC6A0"
  }, null), Vue.createVNode("path", {
    "d": "M130.532 85.488s4.588 5.757 11.619 6.214",
    "stroke": "#DB836E",
    "stroke-width": ".75",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M121.708 105.73s-.393 8.564-1.34 13.612",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M115.784 161.512s-3.57-1.488-2.678-7.14",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M101.52 290.246s4.326 2.057 7.408 1.03c2.842-.948 4.564.673 7.132 1.186 2.57.514 6.925 1.108 11.772-1.269-.104-5.551-6.939-4.01-12.048-6.763-2.582-1.39-3.812-4.757-3.625-8.863h-9.471s-1.402 10.596-1.169 14.68",
    "fill": "#CBD1D1"
  }, null), Vue.createVNode("path", {
    "d": "M101.496 290.073s2.447 1.281 6.809.658c3.081-.44 3.74.485 7.479 1.039 3.739.554 10.802-.07 11.91-.9.415 1.108-.347 2.077-.347 2.077s-1.523.608-4.847.831c-2.045.137-5.843.293-7.663-.507-1.8-1.385-5.286-1.917-5.77-.243-3.947.958-7.41-.288-7.41-.288l-.16-2.667z",
    "fill": "#2B0849"
  }, null), Vue.createVNode("path", {
    "d": "M108.824 276.19h3.116s-.103 6.751 4.57 8.62c-4.673.624-8.62-2.32-7.686-8.62",
    "fill": "#A4AABA"
  }, null), Vue.createVNode("path", {
    "d": "M57.65 272.52s-2.122 7.47-4.518 12.396c-1.811 3.724-4.255 7.548 5.505 7.548 6.698 0 9.02-.483 7.479-6.648-1.541-6.164.268-13.296.268-13.296H57.65z",
    "fill": "#CBD1D1"
  }, null), Vue.createVNode("path", {
    "d": "M51.54 290.04s2.111 1.178 6.682 1.178c6.128 0 8.31-1.662 8.31-1.662s.605 1.122-.624 2.18c-1 .862-3.624 1.603-7.444 1.559-4.177-.049-5.876-.57-6.786-1.177-.831-.554-.692-1.593-.138-2.078",
    "fill": "#2B0849"
  }, null), Vue.createVNode("path", {
    "d": "M58.533 274.438s.034 1.529-.315 2.95c-.352 1.431-1.087 3.127-1.139 4.17-.058 1.16 4.57 1.592 5.194.035.623-1.559 1.303-6.475 1.927-7.306.622-.831-4.94-2.135-5.667.15",
    "fill": "#A4AABA"
  }, null), Vue.createVNode("path", {
    "d": "M100.885 277.015l13.306.092s1.291-54.228 1.843-64.056c.552-9.828 3.756-43.13.997-62.788l-12.48-.64-22.725.776s-.433 3.944-1.19 9.921c-.062.493-.677.838-.744 1.358-.075.582.42 1.347.318 1.956-2.35 14.003-6.343 32.926-8.697 46.425-.116.663-1.227 1.004-1.45 2.677-.04.3.21 1.516.112 1.785-6.836 18.643-10.89 47.584-14.2 61.551l14.528-.014s2.185-8.524 4.008-16.878c2.796-12.817 22.987-84.553 22.987-84.553l3-.517 1.037 46.1s-.223 1.228.334 2.008c.558.782-.556 1.117-.39 2.233l.39 1.784s-.446 7.14-.892 11.826c-.446 4.685-.092 38.954-.092 38.954",
    "fill": "#7BB2F9"
  }, null), Vue.createVNode("path", {
    "d": "M77.438 220.434c1.146.094 4.016-2.008 6.916-4.91M107.55 223.931s2.758-1.103 6.069-3.862",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M108.459 220.905s2.759-1.104 6.07-3.863",
    "stroke": "#648BD8",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M76.099 223.557s2.608-.587 6.47-3.346M87.33 150.82c-.27 3.088.297 8.478-4.315 9.073M104.829 149.075s.11 13.936-1.286 14.983c-2.207 1.655-2.975 1.934-2.975 1.934M101.014 149.63s.035 12.81-1.19 24.245M94.93 174.965s7.174-1.655 9.38-1.655M75.671 204.754c-.316 1.55-.64 3.067-.973 4.535 0 0-1.45 1.822-1.003 3.756.446 1.934-.943 2.034-4.96 15.273-1.686 5.559-4.464 18.49-6.313 27.447-.078.38-4.018 18.06-4.093 18.423M77.043 196.743a313.269 313.269 0 0 1-.877 4.729M83.908 151.414l-1.19 10.413s-1.091.148-.496 2.23c.111 1.34-2.66 15.692-5.153 30.267M57.58 272.94h13.238",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), Vue.createVNode("path", {
    "d": "M117.377 147.423s-16.955-3.087-35.7.199c.157 2.501-.002 4.128-.002 4.128s14.607-2.802 35.476-.31c.251-2.342.226-4.017.226-4.017",
    "fill": "#192064"
  }, null), Vue.createVNode("path", {
    "d": "M107.511 150.353l.004-4.885a.807.807 0 0 0-.774-.81c-2.428-.092-5.04-.108-7.795-.014a.814.814 0 0 0-.784.81l-.003 4.88c0 .456.371.82.827.808a140.76 140.76 0 0 1 7.688.017.81.81 0 0 0 .837-.806",
    "fill": "#FFF"
  }, null), Vue.createVNode("path", {
    "d": "M106.402 149.426l.002-3.06a.64.64 0 0 0-.616-.643 94.135 94.135 0 0 0-5.834-.009.647.647 0 0 0-.626.643l-.001 3.056c0 .36.291.648.651.64 1.78-.04 3.708-.041 5.762.012.36.009.662-.279.662-.64",
    "fill": "#192064"
  }, null), Vue.createVNode("path", {
    "d": "M101.485 273.933h12.272M102.652 269.075c.006 3.368.04 5.759.11 6.47M102.667 263.125c-.009 1.53-.015 2.98-.016 4.313M102.204 174.024l.893 44.402s.669 1.561-.224 2.677c-.892 1.116 2.455.67.893 2.231-1.562 1.562.893 1.116 0 3.347-.592 1.48-.988 20.987-1.09 34.956",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null)])]);
};
var unauthorized = Unauthorized;
var IconMap = {
  success: CheckCircleFilled$1,
  error: CloseCircleFilled$1,
  info: ExclamationCircleFilled$1,
  warning: WarningFilled$1
};
var ExceptionMap = {
  "404": noFound,
  "500": serverError,
  "403": unauthorized
};
var ExceptionStatus = Object.keys(ExceptionMap);
var resultProps = function resultProps2() {
  return {
    prefixCls: String,
    icon: PropTypes$1.any,
    status: {
      type: [Number, String],
      default: "info"
    },
    title: PropTypes$1.any,
    subTitle: PropTypes$1.any,
    extra: PropTypes$1.any
  };
};
var renderIcon = function renderIcon2(prefixCls, _ref) {
  var status = _ref.status, icon = _ref.icon;
  if (ExceptionStatus.includes("".concat(status))) {
    var SVGComponent = ExceptionMap[status];
    return Vue.createVNode("div", {
      "class": "".concat(prefixCls, "-icon ").concat(prefixCls, "-image")
    }, [Vue.createVNode(SVGComponent, null, null)]);
  }
  var IconComponent = IconMap[status];
  var iconNode = icon || Vue.createVNode(IconComponent, null, null);
  return Vue.createVNode("div", {
    "class": "".concat(prefixCls, "-icon")
  }, [iconNode]);
};
var renderExtra = function renderExtra2(prefixCls, extra) {
  return extra && Vue.createVNode("div", {
    "class": "".concat(prefixCls, "-extra")
  }, [extra]);
};
var Result = Vue.defineComponent({
  name: "AResult",
  props: resultProps(),
  slots: ["title", "subTitle", "icon", "extra"],
  setup: function setup118(props2, _ref2) {
    var slots = _ref2.slots;
    var _useConfigInject = useConfigInject("result", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var className = Vue.computed(function() {
      return classNames(prefixCls.value, "".concat(prefixCls.value, "-").concat(props2.status), _defineProperty$T({}, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"));
    });
    return function() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      var title = (_a = props2.title) !== null && _a !== void 0 ? _a : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      var subTitle = (_c = props2.subTitle) !== null && _c !== void 0 ? _c : (_d = slots.subTitle) === null || _d === void 0 ? void 0 : _d.call(slots);
      var icon = (_e = props2.icon) !== null && _e !== void 0 ? _e : (_f = slots.icon) === null || _f === void 0 ? void 0 : _f.call(slots);
      var extra = (_g = props2.extra) !== null && _g !== void 0 ? _g : (_h = slots.extra) === null || _h === void 0 ? void 0 : _h.call(slots);
      var pre = prefixCls.value;
      return Vue.createVNode("div", {
        "class": className.value
      }, [renderIcon(pre, {
        status: props2.status,
        icon
      }), Vue.createVNode("div", {
        "class": "".concat(pre, "-title")
      }, [title]), subTitle && Vue.createVNode("div", {
        "class": "".concat(pre, "-subtitle")
      }, [subTitle]), renderExtra(pre, extra), slots.default && Vue.createVNode("div", {
        "class": "".concat(pre, "-content")
      }, [slots.default()])]);
    };
  }
});
Result.PRESENTED_IMAGE_403 = ExceptionMap[403];
Result.PRESENTED_IMAGE_404 = ExceptionMap[404];
Result.PRESENTED_IMAGE_500 = ExceptionMap[500];
Result.install = function(app) {
  app.component(Result.name, Result);
  return app;
};
var _Result = Result;
var index$i = "";
var index$h = "";
var index$g = "";
var index$f = "";
var __rest$9 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var breadcrumbItemProps = function breadcrumbItemProps2() {
  return {
    prefixCls: String,
    href: String,
    separator: PropTypes$1.any,
    overlay: PropTypes$1.any,
    onClick: Function
  };
};
var BreadcrumbItem = Vue.defineComponent({
  name: "ABreadcrumbItem",
  inheritAttrs: false,
  __ANT_BREADCRUMB_ITEM: true,
  props: breadcrumbItemProps(),
  slots: ["separator", "overlay"],
  setup: function setup119(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("breadcrumb", props2), prefixCls = _useConfigInject.prefixCls;
    var renderBreadcrumbNode = function renderBreadcrumbNode2(breadcrumbItem, prefixCls2) {
      var overlay = getPropsSlot(slots, props2, "overlay");
      if (overlay) {
        return Vue.createVNode(DropDown, {
          "overlay": overlay,
          "placement": "bottom"
        }, {
          default: function _default5() {
            return [Vue.createVNode("span", {
              "class": "".concat(prefixCls2, "-overlay-link")
            }, [breadcrumbItem, Vue.createVNode(DownOutlined$1, null, null)])];
          }
        });
      }
      return breadcrumbItem;
    };
    return function() {
      var _a;
      var separator = (_a = getPropsSlot(slots, props2, "separator")) !== null && _a !== void 0 ? _a : "/";
      var children = getPropsSlot(slots, props2);
      var cls = attrs.class, style = attrs.style, restAttrs = __rest$9(attrs, ["class", "style"]);
      var link;
      if (props2.href !== void 0) {
        link = Vue.createVNode("a", _objectSpread2$1({
          "class": "".concat(prefixCls.value, "-link"),
          "onClick": props2.onClick
        }, restAttrs), [children]);
      } else {
        link = Vue.createVNode("span", _objectSpread2$1({
          "class": "".concat(prefixCls.value, "-link"),
          "onClick": props2.onClick
        }, restAttrs), [children]);
      }
      link = renderBreadcrumbNode(link, prefixCls.value);
      if (children) {
        return Vue.createVNode("span", {
          "class": cls,
          "style": style
        }, [link, separator && Vue.createVNode("span", {
          "class": "".concat(prefixCls.value, "-separator")
        }, [separator])]);
      }
      return null;
    };
  }
});
var breadcrumbProps = function breadcrumbProps2() {
  return {
    prefixCls: String,
    routes: {
      type: Array
    },
    params: PropTypes$1.any,
    separator: PropTypes$1.any,
    itemRender: {
      type: Function
    }
  };
};
function getBreadcrumbName(route, params) {
  if (!route.breadcrumbName) {
    return null;
  }
  var paramsKeys = Object.keys(params).join("|");
  var name = route.breadcrumbName.replace(new RegExp(":(".concat(paramsKeys, ")"), "g"), function(replacement, key2) {
    return params[key2] || replacement;
  });
  return name;
}
function defaultItemRender(opt) {
  var route = opt.route, params = opt.params, routes2 = opt.routes, paths = opt.paths;
  var isLastItem = routes2.indexOf(route) === routes2.length - 1;
  var name = getBreadcrumbName(route, params);
  return isLastItem ? Vue.createVNode("span", null, [name]) : Vue.createVNode("a", {
    "href": "#/".concat(paths.join("/"))
  }, [name]);
}
var Breadcrumb = Vue.defineComponent({
  name: "ABreadcrumb",
  props: breadcrumbProps(),
  slots: ["separator", "itemRender"],
  setup: function setup120(props2, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("breadcrumb", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var getPath = function getPath2(path, params) {
      path = (path || "").replace(/^\//, "");
      Object.keys(params).forEach(function(key2) {
        path = path.replace(":".concat(key2), params[key2]);
      });
      return path;
    };
    var addChildPath = function addChildPath2(paths, childPath, params) {
      var originalPaths = _toConsumableArray(paths);
      var path = getPath(childPath || "", params);
      if (path) {
        originalPaths.push(path);
      }
      return originalPaths;
    };
    var genForRoutes = function genForRoutes2(_ref2) {
      var _ref2$routes = _ref2.routes, routes2 = _ref2$routes === void 0 ? [] : _ref2$routes, _ref2$params = _ref2.params, params = _ref2$params === void 0 ? {} : _ref2$params, separator = _ref2.separator, _ref2$itemRender = _ref2.itemRender, itemRender = _ref2$itemRender === void 0 ? defaultItemRender : _ref2$itemRender;
      var paths = [];
      return routes2.map(function(route) {
        var path = getPath(route.path, params);
        if (path) {
          paths.push(path);
        }
        var tempPaths = [].concat(paths);
        var overlay = null;
        if (route.children && route.children.length) {
          overlay = Vue.createVNode(Menu, null, {
            default: function _default5() {
              return [route.children.map(function(child) {
                return Vue.createVNode(Menu.Item, {
                  "key": child.path || child.breadcrumbName
                }, {
                  default: function _default6() {
                    return [itemRender({
                      route: child,
                      params,
                      routes: routes2,
                      paths: addChildPath(tempPaths, child.path, params)
                    })];
                  }
                });
              })];
            }
          });
        }
        return Vue.createVNode(BreadcrumbItem, {
          "overlay": overlay,
          "separator": separator,
          "key": path || route.breadcrumbName
        }, {
          default: function _default5() {
            return [itemRender({
              route,
              params,
              routes: routes2,
              paths: tempPaths
            })];
          }
        });
      });
    };
    return function() {
      var _breadcrumbClassName;
      var _a;
      var crumbs;
      var routes2 = props2.routes, _props$params = props2.params, params = _props$params === void 0 ? {} : _props$params;
      var children = flattenChildren(getPropsSlot(slots, props2));
      var separator = (_a = getPropsSlot(slots, props2, "separator")) !== null && _a !== void 0 ? _a : "/";
      var itemRender = props2.itemRender || slots.itemRender || defaultItemRender;
      if (routes2 && routes2.length > 0) {
        crumbs = genForRoutes({
          routes: routes2,
          params,
          separator,
          itemRender
        });
      } else if (children.length) {
        crumbs = children.map(function(element, index2) {
          warning(_typeof$1(element.type) === "object" && (element.type.__ANT_BREADCRUMB_ITEM || element.type.__ANT_BREADCRUMB_SEPARATOR), "Breadcrumb", "Only accepts Breadcrumb.Item and Breadcrumb.Separator as it's children");
          return Vue.cloneVNode(element, {
            separator,
            key: index2
          });
        });
      }
      var breadcrumbClassName = (_breadcrumbClassName = {}, _defineProperty$T(_breadcrumbClassName, prefixCls.value, true), _defineProperty$T(_breadcrumbClassName, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _breadcrumbClassName);
      return Vue.createVNode("div", {
        "class": breadcrumbClassName
      }, [crumbs]);
    };
  }
});
var __rest$8 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var breadcrumbSeparatorProps = function breadcrumbSeparatorProps2() {
  return {
    prefixCls: String
  };
};
var BreadcrumbSeparator = Vue.defineComponent({
  name: "ABreadcrumbSeparator",
  __ANT_BREADCRUMB_SEPARATOR: true,
  inheritAttrs: false,
  props: breadcrumbSeparatorProps(),
  setup: function setup121(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("breadcrumb", props2), prefixCls = _useConfigInject.prefixCls;
    return function() {
      var _a;
      attrs.separator;
      var className = attrs.class, restAttrs = __rest$8(attrs, ["separator", "class"]);
      var children = flattenChildren((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
      return Vue.createVNode("span", _objectSpread2$1({
        "class": ["".concat(prefixCls.value, "-separator"), className]
      }, restAttrs), [children.length > 0 ? children : "/"]);
    };
  }
});
Breadcrumb.Item = BreadcrumbItem;
Breadcrumb.Separator = BreadcrumbSeparator;
Breadcrumb.install = function(app) {
  app.component(Breadcrumb.name, Breadcrumb);
  app.component(BreadcrumbItem.name, BreadcrumbItem);
  app.component(BreadcrumbSeparator.name, BreadcrumbSeparator);
  return app;
};
var avatarProps = function avatarProps2() {
  return {
    prefixCls: String,
    shape: {
      type: String,
      default: "circle"
    },
    size: {
      type: [Number, String, Object],
      default: function _default5() {
        return "default";
      }
    },
    src: String,
    srcset: String,
    icon: PropTypes$1.any,
    alt: String,
    gap: Number,
    draggable: {
      type: Boolean,
      default: void 0
    },
    crossOrigin: String,
    loadError: {
      type: Function
    }
  };
};
var Avatar = Vue.defineComponent({
  name: "AAvatar",
  inheritAttrs: false,
  props: avatarProps(),
  slots: ["icon"],
  setup: function setup122(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var isImgExist = Vue.ref(true);
    var isMounted = Vue.ref(false);
    var scale = Vue.ref(1);
    var avatarChildrenRef = Vue.ref(null);
    var avatarNodeRef = Vue.ref(null);
    var _useConfigInject = useConfigInject("avatar", props2), prefixCls = _useConfigInject.prefixCls;
    var groupSize = useInjectSize();
    var size = Vue.computed(function() {
      return props2.size === "default" ? groupSize.value : props2.size;
    });
    var screens2 = useBreakpoint();
    var responsiveSize = eagerComputed(function() {
      if (_typeof$1(props2.size) !== "object") {
        return void 0;
      }
      var currentBreakpoint = responsiveArray.find(function(screen) {
        return screens2.value[screen];
      });
      var currentSize = props2.size[currentBreakpoint];
      return currentSize;
    });
    var responsiveSizeStyle = function responsiveSizeStyle2(hasIcon) {
      if (responsiveSize.value) {
        return {
          width: "".concat(responsiveSize.value, "px"),
          height: "".concat(responsiveSize.value, "px"),
          lineHeight: "".concat(responsiveSize.value, "px"),
          fontSize: "".concat(hasIcon ? responsiveSize.value / 2 : 18, "px")
        };
      }
      return {};
    };
    var setScaleParam = function setScaleParam2() {
      if (!avatarChildrenRef.value || !avatarNodeRef.value) {
        return;
      }
      var childrenWidth = avatarChildrenRef.value.offsetWidth;
      var nodeWidth = avatarNodeRef.value.offsetWidth;
      if (childrenWidth !== 0 && nodeWidth !== 0) {
        var _props$gap = props2.gap, gap = _props$gap === void 0 ? 4 : _props$gap;
        if (gap * 2 < nodeWidth) {
          scale.value = nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1;
        }
      }
    };
    var handleImgLoadError = function handleImgLoadError2() {
      var loadError = props2.loadError;
      var errorFlag = loadError === null || loadError === void 0 ? void 0 : loadError();
      if (errorFlag !== false) {
        isImgExist.value = false;
      }
    };
    Vue.watch(function() {
      return props2.src;
    }, function() {
      Vue.nextTick(function() {
        isImgExist.value = true;
        scale.value = 1;
      });
    });
    Vue.watch(function() {
      return props2.gap;
    }, function() {
      Vue.nextTick(function() {
        setScaleParam();
      });
    });
    Vue.onMounted(function() {
      Vue.nextTick(function() {
        setScaleParam();
        isMounted.value = true;
      });
    });
    return function() {
      var _classString;
      var _a;
      var shape = props2.shape, src = props2.src, alt = props2.alt, srcset = props2.srcset, draggable = props2.draggable, crossOrigin = props2.crossOrigin;
      var icon = getPropsSlot(slots, props2, "icon");
      var pre = prefixCls.value;
      var classString = (_classString = {}, _defineProperty$T(_classString, "".concat(attrs.class), !!attrs.class), _defineProperty$T(_classString, pre, true), _defineProperty$T(_classString, "".concat(pre, "-lg"), size.value === "large"), _defineProperty$T(_classString, "".concat(pre, "-sm"), size.value === "small"), _defineProperty$T(_classString, "".concat(pre, "-").concat(shape), shape), _defineProperty$T(_classString, "".concat(pre, "-image"), src && isImgExist.value), _defineProperty$T(_classString, "".concat(pre, "-icon"), icon), _classString);
      var sizeStyle = typeof size.value === "number" ? {
        width: "".concat(size.value, "px"),
        height: "".concat(size.value, "px"),
        lineHeight: "".concat(size.value, "px"),
        fontSize: icon ? "".concat(size.value / 2, "px") : "18px"
      } : {};
      var children = (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
      var childrenToRender;
      if (src && isImgExist.value) {
        childrenToRender = Vue.createVNode("img", {
          "draggable": draggable,
          "src": src,
          "srcset": srcset,
          "onError": handleImgLoadError,
          "alt": alt,
          "crossorigin": crossOrigin
        }, null);
      } else if (icon) {
        childrenToRender = icon;
      } else if (isMounted.value || scale.value !== 1) {
        var transformString = "scale(".concat(scale.value, ") translateX(-50%)");
        var childrenStyle = {
          msTransform: transformString,
          WebkitTransform: transformString,
          transform: transformString
        };
        var sizeChildrenStyle = typeof size.value === "number" ? {
          lineHeight: "".concat(size.value, "px")
        } : {};
        childrenToRender = Vue.createVNode(ResizeObserver$1, {
          "onResize": setScaleParam
        }, {
          default: function _default5() {
            return [Vue.createVNode("span", {
              "class": "".concat(pre, "-string"),
              "ref": avatarChildrenRef,
              "style": _extends(_extends({}, sizeChildrenStyle), childrenStyle)
            }, [children])];
          }
        });
      } else {
        childrenToRender = Vue.createVNode("span", {
          "class": "".concat(pre, "-string"),
          "ref": avatarChildrenRef,
          "style": {
            opacity: 0
          }
        }, [children]);
      }
      return Vue.createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "ref": avatarNodeRef,
        "class": classString,
        "style": [sizeStyle, responsiveSizeStyle(!!icon), attrs.style]
      }), [childrenToRender]);
    };
  }
});
var Avatar$1 = Avatar;
var popoverProps = function popoverProps2() {
  return _extends(_extends({}, abstractTooltipProps()), {
    content: PropTypes$1.any,
    title: PropTypes$1.any
  });
};
var Popover$1 = Vue.defineComponent({
  name: "APopover",
  props: initDefaultProps$1(popoverProps(), _extends(_extends({}, tooltipDefaultProps()), {
    trigger: "hover",
    transitionName: "zoom-big",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1
  })),
  setup: function setup123(props2, _ref) {
    var expose = _ref.expose, slots = _ref.slots;
    var tooltipRef = Vue.ref();
    expose({
      getPopupDomNode: function getPopupDomNode2() {
        var _a, _b;
        return (_b = (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.getPopupDomNode) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    });
    var _useConfigInject = useConfigInject("popover", props2), prefixCls = _useConfigInject.prefixCls, configProvider = _useConfigInject.configProvider;
    var rootPrefixCls = Vue.computed(function() {
      return configProvider.getPrefixCls();
    });
    var getOverlay = function getOverlay2() {
      var _a, _b;
      var _props$title = props2.title, title = _props$title === void 0 ? filterEmpty((_a = slots.title) === null || _a === void 0 ? void 0 : _a.call(slots)) : _props$title, _props$content = props2.content, content = _props$content === void 0 ? filterEmpty((_b = slots.content) === null || _b === void 0 ? void 0 : _b.call(slots)) : _props$content;
      var hasTitle = !!(Array.isArray(title) ? title.length : title);
      var hasContent = !!(Array.isArray(content) ? content.length : title);
      if (!hasTitle && !hasContent)
        return void 0;
      return Vue.createVNode(Vue.Fragment, null, [hasTitle && Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-title")
      }, [title]), Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-inner-content")
      }, [content])]);
    };
    return function() {
      return Vue.createVNode(_Tooltip, _objectSpread2$1(_objectSpread2$1({}, omit(props2, ["title", "content"])), {}, {
        "prefixCls": prefixCls.value,
        "ref": tooltipRef,
        "transitionName": getTransitionName$1(rootPrefixCls.value, "zoom-big", props2.transitionName)
      }), {
        title: getOverlay,
        default: slots.default
      });
    };
  }
});
var _Popover = withInstall(Popover$1);
var groupProps = function groupProps2() {
  return {
    prefixCls: String,
    maxCount: Number,
    maxStyle: {
      type: Object,
      default: void 0
    },
    maxPopoverPlacement: {
      type: String,
      default: "top"
    },
    maxPopoverTrigger: String,
    size: {
      type: [Number, String, Object],
      default: "default"
    }
  };
};
var Group = Vue.defineComponent({
  name: "AAvatarGroup",
  inheritAttrs: false,
  props: groupProps(),
  setup: function setup124(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("avatar-group", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    useProvideSize(props2);
    return function() {
      var _cls;
      var _props$maxPopoverPlac = props2.maxPopoverPlacement, maxPopoverPlacement = _props$maxPopoverPlac === void 0 ? "top" : _props$maxPopoverPlac, maxCount2 = props2.maxCount, maxStyle = props2.maxStyle, _props$maxPopoverTrig = props2.maxPopoverTrigger, maxPopoverTrigger = _props$maxPopoverTrig === void 0 ? "hover" : _props$maxPopoverTrig;
      var cls = (_cls = {}, _defineProperty$T(_cls, prefixCls.value, true), _defineProperty$T(_cls, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$T(_cls, "".concat(attrs.class), !!attrs.class), _cls);
      var children = getPropsSlot(slots, props2);
      var childrenWithProps = flattenChildren(children).map(function(child, index2) {
        return cloneElement(child, {
          key: "avatar-key-".concat(index2)
        });
      });
      var numOfChildren = childrenWithProps.length;
      if (maxCount2 && maxCount2 < numOfChildren) {
        var childrenShow = childrenWithProps.slice(0, maxCount2);
        var childrenHidden = childrenWithProps.slice(maxCount2, numOfChildren);
        childrenShow.push(Vue.createVNode(_Popover, {
          "key": "avatar-popover-key",
          "content": childrenHidden,
          "trigger": maxPopoverTrigger,
          "placement": maxPopoverPlacement,
          "overlayClassName": "".concat(prefixCls.value, "-popover")
        }, {
          default: function _default5() {
            return [Vue.createVNode(Avatar$1, {
              "style": maxStyle
            }, {
              default: function _default6() {
                return ["+".concat(numOfChildren - maxCount2)];
              }
            })];
          }
        }));
        return Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": cls,
          "style": attrs.style
        }), [childrenShow]);
      }
      return Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": cls,
        "style": attrs.style
      }), [childrenWithProps]);
    };
  }
});
var Group$1 = Group;
Avatar$1.Group = Group$1;
Avatar$1.install = function(app) {
  app.component(Avatar$1.name, Avatar$1);
  app.component(Group$1.name, Group$1);
  return app;
};
var __rest$7 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var inlineStyle = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-block"
};
var TransButton = Vue.defineComponent({
  name: "TransButton",
  inheritAttrs: false,
  props: {
    noStyle: {
      type: Boolean,
      default: void 0
    },
    onClick: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    }
  },
  setup: function setup125(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs, expose = _ref.expose;
    var domRef = Vue.ref();
    var onKeyDown = function onKeyDown2(event) {
      var keyCode = event.keyCode;
      if (keyCode === KeyCode$1.ENTER) {
        event.preventDefault();
      }
    };
    var onKeyUp = function onKeyUp2(event) {
      var keyCode = event.keyCode;
      if (keyCode === KeyCode$1.ENTER) {
        emit("click", event);
      }
    };
    var onClick2 = function onClick3(e2) {
      emit("click", e2);
    };
    var focus = function focus2() {
      if (domRef.value) {
        domRef.value.focus();
      }
    };
    var blur = function blur2() {
      if (domRef.value) {
        domRef.value.blur();
      }
    };
    Vue.onMounted(function() {
      if (props2.autofocus) {
        focus();
      }
    });
    expose({
      focus,
      blur
    });
    return function() {
      var _a;
      var noStyle = props2.noStyle, disabled = props2.disabled, restProps = __rest$7(props2, ["noStyle", "disabled"]);
      var mergedStyle = {};
      if (!noStyle) {
        mergedStyle = _extends({}, inlineStyle);
      }
      if (disabled) {
        mergedStyle.pointerEvents = "none";
      }
      return Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "role": "button",
        "tabindex": 0,
        "ref": domRef
      }, restProps), attrs), {}, {
        "onClick": onClick2,
        "onKeydown": onKeyDown,
        "onKeyup": onKeyUp,
        "style": _extends(_extends({}, mergedStyle), attrs.style || {})
      }), [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
var TransButton$1 = TransButton;
var useDestroyed = function useDestroyed2() {
  var destroyed = Vue.ref(false);
  Vue.onBeforeUnmount(function() {
    destroyed.value = true;
  });
  return destroyed;
};
var useDestroyed$1 = useDestroyed;
var pageHeaderProps = function pageHeaderProps2() {
  return {
    backIcon: PropTypes$1.any,
    prefixCls: String,
    title: PropTypes$1.any,
    subTitle: PropTypes$1.any,
    breadcrumb: PropTypes$1.object,
    tags: PropTypes$1.any,
    footer: PropTypes$1.any,
    extra: PropTypes$1.any,
    avatar: PropTypes$1.object,
    ghost: {
      type: Boolean,
      default: void 0
    },
    onBack: Function
  };
};
var PageHeader = Vue.defineComponent({
  name: "APageHeader",
  props: pageHeaderProps(),
  slots: ["backIcon", "avatar", "breadcrumb", "title", "subTitle", "tags", "extra", "footer"],
  setup: function setup126(props2, _ref) {
    var emit = _ref.emit, slots = _ref.slots;
    var _useConfigInject = useConfigInject("page-header", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, pageHeader = _useConfigInject.pageHeader;
    var compact = Vue.ref(false);
    var isDestroyed = useDestroyed$1();
    var onResize = function onResize2(_ref2) {
      var width = _ref2.width;
      if (!isDestroyed.value) {
        compact.value = width < 768;
      }
    };
    var ghost = Vue.computed(function() {
      var _a, _b, _c;
      return (_c = (_a = props2.ghost) !== null && _a !== void 0 ? _a : (_b = pageHeader.value) === null || _b === void 0 ? void 0 : _b.ghost) !== null && _c !== void 0 ? _c : true;
    });
    var getBackIcon = function getBackIcon2() {
      var _a, _b, _c;
      return (_c = (_a = props2.backIcon) !== null && _a !== void 0 ? _a : (_b = slots.backIcon) === null || _b === void 0 ? void 0 : _b.call(slots)) !== null && _c !== void 0 ? _c : direction.value === "rtl" ? Vue.createVNode(ArrowRightOutlined$1, null, null) : Vue.createVNode(ArrowLeftOutlined$1, null, null);
    };
    var renderBack = function renderBack2(backIcon) {
      if (!backIcon || !props2.onBack) {
        return null;
      }
      return Vue.createVNode(LocaleReceiver, {
        "componentName": "PageHeader",
        "children": function children(_ref3) {
          var back = _ref3.back;
          return Vue.createVNode("div", {
            "class": "".concat(prefixCls.value, "-back")
          }, [Vue.createVNode(TransButton$1, {
            "onClick": function onClick2(e2) {
              emit("back", e2);
            },
            "class": "".concat(prefixCls.value, "-back-button"),
            "aria-label": back
          }, {
            default: function _default5() {
              return [backIcon];
            }
          })]);
        }
      }, null);
    };
    var renderBreadcrumb = function renderBreadcrumb2() {
      var _a;
      return props2.breadcrumb ? Vue.createVNode(Breadcrumb, props2.breadcrumb, null) : (_a = slots.breadcrumb) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
    var renderTitle = function renderTitle2() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      var avatar = props2.avatar;
      var title = (_a = props2.title) !== null && _a !== void 0 ? _a : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      var subTitle = (_c = props2.subTitle) !== null && _c !== void 0 ? _c : (_d = slots.subTitle) === null || _d === void 0 ? void 0 : _d.call(slots);
      var tags = (_e = props2.tags) !== null && _e !== void 0 ? _e : (_f = slots.tags) === null || _f === void 0 ? void 0 : _f.call(slots);
      var extra = (_g = props2.extra) !== null && _g !== void 0 ? _g : (_h = slots.extra) === null || _h === void 0 ? void 0 : _h.call(slots);
      var headingPrefixCls = "".concat(prefixCls.value, "-heading");
      var hasHeading = title || subTitle || tags || extra;
      if (!hasHeading) {
        return null;
      }
      var backIcon = getBackIcon();
      var backIconDom = renderBack(backIcon);
      var hasTitle = backIconDom || avatar || hasHeading;
      return Vue.createVNode("div", {
        "class": headingPrefixCls
      }, [hasTitle && Vue.createVNode("div", {
        "class": "".concat(headingPrefixCls, "-left")
      }, [backIconDom, avatar ? Vue.createVNode(Avatar$1, avatar, null) : (_j = slots.avatar) === null || _j === void 0 ? void 0 : _j.call(slots), title && Vue.createVNode("span", {
        "class": "".concat(headingPrefixCls, "-title"),
        "title": typeof title === "string" ? title : void 0
      }, [title]), subTitle && Vue.createVNode("span", {
        "class": "".concat(headingPrefixCls, "-sub-title"),
        "title": typeof subTitle === "string" ? subTitle : void 0
      }, [subTitle]), tags && Vue.createVNode("span", {
        "class": "".concat(headingPrefixCls, "-tags")
      }, [tags])]), extra && Vue.createVNode("span", {
        "class": "".concat(headingPrefixCls, "-extra")
      }, [extra])]);
    };
    var renderFooter = function renderFooter2() {
      var _a, _b;
      var footer = (_a = props2.footer) !== null && _a !== void 0 ? _a : filterEmpty((_b = slots.footer) === null || _b === void 0 ? void 0 : _b.call(slots));
      return isEmptyContent(footer) ? null : Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-footer")
      }, [footer]);
    };
    var renderChildren2 = function renderChildren3(children) {
      return Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-content")
      }, [children]);
    };
    return function() {
      var _classNames;
      var _a, _b;
      var hasBreadcrumb = ((_a = props2.breadcrumb) === null || _a === void 0 ? void 0 : _a.routes) || slots.breadcrumb;
      var hasFooter = props2.footer || slots.footer;
      var children = flattenChildren((_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots));
      var className = classNames(prefixCls.value, (_classNames = {
        "has-breadcrumb": hasBreadcrumb,
        "has-footer": hasFooter
      }, _defineProperty$T(_classNames, "".concat(prefixCls.value, "-ghost"), ghost.value), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-compact"), compact.value), _classNames));
      return Vue.createVNode(ResizeObserver$1, {
        "onResize": onResize
      }, {
        default: function _default5() {
          return [Vue.createVNode("div", {
            "class": className
          }, [renderBreadcrumb(), renderTitle(), children.length ? renderChildren2(children) : null, renderFooter()])];
        }
      });
    };
  }
});
var _PageHeader = withInstall(PageHeader);
var index$e = "";
var index$d = "";
var actionButtonProps = {
  type: {
    type: String
  },
  actionFn: Function,
  close: Function,
  autofocus: Boolean,
  prefixCls: String,
  buttonProps: Object,
  emitEvent: Boolean,
  quitOnNullishReturnValue: Boolean
};
function isThenable(thing) {
  return !!(thing && !!thing.then);
}
var ActionButton = Vue.defineComponent({
  name: "ActionButton",
  props: actionButtonProps,
  setup: function setup127(props2, _ref) {
    var slots = _ref.slots;
    var clickedRef = Vue.ref(false);
    var buttonRef = Vue.ref();
    var loading = Vue.ref(false);
    var timeoutId;
    var isDestroyed = useDestroyed$1();
    Vue.onMounted(function() {
      if (props2.autofocus) {
        timeoutId = setTimeout(function() {
          var _a;
          return (_a = buttonRef.value.$el) === null || _a === void 0 ? void 0 : _a.focus();
        });
      }
    });
    Vue.onBeforeUnmount(function() {
      clearTimeout(timeoutId);
    });
    var handlePromiseOnOk = function handlePromiseOnOk2(returnValueOfOnOk) {
      var close3 = props2.close;
      if (!isThenable(returnValueOfOnOk)) {
        return;
      }
      loading.value = true;
      returnValueOfOnOk.then(function() {
        if (!isDestroyed.value) {
          loading.value = false;
        }
        close3.apply(void 0, arguments);
        clickedRef.value = false;
      }, function(e2) {
        console.error(e2);
        if (!isDestroyed.value) {
          loading.value = false;
        }
        clickedRef.value = false;
      });
    };
    var onClick2 = function onClick3(e2) {
      var actionFn = props2.actionFn, _props$close = props2.close, close3 = _props$close === void 0 ? function() {
      } : _props$close;
      if (clickedRef.value) {
        return;
      }
      clickedRef.value = true;
      if (!actionFn) {
        close3();
        return;
      }
      var returnValueOfOnOk;
      if (props2.emitEvent) {
        returnValueOfOnOk = actionFn(e2);
        if (props2.quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
          clickedRef.value = false;
          close3(e2);
          return;
        }
      } else if (actionFn.length) {
        returnValueOfOnOk = actionFn(close3);
        clickedRef.value = false;
      } else {
        returnValueOfOnOk = actionFn();
        if (!returnValueOfOnOk) {
          close3();
          return;
        }
      }
      handlePromiseOnOk(returnValueOfOnOk);
    };
    return function() {
      var type2 = props2.type, prefixCls = props2.prefixCls, buttonProps3 = props2.buttonProps;
      return Vue.createVNode(Button$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, convertLegacyProps(type2)), {}, {
        "onClick": onClick2,
        "loading": loading.value,
        "prefixCls": prefixCls
      }, buttonProps3), {}, {
        "ref": buttonRef
      }), slots);
    };
  }
});
var __rest$6 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var popconfirmProps = function popconfirmProps2() {
  return _extends(_extends({}, abstractTooltipProps()), {
    prefixCls: String,
    content: PropTypes$1.any,
    title: PropTypes$1.any,
    okType: {
      type: String,
      default: "primary"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    okText: PropTypes$1.any,
    cancelText: PropTypes$1.any,
    icon: PropTypes$1.any,
    okButtonProps: {
      type: Object,
      default: void 0
    },
    cancelButtonProps: {
      type: Object,
      default: void 0
    },
    showCancel: {
      type: Boolean,
      default: true
    },
    onConfirm: Function,
    onCancel: Function
  });
};
var Popconfirm = Vue.defineComponent({
  name: "APopconfirm",
  props: initDefaultProps$1(popconfirmProps(), _extends(_extends({}, tooltipDefaultProps()), {
    trigger: "click",
    transitionName: "zoom-big",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: false,
    autoAdjustOverflow: true,
    okType: "primary",
    disabled: false
  })),
  slots: ["title", "content", "okText", "icon", "cancelText", "cancelButton", "okButton"],
  emits: ["update:visible", "visibleChange"],
  setup: function setup128(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    Vue.onMounted(function() {
      devWarning(props2.defaultVisible === void 0, "Popconfirm", "'defaultVisible' is deprecated, please use 'v-model:visible'");
    });
    var tooltipRef = Vue.ref();
    expose({
      getPopupDomNode: function getPopupDomNode2() {
        var _a, _b;
        return (_b = (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.getPopupDomNode) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    });
    var _useMergedState = useMergedState(false, {
      value: Vue.toRef(props2, "visible"),
      defaultValue: props2.defaultVisible
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), visible = _useMergedState2[0], setVisible = _useMergedState2[1];
    var settingVisible = function settingVisible2(value, e2) {
      if (props2.visible === void 0) {
        setVisible(value);
      }
      emit("update:visible", value);
      emit("visibleChange", value, e2);
    };
    var close3 = function close4(e2) {
      settingVisible(false, e2);
    };
    var onConfirm = function onConfirm2(e2) {
      var _a;
      return (_a = props2.onConfirm) === null || _a === void 0 ? void 0 : _a.call(props2, e2);
    };
    var onCancel = function onCancel2(e2) {
      var _a;
      settingVisible(false, e2);
      (_a = props2.onCancel) === null || _a === void 0 ? void 0 : _a.call(props2, e2);
    };
    var onKeyDown = function onKeyDown2(e2) {
      if (e2.keyCode === KeyCode$1.ESC && visible) {
        settingVisible(false, e2);
      }
    };
    var onVisibleChange = function onVisibleChange2(value) {
      var disabled = props2.disabled;
      if (disabled) {
        return;
      }
      settingVisible(value);
    };
    var _useConfigInject = useConfigInject("popconfirm", props2), prefixClsConfirm = _useConfigInject.prefixCls, getPrefixCls2 = _useConfigInject.getPrefixCls;
    var rootPrefixCls = Vue.computed(function() {
      return getPrefixCls2();
    });
    var popoverPrefixCls = Vue.computed(function() {
      return getPrefixCls2("popover");
    });
    var btnPrefixCls = Vue.computed(function() {
      return getPrefixCls2("btn");
    });
    var _useLocaleReceiver = useLocaleReceiver("Popconfirm", defaultLocale.Popconfirm), _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 1), popconfirmLocale = _useLocaleReceiver2[0];
    var renderOverlay = function renderOverlay2() {
      var _a, _b, _c, _d;
      var okButtonProps = props2.okButtonProps, cancelButtonProps = props2.cancelButtonProps, _props$title = props2.title, title = _props$title === void 0 ? (_a = slots.title) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$title, _props$cancelText = props2.cancelText, cancelText = _props$cancelText === void 0 ? (_b = slots.cancel) === null || _b === void 0 ? void 0 : _b.call(slots) : _props$cancelText, _props$okText = props2.okText, okText = _props$okText === void 0 ? (_c = slots.okText) === null || _c === void 0 ? void 0 : _c.call(slots) : _props$okText, okType = props2.okType, _props$icon = props2.icon, icon = _props$icon === void 0 ? (_d = slots.icon) === null || _d === void 0 ? void 0 : _d.call(slots) : _props$icon, _props$showCancel = props2.showCancel, showCancel = _props$showCancel === void 0 ? true : _props$showCancel;
      var cancelButton = slots.cancelButton, okButton = slots.okButton;
      var cancelProps = _extends({
        onClick: onCancel,
        size: "small"
      }, cancelButtonProps);
      var okProps = _extends(_extends(_extends({
        onClick: onConfirm
      }, convertLegacyProps(okType)), {
        size: "small"
      }), okButtonProps);
      return Vue.createVNode("div", {
        "class": "".concat(popoverPrefixCls.value, "-inner-content")
      }, [Vue.createVNode("div", {
        "class": "".concat(popoverPrefixCls.value, "-message")
      }, [icon || Vue.createVNode(ExclamationCircleFilled$1, null, null), Vue.createVNode("div", {
        "class": "".concat(popoverPrefixCls.value, "-message-title")
      }, [title])]), Vue.createVNode("div", {
        "class": "".concat(popoverPrefixCls.value, "-buttons")
      }, [showCancel ? cancelButton ? cancelButton(cancelProps) : Vue.createVNode(Button$1, cancelProps, {
        default: function _default5() {
          return [cancelText || popconfirmLocale.value.cancelText];
        }
      }) : null, okButton ? okButton(okProps) : Vue.createVNode(ActionButton, {
        "buttonProps": _extends(_extends({
          size: "small"
        }, convertLegacyProps(okType)), okButtonProps),
        "actionFn": onConfirm,
        "close": close3,
        "prefixCls": btnPrefixCls.value,
        "quitOnNullishReturnValue": true,
        "emitEvent": true
      }, {
        default: function _default5() {
          return [okText || popconfirmLocale.value.okText];
        }
      })])]);
    };
    return function() {
      var _a;
      var placement = props2.placement, overlayClassName = props2.overlayClassName, restProps = __rest$6(props2, ["placement", "overlayClassName"]);
      var otherProps = omit(restProps, ["title", "content", "cancelText", "okText", "onUpdate:visible", "onConfirm", "onCancel"]);
      var overlayClassNames = classNames(prefixClsConfirm.value, overlayClassName);
      return Vue.createVNode(_Tooltip, _objectSpread2$1(_objectSpread2$1({}, otherProps), {}, {
        "prefixCls": popoverPrefixCls.value,
        "placement": placement,
        "onVisibleChange": onVisibleChange,
        "visible": visible.value,
        "overlayClassName": overlayClassNames,
        "transitionName": getTransitionName$1(rootPrefixCls.value, "zoom-big", props2.transitionName),
        "ref": tooltipRef
      }), {
        default: function _default5() {
          return [cloneVNodes(((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)) || [], {
            onKeydown: function onKeydown(e2) {
              onKeyDown(e2);
            }
          }, false)];
        },
        title: renderOverlay
      });
    };
  }
});
var _Popconfirm = withInstall(Popconfirm);
var index$c = "";
var index$b = "";
var listItemMetaProps = function listItemMetaProps2() {
  return {
    avatar: PropTypes$1.any,
    description: PropTypes$1.any,
    prefixCls: String,
    title: PropTypes$1.any
  };
};
var ItemMeta = Vue.defineComponent({
  name: "AListItemMeta",
  props: listItemMetaProps(),
  displayName: "AListItemMeta",
  __ANT_LIST_ITEM_META: true,
  slots: ["avatar", "description", "title"],
  setup: function setup129(props2, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("list", props2), prefixCls = _useConfigInject.prefixCls;
    return function() {
      var _a, _b, _c, _d, _e, _f;
      var classString = "".concat(prefixCls.value, "-item-meta");
      var title = (_a = props2.title) !== null && _a !== void 0 ? _a : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      var description = (_c = props2.description) !== null && _c !== void 0 ? _c : (_d = slots.description) === null || _d === void 0 ? void 0 : _d.call(slots);
      var avatar = (_e = props2.avatar) !== null && _e !== void 0 ? _e : (_f = slots.avatar) === null || _f === void 0 ? void 0 : _f.call(slots);
      var content = Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-item-meta-content")
      }, [title && Vue.createVNode("h4", {
        "class": "".concat(prefixCls.value, "-item-meta-title")
      }, [title]), description && Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-item-meta-description")
      }, [description])]);
      return Vue.createVNode("div", {
        "class": classString
      }, [avatar && Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-item-meta-avatar")
      }, [avatar]), (title || description) && content]);
    };
  }
});
var ListContextKey = Symbol("ListContextKey");
var __rest$5 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var listItemProps = function listItemProps3() {
  return {
    prefixCls: String,
    extra: PropTypes$1.any,
    actions: PropTypes$1.array,
    grid: Object,
    colStyle: {
      type: Object,
      default: void 0
    }
  };
};
var Item = Vue.defineComponent({
  name: "AListItem",
  inheritAttrs: false,
  Meta: ItemMeta,
  props: listItemProps(),
  slots: ["actions", "extra"],
  setup: function setup130(props2, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _inject = Vue.inject(ListContextKey, {
      grid: Vue.ref(),
      itemLayout: Vue.ref()
    }), itemLayout = _inject.itemLayout, grid = _inject.grid;
    var _useConfigInject = useConfigInject("list", props2), prefixCls = _useConfigInject.prefixCls;
    var isItemContainsTextNodeAndNotSingular = function isItemContainsTextNodeAndNotSingular2() {
      var _a;
      var children = ((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)) || [];
      var result;
      children.forEach(function(element) {
        if (isStringElement(element) && !isEmptyElement(element)) {
          result = true;
        }
      });
      return result && children.length > 1;
    };
    var isFlexMode = function isFlexMode2() {
      var _a, _b;
      var extra = (_a = props2.extra) !== null && _a !== void 0 ? _a : (_b = slots.extra) === null || _b === void 0 ? void 0 : _b.call(slots);
      if (itemLayout.value === "vertical") {
        return !!extra;
      }
      return !isItemContainsTextNodeAndNotSingular();
    };
    return function() {
      var _a, _b, _c, _d, _e;
      var className = attrs.class, restAttrs = __rest$5(attrs, ["class"]);
      var pre = prefixCls.value;
      var extra = (_a = props2.extra) !== null && _a !== void 0 ? _a : (_b = slots.extra) === null || _b === void 0 ? void 0 : _b.call(slots);
      var children = (_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots);
      var actions = (_d = props2.actions) !== null && _d !== void 0 ? _d : flattenChildren((_e = slots.actions) === null || _e === void 0 ? void 0 : _e.call(slots));
      actions = actions && !Array.isArray(actions) ? [actions] : actions;
      var actionsContent = actions && actions.length > 0 && Vue.createVNode("ul", {
        "class": "".concat(pre, "-item-action"),
        "key": "actions"
      }, [actions.map(function(action, i2) {
        return Vue.createVNode("li", {
          "key": "".concat(pre, "-item-action-").concat(i2)
        }, [action, i2 !== actions.length - 1 && Vue.createVNode("em", {
          "class": "".concat(pre, "-item-action-split")
        }, null)]);
      })]);
      var Element2 = grid.value ? "div" : "li";
      var itemChildren = Vue.createVNode(Element2, _objectSpread2$1(_objectSpread2$1({}, restAttrs), {}, {
        "class": classNames("".concat(pre, "-item"), _defineProperty$T({}, "".concat(pre, "-item-no-flex"), !isFlexMode()), className)
      }), {
        default: function _default5() {
          return [itemLayout.value === "vertical" && extra ? [Vue.createVNode("div", {
            "class": "".concat(pre, "-item-main"),
            "key": "content"
          }, [children, actionsContent]), Vue.createVNode("div", {
            "class": "".concat(pre, "-item-extra"),
            "key": "extra"
          }, [extra])] : [children, actionsContent, cloneElement(extra, {
            key: "extra"
          })]];
        }
      });
      return grid.value ? Vue.createVNode(Col$1, {
        "flex": 1,
        "style": props2.colStyle
      }, {
        default: function _default5() {
          return [itemChildren];
        }
      }) : itemChildren;
    };
  }
});
var listProps = function listProps2() {
  return {
    bordered: {
      type: Boolean,
      default: void 0
    },
    dataSource: PropTypes$1.array,
    extra: PropTypes$1.any,
    grid: {
      type: Object,
      default: void 0
    },
    itemLayout: String,
    loading: {
      type: [Boolean, Object],
      default: void 0
    },
    loadMore: PropTypes$1.any,
    pagination: {
      type: [Boolean, Object],
      default: void 0
    },
    prefixCls: String,
    rowKey: [String, Number, Function],
    renderItem: Function,
    size: String,
    split: {
      type: Boolean,
      default: void 0
    },
    header: PropTypes$1.any,
    footer: PropTypes$1.any,
    locale: {
      type: Object
    }
  };
};
var List = Vue.defineComponent({
  name: "AList",
  Item,
  props: initDefaultProps$1(listProps(), {
    dataSource: [],
    bordered: false,
    split: true,
    loading: false,
    pagination: false
  }),
  slots: ["extra", "loadMore", "renderItem", "header", "footer"],
  setup: function setup131(props2, _ref) {
    var slots = _ref.slots;
    var _a, _b;
    Vue.provide(ListContextKey, {
      grid: Vue.toRef(props2, "grid"),
      itemLayout: Vue.toRef(props2, "itemLayout")
    });
    var defaultPaginationProps = {
      current: 1,
      total: 0
    };
    var _useConfigInject = useConfigInject("list", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, renderEmpty2 = _useConfigInject.renderEmpty;
    var paginationObj = Vue.computed(function() {
      return props2.pagination && _typeof$1(props2.pagination) === "object" ? props2.pagination : {};
    });
    var paginationCurrent = Vue.ref((_a = paginationObj.value.defaultCurrent) !== null && _a !== void 0 ? _a : 1);
    var paginationSize = Vue.ref((_b = paginationObj.value.defaultPageSize) !== null && _b !== void 0 ? _b : 10);
    Vue.watch(paginationObj, function() {
      if ("current" in paginationObj.value) {
        paginationCurrent.value = paginationObj.value.current;
      }
      if ("pageSize" in paginationObj.value) {
        paginationSize.value = paginationObj.value.pageSize;
      }
    });
    var listItemsKeys = [];
    var triggerPaginationEvent = function triggerPaginationEvent2(eventName) {
      return function(page, pageSize2) {
        paginationCurrent.value = page;
        paginationSize.value = pageSize2;
        if (paginationObj.value[eventName]) {
          paginationObj.value[eventName](page, pageSize2);
        }
      };
    };
    var onPaginationChange = triggerPaginationEvent("onChange");
    var onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
    var renderEmptyFunc = function renderEmptyFunc2(renderEmptyHandler) {
      var _a2;
      return Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-empty-text")
      }, [((_a2 = props2.locale) === null || _a2 === void 0 ? void 0 : _a2.emptyText) || renderEmptyHandler("List")]);
    };
    var loadingProp = Vue.computed(function() {
      if (typeof props2.loading === "boolean") {
        return {
          spinning: props2.loading
        };
      } else {
        return props2.loading;
      }
    });
    var isLoading = Vue.computed(function() {
      return loadingProp.value && loadingProp.value.spinning;
    });
    var sizeCls = Vue.computed(function() {
      var size = "";
      switch (props2.size) {
        case "large":
          size = "lg";
          break;
        case "small":
          size = "sm";
          break;
      }
      return size;
    });
    var classObj = Vue.computed(function() {
      var _ref2;
      return _ref2 = {}, _defineProperty$T(_ref2, "".concat(prefixCls.value), true), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-vertical"), props2.itemLayout === "vertical"), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-").concat(sizeCls.value), sizeCls.value), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-split"), props2.split), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-bordered"), props2.bordered), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-loading"), isLoading.value), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-grid"), !!props2.grid), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _ref2;
    });
    var paginationProps3 = Vue.computed(function() {
      var pp = _extends(_extends(_extends({}, defaultPaginationProps), {
        total: props2.dataSource.length,
        current: paginationCurrent.value,
        pageSize: paginationSize.value
      }), props2.pagination || {});
      var largestPage = Math.ceil(pp.total / pp.pageSize);
      if (pp.current > largestPage) {
        pp.current = largestPage;
      }
      return pp;
    });
    var splitDataSource = Vue.computed(function() {
      var dd = _toConsumableArray(props2.dataSource);
      if (props2.pagination) {
        if (props2.dataSource.length > (paginationProps3.value.current - 1) * paginationProps3.value.pageSize) {
          dd = _toConsumableArray(props2.dataSource).splice((paginationProps3.value.current - 1) * paginationProps3.value.pageSize, paginationProps3.value.pageSize);
        }
      }
      return dd;
    });
    var screens2 = useBreakpoint();
    var currentBreakpoint = eagerComputed(function() {
      for (var i2 = 0; i2 < responsiveArray.length; i2 += 1) {
        var breakpoint = responsiveArray[i2];
        if (screens2.value[breakpoint]) {
          return breakpoint;
        }
      }
      return void 0;
    });
    var colStyle = Vue.computed(function() {
      if (!props2.grid) {
        return void 0;
      }
      var columnCount = currentBreakpoint.value && props2.grid[currentBreakpoint.value] ? props2.grid[currentBreakpoint.value] : props2.grid.column;
      if (columnCount) {
        return {
          width: "".concat(100 / columnCount, "%"),
          maxWidth: "".concat(100 / columnCount, "%")
        };
      }
      return void 0;
    });
    var renderInnerItem = function renderInnerItem2(item, index2) {
      var _a2;
      var renderItem = (_a2 = props2.renderItem) !== null && _a2 !== void 0 ? _a2 : slots.renderItem;
      if (!renderItem)
        return null;
      var key2;
      var rowKeyType = _typeof$1(props2.rowKey);
      if (rowKeyType === "function") {
        key2 = props2.rowKey(item);
      } else if (rowKeyType === "string" || rowKeyType === "number") {
        key2 = item[props2.rowKey];
      } else {
        key2 = item.key;
      }
      if (!key2) {
        key2 = "list-item-".concat(index2);
      }
      listItemsKeys[index2] = key2;
      return renderItem({
        item,
        index: index2
      });
    };
    return function() {
      var _a2, _b2, _c, _d, _e, _f, _g;
      var loadMore = (_a2 = props2.loadMore) !== null && _a2 !== void 0 ? _a2 : (_b2 = slots.loadMore) === null || _b2 === void 0 ? void 0 : _b2.call(slots);
      var footer = (_c = props2.footer) !== null && _c !== void 0 ? _c : (_d = slots.footer) === null || _d === void 0 ? void 0 : _d.call(slots);
      var header = (_e = props2.header) !== null && _e !== void 0 ? _e : (_f = slots.header) === null || _f === void 0 ? void 0 : _f.call(slots);
      var children = flattenChildren((_g = slots.default) === null || _g === void 0 ? void 0 : _g.call(slots));
      var isSomethingAfterLastItem = !!(loadMore || props2.pagination || footer);
      var classString = _extends(_extends({}, classObj.value), _defineProperty$T({}, "".concat(prefixCls.value, "-something-after-last-item"), isSomethingAfterLastItem));
      var paginationContent = props2.pagination ? Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-pagination")
      }, [Vue.createVNode(_Pagination, _objectSpread2$1(_objectSpread2$1({}, paginationProps3.value), {}, {
        "onChange": onPaginationChange,
        "onShowSizeChange": onPaginationShowSizeChange
      }), null)]) : null;
      var childrenContent = isLoading.value && Vue.createVNode("div", {
        "style": {
          minHeight: "53px"
        }
      }, null);
      if (splitDataSource.value.length > 0) {
        listItemsKeys.length = 0;
        var items = splitDataSource.value.map(function(item, index2) {
          return renderInnerItem(item, index2);
        });
        var childrenList = items.map(function(child, index2) {
          return Vue.createVNode("div", {
            "key": listItemsKeys[index2],
            "style": colStyle.value
          }, [child]);
        });
        childrenContent = props2.grid ? Vue.createVNode(Row$3, {
          "gutter": props2.grid.gutter
        }, {
          default: function _default5() {
            return [childrenList];
          }
        }) : Vue.createVNode("ul", {
          "class": "".concat(prefixCls.value, "-items")
        }, [items]);
      } else if (!children.length && !isLoading.value) {
        childrenContent = renderEmptyFunc(renderEmpty2.value);
      }
      var paginationPosition = paginationProps3.value.position || "bottom";
      return Vue.createVNode("div", {
        "class": classString
      }, [(paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-header")
      }, [header]), Vue.createVNode(Spin, loadingProp.value, {
        default: function _default5() {
          return [childrenContent, children];
        }
      }), footer && Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-footer")
      }, [footer]), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent]);
    };
  }
});
List.install = function(app) {
  app.component(List.name, List);
  app.component(List.Item.name, List.Item);
  app.component(List.Item.Meta.name, List.Item.Meta);
  return app;
};
var _List = List;
var index$a = "";
function dialogPropTypes() {
  return {
    keyboard: {
      type: Boolean,
      default: void 0
    },
    mask: {
      type: Boolean,
      default: void 0
    },
    afterClose: Function,
    closable: {
      type: Boolean,
      default: void 0
    },
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    destroyOnClose: {
      type: Boolean,
      default: void 0
    },
    mousePosition: PropTypes$1.shape({
      x: Number,
      y: Number
    }).loose,
    title: PropTypes$1.any,
    footer: PropTypes$1.any,
    transitionName: String,
    maskTransitionName: String,
    animation: PropTypes$1.any,
    maskAnimation: PropTypes$1.any,
    wrapStyle: {
      type: Object,
      default: void 0
    },
    bodyStyle: {
      type: Object,
      default: void 0
    },
    maskStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: String,
    wrapClassName: String,
    rootClassName: String,
    width: [String, Number],
    height: [String, Number],
    zIndex: Number,
    bodyProps: PropTypes$1.any,
    maskProps: PropTypes$1.any,
    wrapProps: PropTypes$1.any,
    getContainer: PropTypes$1.any,
    dialogStyle: {
      type: Object,
      default: void 0
    },
    dialogClass: String,
    closeIcon: PropTypes$1.any,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getOpenCount: Function,
    focusTriggerAfterClose: {
      type: Boolean,
      default: void 0
    },
    onClose: Function,
    modalRender: Function
  };
}
function getMotionName(prefixCls, transitionName2, animationName) {
  var motionName = transitionName2;
  if (!motionName && animationName) {
    motionName = "".concat(prefixCls, "-").concat(animationName);
  }
  return motionName;
}
var uuid$1 = -1;
function getUUID() {
  uuid$1 += 1;
  return uuid$1;
}
function getScroll(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method];
    if (typeof ret !== "number") {
      ret = d2.body[method];
    }
  }
  return ret;
}
function offset(el) {
  var rect = el.getBoundingClientRect();
  var pos = {
    left: rect.left,
    top: rect.top
  };
  var doc = el.ownerDocument;
  var w2 = doc.defaultView || doc.parentWindow;
  pos.left += getScroll(w2);
  pos.top += getScroll(w2, true);
  return pos;
}
var sentinelStyle = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
};
var Content = Vue.defineComponent({
  name: "Content",
  inheritAttrs: false,
  props: _extends(_extends({}, dialogPropTypes()), {
    motionName: String,
    ariaId: String,
    onVisibleChanged: Function,
    onMousedown: Function,
    onMouseup: Function
  }),
  setup: function setup132(props2, _ref) {
    var expose = _ref.expose, slots = _ref.slots, attrs = _ref.attrs;
    var sentinelStartRef = Vue.ref();
    var sentinelEndRef = Vue.ref();
    var dialogRef = Vue.ref();
    expose({
      focus: function focus() {
        var _a;
        (_a = sentinelStartRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      },
      changeActive: function changeActive(next2) {
        var _document = document, activeElement = _document.activeElement;
        if (next2 && activeElement === sentinelEndRef.value) {
          sentinelStartRef.value.focus();
        } else if (!next2 && activeElement === sentinelStartRef.value) {
          sentinelEndRef.value.focus();
        }
      }
    });
    var transformOrigin = Vue.ref();
    var contentStyleRef = Vue.computed(function() {
      var width = props2.width, height = props2.height;
      var contentStyle = {};
      if (width !== void 0) {
        contentStyle.width = typeof width === "number" ? "".concat(width, "px") : width;
      }
      if (height !== void 0) {
        contentStyle.height = typeof height === "number" ? "".concat(height, "px") : height;
      }
      if (transformOrigin.value) {
        contentStyle.transformOrigin = transformOrigin.value;
      }
      return contentStyle;
    });
    var onPrepare = function onPrepare2() {
      Vue.nextTick(function() {
        if (dialogRef.value) {
          var elementOffset = offset(dialogRef.value);
          transformOrigin.value = props2.mousePosition ? "".concat(props2.mousePosition.x - elementOffset.left, "px ").concat(props2.mousePosition.y - elementOffset.top, "px") : "";
        }
      });
    };
    var onVisibleChanged = function onVisibleChanged2(visible) {
      props2.onVisibleChanged(visible);
    };
    return function() {
      var _a, _b, _c, _d;
      var prefixCls = props2.prefixCls, _props$footer = props2.footer, footer = _props$footer === void 0 ? (_a = slots.footer) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$footer, _props$title = props2.title, title = _props$title === void 0 ? (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots) : _props$title, ariaId = props2.ariaId, closable = props2.closable, _props$closeIcon = props2.closeIcon, closeIcon = _props$closeIcon === void 0 ? (_c = slots.closeIcon) === null || _c === void 0 ? void 0 : _c.call(slots) : _props$closeIcon, onClose = props2.onClose, bodyStyle = props2.bodyStyle, bodyProps = props2.bodyProps, onMousedown2 = props2.onMousedown, onMouseup = props2.onMouseup, visible = props2.visible, _props$modalRender = props2.modalRender, modalRender = _props$modalRender === void 0 ? slots.modalRender : _props$modalRender, destroyOnClose = props2.destroyOnClose, motionName = props2.motionName;
      var footerNode;
      if (footer) {
        footerNode = Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-footer")
        }, [footer]);
      }
      var headerNode;
      if (title) {
        headerNode = Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-header")
        }, [Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-title"),
          "id": ariaId
        }, [title])]);
      }
      var closer;
      if (closable) {
        closer = Vue.createVNode("button", {
          "type": "button",
          "onClick": onClose,
          "aria-label": "Close",
          "class": "".concat(prefixCls, "-close")
        }, [closeIcon || Vue.createVNode("span", {
          "class": "".concat(prefixCls, "-close-x")
        }, null)]);
      }
      var content = Vue.createVNode("div", {
        "class": "".concat(prefixCls, "-content")
      }, [closer, headerNode, Vue.createVNode("div", _objectSpread2$1({
        "class": "".concat(prefixCls, "-body"),
        "style": bodyStyle
      }, bodyProps), [(_d = slots.default) === null || _d === void 0 ? void 0 : _d.call(slots)]), footerNode]);
      var transitionProps = getTransitionProps(motionName);
      return Vue.createVNode(Transition$1, _objectSpread2$1(_objectSpread2$1({}, transitionProps), {}, {
        "onBeforeEnter": onPrepare,
        "onAfterEnter": function onAfterEnter() {
          return onVisibleChanged(true);
        },
        "onAfterLeave": function onAfterLeave() {
          return onVisibleChanged(false);
        }
      }), {
        default: function _default5() {
          return [visible || !destroyOnClose ? Vue.withDirectives(Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
            "ref": dialogRef,
            "key": "dialog-element",
            "role": "document",
            "style": [contentStyleRef.value, attrs.style],
            "class": [prefixCls, attrs.class],
            "onMousedown": onMousedown2,
            "onMouseup": onMouseup
          }), [Vue.createVNode("div", {
            "tabindex": 0,
            "ref": sentinelStartRef,
            "style": sentinelStyle,
            "aria-hidden": "true"
          }, null), modalRender ? modalRender({
            originVNode: content
          }) : content, Vue.createVNode("div", {
            "tabindex": 0,
            "ref": sentinelEndRef,
            "style": sentinelStyle,
            "aria-hidden": "true"
          }, null)]), [[Vue.vShow, visible]]) : null];
        }
      });
    };
  }
});
function _objectDestructuringEmpty(obj) {
  if (obj == null)
    throw new TypeError("Cannot destructure undefined");
}
var Mask = Vue.defineComponent({
  name: "Mask",
  props: {
    prefixCls: String,
    visible: Boolean,
    motionName: String,
    maskProps: Object
  },
  setup: function setup133(props2, _ref) {
    _objectDestructuringEmpty(_ref);
    return function() {
      var prefixCls = props2.prefixCls, visible = props2.visible, maskProps = props2.maskProps, motionName = props2.motionName;
      var transitionProps = getTransitionProps(motionName);
      return Vue.createVNode(Transition$1, transitionProps, {
        default: function _default5() {
          return [Vue.withDirectives(Vue.createVNode("div", _objectSpread2$1({
            "class": "".concat(prefixCls, "-mask")
          }, maskProps), null), [[Vue.vShow, visible]])];
        }
      });
    };
  }
});
var Dialog = Vue.defineComponent({
  name: "Dialog",
  inheritAttrs: false,
  props: initDefaultProps$1(_extends(_extends({}, dialogPropTypes()), {
    getOpenCount: Function,
    scrollLocker: Object
  }), {
    mask: true,
    visible: false,
    keyboard: true,
    closable: true,
    maskClosable: true,
    destroyOnClose: false,
    prefixCls: "rc-dialog",
    getOpenCount: function getOpenCount() {
      return null;
    },
    focusTriggerAfterClose: true
  }),
  setup: function setup134(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var lastOutSideActiveElementRef = Vue.ref();
    var wrapperRef = Vue.ref();
    var contentRef = Vue.ref();
    var animatedVisible = Vue.ref(props2.visible);
    var ariaIdRef = Vue.ref("vcDialogTitle".concat(getUUID()));
    var onDialogVisibleChanged = function onDialogVisibleChanged2(newVisible) {
      var _a, _b;
      if (newVisible) {
        if (!contains(wrapperRef.value, document.activeElement)) {
          lastOutSideActiveElementRef.value = document.activeElement;
          (_a = contentRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        }
      } else {
        var preAnimatedVisible = animatedVisible.value;
        animatedVisible.value = false;
        if (props2.mask && lastOutSideActiveElementRef.value && props2.focusTriggerAfterClose) {
          try {
            lastOutSideActiveElementRef.value.focus({
              preventScroll: true
            });
          } catch (e2) {
          }
          lastOutSideActiveElementRef.value = null;
        }
        if (preAnimatedVisible) {
          (_b = props2.afterClose) === null || _b === void 0 ? void 0 : _b.call(props2);
        }
      }
    };
    var onInternalClose = function onInternalClose2(e2) {
      var _a;
      (_a = props2.onClose) === null || _a === void 0 ? void 0 : _a.call(props2, e2);
    };
    var contentClickRef = Vue.ref(false);
    var contentTimeoutRef = Vue.ref();
    var onContentMouseDown = function onContentMouseDown2() {
      clearTimeout(contentTimeoutRef.value);
      contentClickRef.value = true;
    };
    var onContentMouseUp = function onContentMouseUp2() {
      contentTimeoutRef.value = setTimeout(function() {
        contentClickRef.value = false;
      });
    };
    var onWrapperClick = function onWrapperClick2(e2) {
      if (!props2.maskClosable)
        return null;
      if (contentClickRef.value) {
        contentClickRef.value = false;
      } else if (wrapperRef.value === e2.target) {
        onInternalClose(e2);
      }
    };
    var onWrapperKeyDown = function onWrapperKeyDown2(e2) {
      if (props2.keyboard && e2.keyCode === KeyCode$1.ESC) {
        e2.stopPropagation();
        onInternalClose(e2);
        return;
      }
      if (props2.visible) {
        if (e2.keyCode === KeyCode$1.TAB) {
          contentRef.value.changeActive(!e2.shiftKey);
        }
      }
    };
    Vue.watch(function() {
      return props2.visible;
    }, function() {
      if (props2.visible) {
        animatedVisible.value = true;
      }
    }, {
      flush: "post"
    });
    Vue.onBeforeUnmount(function() {
      var _a;
      clearTimeout(contentTimeoutRef.value);
      (_a = props2.scrollLocker) === null || _a === void 0 ? void 0 : _a.unLock();
    });
    Vue.watchEffect(function() {
      var _a, _b;
      (_a = props2.scrollLocker) === null || _a === void 0 ? void 0 : _a.unLock();
      if (animatedVisible.value) {
        (_b = props2.scrollLocker) === null || _b === void 0 ? void 0 : _b.lock();
      }
    });
    return function() {
      var prefixCls = props2.prefixCls, mask = props2.mask, visible = props2.visible, maskTransitionName = props2.maskTransitionName, maskAnimation = props2.maskAnimation, zIndex = props2.zIndex, wrapClassName = props2.wrapClassName, rootClassName = props2.rootClassName, wrapStyle = props2.wrapStyle, closable = props2.closable, maskProps = props2.maskProps, maskStyle = props2.maskStyle, transitionName2 = props2.transitionName, animation = props2.animation, wrapProps = props2.wrapProps, _props$title = props2.title, title = _props$title === void 0 ? slots.title : _props$title;
      var style = attrs.style, className = attrs.class;
      return Vue.createVNode("div", _objectSpread2$1({
        "class": ["".concat(prefixCls, "-root"), rootClassName]
      }, pickAttrs(props2, {
        data: true
      })), [Vue.createVNode(Mask, {
        "prefixCls": prefixCls,
        "visible": mask && visible,
        "motionName": getMotionName(prefixCls, maskTransitionName, maskAnimation),
        "style": _extends({
          zIndex
        }, maskStyle),
        "maskProps": maskProps
      }, null), Vue.createVNode("div", _objectSpread2$1({
        "tabIndex": -1,
        "onKeydown": onWrapperKeyDown,
        "class": classNames("".concat(prefixCls, "-wrap"), wrapClassName),
        "ref": wrapperRef,
        "onClick": onWrapperClick,
        "role": "dialog",
        "aria-labelledby": title ? ariaIdRef.value : null,
        "style": _extends(_extends({
          zIndex
        }, wrapStyle), {
          display: !animatedVisible.value ? "none" : null
        })
      }, wrapProps), [Vue.createVNode(Content, _objectSpread2$1(_objectSpread2$1({}, omit(props2, ["scrollLocker"])), {}, {
        "style": style,
        "class": className,
        "onMousedown": onContentMouseDown,
        "onMouseup": onContentMouseUp,
        "ref": contentRef,
        "closable": closable,
        "ariaId": ariaIdRef.value,
        "prefixCls": prefixCls,
        "visible": visible,
        "onClose": onInternalClose,
        "onVisibleChanged": onDialogVisibleChanged,
        "motionName": getMotionName(prefixCls, transitionName2, animation)
      }), slots)])]);
    };
  }
});
function setStyle(style) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _options$element = options.element, element = _options$element === void 0 ? document.body : _options$element;
  var oldStyle = {};
  var styleKeys = Object.keys(style);
  styleKeys.forEach(function(key2) {
    oldStyle[key2] = element.style[key2];
  });
  styleKeys.forEach(function(key2) {
    element.style[key2] = style[key2];
  });
  return oldStyle;
}
function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
var cacheStyle$1 = {};
var switchScrollingEffect = function(close3) {
  if (!isBodyOverflowing() && !close3) {
    return;
  }
  var scrollingEffectClassName2 = "ant-scrolling-effect";
  var scrollingEffectClassNameReg2 = new RegExp("".concat(scrollingEffectClassName2), "g");
  var bodyClassName = document.body.className;
  if (close3) {
    if (!scrollingEffectClassNameReg2.test(bodyClassName))
      return;
    setStyle(cacheStyle$1);
    cacheStyle$1 = {};
    document.body.className = bodyClassName.replace(scrollingEffectClassNameReg2, "").trim();
    return;
  }
  var scrollBarSize = getScrollBarSize();
  if (scrollBarSize) {
    cacheStyle$1 = setStyle({
      position: "relative",
      width: "calc(100% - ".concat(scrollBarSize, "px)")
    });
    if (!scrollingEffectClassNameReg2.test(bodyClassName)) {
      var addClassName = "".concat(bodyClassName, " ").concat(scrollingEffectClassName2);
      document.body.className = addClassName.trim();
    }
  }
};
var locks = [];
var scrollingEffectClassName = "ant-scrolling-effect";
var scrollingEffectClassNameReg = new RegExp("".concat(scrollingEffectClassName), "g");
var uuid = 0;
var cacheStyle = /* @__PURE__ */ new Map();
var ScrollLocker = /* @__PURE__ */ _createClass(function ScrollLocker2(options) {
  var _this = this;
  _classCallCheck(this, ScrollLocker2);
  this.getContainer = function() {
    var _a;
    return (_a = _this.options) === null || _a === void 0 ? void 0 : _a.container;
  };
  this.reLock = function(options2) {
    var findLock = locks.find(function(_ref) {
      var target = _ref.target;
      return target === _this.lockTarget;
    });
    if (findLock) {
      _this.unLock();
    }
    _this.options = options2;
    if (findLock) {
      findLock.options = options2;
      _this.lock();
    }
  };
  this.lock = function() {
    var _a;
    if (locks.some(function(_ref2) {
      var target = _ref2.target;
      return target === _this.lockTarget;
    })) {
      return;
    }
    if (locks.some(function(_ref3) {
      var options2 = _ref3.options;
      var _a2;
      return (options2 === null || options2 === void 0 ? void 0 : options2.container) === ((_a2 = _this.options) === null || _a2 === void 0 ? void 0 : _a2.container);
    })) {
      locks = [].concat(_toConsumableArray(locks), [{
        target: _this.lockTarget,
        options: _this.options
      }]);
      return;
    }
    var scrollBarSize = 0;
    var container = ((_a = _this.options) === null || _a === void 0 ? void 0 : _a.container) || document.body;
    if (container === document.body && window.innerWidth - document.documentElement.clientWidth > 0 || container.scrollHeight > container.clientHeight) {
      scrollBarSize = getScrollBarSize();
    }
    var containerClassName = container.className;
    if (locks.filter(function(_ref4) {
      var options2 = _ref4.options;
      var _a2;
      return (options2 === null || options2 === void 0 ? void 0 : options2.container) === ((_a2 = _this.options) === null || _a2 === void 0 ? void 0 : _a2.container);
    }).length === 0) {
      cacheStyle.set(container, setStyle({
        width: scrollBarSize !== 0 ? "calc(100% - ".concat(scrollBarSize, "px)") : void 0,
        overflow: "hidden",
        overflowX: "hidden",
        overflowY: "hidden"
      }, {
        element: container
      }));
    }
    if (!scrollingEffectClassNameReg.test(containerClassName)) {
      var addClassName = "".concat(containerClassName, " ").concat(scrollingEffectClassName);
      container.className = addClassName.trim();
    }
    locks = [].concat(_toConsumableArray(locks), [{
      target: _this.lockTarget,
      options: _this.options
    }]);
  };
  this.unLock = function() {
    var _a;
    var findLock = locks.find(function(_ref5) {
      var target = _ref5.target;
      return target === _this.lockTarget;
    });
    locks = locks.filter(function(_ref6) {
      var target = _ref6.target;
      return target !== _this.lockTarget;
    });
    if (!findLock || locks.some(function(_ref7) {
      var options2 = _ref7.options;
      var _a2;
      return (options2 === null || options2 === void 0 ? void 0 : options2.container) === ((_a2 = findLock.options) === null || _a2 === void 0 ? void 0 : _a2.container);
    })) {
      return;
    }
    var container = ((_a = _this.options) === null || _a === void 0 ? void 0 : _a.container) || document.body;
    var containerClassName = container.className;
    if (!scrollingEffectClassNameReg.test(containerClassName))
      return;
    setStyle(cacheStyle.get(container), {
      element: container
    });
    cacheStyle.delete(container);
    container.className = container.className.replace(scrollingEffectClassNameReg, "").trim();
  };
  this.lockTarget = uuid++;
  this.options = options;
});
var openCount = 0;
var supportDom = canUseDom();
var cacheOverflow = {};
var getParent = function getParent3(getContainer4) {
  if (!supportDom) {
    return null;
  }
  if (getContainer4) {
    if (typeof getContainer4 === "string") {
      return document.querySelectorAll(getContainer4)[0];
    }
    if (typeof getContainer4 === "function") {
      return getContainer4();
    }
    if (_typeof$1(getContainer4) === "object" && getContainer4 instanceof window.HTMLElement) {
      return getContainer4;
    }
  }
  return document.body;
};
var Portal = Vue.defineComponent({
  name: "PortalWrapper",
  inheritAttrs: false,
  props: {
    wrapperClassName: String,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getContainer: PropTypes$1.any,
    visible: {
      type: Boolean,
      default: void 0
    }
  },
  setup: function setup135(props2, _ref) {
    var slots = _ref.slots;
    var container = Vue.ref();
    var componentRef = Vue.ref();
    var rafId = Vue.ref();
    var scrollLocker = new ScrollLocker({
      container: getParent(props2.getContainer)
    });
    var removeCurrentContainer = function removeCurrentContainer2() {
      var _a, _b;
      (_b = (_a = container.value) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(container.value);
    };
    var attachToParent = function attachToParent2() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (force || container.value && !container.value.parentNode) {
        var parent = getParent(props2.getContainer);
        if (parent) {
          parent.appendChild(container.value);
          return true;
        }
        return false;
      }
      return true;
    };
    var getContainer4 = function getContainer5() {
      if (!supportDom) {
        return null;
      }
      if (!container.value) {
        container.value = document.createElement("div");
        attachToParent(true);
      }
      setWrapperClassName();
      return container.value;
    };
    var setWrapperClassName = function setWrapperClassName2() {
      var wrapperClassName = props2.wrapperClassName;
      if (container.value && wrapperClassName && wrapperClassName !== container.value.className) {
        container.value.className = wrapperClassName;
      }
    };
    Vue.onUpdated(function() {
      setWrapperClassName();
      attachToParent();
    });
    var switchScrolling = function switchScrolling2() {
      if (openCount === 1 && !Object.keys(cacheOverflow).length) {
        switchScrollingEffect();
        cacheOverflow = setStyle({
          overflow: "hidden",
          overflowX: "hidden",
          overflowY: "hidden"
        });
      } else if (!openCount) {
        setStyle(cacheOverflow);
        cacheOverflow = {};
        switchScrollingEffect(true);
      }
    };
    var instance = Vue.getCurrentInstance();
    Vue.onMounted(function() {
      var init = false;
      Vue.watch([function() {
        return props2.visible;
      }, function() {
        return props2.getContainer;
      }], function(_ref2, _ref3) {
        var _ref4 = _slicedToArray(_ref2, 2), visible = _ref4[0], getContainer5 = _ref4[1];
        var _ref5 = _slicedToArray(_ref3, 2), prevVisible = _ref5[0], prevGetContainer = _ref5[1];
        if (supportDom && getParent(props2.getContainer) === document.body) {
          if (visible && !prevVisible) {
            openCount += 1;
          } else if (init) {
            openCount -= 1;
          }
        }
        if (init) {
          var getContainerIsFunc = typeof getContainer5 === "function" && typeof prevGetContainer === "function";
          if (getContainerIsFunc ? getContainer5.toString() !== prevGetContainer.toString() : getContainer5 !== prevGetContainer) {
            removeCurrentContainer();
          }
          if (visible && visible !== prevVisible && supportDom && getParent(getContainer5) !== scrollLocker.getContainer()) {
            scrollLocker.reLock({
              container: getParent(getContainer5)
            });
          }
        }
        init = true;
      }, {
        immediate: true,
        flush: "post"
      });
      Vue.nextTick(function() {
        if (!attachToParent()) {
          rafId.value = wrapperRaf(function() {
            instance.update();
          });
        }
      });
    });
    Vue.onBeforeUnmount(function() {
      var visible = props2.visible, getContainer5 = props2.getContainer;
      if (supportDom && getParent(getContainer5) === document.body) {
        openCount = visible && openCount ? openCount - 1 : openCount;
      }
      removeCurrentContainer();
      wrapperRaf.cancel(rafId.value);
    });
    return function() {
      var forceRender = props2.forceRender, visible = props2.visible;
      var portal = null;
      var childProps = {
        getOpenCount: function getOpenCount2() {
          return openCount;
        },
        getContainer: getContainer4,
        switchScrollingEffect: switchScrolling,
        scrollLocker
      };
      if (forceRender || visible || componentRef.value) {
        portal = Vue.createVNode(Portal$1, {
          "getContainer": getContainer4,
          "ref": componentRef
        }, {
          default: function _default5() {
            var _a;
            return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, childProps);
          }
        });
      }
      return portal;
    };
  }
});
var IDialogPropTypes = dialogPropTypes();
var DialogWrap = Vue.defineComponent({
  name: "DialogWrap",
  inheritAttrs: false,
  props: initDefaultProps$1(IDialogPropTypes, {
    visible: false
  }),
  setup: function setup136(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var animatedVisible = Vue.ref(props2.visible);
    useProvidePortal({}, {
      inTriggerContext: false
    });
    Vue.watch(function() {
      return props2.visible;
    }, function() {
      if (props2.visible) {
        animatedVisible.value = true;
      }
    }, {
      flush: "post"
    });
    return function() {
      var visible = props2.visible, getContainer4 = props2.getContainer, forceRender = props2.forceRender, _props$destroyOnClose = props2.destroyOnClose, destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose, _afterClose = props2.afterClose;
      var dialogProps = _extends(_extends(_extends({}, props2), attrs), {
        ref: "_component",
        key: "dialog"
      });
      if (getContainer4 === false) {
        return Vue.createVNode(Dialog, _objectSpread2$1(_objectSpread2$1({}, dialogProps), {}, {
          "getOpenCount": function getOpenCount2() {
            return 2;
          }
        }), slots);
      }
      if (!forceRender && destroyOnClose && !animatedVisible.value) {
        return null;
      }
      return Vue.createVNode(Portal, {
        "visible": visible,
        "forceRender": forceRender,
        "getContainer": getContainer4
      }, {
        default: function _default5(childProps) {
          dialogProps = _extends(_extends(_extends({}, dialogProps), childProps), {
            afterClose: function afterClose() {
              _afterClose === null || _afterClose === void 0 ? void 0 : _afterClose();
              animatedVisible.value = false;
            }
          });
          return Vue.createVNode(Dialog, dialogProps, slots);
        }
      });
    };
  }
});
var DialogWrap$1 = DialogWrap;
var __rest$4 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var mousePosition = null;
var getClickPosition = function getClickPosition2(e2) {
  mousePosition = {
    x: e2.pageX,
    y: e2.pageY
  };
  setTimeout(function() {
    return mousePosition = null;
  }, 100);
};
if (canUseDocElement()) {
  addEventListenerWrap(document.documentElement, "click", getClickPosition, true);
}
var modalProps = function modalProps2() {
  return {
    prefixCls: String,
    visible: {
      type: Boolean,
      default: void 0
    },
    confirmLoading: {
      type: Boolean,
      default: void 0
    },
    title: PropTypes$1.any,
    closable: {
      type: Boolean,
      default: void 0
    },
    closeIcon: PropTypes$1.any,
    onOk: Function,
    onCancel: Function,
    "onUpdate:visible": Function,
    onChange: Function,
    afterClose: Function,
    centered: {
      type: Boolean,
      default: void 0
    },
    width: [String, Number],
    footer: PropTypes$1.any,
    okText: PropTypes$1.any,
    okType: String,
    cancelText: PropTypes$1.any,
    icon: PropTypes$1.any,
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    forceRender: {
      type: Boolean,
      default: void 0
    },
    okButtonProps: Object,
    cancelButtonProps: Object,
    destroyOnClose: {
      type: Boolean,
      default: void 0
    },
    wrapClassName: String,
    maskTransitionName: String,
    transitionName: String,
    getContainer: {
      type: [String, Function, Boolean, Object],
      default: void 0
    },
    zIndex: Number,
    bodyStyle: {
      type: Object,
      default: void 0
    },
    maskStyle: {
      type: Object,
      default: void 0
    },
    mask: {
      type: Boolean,
      default: void 0
    },
    keyboard: {
      type: Boolean,
      default: void 0
    },
    wrapProps: Object,
    focusTriggerAfterClose: {
      type: Boolean,
      default: void 0
    },
    modalRender: Function
  };
};
var destroyFns = [];
var Modal = Vue.defineComponent({
  name: "AModal",
  inheritAttrs: false,
  props: initDefaultProps$1(modalProps(), {
    width: 520,
    transitionName: "zoom",
    maskTransitionName: "fade",
    confirmLoading: false,
    visible: false,
    okType: "primary"
  }),
  setup: function setup137(props2, _ref) {
    var emit = _ref.emit, slots = _ref.slots, attrs = _ref.attrs;
    var _useLocaleReceiver = useLocaleReceiver("Modal"), _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 1), locale2 = _useLocaleReceiver2[0];
    var _useConfigInject = useConfigInject("modal", props2), prefixCls = _useConfigInject.prefixCls, rootPrefixCls = _useConfigInject.rootPrefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer;
    var handleCancel = function handleCancel2(e2) {
      emit("update:visible", false);
      emit("cancel", e2);
      emit("change", false);
    };
    var handleOk = function handleOk2(e2) {
      emit("ok", e2);
    };
    var renderFooter = function renderFooter2() {
      var _a, _b;
      var _props$okText = props2.okText, okText = _props$okText === void 0 ? (_a = slots.okText) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$okText, okType = props2.okType, _props$cancelText = props2.cancelText, cancelText = _props$cancelText === void 0 ? (_b = slots.cancelText) === null || _b === void 0 ? void 0 : _b.call(slots) : _props$cancelText, confirmLoading = props2.confirmLoading;
      return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode(Button$1, _objectSpread2$1({
        "onClick": handleCancel
      }, props2.cancelButtonProps), {
        default: function _default5() {
          return [cancelText || locale2.value.cancelText];
        }
      }), Vue.createVNode(Button$1, _objectSpread2$1(_objectSpread2$1({}, convertLegacyProps(okType)), {}, {
        "loading": confirmLoading,
        "onClick": handleOk
      }, props2.okButtonProps), {
        default: function _default5() {
          return [okText || locale2.value.okText];
        }
      })]);
    };
    return function() {
      var _classNames;
      var _a;
      props2.prefixCls;
      var visible = props2.visible, wrapClassName = props2.wrapClassName, centered = props2.centered, getContainer4 = props2.getContainer, _props$closeIcon = props2.closeIcon, _closeIcon = _props$closeIcon === void 0 ? (_a = slots.closeIcon) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$closeIcon, _props$focusTriggerAf = props2.focusTriggerAfterClose, focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf, restProps = __rest$4(props2, ["prefixCls", "visible", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose"]);
      var wrapClassNameExtended = classNames(wrapClassName, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls.value, "-centered"), !!centered), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-wrap-rtl"), direction.value === "rtl"), _classNames));
      return Vue.createVNode(DialogWrap$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restProps), attrs), {}, {
        "getContainer": getContainer4 || getPopupContainer.value,
        "prefixCls": prefixCls.value,
        "wrapClassName": wrapClassNameExtended,
        "visible": visible,
        "mousePosition": mousePosition,
        "onClose": handleCancel,
        "focusTriggerAfterClose": focusTriggerAfterClose,
        "transitionName": getTransitionName$1(rootPrefixCls.value, "zoom", props2.transitionName),
        "maskTransitionName": getTransitionName$1(rootPrefixCls.value, "fade", props2.maskTransitionName)
      }), _extends(_extends({}, slots), {
        footer: slots.footer || renderFooter,
        closeIcon: function closeIcon() {
          return Vue.createVNode("span", {
            "class": "".concat(prefixCls.value, "-close-x")
          }, [_closeIcon || Vue.createVNode(CloseOutlined$1, {
            "class": "".concat(prefixCls.value, "-close-icon")
          }, null)]);
        }
      }));
    };
  }
});
function renderSomeContent(someContent) {
  if (typeof someContent === "function") {
    return someContent();
  }
  return someContent;
}
var ConfirmDialog = Vue.defineComponent({
  name: "ConfirmDialog",
  inheritAttrs: false,
  props: ["icon", "onCancel", "onOk", "close", "closable", "zIndex", "afterClose", "visible", "keyboard", "centered", "getContainer", "maskStyle", "okButtonProps", "cancelButtonProps", "okType", "prefixCls", "okCancel", "width", "mask", "maskClosable", "okText", "cancelText", "autoFocusButton", "transitionName", "maskTransitionName", "type", "title", "content", "direction", "rootPrefixCls", "bodyStyle", "closeIcon", "modalRender", "focusTriggerAfterClose", "wrapClassName"],
  setup: function setup138(props2, _ref) {
    var attrs = _ref.attrs;
    var _useLocaleReceiver = useLocaleReceiver("Modal"), _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 1), locale2 = _useLocaleReceiver2[0];
    return function() {
      var icon = props2.icon, onCancel = props2.onCancel, onOk = props2.onOk, close3 = props2.close, _props$closable = props2.closable, closable = _props$closable === void 0 ? false : _props$closable, zIndex = props2.zIndex, afterClose = props2.afterClose, visible = props2.visible, keyboard = props2.keyboard, centered = props2.centered, getContainer4 = props2.getContainer, maskStyle = props2.maskStyle, okButtonProps = props2.okButtonProps, cancelButtonProps = props2.cancelButtonProps, _props$okCancel = props2.okCancel, okCancel = _props$okCancel === void 0 ? true : _props$okCancel, _props$width = props2.width, width = _props$width === void 0 ? 416 : _props$width, _props$mask = props2.mask, mask = _props$mask === void 0 ? true : _props$mask, _props$maskClosable = props2.maskClosable, maskClosable = _props$maskClosable === void 0 ? false : _props$maskClosable, type2 = props2.type, title = props2.title, content = props2.content, direction = props2.direction, closeIcon = props2.closeIcon, modalRender = props2.modalRender, focusTriggerAfterClose = props2.focusTriggerAfterClose, rootPrefixCls = props2.rootPrefixCls, bodyStyle = props2.bodyStyle, wrapClassName = props2.wrapClassName;
      var okType = props2.okType || "primary";
      var prefixCls = props2.prefixCls || "ant-modal";
      var contentPrefixCls = "".concat(prefixCls, "-confirm");
      var style = attrs.style || {};
      var okText = renderSomeContent(props2.okText) || (okCancel ? locale2.value.okText : locale2.value.justOkText);
      var cancelText = renderSomeContent(props2.cancelText) || locale2.value.cancelText;
      var autoFocusButton = props2.autoFocusButton === null ? false : props2.autoFocusButton || "ok";
      var classString = classNames(contentPrefixCls, "".concat(contentPrefixCls, "-").concat(type2), "".concat(prefixCls, "-").concat(type2), _defineProperty$T({}, "".concat(contentPrefixCls, "-rtl"), direction === "rtl"), attrs.class);
      var cancelButton = okCancel && Vue.createVNode(ActionButton, {
        "actionFn": onCancel,
        "close": close3,
        "autofocus": autoFocusButton === "cancel",
        "buttonProps": cancelButtonProps,
        "prefixCls": "".concat(rootPrefixCls, "-btn")
      }, {
        default: function _default5() {
          return [cancelText];
        }
      });
      return Vue.createVNode(Modal, {
        "prefixCls": prefixCls,
        "class": classString,
        "wrapClassName": classNames(_defineProperty$T({}, "".concat(contentPrefixCls, "-centered"), !!centered), wrapClassName),
        "onCancel": function onCancel2(e2) {
          return close3({
            triggerCancel: true
          }, e2);
        },
        "visible": visible,
        "title": "",
        "footer": "",
        "transitionName": getTransitionName$1(rootPrefixCls, "zoom", props2.transitionName),
        "maskTransitionName": getTransitionName$1(rootPrefixCls, "fade", props2.maskTransitionName),
        "mask": mask,
        "maskClosable": maskClosable,
        "maskStyle": maskStyle,
        "style": style,
        "bodyStyle": bodyStyle,
        "width": width,
        "zIndex": zIndex,
        "afterClose": afterClose,
        "keyboard": keyboard,
        "centered": centered,
        "getContainer": getContainer4,
        "closable": closable,
        "closeIcon": closeIcon,
        "modalRender": modalRender,
        "focusTriggerAfterClose": focusTriggerAfterClose
      }, {
        default: function _default5() {
          return [Vue.createVNode("div", {
            "class": "".concat(contentPrefixCls, "-body-wrapper")
          }, [Vue.createVNode("div", {
            "class": "".concat(contentPrefixCls, "-body")
          }, [renderSomeContent(icon), title === void 0 ? null : Vue.createVNode("span", {
            "class": "".concat(contentPrefixCls, "-title")
          }, [renderSomeContent(title)]), Vue.createVNode("div", {
            "class": "".concat(contentPrefixCls, "-content")
          }, [renderSomeContent(content)])]), Vue.createVNode("div", {
            "class": "".concat(contentPrefixCls, "-btns")
          }, [cancelButton, Vue.createVNode(ActionButton, {
            "type": okType,
            "actionFn": onOk,
            "close": close3,
            "autofocus": autoFocusButton === "ok",
            "buttonProps": okButtonProps,
            "prefixCls": "".concat(rootPrefixCls, "-btn")
          }, {
            default: function _default6() {
              return [okText];
            }
          })])])];
        }
      });
    };
  }
});
var confirm = function confirm2(config) {
  var container = document.createDocumentFragment();
  var currentConfig = _extends(_extends({}, omit(config, ["parentContext", "appContext"])), {
    close: close3,
    visible: true
  });
  var confirmDialogInstance = null;
  function destroy3() {
    if (confirmDialogInstance) {
      Vue.render(null, container);
      confirmDialogInstance.component.update();
      confirmDialogInstance = null;
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var triggerCancel = args.some(function(param) {
      return param && param.triggerCancel;
    });
    if (config.onCancel && triggerCancel) {
      config.onCancel.apply(config, args);
    }
    for (var i2 = 0; i2 < destroyFns.length; i2++) {
      var fn = destroyFns[i2];
      if (fn === close3) {
        destroyFns.splice(i2, 1);
        break;
      }
    }
  }
  function close3() {
    var _this = this;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    currentConfig = _extends(_extends({}, currentConfig), {
      visible: false,
      afterClose: function afterClose() {
        if (typeof config.afterClose === "function") {
          config.afterClose();
        }
        destroy3.apply(_this, args);
      }
    });
    update(currentConfig);
  }
  function update(configUpdate) {
    if (typeof configUpdate === "function") {
      currentConfig = configUpdate(currentConfig);
    } else {
      currentConfig = _extends(_extends({}, currentConfig), configUpdate);
    }
    if (confirmDialogInstance) {
      _extends(confirmDialogInstance.component.props, currentConfig);
      confirmDialogInstance.component.update();
    }
  }
  var Wrapper = function Wrapper2(p2) {
    var global2 = globalConfigForApi;
    var rootPrefixCls = global2.prefixCls;
    var prefixCls = p2.prefixCls || "".concat(rootPrefixCls, "-modal");
    return Vue.createVNode(ConfigProvider, _objectSpread2$1(_objectSpread2$1({}, global2), {}, {
      "notUpdateGlobalConfig": true,
      "prefixCls": rootPrefixCls
    }), {
      default: function _default5() {
        return [Vue.createVNode(ConfirmDialog, _objectSpread2$1(_objectSpread2$1({}, p2), {}, {
          "rootPrefixCls": rootPrefixCls,
          "prefixCls": prefixCls
        }), null)];
      }
    });
  };
  function render10(props2) {
    var vm = Vue.createVNode(Wrapper, _extends({}, props2));
    vm.appContext = config.parentContext || config.appContext || vm.appContext;
    Vue.render(vm, container);
    return vm;
  }
  confirmDialogInstance = render10(currentConfig);
  destroyFns.push(close3);
  return {
    destroy: close3,
    update
  };
};
var confirm$1 = confirm;
function withWarn(props2) {
  return _extends(_extends({
    icon: function icon() {
      return Vue.createVNode(ExclamationCircleOutlined$1, null, null);
    },
    okCancel: false
  }, props2), {
    type: "warning"
  });
}
function withInfo(props2) {
  return _extends(_extends({
    icon: function icon() {
      return Vue.createVNode(InfoCircleOutlined$1, null, null);
    },
    okCancel: false
  }, props2), {
    type: "info"
  });
}
function withSuccess(props2) {
  return _extends(_extends({
    icon: function icon() {
      return Vue.createVNode(CheckCircleOutlined$1, null, null);
    },
    okCancel: false
  }, props2), {
    type: "success"
  });
}
function withError(props2) {
  return _extends(_extends({
    icon: function icon() {
      return Vue.createVNode(CloseCircleOutlined$1, null, null);
    },
    okCancel: false
  }, props2), {
    type: "error"
  });
}
function withConfirm(props2) {
  return _extends(_extends({
    icon: function icon() {
      return Vue.createVNode(ExclamationCircleOutlined$1, null, null);
    },
    okCancel: true
  }, props2), {
    type: "confirm"
  });
}
function modalWarn(props2) {
  return confirm$1(withWarn(props2));
}
Modal.info = function infoFn(props2) {
  return confirm$1(withInfo(props2));
};
Modal.success = function successFn(props2) {
  return confirm$1(withSuccess(props2));
};
Modal.error = function errorFn(props2) {
  return confirm$1(withError(props2));
};
Modal.warning = modalWarn;
Modal.warn = modalWarn;
Modal.confirm = function confirmFn(props2) {
  return confirm$1(withConfirm(props2));
};
Modal.destroyAll = function destroyAllFn() {
  while (destroyFns.length) {
    var close3 = destroyFns.pop();
    if (close3) {
      close3();
    }
  }
};
Modal.install = function(app) {
  app.component(Modal.name, Modal);
  return app;
};
var index$9 = "";
function notEmpty(val) {
  return val !== void 0 && val !== null;
}
var Cell = function Cell2(props2) {
  var itemPrefixCls = props2.itemPrefixCls, component = props2.component, span = props2.span, labelStyle = props2.labelStyle, contentStyle = props2.contentStyle, bordered = props2.bordered, label = props2.label, content = props2.content, colon = props2.colon;
  var Component = component;
  if (bordered) {
    var _ref;
    return Vue.createVNode(Component, {
      "class": [(_ref = {}, _defineProperty$T(_ref, "".concat(itemPrefixCls, "-item-label"), notEmpty(label)), _defineProperty$T(_ref, "".concat(itemPrefixCls, "-item-content"), notEmpty(content)), _ref)],
      "colSpan": span
    }, {
      default: function _default5() {
        return [notEmpty(label) && Vue.createVNode("span", {
          "style": labelStyle
        }, [label]), notEmpty(content) && Vue.createVNode("span", {
          "style": contentStyle
        }, [content])];
      }
    });
  }
  return Vue.createVNode(Component, {
    "class": ["".concat(itemPrefixCls, "-item")],
    "colSpan": span
  }, {
    default: function _default5() {
      return [Vue.createVNode("div", {
        "class": "".concat(itemPrefixCls, "-item-container")
      }, [label && Vue.createVNode("span", {
        "class": ["".concat(itemPrefixCls, "-item-label"), _defineProperty$T({}, "".concat(itemPrefixCls, "-item-no-colon"), !colon)],
        "style": labelStyle
      }, [label]), content && Vue.createVNode("span", {
        "class": "".concat(itemPrefixCls, "-item-content"),
        "style": contentStyle
      }, [content])])];
    }
  });
};
var Cell$1 = Cell;
var Row$1 = function Row2(props2) {
  var renderCells = function renderCells2(items, _ref, _ref2) {
    var colon = _ref.colon, prefixCls2 = _ref.prefixCls, bordered2 = _ref.bordered;
    var component = _ref2.component, type2 = _ref2.type, showLabel = _ref2.showLabel, showContent = _ref2.showContent, rootLabelStyle = _ref2.labelStyle, rootContentStyle = _ref2.contentStyle;
    return items.map(function(item, index3) {
      var _a, _b;
      var _ref3 = item.props || {}, _ref3$prefixCls = _ref3.prefixCls, itemPrefixCls = _ref3$prefixCls === void 0 ? prefixCls2 : _ref3$prefixCls, _ref3$span = _ref3.span, span = _ref3$span === void 0 ? 1 : _ref3$span, labelStyle2 = _ref3.labelStyle, contentStyle2 = _ref3.contentStyle, _ref3$label = _ref3.label, label = _ref3$label === void 0 ? (_b = (_a = item.children) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.call(_a) : _ref3$label;
      var children = getSlot(item);
      var className = getClass(item);
      var style = getStyle(item);
      var key2 = item.key;
      if (typeof component === "string") {
        return Vue.createVNode(Cell$1, {
          "key": "".concat(type2, "-").concat(String(key2) || index3),
          "class": className,
          "style": style,
          "labelStyle": _extends(_extends({}, rootLabelStyle.value), labelStyle2),
          "contentStyle": _extends(_extends({}, rootContentStyle.value), contentStyle2),
          "span": span,
          "colon": colon,
          "component": component,
          "itemPrefixCls": itemPrefixCls,
          "bordered": bordered2,
          "label": showLabel ? label : null,
          "content": showContent ? children : null
        }, null);
      }
      return [Vue.createVNode(Cell$1, {
        "key": "label-".concat(String(key2) || index3),
        "class": className,
        "style": _extends(_extends(_extends({}, rootLabelStyle.value), style), labelStyle2),
        "span": 1,
        "colon": colon,
        "component": component[0],
        "itemPrefixCls": itemPrefixCls,
        "bordered": bordered2,
        "label": label
      }, null), Vue.createVNode(Cell$1, {
        "key": "content-".concat(String(key2) || index3),
        "class": className,
        "style": _extends(_extends(_extends({}, rootContentStyle.value), style), contentStyle2),
        "span": span * 2 - 1,
        "component": component[1],
        "itemPrefixCls": itemPrefixCls,
        "bordered": bordered2,
        "content": children
      }, null)];
    });
  };
  var prefixCls = props2.prefixCls, vertical = props2.vertical, row = props2.row, index2 = props2.index, bordered = props2.bordered;
  var _inject = Vue.inject(descriptionsContext, {
    labelStyle: Vue.ref({}),
    contentStyle: Vue.ref({})
  }), labelStyle = _inject.labelStyle, contentStyle = _inject.contentStyle;
  if (vertical) {
    return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode("tr", {
      "key": "label-".concat(index2),
      "class": "".concat(prefixCls, "-row")
    }, [renderCells(row, props2, {
      component: "th",
      type: "label",
      showLabel: true,
      labelStyle,
      contentStyle
    })]), Vue.createVNode("tr", {
      "key": "content-".concat(index2),
      "class": "".concat(prefixCls, "-row")
    }, [renderCells(row, props2, {
      component: "td",
      type: "content",
      showContent: true,
      labelStyle,
      contentStyle
    })])]);
  }
  return Vue.createVNode("tr", {
    "key": index2,
    "class": "".concat(prefixCls, "-row")
  }, [renderCells(row, props2, {
    component: bordered ? ["th", "td"] : "td",
    type: "item",
    showLabel: true,
    showContent: true,
    labelStyle,
    contentStyle
  })]);
};
var Row$2 = Row$1;
({
  prefixCls: String,
  label: PropTypes$1.any,
  span: Number
});
var descriptionsItemProp = function descriptionsItemProp2() {
  return {
    prefixCls: String,
    label: PropTypes$1.any,
    labelStyle: {
      type: Object,
      default: void 0
    },
    contentStyle: {
      type: Object,
      default: void 0
    },
    span: {
      type: Number,
      default: 1
    }
  };
};
var DescriptionsItem = Vue.defineComponent({
  name: "ADescriptionsItem",
  props: descriptionsItemProp(),
  slots: ["label"],
  setup: function setup139(_2, _ref) {
    var slots = _ref.slots;
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
  }
});
var DEFAULT_COLUMN_MAP = {
  xxxl: 3,
  xxl: 3,
  xl: 3,
  lg: 3,
  md: 3,
  sm: 2,
  xs: 1
};
function getColumn(column, screens2) {
  if (typeof column === "number") {
    return column;
  }
  if (_typeof$1(column) === "object") {
    for (var i2 = 0; i2 < responsiveArray.length; i2++) {
      var breakpoint = responsiveArray[i2];
      if (screens2[breakpoint] && column[breakpoint] !== void 0) {
        return column[breakpoint] || DEFAULT_COLUMN_MAP[breakpoint];
      }
    }
  }
  return 3;
}
function getFilledItem(node, span, rowRestCol) {
  var clone2 = node;
  if (span === void 0 || span > rowRestCol) {
    clone2 = cloneElement(node, {
      span: rowRestCol
    });
    warning(span === void 0, "Descriptions", "Sum of column `span` in a line not match `column` of Descriptions.");
  }
  return clone2;
}
function getRows(children, column) {
  var childNodes = flattenChildren(children);
  var rows = [];
  var tmpRow = [];
  var rowRestCol = column;
  childNodes.forEach(function(node, index2) {
    var _a;
    var span = (_a = node.props) === null || _a === void 0 ? void 0 : _a.span;
    var mergedSpan = span || 1;
    if (index2 === childNodes.length - 1) {
      tmpRow.push(getFilledItem(node, span, rowRestCol));
      rows.push(tmpRow);
      return;
    }
    if (mergedSpan < rowRestCol) {
      rowRestCol -= mergedSpan;
      tmpRow.push(node);
    } else {
      tmpRow.push(getFilledItem(node, mergedSpan, rowRestCol));
      rows.push(tmpRow);
      rowRestCol = column;
      tmpRow = [];
    }
  });
  return rows;
}
var descriptionsProps = function descriptionsProps2() {
  return {
    prefixCls: String,
    bordered: {
      type: Boolean,
      default: void 0
    },
    size: {
      type: String,
      default: "default"
    },
    title: PropTypes$1.any,
    extra: PropTypes$1.any,
    column: {
      type: [Number, Object],
      default: function _default5() {
        return DEFAULT_COLUMN_MAP;
      }
    },
    layout: String,
    colon: {
      type: Boolean,
      default: void 0
    },
    labelStyle: {
      type: Object,
      default: void 0
    },
    contentStyle: {
      type: Object,
      default: void 0
    }
  };
};
var descriptionsContext = Symbol("descriptionsContext");
var Descriptions = Vue.defineComponent({
  name: "ADescriptions",
  props: descriptionsProps(),
  slots: ["title", "extra"],
  Item: DescriptionsItem,
  setup: function setup140(props2, _ref2) {
    var slots = _ref2.slots;
    var _useConfigInject = useConfigInject("descriptions", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var token;
    var screens2 = Vue.ref({});
    Vue.onBeforeMount(function() {
      token = ResponsiveObserve.subscribe(function(screen) {
        if (_typeof$1(props2.column) !== "object") {
          return;
        }
        screens2.value = screen;
      });
    });
    Vue.onBeforeUnmount(function() {
      ResponsiveObserve.unsubscribe(token);
    });
    Vue.provide(descriptionsContext, {
      labelStyle: Vue.toRef(props2, "labelStyle"),
      contentStyle: Vue.toRef(props2, "contentStyle")
    });
    var mergeColumn = Vue.computed(function() {
      return getColumn(props2.column, screens2.value);
    });
    return function() {
      var _ref3;
      var _a, _b, _c;
      var size = props2.size, _props$bordered = props2.bordered, bordered = _props$bordered === void 0 ? false : _props$bordered, _props$layout = props2.layout, layout = _props$layout === void 0 ? "horizontal" : _props$layout, _props$colon = props2.colon, colon = _props$colon === void 0 ? true : _props$colon, _props$title = props2.title, title = _props$title === void 0 ? (_a = slots.title) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$title, _props$extra = props2.extra, extra = _props$extra === void 0 ? (_b = slots.extra) === null || _b === void 0 ? void 0 : _b.call(slots) : _props$extra;
      var children = (_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots);
      var rows = getRows(children, mergeColumn.value);
      return Vue.createVNode("div", {
        "class": [prefixCls.value, (_ref3 = {}, _defineProperty$T(_ref3, "".concat(prefixCls.value, "-").concat(size), size !== "default"), _defineProperty$T(_ref3, "".concat(prefixCls.value, "-bordered"), !!bordered), _defineProperty$T(_ref3, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _ref3)]
      }, [(title || extra) && Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-header")
      }, [title && Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-title")
      }, [title]), extra && Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-extra")
      }, [extra])]), Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-view")
      }, [Vue.createVNode("table", null, [Vue.createVNode("tbody", null, [rows.map(function(row, index2) {
        return Vue.createVNode(Row$2, {
          "key": index2,
          "index": index2,
          "colon": colon,
          "prefixCls": prefixCls.value,
          "vertical": layout === "vertical",
          "bordered": bordered,
          "row": row
        }, null);
      })])])])]);
    };
  }
});
Descriptions.install = function(app) {
  app.component(Descriptions.name, Descriptions);
  app.component(Descriptions.Item.name, Descriptions.Item);
  return app;
};
var _Descriptions = Descriptions;
var index$8 = "";
var Row = withInstall(Row$3);
var Col = withInstall(Col$1);
var TabPane = Tabs.TabPane;
var cardProps = function cardProps2() {
  return {
    prefixCls: String,
    title: PropTypes$1.any,
    extra: PropTypes$1.any,
    bordered: {
      type: Boolean,
      default: true
    },
    bodyStyle: {
      type: Object,
      default: void 0
    },
    headStyle: {
      type: Object,
      default: void 0
    },
    loading: {
      type: Boolean,
      default: false
    },
    hoverable: {
      type: Boolean,
      default: false
    },
    type: {
      type: String
    },
    size: {
      type: String
    },
    actions: PropTypes$1.any,
    tabList: {
      type: Array
    },
    tabBarExtraContent: PropTypes$1.any,
    activeTabKey: String,
    defaultActiveTabKey: String,
    cover: PropTypes$1.any,
    onTabChange: {
      type: Function
    }
  };
};
var Card = Vue.defineComponent({
  name: "ACard",
  props: cardProps(),
  slots: ["title", "extra", "tabBarExtraContent", "actions", "cover", "customTab"],
  setup: function setup141(props2, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("card", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, size = _useConfigInject.size;
    var getAction = function getAction2(actions) {
      var actionList = actions.map(function(action, index2) {
        return Vue.isVNode(action) && !isEmptyElement(action) || !Vue.isVNode(action) ? Vue.createVNode("li", {
          "style": {
            width: "".concat(100 / actions.length, "%")
          },
          "key": "action-".concat(index2)
        }, [Vue.createVNode("span", null, [action])]) : null;
      });
      return actionList;
    };
    var triggerTabChange = function triggerTabChange2(key2) {
      var _a;
      (_a = props2.onTabChange) === null || _a === void 0 ? void 0 : _a.call(props2, key2);
    };
    var isContainGrid = function isContainGrid2() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var containGrid;
      obj.forEach(function(element) {
        if (element && isPlainObject(element.type) && element.type.__ANT_CARD_GRID) {
          containGrid = true;
        }
      });
      return containGrid;
    };
    return function() {
      var _classString, _tabsProps;
      var _a, _b, _c, _d, _e, _f;
      var _props$headStyle = props2.headStyle, headStyle = _props$headStyle === void 0 ? {} : _props$headStyle, _props$bodyStyle = props2.bodyStyle, bodyStyle = _props$bodyStyle === void 0 ? {} : _props$bodyStyle, loading = props2.loading, _props$bordered = props2.bordered, bordered = _props$bordered === void 0 ? true : _props$bordered, type2 = props2.type, tabList = props2.tabList, hoverable = props2.hoverable, activeTabKey = props2.activeTabKey, defaultActiveTabKey = props2.defaultActiveTabKey, _props$tabBarExtraCon = props2.tabBarExtraContent, tabBarExtraContent = _props$tabBarExtraCon === void 0 ? filterEmptyWithUndefined((_a = slots.tabBarExtraContent) === null || _a === void 0 ? void 0 : _a.call(slots)) : _props$tabBarExtraCon, _props$title = props2.title, title = _props$title === void 0 ? filterEmptyWithUndefined((_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots)) : _props$title, _props$extra = props2.extra, extra = _props$extra === void 0 ? filterEmptyWithUndefined((_c = slots.extra) === null || _c === void 0 ? void 0 : _c.call(slots)) : _props$extra, _props$actions = props2.actions, actions = _props$actions === void 0 ? filterEmptyWithUndefined((_d = slots.actions) === null || _d === void 0 ? void 0 : _d.call(slots)) : _props$actions, _props$cover = props2.cover, cover = _props$cover === void 0 ? filterEmptyWithUndefined((_e = slots.cover) === null || _e === void 0 ? void 0 : _e.call(slots)) : _props$cover;
      var children = flattenChildren((_f = slots.default) === null || _f === void 0 ? void 0 : _f.call(slots));
      var pre = prefixCls.value;
      var classString = (_classString = {}, _defineProperty$T(_classString, "".concat(pre), true), _defineProperty$T(_classString, "".concat(pre, "-loading"), loading), _defineProperty$T(_classString, "".concat(pre, "-bordered"), bordered), _defineProperty$T(_classString, "".concat(pre, "-hoverable"), !!hoverable), _defineProperty$T(_classString, "".concat(pre, "-contain-grid"), isContainGrid(children)), _defineProperty$T(_classString, "".concat(pre, "-contain-tabs"), tabList && tabList.length), _defineProperty$T(_classString, "".concat(pre, "-").concat(size.value), size.value), _defineProperty$T(_classString, "".concat(pre, "-type-").concat(type2), !!type2), _defineProperty$T(_classString, "".concat(pre, "-rtl"), direction.value === "rtl"), _classString);
      var loadingBlockStyle = bodyStyle.padding === 0 || bodyStyle.padding === "0px" ? {
        padding: "24px"
      } : void 0;
      var block = Vue.createVNode("div", {
        "class": "".concat(pre, "-loading-block")
      }, null);
      var loadingBlock = Vue.createVNode("div", {
        "class": "".concat(pre, "-loading-content"),
        "style": loadingBlockStyle
      }, [Vue.createVNode(Row, {
        "gutter": 8
      }, {
        default: function _default5() {
          return [Vue.createVNode(Col, {
            "span": 22
          }, {
            default: function _default6() {
              return [block];
            }
          })];
        }
      }), Vue.createVNode(Row, {
        "gutter": 8
      }, {
        default: function _default5() {
          return [Vue.createVNode(Col, {
            "span": 8
          }, {
            default: function _default6() {
              return [block];
            }
          }), Vue.createVNode(Col, {
            "span": 15
          }, {
            default: function _default6() {
              return [block];
            }
          })];
        }
      }), Vue.createVNode(Row, {
        "gutter": 8
      }, {
        default: function _default5() {
          return [Vue.createVNode(Col, {
            "span": 6
          }, {
            default: function _default6() {
              return [block];
            }
          }), Vue.createVNode(Col, {
            "span": 18
          }, {
            default: function _default6() {
              return [block];
            }
          })];
        }
      }), Vue.createVNode(Row, {
        "gutter": 8
      }, {
        default: function _default5() {
          return [Vue.createVNode(Col, {
            "span": 13
          }, {
            default: function _default6() {
              return [block];
            }
          }), Vue.createVNode(Col, {
            "span": 9
          }, {
            default: function _default6() {
              return [block];
            }
          })];
        }
      }), Vue.createVNode(Row, {
        "gutter": 8
      }, {
        default: function _default5() {
          return [Vue.createVNode(Col, {
            "span": 4
          }, {
            default: function _default6() {
              return [block];
            }
          }), Vue.createVNode(Col, {
            "span": 3
          }, {
            default: function _default6() {
              return [block];
            }
          }), Vue.createVNode(Col, {
            "span": 16
          }, {
            default: function _default6() {
              return [block];
            }
          })];
        }
      })]);
      var hasActiveTabKey = activeTabKey !== void 0;
      var tabsProps3 = (_tabsProps = {
        size: "large"
      }, _defineProperty$T(_tabsProps, hasActiveTabKey ? "activeKey" : "defaultActiveKey", hasActiveTabKey ? activeTabKey : defaultActiveTabKey), _defineProperty$T(_tabsProps, "onChange", triggerTabChange), _defineProperty$T(_tabsProps, "class", "".concat(pre, "-head-tabs")), _tabsProps);
      var head;
      var tabs = tabList && tabList.length ? Vue.createVNode(Tabs, tabsProps3, {
        default: function _default5() {
          return [tabList.map(function(item) {
            var temp = item.tab, itemSlots = item.slots;
            var name = itemSlots === null || itemSlots === void 0 ? void 0 : itemSlots.tab;
            devWarning(!itemSlots, "Card", "tabList slots is deprecated, Please use `customTab` instead.");
            var tab = temp !== void 0 ? temp : slots[name] ? slots[name](item) : null;
            tab = Vue.renderSlot(slots, "customTab", item, function() {
              return [tab];
            });
            return Vue.createVNode(TabPane, {
              "tab": tab,
              "key": item.key,
              "disabled": item.disabled
            }, null);
          })];
        },
        rightExtra: tabBarExtraContent ? function() {
          return tabBarExtraContent;
        } : null
      }) : null;
      if (title || extra || tabs) {
        head = Vue.createVNode("div", {
          "class": "".concat(pre, "-head"),
          "style": headStyle
        }, [Vue.createVNode("div", {
          "class": "".concat(pre, "-head-wrapper")
        }, [title && Vue.createVNode("div", {
          "class": "".concat(pre, "-head-title")
        }, [title]), extra && Vue.createVNode("div", {
          "class": "".concat(pre, "-extra")
        }, [extra])]), tabs]);
      }
      var coverDom = cover ? Vue.createVNode("div", {
        "class": "".concat(pre, "-cover")
      }, [cover]) : null;
      var body = Vue.createVNode("div", {
        "class": "".concat(pre, "-body"),
        "style": bodyStyle
      }, [loading ? loadingBlock : children]);
      var actionDom = actions && actions.length ? Vue.createVNode("ul", {
        "class": "".concat(pre, "-actions")
      }, [getAction(actions)]) : null;
      return Vue.createVNode("div", {
        "class": classString,
        "ref": "cardContainerRef"
      }, [head, coverDom, children && children.length ? body : null, actionDom]);
    };
  }
});
var Card$1 = Card;
var cardMetaProps = function cardMetaProps2() {
  return {
    prefixCls: String,
    title: PropTypes$1.any,
    description: PropTypes$1.any,
    avatar: PropTypes$1.any
  };
};
var Meta = Vue.defineComponent({
  name: "ACardMeta",
  props: cardMetaProps(),
  slots: ["title", "description", "avatar"],
  setup: function setup142(props2, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("card", props2), prefixCls = _useConfigInject.prefixCls;
    return function() {
      var classString = _defineProperty$T({}, "".concat(prefixCls.value, "-meta"), true);
      var avatar = getPropsSlot(slots, props2, "avatar");
      var title = getPropsSlot(slots, props2, "title");
      var description = getPropsSlot(slots, props2, "description");
      var avatarDom = avatar ? Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-meta-avatar")
      }, [avatar]) : null;
      var titleDom = title ? Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-meta-title")
      }, [title]) : null;
      var descriptionDom = description ? Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-meta-description")
      }, [description]) : null;
      var MetaDetail = titleDom || descriptionDom ? Vue.createVNode("div", {
        "class": "".concat(prefixCls.value, "-meta-detail")
      }, [titleDom, descriptionDom]) : null;
      return Vue.createVNode("div", {
        "class": classString
      }, [avatarDom, MetaDetail]);
    };
  }
});
var cardGridProps = function cardGridProps2() {
  return {
    prefixCls: String,
    hoverable: {
      type: Boolean,
      default: true
    }
  };
};
var Grid = Vue.defineComponent({
  name: "ACardGrid",
  __ANT_CARD_GRID: true,
  props: cardGridProps(),
  setup: function setup143(props2, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("card", props2), prefixCls = _useConfigInject.prefixCls;
    var classNames2 = Vue.computed(function() {
      var _ref2;
      return _ref2 = {}, _defineProperty$T(_ref2, "".concat(prefixCls.value, "-grid"), true), _defineProperty$T(_ref2, "".concat(prefixCls.value, "-grid-hoverable"), props2.hoverable), _ref2;
    });
    return function() {
      var _a;
      return Vue.createVNode("div", {
        "class": classNames2.value
      }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
Card$1.Meta = Meta;
Card$1.Grid = Grid;
Card$1.install = function(app) {
  app.component(Card$1.name, Card$1);
  app.component(Meta.name, Meta);
  app.component(Grid.name, Grid);
  return app;
};
var index$7 = "";
var iconMapFilled = {
  success: CheckCircleFilled$1,
  info: InfoCircleFilled$1,
  error: CloseCircleFilled$1,
  warning: ExclamationCircleFilled$1
};
var iconMapOutlined = {
  success: CheckCircleOutlined$1,
  info: InfoCircleOutlined$1,
  error: CloseCircleOutlined$1,
  warning: ExclamationCircleOutlined$1
};
var AlertTypes = tuple$1("success", "info", "warning", "error");
var alertProps = function alertProps2() {
  return {
    type: PropTypes$1.oneOf(AlertTypes),
    closable: {
      type: Boolean,
      default: void 0
    },
    closeText: PropTypes$1.any,
    message: PropTypes$1.any,
    description: PropTypes$1.any,
    afterClose: Function,
    showIcon: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    banner: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes$1.any,
    closeIcon: PropTypes$1.any,
    onClose: Function
  };
};
var Alert = Vue.defineComponent({
  name: "AAlert",
  inheritAttrs: false,
  props: alertProps(),
  setup: function setup144(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs, expose = _ref.expose;
    var _useConfigInject = useConfigInject("alert", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var closing = Vue.ref(false);
    var closed = Vue.ref(false);
    var alertNode = Vue.ref();
    var handleClose = function handleClose2(e2) {
      e2.preventDefault();
      var dom = alertNode.value;
      dom.style.height = "".concat(dom.offsetHeight, "px");
      dom.style.height = "".concat(dom.offsetHeight, "px");
      closing.value = true;
      emit("close", e2);
    };
    var animationEnd = function animationEnd2() {
      var _a;
      closing.value = false;
      closed.value = true;
      (_a = props2.afterClose) === null || _a === void 0 ? void 0 : _a.call(props2);
    };
    expose({
      animationEnd
    });
    var motionStyle = Vue.ref({});
    return function() {
      var _classNames;
      var _a;
      var banner = props2.banner, _props$closeIcon = props2.closeIcon, customCloseIcon = _props$closeIcon === void 0 ? (_a = slots.closeIcon) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$closeIcon;
      var closable = props2.closable, type2 = props2.type, showIcon = props2.showIcon;
      var closeText = getPropsSlot(slots, props2, "closeText");
      var description = getPropsSlot(slots, props2, "description");
      var message = getPropsSlot(slots, props2, "message");
      var icon = getPropsSlot(slots, props2, "icon");
      showIcon = banner && showIcon === void 0 ? true : showIcon;
      type2 = banner && type2 === void 0 ? "warning" : type2 || "info";
      var IconType = (description ? iconMapOutlined : iconMapFilled)[type2] || null;
      if (closeText) {
        closable = true;
      }
      var prefixClsValue = prefixCls.value;
      var alertCls = classNames(prefixClsValue, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixClsValue, "-").concat(type2), true), _defineProperty$T(_classNames, "".concat(prefixClsValue, "-closing"), closing.value), _defineProperty$T(_classNames, "".concat(prefixClsValue, "-with-description"), !!description), _defineProperty$T(_classNames, "".concat(prefixClsValue, "-no-icon"), !showIcon), _defineProperty$T(_classNames, "".concat(prefixClsValue, "-banner"), !!banner), _defineProperty$T(_classNames, "".concat(prefixClsValue, "-closable"), closable), _defineProperty$T(_classNames, "".concat(prefixClsValue, "-rtl"), direction.value === "rtl"), _classNames));
      var closeIcon = closable ? Vue.createVNode("button", {
        "type": "button",
        "onClick": handleClose,
        "class": "".concat(prefixClsValue, "-close-icon"),
        "tabindex": 0
      }, [closeText ? Vue.createVNode("span", {
        "class": "".concat(prefixClsValue, "-close-text")
      }, [closeText]) : customCloseIcon === void 0 ? Vue.createVNode(CloseOutlined$1, null, null) : customCloseIcon]) : null;
      var iconNode = icon && (isValidElement(icon) ? cloneElement(icon, {
        class: "".concat(prefixClsValue, "-icon")
      }) : Vue.createVNode("span", {
        "class": "".concat(prefixClsValue, "-icon")
      }, [icon])) || Vue.createVNode(IconType, {
        "class": "".concat(prefixClsValue, "-icon")
      }, null);
      var transitionProps = getTransitionProps("".concat(prefixClsValue, "-motion"), {
        appear: false,
        css: true,
        onAfterLeave: animationEnd,
        onBeforeLeave: function onBeforeLeave(node) {
          node.style.maxHeight = "".concat(node.offsetHeight, "px");
        },
        onLeave: function onLeave(node) {
          node.style.maxHeight = "0px";
        }
      });
      return closed.value ? null : Vue.createVNode(Transition, transitionProps, {
        default: function _default5() {
          return [Vue.withDirectives(Vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({
            "role": "alert"
          }, attrs), {}, {
            "style": [attrs.style, motionStyle.value],
            "class": [attrs.class, alertCls],
            "data-show": !closing.value,
            "ref": alertNode
          }), [showIcon ? iconNode : null, Vue.createVNode("div", {
            "class": "".concat(prefixClsValue, "-content")
          }, [message ? Vue.createVNode("div", {
            "class": "".concat(prefixClsValue, "-message")
          }, [message]) : null, description ? Vue.createVNode("div", {
            "class": "".concat(prefixClsValue, "-description")
          }, [description]) : null]), closeIcon]), [[Vue.vShow, !closing.value]])];
        }
      });
    };
  }
});
var _Alert = withInstall(Alert);
var index$6 = "";
var index$5 = "";
const KEY = {
  right: 39,
  left: 37,
  esc: 27
};
const $win = $(window);
const $html = $("html");
const DOMS = ["layui-layer", ".layui-layer-title", ".layui-layer-main", ".layui-layer-dialog", "layui-layer-iframe", "layui-layer-content", "layui-layer-btn", "layui-layer-close"];
const DOMS_ANIM = ["layer-anim-00", "layer-anim-01", "layer-anim-02", "layer-anim-03", "layer-anim-04", "layer-anim-05", "layer-anim-06"];
const DOMS_SHADE = "layui-layer-shade";
const DOMS_MOVE = "layui-layer-move";
const READY = {
  getPath: function() {
    var jsPath = document.currentScript ? document.currentScript.src : function() {
      var js = document.scripts, last = js.length - 1, src;
      for (var i2 = last; i2 > 0; i2--) {
        if (js[i2].readyState === "interactive") {
          src = js[i2].src;
          break;
        }
      }
      return src || js[last].src;
    }();
    const GLOBAL = {};
    return GLOBAL.layer_dir || jsPath.substring(0, jsPath.lastIndexOf("/") + 1);
  }(),
  config: {},
  end: {},
  minIndex: 0,
  minLeft: [],
  btn: ["&#x786E;&#x5B9A;", "&#x53D6;&#x6D88;"],
  type: ["dialog", "page", "iframe", "loading", "tips"],
  getStyle: function(node, name) {
    var style = node.currentStyle ? node.currentStyle : window.getComputedStyle(node, null);
    return style[style.getPropertyValue ? "getPropertyValue" : "getAttribute"](name);
  }
};
const layer = {
  MSG: 0,
  DIALOG: 1,
  IFRAME: 2,
  LOADING: 3,
  TIPS: 4,
  UP: 1,
  RIGHT: 2,
  BOTTOM: 3,
  LEFT: 4,
  v: "3.5.1",
  ie: function() {
    var agent = navigator.userAgent.toLowerCase();
    return !!window.ActiveXObject || "ActiveXObject" in window ? (agent.match(/msie\s(\d+)/) || [])[1] || "11" : false;
  }(),
  index: 1,
  path: READY.getPath,
  config: function(options, fn) {
    options = options || {};
    layer.cache = READY.config = $.extend({}, READY.config, options);
    layer.path = READY.config.path || layer.path;
    typeof options.extend === "string" && (options.extend = [options.extend]);
    if (READY.config.path)
      layer.ready();
    if (!options.extend)
      return this;
    return this;
  },
  ready(callback) {
    return this;
  },
  alert: function(content, options, yes) {
    var type2 = typeof options === "function";
    if (type2)
      yes = options;
    return layer.open($.extend({
      content,
      yes
    }, type2 ? {} : options));
  },
  confirm: function(content, options, yes, cancel) {
    if (_.isFunction(options)) {
      cancel = yes;
      yes = options;
    }
    return layer.open($.extend({
      content,
      btn: READY.btn,
      yes,
      btn2: cancel
    }, type ? {} : options));
  },
  msg: function(content, options, end) {
    var isOptionsIsFunction = _.isFunction(options), rskin = READY.config.skin;
    var skin2 = (rskin ? rskin + " " + rskin + "-msg" : "") || "layui-layer-msg";
    var anim = DOMS_ANIM.length - 1;
    if (isOptionsIsFunction)
      end = options;
    return layer.open($.extend({
      content,
      time: 3e3,
      shade: false,
      skin: skin2,
      title: false,
      closeBtn: false,
      btn: false,
      resize: false,
      end
    }, isOptionsIsFunction && !READY.config.skin ? {
      skin: skin2 + " layui-layer-hui",
      anim
    } : function() {
      options = options || {};
      if (options.icon === -1 || options.icon === void 0 && !READY.config.skin) {
        options.skin = skin2 + " " + (options.skin || "layui-layer-hui");
      }
      return options;
    }()));
  },
  load: function(icon, options) {
    return layer.open($.extend({
      type: 3,
      icon: icon || 0,
      resize: false,
      shade: 0.01
    }, options));
  },
  tips(content, follow, options) {
    return layer.open($.extend({
      type: layer.TIPS,
      content: [content, follow],
      closeBtn: false,
      time: 3e3,
      shade: false,
      resize: false,
      fixed: false,
      maxWidth: 260
    }, options));
  }
};
function ClassLayer(setings) {
  var that = this;
  that.index = ++layer.index;
  that.config.maxWidth = $($win).width() - 15 * 2;
  that.config = $.extend({}, that.config, READY.config, setings);
  that.creat();
}
ClassLayer.pt = ClassLayer.prototype;
ClassLayer.pt.config = {
  type: 0,
  shade: 0.3,
  fixed: true,
  move: DOMS[1],
  title: "&#x4FE1;&#x606F;",
  offset: "auto",
  area: "auto",
  closeBtn: 1,
  time: 0,
  zIndex: 1,
  maxWidth: 360,
  anim: 0,
  isOutAnim: true,
  minStack: true,
  icon: -1,
  moveType: 1,
  resize: true,
  scrollbar: true,
  tips: 2
};
ClassLayer.pt.vessel = function(conType, callback) {
  var that = this, times = that.index, config = that.config;
  var zIndex = config.zIndex + times, titype = typeof config.title === "object";
  var ismax = config.maxmin && (config.type === 1 || config.type === 2);
  var titleHTML = config.title ? `
  <div class="layui-layer-title" style="${titype ? config.title[1] : ""}">
    ${titype ? config.title[0] : config.title}
  </div >` : "";
  config.zIndex = zIndex;
  callback([config.shade ? `<div class="${DOMS_SHADE}" id="${DOMS_SHADE}${times}" times="${times}" style="z-index:${zIndex - 1};"></div>` : "", `<div class="flex vertical ${DOMS[0]} layui-layer-${READY.type[config.type]} ${(config.type == 0 || config.type == 2) && !config.shade ? " layui-layer-border" : ""} ${config.skin || ""}"
				  id="${DOMS[0]}${times}"
				  type="${READY.type[config.type]}"
				  times="${times}"
				  showtime="${config.time}"
				  conType="${conType ? "object" : "string"}"
				  style="z-index:${zIndex};
					  width:${config.area[0]};
					  height:${config.area[1]};
					  position:${config.fixed ? "fixed;" : "absolute;"}">
				${conType && config.type != 2 ? "" : titleHTML}
				<div id="${config.id || ""}" class="flex1 ${DOMS[5]}${config.type == 0 && config.icon !== -1 ? " layui-layer-padding" : ""} ${config.type == 3 ? " layui-layer-loading" + config.icon : ""}">` + (config.type == 0 && config.icon !== -1 ? '<i class="layui-layer-ico layui-layer-ico' + config.icon + '"></i>' : "") + (config.type == 1 && conType ? "" : config.content || "") + '</div><span class="layui-layer-setwin">' + function() {
    var closebtn = ismax ? '<a class="layui-layer-min" href="javascript:;"><cite></cite></a><a class="layui-layer-ico layui-layer-max" href="javascript:;"></a>' : "";
    config.closeBtn && (closebtn += '<a class="layui-layer-ico ' + DOMS[7] + " " + DOMS[7] + (config.title ? config.closeBtn : config.type == 4 ? "1" : "2") + '" href="javascript:;"></a>');
    return closebtn;
  }() + "</span>" + (config.btn ? function() {
    var button = "";
    typeof config.btn === "string" && (config.btn = [config.btn]);
    if (config.btn.length === 0)
      return "";
    for (var i2 = 0, len = config.btn.length; i2 < len; i2++) {
      button += `<a class="${DOMS[6]}">${config.btn[i2]}</a>`;
    }
    return `<div class="${DOMS[6]} layui-layer-btn-${config.btnAlign || ""}">${button}</div>`;
  }() : "") + (config.resize ? '<span class="layui-layer-resize"></span>' : "") + "</div>"], titleHTML, $(`<div class="${DOMS_MOVE}" id="${DOMS_MOVE}"></div>`));
  return that;
};
ClassLayer.pt.creat = function() {
  var that = this, config = that.config, times = that.index, content = config.content, conType = typeof content === "object", body = $("body");
  if (config.id && $("#" + config.id)[0])
    return;
  if (typeof config.area === "string") {
    config.area = config.area === "auto" ? ["", ""] : [config.area, ""];
  }
  if (config.shift) {
    config.anim = config.shift;
  }
  if (layer.ie == 6) {
    config.fixed = false;
  }
  switch (config.type) {
    case layer.MSG:
      config.btn = "btn" in config ? config.btn : READY.btn[0];
      layer.closeAll("dialog");
      break;
    case layer.IFRAME:
      var content = config.content = conType ? config.content : [config.content || "", "auto"];
      config.content = '<iframe scrolling="' + (config.content[1] || "auto") + '" allowtransparency="true" id="' + DOMS[4] + times + '" name="' + DOMS[4] + times + `" onload="this.className='';" class="layui-layer-load" frameborder="0" src="` + config.content[0] + '"></iframe>';
      break;
    case layer.LOADING:
      delete config.title;
      delete config.closeBtn;
      config.icon === -1 && config.icon === 0;
      layer.closeAll("loading");
      break;
    case layer.TIPS: {
      conType || (config.content = [config.content, "body"]);
      config.follow = config.content[1];
      const arrow = '<i class="layui-layer-TipsG"></i>';
      config.content = `${config.content[0]}${arrow}`;
      delete config.title;
      config.tips = typeof config.tips === "object" ? config.tips : [config.tips, true];
      config.tipsMore || layer.closeAll("tips");
      break;
    }
  }
  that.vessel(conType, function(html, titleHTML, moveElem) {
    body.append(html[0]);
    conType ? function() {
      config.type == 2 || config.type == 4 ? function() {
        $("body").append(html[1]);
      }() : function() {
        if (!content.parents("." + DOMS[0])[0]) {
          content.data("display", content.css("display")).show().addClass("layui-layer-wrap").wrap(html[1]);
          $("#" + DOMS[0] + times).find("." + DOMS[5]).before(titleHTML);
        }
      }();
    }() : body.append(html[1]);
    $("#" + DOMS_MOVE)[0] || body.append(READY.moveElem = moveElem);
    that.layero = $("#" + DOMS[0] + times);
    that.shadeo = $("#" + DOMS_SHADE + times);
    config.scrollbar || $html.css("overflow", "hidden").attr("layer-full", times);
  }).auto(times);
  that.shadeo.css({
    "background-color": config.shade[1] || "#000",
    opacity: config.shade[0] || config.shade
  });
  config.type == 2 && layer.ie == 6 && that.layero.find("iframe").attr("src", content[0]);
  config.type == 4 ? that.tips() : function() {
    that.offset();
    parseInt(READY.getStyle(document.getElementById(DOMS_MOVE), "z-index")) || function() {
      that.layero.css("visibility", "hidden");
      layer.ready(function() {
        that.offset();
        that.layero.css("visibility", "visible");
      });
    }();
  }();
  if (config.fixed) {
    $win.on("resize", function() {
      that.offset();
      (/^\d+%$/.test(config.area[0]) || /^\d+%$/.test(config.area[1])) && that.auto(times);
      config.type == 4 && that.tips();
    });
  }
  config.time <= 0 || setTimeout(function() {
    layer.close(that.index);
  }, config.time);
  that.move().callback();
  if (DOMS_ANIM[config.anim]) {
    var animClass = "layer-anim " + DOMS_ANIM[config.anim];
    that.layero.addClass(animClass).one("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend", function() {
      $(this).removeClass(animClass);
    });
  }
  if (config.isOutAnim) {
    that.layero.data("isOutAnim", true);
  }
};
ClassLayer.pt.auto = function(index2) {
  var that = this, config = that.config, layero = $("#" + DOMS[0] + index2);
  if (config.area[0] === "" && config.maxWidth > 0) {
    if (layer.ie && layer.ie < 8 && config.btn) {
      layero.width(layero.innerWidth());
    }
    layero.outerWidth() > config.maxWidth && layero.width(config.maxWidth);
  }
  var area = [layero.innerWidth(), layero.innerHeight()], titHeight = layero.find(DOMS[1]).outerHeight() || 0, btnHeight = layero.find("." + DOMS[6]).outerHeight() || 0, setHeight = function(elem) {
    elem = layero.find(elem);
    elem.height(area[1] - titHeight - btnHeight - 2 * (parseFloat(elem.css("padding-top")) | 0));
  };
  switch (config.type) {
    case 2: {
      setHeight("iframe");
      break;
    }
    default: {
      if (config.area[1] === "") {
        if (config.maxHeight > 0 && layero.outerHeight() > config.maxHeight) {
          area[1] = config.maxHeight;
          setHeight("." + DOMS[5]);
        } else if (config.fixed && area[1] >= $win.height()) {
          area[1] = $win.height();
          setHeight("." + DOMS[5]);
        }
      } else {
        setHeight("." + DOMS[5]);
      }
      break;
    }
  }
  return that;
};
ClassLayer.pt.offset = function() {
  var that = this, config = that.config, layero = that.layero;
  var area = [layero.outerWidth(), layero.outerHeight()];
  var type2 = typeof config.offset === "object";
  that.offsetTop = ($win.height() - area[1]) / 2;
  that.offsetLeft = ($win.width() - area[0]) / 2;
  if (type2) {
    that.offsetTop = config.offset[0];
    that.offsetLeft = config.offset[1] || that.offsetLeft;
  } else if (config.offset !== "auto") {
    if (config.offset === "t") {
      that.offsetTop = 0;
    } else if (config.offset === "r") {
      that.offsetLeft = $win.width() - area[0];
    } else if (config.offset === "b") {
      that.offsetTop = $win.height() - area[1];
    } else if (config.offset === "l") {
      that.offsetLeft = 0;
    } else if (config.offset === "lt") {
      that.offsetTop = 0;
      that.offsetLeft = 0;
    } else if (config.offset === "lb") {
      that.offsetTop = $win.height() - area[1];
      that.offsetLeft = 0;
    } else if (config.offset === "rt") {
      that.offsetTop = 0;
      that.offsetLeft = $win.width() - area[0];
    } else if (config.offset === "rb") {
      that.offsetTop = $win.height() - area[1];
      that.offsetLeft = $win.width() - area[0];
    } else {
      that.offsetTop = config.offset;
    }
  }
  if (!config.fixed) {
    that.offsetTop = /%$/.test(that.offsetTop) ? $win.height() * parseFloat(that.offsetTop) / 100 : parseFloat(that.offsetTop);
    that.offsetLeft = /%$/.test(that.offsetLeft) ? $win.width() * parseFloat(that.offsetLeft) / 100 : parseFloat(that.offsetLeft);
    that.offsetTop += $win.scrollTop();
    that.offsetLeft += $win.scrollLeft();
  }
  if (layero.attr("minLeft")) {
    that.offsetTop = $win.height() - (layero.find(DOMS[1]).outerHeight() || 0);
    that.offsetLeft = layero.css("left");
  }
  layero.css({
    top: that.offsetTop,
    left: that.offsetLeft
  });
};
ClassLayer.pt.tips = function() {
  var that = this, config = that.config, layero = that.layero;
  var layArea = [layero.outerWidth(), layero.outerHeight()], follow = $(config.follow);
  if (!follow[0])
    follow = $("body");
  var goal = {
    width: follow.outerWidth(),
    height: follow.outerHeight(),
    top: follow.offset().top,
    left: follow.offset().left
  }, tipsG = layero.find(".layui-layer-TipsG");
  var guide = config.tips[0];
  config.tips[1] || tipsG.remove();
  goal.autoLeft = function() {
    if (goal.left + layArea[0] - $win.width() > 0) {
      goal.tipLeft = goal.left + goal.width - layArea[0];
      tipsG.css({
        right: 12,
        left: "auto"
      });
    } else {
      goal.tipLeft = goal.left;
    }
  };
  goal.where = [function() {
    goal.autoLeft();
    goal.tipTop = goal.top - layArea[1] - 10;
    tipsG.removeClass("layui-layer-TipsB").addClass("layui-layer-TipsT").css("border-right-color", config.tips[1]);
  }, function() {
    goal.tipLeft = goal.left + goal.width + 10;
    goal.tipTop = goal.top;
    tipsG.removeClass("layui-layer-TipsL").addClass("layui-layer-TipsR").css("border-bottom-color", config.tips[1]);
  }, function() {
    goal.autoLeft();
    goal.tipTop = goal.top + goal.height + 10;
    tipsG.removeClass("layui-layer-TipsT").addClass("layui-layer-TipsB").css("border-right-color", config.tips[1]);
  }, function() {
    goal.tipLeft = goal.left - layArea[0] - 10;
    goal.tipTop = goal.top;
    tipsG.removeClass("layui-layer-TipsR").addClass("layui-layer-TipsL").css("border-bottom-color", config.tips[1]);
  }];
  goal.where[guide - 1]();
  if (guide === 1) {
    goal.top - ($win.scrollTop() + layArea[1] + 8 * 2) < 0 && goal.where[2]();
  } else if (guide === 2) {
    $win.width() - (goal.left + goal.width + layArea[0] + 8 * 2) > 0 || goal.where[3]();
  } else if (guide === 3) {
    goal.top - $win.scrollTop() + goal.height + layArea[1] + 8 * 2 - $win.height() > 0 && goal.where[0]();
  } else if (guide === 4) {
    layArea[0] + 8 * 2 - goal.left > 0 && goal.where[1]();
  }
  layero[0].dataset["layerTipsId"] = config.follow.substring(1);
  layero.find("." + DOMS[5]).css({
    "background-color": config.tips[1],
    "padding-right": config.closeBtn ? "30px" : ""
  });
  layero.css({
    left: goal.tipLeft - (config.fixed ? $win.scrollLeft() : 0),
    top: goal.tipTop - (config.fixed ? $win.scrollTop() : 0)
  });
};
ClassLayer.pt.move = function() {
  var that = this, config = that.config, _DOC = $(document), layero = that.layero, moveElem = layero.find(config.move), resizeElem = layero.find(".layui-layer-resize"), dict = {};
  if (config.move) {
    moveElem.css("cursor", "move");
  }
  moveElem.on("mousedown", function(e2) {
    e2.preventDefault();
    if (config.move) {
      dict.moveStart = true;
      dict.offset = [e2.clientX - parseFloat(layero.css("left")), e2.clientY - parseFloat(layero.css("top"))];
      READY.moveElem.css("cursor", "move").show();
    }
  });
  resizeElem.on("mousedown", function(e2) {
    e2.preventDefault();
    dict.resizeStart = true;
    dict.offset = [e2.clientX, e2.clientY];
    dict.area = [layero.outerWidth(), layero.outerHeight()];
    READY.moveElem.css("cursor", "se-resize").show();
  });
  _DOC.on("mousemove", function(e2) {
    if (dict.moveStart) {
      var X = e2.clientX - dict.offset[0], Y2 = e2.clientY - dict.offset[1], fixed = layero.css("position") === "fixed";
      e2.preventDefault();
      dict.stX = fixed ? 0 : $win.scrollLeft();
      dict.stY = fixed ? 0 : $win.scrollTop();
      if (!config.moveOut) {
        var setRig = $win.width() - layero.outerWidth() + dict.stX, setBot = $win.height() - layero.outerHeight() + dict.stY;
        X < dict.stX && (X = dict.stX);
        X > setRig && (X = setRig);
        Y2 < dict.stY && (Y2 = dict.stY);
        Y2 > setBot && (Y2 = setBot);
      }
      layero.css({
        left: X,
        top: Y2
      });
    }
    if (config.resize && dict.resizeStart) {
      var X = e2.clientX - dict.offset[0], Y2 = e2.clientY - dict.offset[1];
      e2.preventDefault();
      layer.style(that.index, {
        width: dict.area[0] + X,
        height: dict.area[1] + Y2
      });
      dict.isResize = true;
      config.resizing && config.resizing(layero);
    }
  }).on("mouseup", function(e2) {
    if (dict.moveStart) {
      delete dict.moveStart;
      READY.moveElem.hide();
      config.moveEnd && config.moveEnd(layero);
    }
    if (dict.resizeStart) {
      delete dict.resizeStart;
      READY.moveElem.hide();
    }
  });
  return that;
};
ClassLayer.pt.callback = function() {
  var that = this, layero = that.layero, config = that.config;
  that.openLayer();
  if (config.success) {
    if (config.type == 2) {
      layero.find("iframe").on("load", function() {
        config.success(layero, that.index);
      });
    } else {
      config.success(layero, that.index);
    }
  }
  layer.ie == 6 && that.IE6(layero);
  layero.find("." + DOMS[6]).children("a").on("click", function() {
    var index2 = $(this).index();
    if (index2 === 0) {
      if (config.yes) {
        config.yes(that.index, layero);
      } else if (config["btn1"]) {
        config["btn1"](that.index, layero);
      } else {
        layer.close(that.index);
      }
    } else {
      var close3 = config["btn" + (index2 + 1)] && config["btn" + (index2 + 1)](that.index, layero);
      close3 === false || layer.close(that.index);
    }
  });
  function cancel() {
    var close3 = config.cancel && config.cancel(that.index, layero);
    close3 === false || layer.close(that.index);
  }
  layero.find("." + DOMS[7]).on("click", cancel);
  if (config.shadeClose) {
    that.shadeo.on("click", function() {
      layer.close(that.index);
    });
  }
  layero.find(".layui-layer-min").on("click", function() {
    var min = config.min && config.min(layero, that.index);
    min === false || layer.min(that.index, config);
  });
  layero.find(".layui-layer-max").on("click", function() {
    if ($(this).hasClass("layui-layer-maxmin")) {
      layer.restore(that.index);
      config.restore && config.restore(layero, that.index);
    } else {
      layer.full(that.index, config);
      setTimeout(function() {
        config.full && config.full(layero, that.index);
      }, 100);
    }
  });
  config.end && (READY.end[that.index] = config.end);
};
READY.reselect = function() {
  $.each($("select"), function(index2, value) {
    var sthis = $(this);
    if (!sthis.parents("." + DOMS[0])[0]) {
      sthis.attr("layer") == 1 && $("." + DOMS[0]).length < 1 && sthis.removeAttr("layer").show();
    }
    sthis = null;
  });
};
ClassLayer.pt.IE6 = function(layero) {
  $("select").each(function(index2, value) {
    var sthis = $(this);
    if (!sthis.parents("." + DOMS[0])[0]) {
      sthis.css("display") === "none" || sthis.attr({
        layer: "1"
      }).hide();
    }
    sthis = null;
  });
};
ClassLayer.pt.openLayer = function() {
  var that = this;
  layer.zIndex = that.config.zIndex;
  layer.setTop = function(layero) {
    var setZindex = function() {
      layer.zIndex++;
      layero.css("z-index", layer.zIndex + 1);
    };
    layer.zIndex = parseInt(layero[0].style.zIndex);
    layero.on("mousedown", setZindex);
    return layer.zIndex;
  };
};
READY.record = function(layero) {
  var area = [layero.width(), layero.height(), layero.position().top, layero.position().left + parseFloat(layero.css("margin-left"))];
  layero.find(".layui-layer-max").addClass("layui-layer-maxmin");
  layero.attr({
    area
  });
};
READY.rescollbar = function(index2) {
  if ($html.attr("layer-full") == index2) {
    if ($html[0].style.removeProperty) {
      $html[0].style.removeProperty("overflow");
    } else {
      $html[0].style.removeAttribute("overflow");
    }
    $html.removeAttr("layer-full");
  }
};
layer.getChildFrame = function(selector, index2) {
  index2 = index2 || $("." + DOMS[4]).attr("times");
  return $("#" + DOMS[0] + index2).find("iframe").contents().find(selector);
};
layer.getFrameIndex = function(name) {
  return $("#" + name).parents("." + DOMS[4]).attr("times");
};
layer.iframeAuto = function(index2) {
  if (!index2)
    return;
  var heg = layer.getChildFrame("html", index2).outerHeight();
  var layero = $("#" + DOMS[0] + index2);
  var titHeight = layero.find(DOMS[1]).outerHeight() || 0;
  var btnHeight = layero.find("." + DOMS[6]).outerHeight() || 0;
  layero.css({
    height: heg + titHeight + btnHeight
  });
  layero.find("iframe").css({
    height: heg
  });
};
layer.iframeSrc = function(index2, url2) {
  $("#" + DOMS[0] + index2).find("iframe").attr("src", url2);
};
layer.style = function(index2, options, limit) {
  var $layero = $("#" + DOMS[0] + index2), contElem = $layero.find(".layui-layer-content"), type2 = $layero.attr("type"), titHeight = $layero.find(DOMS[1]).outerHeight() || 0, btnHeight = $layero.find("." + DOMS[6]).outerHeight() || 0;
  $layero.attr("minLeft");
  if (type2 === READY.type[3] || type2 === READY.type[4]) {
    return;
  }
  if (!limit) {
    if (parseFloat(options.width) <= 260) {
      options.width = 260;
    }
    if (parseFloat(options.height) - titHeight - btnHeight <= 64) {
      options.height = 64 + titHeight + btnHeight;
    }
  }
  $layero.css(options);
  btnHeight = $layero.find("." + DOMS[6]).outerHeight();
  if (type2 === READY.type[2]) {
    $layero.find("iframe").css({
      height: parseFloat(options.height) - titHeight - btnHeight
    });
  } else {
    contElem.css({
      height: parseFloat(options.height) - titHeight - btnHeight - parseFloat(contElem.css("padding-top")) - parseFloat(contElem.css("padding-bottom"))
    });
  }
};
layer.min = function(index2, options) {
  options = options || {};
  var layero = $("#" + DOMS[0] + index2), shadeo = $("#" + DOMS_SHADE + index2), titHeight = layero.find(DOMS[1]).outerHeight() || 0, left = layero.attr("minLeft") || 181 * READY.minIndex + "px", position = layero.css("position"), settings = {
    width: 180,
    height: titHeight,
    position: "fixed",
    overflow: "hidden"
  };
  READY.record(layero);
  if (READY.minLeft[0]) {
    left = READY.minLeft[0];
    READY.minLeft.shift();
  }
  if (options.minStack) {
    settings.left = left;
    settings.top = $win.height() - titHeight;
    layero.attr("minLeft") || READY.minIndex++;
    layero.attr("minLeft", left);
  }
  layero.attr("position", position);
  layer.style(index2, settings, true);
  layero.find(".layui-layer-min").hide();
  layero.attr("type") === "page" && layero.find(DOMS[4]).hide();
  READY.rescollbar(index2);
  shadeo.hide();
};
layer.restore = function(index2) {
  var layero = $("#" + DOMS[0] + index2), shadeo = $("#" + DOMS_SHADE + index2), area = layero.attr("area").split(",");
  layero.attr("type");
  layer.style(index2, {
    width: parseFloat(area[0]),
    height: parseFloat(area[1]),
    top: parseFloat(area[2]),
    left: parseFloat(area[3]),
    position: layero.attr("position"),
    overflow: "visible"
  }, true);
  layero.find(".layui-layer-max").removeClass("layui-layer-maxmin");
  layero.find(".layui-layer-min").show();
  layero.attr("type") === "page" && layero.find(DOMS[4]).show();
  READY.rescollbar(index2);
  shadeo.show();
};
layer.full = function(index2) {
  var layero = $("#" + DOMS[0] + index2), timer;
  READY.record(layero);
  if (!$html.attr("layer-full")) {
    $html.css("overflow", "hidden").attr("layer-full", index2);
  }
  clearTimeout(timer);
  timer = setTimeout(function() {
    var isfix = layero.css("position") === "fixed";
    layer.style(index2, {
      top: isfix ? 0 : $win.scrollTop(),
      left: isfix ? 0 : $win.scrollLeft(),
      width: $win.width(),
      height: $win.height()
    }, true);
    layero.find(".layui-layer-min").hide();
  }, 100);
};
layer.title = function(name, index2) {
  var title = $("#" + DOMS[0] + (index2 || layer.index)).find(DOMS[1]);
  title.html(name);
};
layer.close = function(index2, callback) {
  var layero = $("#" + DOMS[0] + index2), type2 = layero.attr("type"), closeAnim = "layer-anim-close";
  if (!layero[0])
    return;
  var WRAP = "layui-layer-wrap", remove = function() {
    if (type2 === READY.type[1] && layero.attr("conType") === "object") {
      layero.children(":not(." + DOMS[5] + ")").remove();
      var wrap = layero.find("." + WRAP);
      for (var i2 = 0; i2 < 2; i2++) {
        wrap.unwrap();
      }
      wrap.css("display", wrap.data("display")).removeClass(WRAP);
    } else {
      if (type2 === READY.type[2]) {
        try {
          var iframe = $("#" + DOMS[4] + index2)[0];
          iframe.contentWindow.document.write("");
          iframe.contentWindow.close();
          layero.find("." + DOMS[5])[0].removeChild(iframe);
        } catch (e2) {
        }
      }
      layero[0].innerHTML = "";
      layero.remove();
    }
    typeof READY.end[index2] === "function" && READY.end[index2]();
    delete READY.end[index2];
    typeof callback === "function" && callback();
  };
  if (layero.data("isOutAnim")) {
    layero.addClass("layer-anim " + closeAnim);
  }
  $("#layui-layer-moves, #" + DOMS_SHADE + index2).remove();
  layer.ie == 6 && READY.reselect();
  READY.rescollbar(index2);
  if (layero.attr("minLeft")) {
    READY.minIndex--;
    READY.minLeft.push(layero.attr("minLeft"));
  }
  if (layer.ie && layer.ie < 10 || !layero.data("isOutAnim")) {
    remove();
  } else {
    setTimeout(function() {
      remove();
    }, 200);
  }
};
layer.closeAll = function(type2, callback) {
  if (typeof type2 === "function") {
    callback = type2;
    type2 = null;
  }
  var domsElem = $("." + DOMS[0]);
  $.each(domsElem, function(_index) {
    var othis = $(this);
    var is = type2 ? othis.attr("type") === type2 : 1;
    is && layer.close(othis.attr("times"), _index === domsElem.length - 1 ? callback : null);
    is = null;
  });
  if (domsElem.length === 0)
    typeof callback === "function" && callback();
};
var cache = layer.cache || {}, skin = function(type2) {
  return cache.skin ? " " + cache.skin + " " + cache.skin + "-" + type2 : "";
};
layer.prompt = function(options = {}, yes) {
  var style = "";
  if (typeof options === "function") {
    yes = options;
  }
  if (options.area) {
    var area = options.area;
    style = `style="width: ${area[0]}; height: ${area[1]};"`;
    delete options.area;
  }
  var prompt;
  var content = options.formType == 2 ? `<textarea class="layui-layer-input" ${style}></textarea>` : `<input type="${options.formType === 1 ? "password" : "text"}" class="layui-layer-input">`;
  var success = options.success;
  delete options.success;
  return layer.open($.extend({
    type: 1,
    btn: ["&#x786E;&#x5B9A;", "&#x53D6;&#x6D88;"],
    content,
    skin: "layui-layer-prompt" + skin("prompt"),
    maxWidth: $win.width(),
    success(layero) {
      prompt = layero.find(".layui-layer-input");
      prompt.val(options.value || "").focus();
      typeof success === "function" && success(layero);
    },
    resize: false,
    yes(index2) {
      var value = prompt.val();
      if (value === "") {
        prompt.focus();
      } else if (value.length > (options.maxlength || 500)) {
        layer.tips("&#x6700;&#x591A;&#x8F93;&#x5165;" + (options.maxlength || 500) + "&#x4E2A;&#x5B57;&#x6570;", prompt, {
          tips: 1
        });
      } else {
        yes && yes(value, index2, prompt);
      }
    }
  }, options));
};
layer.tab = function(options) {
  options = options || {};
  var tab = options.tab || {}, THIS = "layui-this", success = options.success;
  delete options.success;
  return layer.open($.extend({
    type: 1,
    skin: "layui-layer-tab" + skin("tab"),
    resize: false,
    title: function() {
      var len = tab.length, ii = 1, str = "";
      if (len > 0) {
        str = '<span class="' + THIS + '">' + tab[0].title + "</span>";
        for (; ii < len; ii++) {
          str += "<span>" + tab[ii].title + "</span>";
        }
      }
      return str;
    }(),
    content: '<ul class="layui-layer-tabmain">' + function() {
      var len = tab.length, ii = 1, str = "";
      if (len > 0) {
        str = '<li class="layui-layer-tabli ' + THIS + '">' + (tab[0].content || "no content") + "</li>";
        for (; ii < len; ii++) {
          str += '<li class="layui-layer-tabli">' + (tab[ii].content || "no  content") + "</li>";
        }
      }
      return str;
    }() + "</ul>",
    success(layero) {
      var btn = layero.find(".layui-layer-title").children();
      var main2 = layero.find(".layui-layer-tabmain").children();
      btn.on("mousedown", function(e2) {
        e2.stopPropagation ? e2.stopPropagation() : e2.cancelBubble = true;
        var othis = $(this), index2 = othis.index();
        othis.addClass(THIS).siblings().removeClass(THIS);
        main2.eq(index2).show().siblings().hide();
        typeof options.change === "function" && options.change(index2);
      });
      typeof success === "function" && success(layero);
    }
  }, options));
};
layer.photos = function(options, loop, key2) {
  var dict = {};
  options = options || {};
  if (!options.photos)
    return;
  var isObject3 = !(typeof options.photos === "string" || options.photos instanceof $), photos = isObject3 ? options.photos : {}, data4 = photos.data || [], start = photos.start || 0;
  dict.imgIndex = (start | 0) + 1;
  options.img = options.img || "img";
  var success = options.success;
  delete options.success;
  if (!isObject3) {
    var parent = $(options.photos), pushData = function() {
      data4 = [];
      parent.find(options.img).each(function(index2) {
        var othis = $(this);
        othis.attr("layer-index", index2);
        data4.push({
          alt: othis.attr("alt"),
          pid: othis.attr("layer-pid"),
          src: othis.attr("layer-src") || othis.attr("src"),
          thumb: othis.attr("src")
        });
      });
    };
    pushData();
    if (data4.length === 0)
      return;
    loop || parent.on("click", options.img, function() {
      pushData();
      var othis = $(this), index2 = othis.attr("layer-index");
      layer.photos($.extend(options, {
        photos: {
          start: index2,
          data: data4,
          tab: options.tab
        },
        full: options.full
      }), true);
    });
    if (!loop)
      return;
  } else if (data4.length === 0) {
    return layer.msg("&#x6CA1;&#x6709;&#x56FE;&#x7247;");
  }
  dict.imgprev = function(key22) {
    dict.imgIndex--;
    if (dict.imgIndex < 1) {
      dict.imgIndex = data4.length;
    }
    dict.tabimg(key22);
  };
  dict.imgnext = function(key22, errorMsg) {
    dict.imgIndex++;
    if (dict.imgIndex > data4.length) {
      dict.imgIndex = 1;
      if (errorMsg) {
        return;
      }
    }
    dict.tabimg(key22);
  };
  dict.keyup = function(event) {
    if (!dict.end) {
      var code = event.keyCode;
      event.preventDefault();
      if (code === KEY.left) {
        dict.imgprev(true);
      } else if (code === KEY.right) {
        dict.imgnext(true);
      } else if (code === KEY.esc) {
        layer.close(dict.index);
      }
    }
  };
  dict.tabimg = function(key22) {
    if (data4.length <= 1)
      return;
    photos.start = dict.imgIndex - 1;
    layer.close(dict.index);
    return layer.photos(options, true, key22);
  };
  dict.event = function() {
    dict.bigimg.find(".layui-layer-imgprev").on("click", function(event) {
      event.preventDefault();
      dict.imgprev(true);
    });
    dict.bigimg.find(".layui-layer-imgnext").on("click", function(event) {
      event.preventDefault();
      dict.imgnext(true);
    });
    $(document).on("keyup", dict.keyup);
  };
  function loadImage(url2, callback, error) {
    var img = new Image();
    img.src = url2;
    if (img.complete) {
      return callback(img);
    }
    img.onload = function() {
      img.onload = null;
      callback(img);
    };
    img.onerror = function(e2) {
      img.onerror = null;
      error(e2);
    };
  }
  dict.loadi = layer.load(1, {
    shade: "shade" in options ? false : 0.9,
    scrollbar: false
  });
  loadImage(data4[start].src, function(img) {
    layer.close(dict.loadi);
    if (key2)
      options.anim = -1;
    dict.index = layer.open($.extend({
      type: 1,
      id: "layui-layer-photos",
      area: function() {
        var imgarea = [img.width, img.height];
        var winarea = [$(window).width() - 100, $(window).height() - 100];
        if (!options.full && (imgarea[0] > winarea[0] || imgarea[1] > winarea[1])) {
          var wh = [imgarea[0] / winarea[0], imgarea[1] / winarea[1]];
          if (wh[0] > wh[1]) {
            imgarea[0] = imgarea[0] / wh[0];
            imgarea[1] = imgarea[1] / wh[0];
          } else if (wh[0] < wh[1]) {
            imgarea[0] = imgarea[0] / wh[1];
            imgarea[1] = imgarea[1] / wh[1];
          }
        }
        return [imgarea[0] + "px", imgarea[1] + "px"];
      }(),
      title: false,
      shade: 0.9,
      shadeClose: true,
      closeBtn: false,
      move: ".layui-layer-phimg img",
      moveType: 1,
      scrollbar: false,
      moveOut: true,
      anim: 5,
      isOutAnim: false,
      skin: "layui-layer-photos" + skin("photos"),
      content: '<div class="layui-layer-phimg"><img src="' + data4[start].src + '" alt="' + (data4[start].alt || "") + '" layer-pid="' + data4[start].pid + '">' + function() {
        if (data4.length > 1) {
          return '<div class="layui-layer-imgsee"><span class="layui-layer-imguide"><a href="javascript:;" class="layui-layer-iconext layui-layer-imgprev"></a><a href="javascript:;" class="layui-layer-iconext layui-layer-imgnext"></a></span><div class="layui-layer-imgbar" style="display:' + (key2 ? "block" : "") + '"><span class="layui-layer-imgtit"><a href="javascript:;">' + (data4[start].alt || "") + "</a><em>" + dict.imgIndex + " / " + data4.length + "</em></span></div></div>";
        }
        return "";
      }() + "</div>",
      success: function(layero, index2) {
        dict.bigimg = layero.find(".layui-layer-phimg");
        dict.imgsee = layero.find(".layui-layer-imgbar");
        dict.event(layero);
        options.tab && options.tab(data4[start], layero);
        typeof success === "function" && success(layero);
      },
      end: function() {
        dict.end = true;
        $(document).off("keyup", dict.keyup);
      }
    }, options));
  }, function() {
    layer.close(dict.loadi);
    layer.msg("&#x5F53;&#x524D;&#x56FE;&#x7247;&#x5730;&#x5740;&#x5F02;&#x5E38;<br>&#x662F;&#x5426;&#x7EE7;&#x7EED;&#x67E5;&#x770B;&#x4E0B;&#x4E00;&#x5F20;&#xFF1F;", {
      time: 3e4,
      btn: ["&#x4E0B;&#x4E00;&#x5F20;", "&#x4E0D;&#x770B;&#x4E86;"],
      yes: function() {
        data4.length > 1 && dict.imgnext(true, true);
      }
    });
  });
};
layer.open = (deliver) => new ClassLayer(deliver).index;
var dayjs_min = { exports: {} };
(function(module2, exports2) {
  !function(t2, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", $2 = "Invalid Date", l2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = {
      name: "en",
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
    }, m2 = function(t3, e3, n3) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
    }, g2 = {
      s: m2,
      z: function(t3) {
        var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
      },
      m: function t3(e3, n3) {
        if (e3.date() < n3.date())
          return -t3(n3, e3);
        var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, f2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), f2);
        return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
      },
      a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      },
      p: function(t3) {
        return {
          M: f2,
          y: c2,
          w: o2,
          d: a2,
          D: d2,
          h: u2,
          m: s2,
          s: i2,
          ms: r2,
          Q: h2
        }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      },
      u: function(t3) {
        return t3 === void 0;
      }
    }, v2 = "en", D2 = {};
    D2[v2] = M2;
    var p2 = function(t3) {
      return t3 instanceof _2;
    }, S2 = function t3(e3, n3, r3) {
      var i3;
      if (!e3)
        return v2;
      if (typeof e3 == "string") {
        var s3 = e3.toLowerCase();
        D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
        var u3 = e3.split("-");
        if (!i3 && u3.length > 1)
          return t3(u3[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i3 = a3;
      }
      return !r3 && i3 && (v2 = i3), i3 || !r3 && v2;
    }, w2 = function(t3, e3) {
      if (p2(t3))
        return t3.clone();
      var n3 = typeof e3 == "object" ? e3 : {};
      return n3.date = t3, n3.args = arguments, new _2(n3);
    }, O2 = g2;
    O2.l = S2, O2.i = p2, O2.w = function(t3, e3) {
      return w2(t3, {
        locale: e3.$L,
        utc: e3.$u,
        x: e3.$x,
        $offset: e3.$offset
      });
    };
    var _2 = function() {
      function M3(t3) {
        this.$L = S2(t3.locale, null, true), this.parse(t3);
      }
      var m3 = M3.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n3 = t4.utc;
          if (e3 === null)
            return new Date(NaN);
          if (O2.u(e3))
            return new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if (typeof e3 == "string" && !/Z$/i.test(e3)) {
            var r3 = e3.match(l2);
            if (r3) {
              var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t3), this.$x = t3.x || {}, this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return O2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === $2);
      }, m3.isSame = function(t3, e3) {
        var n3 = w2(t3);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m3.isAfter = function(t3, e3) {
        return w2(t3) < this.startOf(e3);
      }, m3.isBefore = function(t3, e3) {
        return this.endOf(e3) < w2(t3);
      }, m3.$g = function(t3, e3, n3) {
        return O2.u(t3) ? this[e3] : this.set(n3, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e3) {
        var n3 = this, r3 = !!O2.u(e3) || e3, h3 = O2.p(t3), $3 = function(t4, e4) {
          var i3 = O2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
          return r3 ? i3 : i3.endOf(a2);
        }, l3 = function(t4, e4) {
          return O2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M4 = this.$M, m4 = this.$D, g3 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c2:
            return r3 ? $3(1, 0) : $3(31, 11);
          case f2:
            return r3 ? $3(1, M4) : $3(0, M4 + 1);
          case o2:
            var v3 = this.$locale().weekStart || 0, D3 = (y3 < v3 ? y3 + 7 : y3) - v3;
            return $3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
          case a2:
          case d2:
            return l3(g3 + "Hours", 0);
          case u2:
            return l3(g3 + "Minutes", 1);
          case s2:
            return l3(g3 + "Seconds", 2);
          case i2:
            return l3(g3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e3) {
        var n3, o3 = O2.p(t3), h3 = "set" + (this.$u ? "UTC" : ""), $3 = (n3 = {}, n3[a2] = h3 + "Date", n3[d2] = h3 + "Date", n3[f2] = h3 + "Month", n3[c2] = h3 + "FullYear", n3[u2] = h3 + "Hours", n3[s2] = h3 + "Minutes", n3[i2] = h3 + "Seconds", n3[r2] = h3 + "Milliseconds", n3)[o3], l3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === f2 || o3 === c2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[$3](l3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          $3 && this.$d[$3](l3);
        return this.init(), this;
      }, m3.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m3.get = function(t3) {
        return this[O2.p(t3)]();
      }, m3.add = function(r3, h3) {
        var d3, $3 = this;
        r3 = Number(r3);
        var l3 = O2.p(h3), y3 = function(t3) {
          var e3 = w2($3);
          return O2.w(e3.date(e3.date() + Math.round(t3 * r3)), $3);
        };
        if (l3 === f2)
          return this.set(f2, this.$M + r3);
        if (l3 === c2)
          return this.set(c2, this.$y + r3);
        if (l3 === a2)
          return y3(1);
        if (l3 === o2)
          return y3(7);
        var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i2] = t2, d3)[l3] || 1, m4 = this.$d.getTime() + r3 * M4;
        return O2.w(m4, this);
      }, m3.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m3.format = function(t3) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || $2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, f3 = n3.months, h3 = function(t4, n4, i4, s4) {
          return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
        }, c3 = function(t4) {
          return O2.s(s3 % 12 || 12, t4, "0");
        }, d3 = n3.meridiem || function(t4, e4, n4) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        }, l3 = {
          YY: String(this.$y).slice(-2),
          YYYY: this.$y,
          M: a3 + 1,
          MM: O2.s(a3 + 1, 2, "0"),
          MMM: h3(n3.monthsShort, a3, f3, 3),
          MMMM: h3(f3, a3),
          D: this.$D,
          DD: O2.s(this.$D, 2, "0"),
          d: String(this.$W),
          dd: h3(n3.weekdaysMin, this.$W, o3, 2),
          ddd: h3(n3.weekdaysShort, this.$W, o3, 3),
          dddd: o3[this.$W],
          H: String(s3),
          HH: O2.s(s3, 2, "0"),
          h: c3(1),
          hh: c3(2),
          a: d3(s3, u3, true),
          A: d3(s3, u3, false),
          m: String(u3),
          mm: O2.s(u3, 2, "0"),
          s: String(this.$s),
          ss: O2.s(this.$s, 2, "0"),
          SSS: O2.s(this.$ms, 3, "0"),
          Z: i3
        };
        return r3.replace(y2, function(t4, e4) {
          return e4 || l3[t4] || i3.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d3, $3) {
        var l3, y3 = O2.p(d3), M4 = w2(r3), m4 = (M4.utcOffset() - this.utcOffset()) * e2, g3 = this - M4, v3 = O2.m(this, M4);
        return v3 = (l3 = {}, l3[c2] = v3 / 12, l3[f2] = v3, l3[h2] = v3 / 3, l3[o2] = (g3 - m4) / 6048e5, l3[a2] = (g3 - m4) / 864e5, l3[u2] = g3 / n2, l3[s2] = g3 / e2, l3[i2] = g3 / t2, l3)[y3] || g3, $3 ? v3 : O2.a(v3);
      }, m3.daysInMonth = function() {
        return this.endOf(f2).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n3 = this.clone(), r3 = S2(t3, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m3.clone = function() {
        return O2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), T2 = _2.prototype;
    return w2.prototype = T2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t3) {
      T2[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), w2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _2, w2), t3.$i = true), w2;
    }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t3) {
      return w2(1e3 * t3);
    }, w2.en = D2[v2], w2.Ls = D2, w2.p = {}, w2;
  });
})(dayjs_min);
var dayjs = dayjs_min.exports;
_.WORDS = {
  INVALID_DATE: "Invalid Date",
  format_ymd: "YYYY-MM-DD"
};
_.doNothing = (...args) => {
  if (localStorage.isShowDevLog) {
    const e2 = new Error();
    console.log("\u{1F680}:", e2.stack.split("\n")[2].replace("    at ", ""));
    console.log.apply(console, args);
  }
};
_.sleep = (t2) => new Promise((r2) => setTimeout(r2, t2));
const onRE = /^on[^a-z]/;
_.isOn = (key2) => onRE.test(key2);
_.isModelListener = (key2) => key2.startsWith("onUpdate:");
_.isListener = (key2) => _.isOn(key2) || _.isModelListener(key2);
_.isArrayFill = (arr) => _.isArray(arr) && arr.length > 0;
_.isObjectFill = (obj) => _.isPlainObject(obj) && Object.keys(obj).length > 0;
_.safeFirst = (arr, fnCheck) => {
  fnCheck = fnCheck || ((value) => _.isInput(value));
  const obj = _.first(arr);
  return fnCheck(obj) ? obj : false;
};
_.safeToString = (val, isBeautiful) => {
  if (typeof val === "object") {
    if (isBeautiful) {
      return JSON.stringify(val, null, 2);
    } else {
      return JSON.stringify(val);
    }
  } else {
    return String(val);
  }
};
_.safeParse = (val, defaultObj = {}) => {
  let obj = defaultObj;
  try {
    obj = JSON.parse(val);
    if (!val) {
      obj = defaultObj;
      throw new Error("json parse error");
    }
  } catch (error) {
    _.doNothing(error);
  }
  return obj;
};
_.safeSplit = function(target, sp) {
  return (target == null ? void 0 : target.split) ? target.split(sp) : [];
};
_.safeDate = function(val) {
  if (!val) {
    return "";
  }
  let date = dayjs(val);
  if (date === _.WORDS.INVALID_DATE) {
    return "";
  } else {
    return date;
  }
};
_.isInput = (val) => {
  if (val)
    return true;
  if (val === 0)
    return true;
  if (val === false)
    return true;
  return false;
};
_.is$Selected = ($ele) => $ele && $ele.length > 0;
_.getObjectFirstKeyValue = (obj, defaultValue = "") => {
  if (!obj)
    return defaultValue;
  const keyArray = Object.keys(obj);
  if (!_.isArrayFill(keyArray))
    return defaultValue;
  return _.isInput(keyArray[0]) ? obj[keyArray[0]] : defaultValue;
};
_.asyncLoadJS = async (url2, globalName) => {
  if (window[globalName]) {
    return window[globalName];
  }
  const $style = $("<style/>").attr("id", `${asyncLoadJS}${globalName}`);
  $style.appendTo($("body")).on("load", function() {
    return window[globalName];
  });
  $style.attr("src", url2);
};
_.ensureValueDone = async (fnGetValue) => {
  return new Promise(async (resolve) => {
    let exeFnGetValue = async function() {
      const value = await fnGetValue();
      if (value) {
        exeFnGetValue = null;
        resolve();
      } else {
        setTimeout(exeFnGetValue, 1e3 * exeFnGetValue.count++);
      }
    };
    exeFnGetValue.count = 1;
    exeFnGetValue();
  });
};
function genId(category) {
  if (genId.idCount > genId.ID_COUNT_MAX) {
    genId.idCount = 1;
    genId.DATE_NOW = Date.now();
  }
  return `${category}_${genId.DATE_NOW}_${genId.idCount++}`;
}
genId.idCount = 1;
genId.ID_COUNT_MAX = 4e4;
genId.DATE_NOW = Date.now();
_.genId = genId;
_.genProp = (someString) => {
  return `k${_.camelCase(someString)}`;
};
_.preload = (baseModule, deps) => {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  return Promise.all(deps.map((dep) => {
    dep = `${base}${dep}`;
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", rej);
      });
    }
  })).then(() => baseModule());
};
const parseContent = (returnSentence) => {
  if (!returnSentence)
    return;
  return new Function(`
	${returnSentence}
	return module();
	`);
};
_.asyncLoadText = function(url2) {
  _.asyncLoadText.cache = _.asyncLoadText.cache || {};
  return new Promise((resolve, reject) => $.ajax({
    type: "GET",
    async: true,
    url: url2,
    dataType: "text",
    success: resolve,
    error: reject
  }));
};
async function asyncExecFnString(url2) {
  let data4 = "";
  try {
    data4 = await _.asyncLoadText(url2);
  } catch (error) {
  }
  return parseContent(data4);
}
_.asyncExecFnString = asyncExecFnString;
const VueComponents = {};
async function asyncImportSFC(url) {
  if (VueComponents[url]) {
    return VueComponents[url];
  }
  const scfSourceCode = await _.asyncLoadText(url);
  const scfObjSourceCode = VueLoader(scfSourceCode);
  let scfObjAsyncFn = (...args) => {
    console.log(args);
  };
  try {
    scfObjAsyncFn = eval(scfObjSourceCode);
  } catch (e2) {
    console.error(e2);
  }
  const scfObj = await scfObjAsyncFn(window.Vue, {
    url
  });
  return scfObj;
}
_.asyncImportSFC = asyncImportSFC;
function VueLoader(code) {
  function getSource(source, type2) {
    var regex = new RegExp("<" + type2 + "[^>]*>");
    var openingTag = source.match(regex);
    if (!openingTag)
      return "";
    else
      openingTag = openingTag[0];
    var targetSource = source.slice(source.indexOf(openingTag) + openingTag.length, source.lastIndexOf("</" + type2 + ">"));
    return type2 === "template" ? targetSource.replace(/`/g, "\\`") : targetSource;
  }
  function splitCode() {
    if (!/TEMPLATE_PLACEHOLDER/.test(code)) {
      alert("SFC miss TEMPLATE_PLACEHOLDER");
      console.error(code);
    }
    return getSource(code, "script").replace(/TEMPLATE_PLACEHOLDER/, `template: \`${getSource(code, "template")}\``);
  }
  return splitCode();
}
_.loadCss = function(cssname) {
  const cssPath = `${cssname}`;
  let $link = $("<link/>", {
    rel: "stylesheet",
    type: "text/css"
  });
  $link.appendTo($("head"));
  $link[0].href = `${cssPath}?_t=${Date.now()}`;
  return () => {
    $link.remove();
    $link = null;
  };
};
const _global__ = _;
const timeoutDelay = 400;
const popverOptionsCollection = {};
const popverIndexCollection = {};
const appAddPlugin = {};
const appDependState = {};
const timerCollection = {};
const visibleArea = {};
function installPopoverDirective(app, appSettings) {
  const appId = _global__.genId("appId");
  appAddPlugin[appId] = appSettings.appPlugins;
  appDependState[appId] = appSettings.dependState;
  app.directive("uiPopover", {
    mounted(el, binding) {
      const followId = _global__.genId("xPopoverTarget");
      $(el).addClass("x-ui-popover").attr("id", followId);
      el.dataset["followId"] = followId;
      el.dataset["appId"] = appId;
      if (binding.value) {
        popverOptionsCollection[followId] = binding.value;
      }
    },
    unmounted(el) {
      const followId = el.dataset["followId"];
      layer.close(popverIndexCollection[followId]);
      delete popverOptionsCollection[followId];
      delete popverIndexCollection[followId];
    }
  });
}
$(document).on("click.uiPopver", "[data-follow-id]", function(event) {
  const followId = this.dataset["followId"];
  this.dataset["appId"];
  const popverOptions = popverOptionsCollection[followId];
  new Popover(this, popverOptions);
});
function inVisibleArea(followId) {
  if (timerCollection[followId]) {
    clearTimeout(timerCollection[followId]);
    delete timerCollection[followId];
  }
  visibleArea[followId] = true;
}
function closeTips(followId) {
  delete visibleArea[followId];
  timerCollection[followId] = setTimeout(() => {
    layer.close(popverIndexCollection[followId]);
    delete popverIndexCollection[followId];
  }, timeoutDelay);
}
$(document).on("mouseenter.uiPopver", "[data-follow-id]", function(event) {
  console.log("hover.uiPopver,this", this.dataset);
  const followId = this.dataset.followId;
  const appId = this.dataset["appId"];
  inVisibleArea(followId);
  if (popverIndexCollection[followId]) {
    return;
  }
  const options = popverOptionsCollection[followId] || {
    content: ""
  };
  if (!options.content) {
    return;
  }
  let app;
  const tipsContent = _global__.isPlainObject(options.content) ? `<div id="${followId}_content">.</div>` : options.content;
  const popoverIndex = layer.tips(tipsContent, `#${followId}`, {
    tips: [layer.UP, "#0FA6D8"],
    time: 1e3 * 60 * 10,
    success(indexPanel, layerIndex) {
      try {
        app = Vue.createApp(options.content);
        app.use(appAddPlugin[appId], {
          dependState: appDependState[appId]
        });
        app.mount(`#${followId}_content`);
      } catch (e2) {
        console.error(e2);
      }
      options.afterOpenDialoag && options.afterOpenDialoag(app);
    },
    end() {
      if (app) {
        app.unmount();
        app = null;
      }
    }
  });
  popverIndexCollection[followId] = popoverIndex;
});
$(document).on("mouseleave.uiPopver", "[data-follow-id]", function(event) {
  closeTips(this.dataset.followId);
});
$(document).on("mouseenter.uiPopverTips", "[data-layer-tips-id]", function(event) {
  inVisibleArea(this.dataset.layerTipsId);
});
$(document).on("mouseleave.uiPopverTips", "[data-layer-tips-id]", function(event) {
  closeTips(this.dataset.layerTipsId);
});
var xRender = Vue.defineComponent(Vue.markRaw({
  name: "xRender",
  props: {
    render: {
      type: Function,
      required: true
    }
  },
  render() {
    return Vue.h(this.render, {
      vm: this,
      props: this.$props,
      attrs: this.$attrs
    });
  }
}));
var index$4 = "";
function supportBigInt() {
  return typeof BigInt === "function";
}
function trimNumber(numStr) {
  var str = numStr.trim();
  var negative = str.startsWith("-");
  if (negative) {
    str = str.slice(1);
  }
  str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
  if (str.startsWith(".")) {
    str = "0".concat(str);
  }
  var trimStr = str || "0";
  var splitNumber = trimStr.split(".");
  var integerStr = splitNumber[0] || "0";
  var decimalStr = splitNumber[1] || "0";
  if (integerStr === "0" && decimalStr === "0") {
    negative = false;
  }
  var negativeStr = negative ? "-" : "";
  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: "".concat(negativeStr).concat(trimStr)
  };
}
function isE(number) {
  var str = String(number);
  return !Number.isNaN(Number(str)) && str.includes("e");
}
function getNumberPrecision(number) {
  var numStr = String(number);
  if (isE(number)) {
    var precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
    var decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch === null || decimalMatch === void 0 ? void 0 : decimalMatch[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }
  return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
}
function num2str(number) {
  var numStr = String(number);
  if (isE(number)) {
    if (number > Number.MAX_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number).toString() : Number.MAX_SAFE_INTEGER);
    }
    if (number < Number.MIN_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number).toString() : Number.MIN_SAFE_INTEGER);
    }
    numStr = number.toFixed(getNumberPrecision(numStr));
  }
  return trimNumber(numStr).fullStr;
}
function validateNumber(num) {
  if (typeof num === "number") {
    return !Number.isNaN(num);
  }
  if (!num) {
    return false;
  }
  return /^\s*-?\d+(\.\d+)?\s*$/.test(num) || /^\s*-?\d+\.\s*$/.test(num) || /^\s*-?\.\d+\s*$/.test(num);
}
var NumberDecimal = /* @__PURE__ */ function() {
  function NumberDecimal2(value) {
    _classCallCheck(this, NumberDecimal2);
    this.origin = "";
    if (!value && value !== 0 || !String(value).trim()) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    this.number = Number(value);
  }
  _createClass(NumberDecimal2, [{
    key: "negate",
    value: function negate() {
      return new NumberDecimal2(-this.toNumber());
    }
  }, {
    key: "add",
    value: function add(value) {
      if (this.isInvalidate()) {
        return new NumberDecimal2(value);
      }
      var target = Number(value);
      if (Number.isNaN(target)) {
        return this;
      }
      var number = this.number + target;
      if (number > Number.MAX_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
      }
      if (number < Number.MIN_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
      }
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal2(number.toFixed(maxPrecision));
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN2() {
      return Number.isNaN(this.number);
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber2() {
      return this.number;
    }
  }, {
    key: "toString",
    value: function toString3() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return num2str(this.number);
    }
  }]);
  return NumberDecimal2;
}();
var BigIntDecimal = /* @__PURE__ */ function() {
  function BigIntDecimal2(value) {
    _classCallCheck(this, BigIntDecimal2);
    this.origin = "";
    if (!value && value !== 0 || !String(value).trim()) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    if (value === "-") {
      this.nan = true;
      return;
    }
    var mergedValue = value;
    if (isE(mergedValue)) {
      mergedValue = Number(mergedValue);
    }
    mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
    if (validateNumber(mergedValue)) {
      var trimRet = trimNumber(mergedValue);
      this.negative = trimRet.negative;
      var numbers = trimRet.trimStr.split(".");
      this.integer = BigInt(numbers[0]);
      var decimalStr = numbers[1] || "0";
      this.decimal = BigInt(decimalStr);
      this.decimalLen = decimalStr.length;
    } else {
      this.nan = true;
    }
  }
  _createClass(BigIntDecimal2, [{
    key: "getMark",
    value: function getMark2() {
      return this.negative ? "-" : "";
    }
  }, {
    key: "getIntegerStr",
    value: function getIntegerStr() {
      return this.integer.toString();
    }
  }, {
    key: "getDecimalStr",
    value: function getDecimalStr() {
      return this.decimal.toString().padStart(this.decimalLen, "0");
    }
  }, {
    key: "alignDecimal",
    value: function alignDecimal(decimalLength) {
      var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
      return BigInt(str);
    }
  }, {
    key: "negate",
    value: function negate() {
      var clone2 = new BigIntDecimal2(this.toString());
      clone2.negative = !clone2.negative;
      return clone2;
    }
  }, {
    key: "add",
    value: function add(value) {
      if (this.isInvalidate()) {
        return new BigIntDecimal2(value);
      }
      var offset3 = new BigIntDecimal2(value);
      if (offset3.isInvalidate()) {
        return this;
      }
      var maxDecimalLength = Math.max(this.getDecimalStr().length, offset3.getDecimalStr().length);
      var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
      var offsetAlignedDecimal = offset3.alignDecimal(maxDecimalLength);
      var valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();
      var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
      var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(maxDecimalLength + 1, "0"));
      return new BigIntDecimal2("".concat(hydrateValueStr.slice(0, -maxDecimalLength), ".").concat(hydrateValueStr.slice(-maxDecimalLength)));
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN2() {
      return this.nan;
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber2() {
      if (this.isNaN()) {
        return NaN;
      }
      return Number(this.toString());
    }
  }, {
    key: "toString",
    value: function toString3() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
    }
  }]);
  return BigIntDecimal2;
}();
function getMiniDecimal(value) {
  if (supportBigInt()) {
    return new BigIntDecimal(value);
  }
  return new NumberDecimal(value);
}
function toFixed(numStr, separatorStr, precision) {
  if (numStr === "") {
    return "";
  }
  var _trimNumber4 = trimNumber(numStr), negativeStr = _trimNumber4.negativeStr, integerStr = _trimNumber4.integerStr, decimalStr = _trimNumber4.decimalStr;
  var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
  var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
  if (precision >= 0) {
    var advancedNum = Number(decimalStr[precision]);
    if (advancedNum >= 5) {
      var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum));
      return toFixed(advancedDecimal.toString(), separatorStr, precision);
    }
    if (precision === 0) {
      return numberWithoutDecimal;
    }
    return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
  }
  if (precisionDecimalStr === ".0") {
    return numberWithoutDecimal;
  }
  return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
}
var STEP_INTERVAL = 200;
var STEP_DELAY = 600;
var StepHandler = Vue.defineComponent({
  name: "StepHandler",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    upDisabled: Boolean,
    downDisabled: Boolean,
    onStep: {
      type: Function
    }
  },
  slots: ["upNode", "downNode"],
  setup: function setup145(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit;
    var stepTimeoutRef = Vue.ref();
    var onStepMouseDown = function onStepMouseDown2(e2, up) {
      e2.preventDefault();
      emit("step", up);
      function loopStep() {
        emit("step", up);
        stepTimeoutRef.value = setTimeout(loopStep, STEP_INTERVAL);
      }
      stepTimeoutRef.value = setTimeout(loopStep, STEP_DELAY);
    };
    var onStopStep = function onStopStep2() {
      clearTimeout(stepTimeoutRef.value);
    };
    Vue.onBeforeUnmount(function() {
      onStopStep();
    });
    return function() {
      if (isMobile$2()) {
        return null;
      }
      var prefixCls = props2.prefixCls, upDisabled = props2.upDisabled, downDisabled = props2.downDisabled;
      var handlerClassName = "".concat(prefixCls, "-handler");
      var upClassName = classNames(handlerClassName, "".concat(handlerClassName, "-up"), _defineProperty$T({}, "".concat(handlerClassName, "-up-disabled"), upDisabled));
      var downClassName = classNames(handlerClassName, "".concat(handlerClassName, "-down"), _defineProperty$T({}, "".concat(handlerClassName, "-down-disabled"), downDisabled));
      var sharedHandlerProps = {
        unselectable: "on",
        role: "button",
        onMouseup: onStopStep,
        onMouseleave: onStopStep
      };
      var upNode = slots.upNode, downNode = slots.downNode;
      return Vue.createVNode("div", {
        "class": "".concat(handlerClassName, "-wrap")
      }, [Vue.createVNode("span", _objectSpread2$1(_objectSpread2$1({}, sharedHandlerProps), {}, {
        "onMousedown": function onMousedown2(e2) {
          onStepMouseDown(e2, true);
        },
        "aria-label": "Increase Value",
        "aria-disabled": upDisabled,
        "class": upClassName
      }), [(upNode === null || upNode === void 0 ? void 0 : upNode()) || Vue.createVNode("span", {
        "unselectable": "on",
        "class": "".concat(prefixCls, "-handler-up-inner")
      }, null)]), Vue.createVNode("span", _objectSpread2$1(_objectSpread2$1({}, sharedHandlerProps), {}, {
        "onMousedown": function onMousedown2(e2) {
          onStepMouseDown(e2, false);
        },
        "aria-label": "Decrease Value",
        "aria-disabled": downDisabled,
        "class": downClassName
      }), [(downNode === null || downNode === void 0 ? void 0 : downNode()) || Vue.createVNode("span", {
        "unselectable": "on",
        "class": "".concat(prefixCls, "-handler-down-inner")
      }, null)])]);
    };
  }
});
function useCursor(inputRef, focused) {
  var selectionRef = Vue.ref(null);
  function recordCursor() {
    try {
      var _inputRef$value = inputRef.value, start = _inputRef$value.selectionStart, end = _inputRef$value.selectionEnd, value = _inputRef$value.value;
      var beforeTxt = value.substring(0, start);
      var afterTxt = value.substring(end);
      selectionRef.value = {
        start,
        end,
        value,
        beforeTxt,
        afterTxt
      };
    } catch (e2) {
    }
  }
  function restoreCursor() {
    if (inputRef.value && selectionRef.value && focused.value) {
      try {
        var value = inputRef.value.value;
        var _selectionRef$value = selectionRef.value, beforeTxt = _selectionRef$value.beforeTxt, afterTxt = _selectionRef$value.afterTxt, start = _selectionRef$value.start;
        var startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - selectionRef.value.afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          var beforeLastChar = beforeTxt[start - 1];
          var newIndex = value.indexOf(beforeLastChar, start - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        inputRef.value.setSelectionRange(startPos, startPos);
      } catch (e2) {
        warning$1(false, "Something warning of cursor restore. Please fire issue about this: ".concat(e2.message));
      }
    }
  }
  return [recordCursor, restoreCursor];
}
var useFrame = function() {
  var idRef = Vue.ref(0);
  var cleanUp = function cleanUp2() {
    wrapperRaf.cancel(idRef.value);
  };
  Vue.onBeforeUnmount(function() {
    cleanUp();
  });
  return function(callback) {
    cleanUp();
    idRef.value = wrapperRaf(function() {
      callback();
    });
  };
};
var __rest$3 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var getDecimalValue = function getDecimalValue2(stringMode, decimalValue) {
  if (stringMode || decimalValue.isEmpty()) {
    return decimalValue.toString();
  }
  return decimalValue.toNumber();
};
var getDecimalIfValidate = function getDecimalIfValidate2(value) {
  var decimal = getMiniDecimal(value);
  return decimal.isInvalidate() ? null : decimal;
};
var inputNumberProps$1 = function inputNumberProps2() {
  return {
    stringMode: {
      type: Boolean
    },
    defaultValue: {
      type: [String, Number]
    },
    value: {
      type: [String, Number]
    },
    prefixCls: {
      type: String
    },
    min: {
      type: [String, Number]
    },
    max: {
      type: [String, Number]
    },
    step: {
      type: [String, Number],
      default: 1
    },
    tabindex: {
      type: Number
    },
    controls: {
      type: Boolean,
      default: true
    },
    readonly: {
      type: Boolean
    },
    disabled: {
      type: Boolean
    },
    autofocus: {
      type: Boolean
    },
    keyboard: {
      type: Boolean,
      default: true
    },
    parser: {
      type: Function
    },
    formatter: {
      type: Function
    },
    precision: {
      type: Number
    },
    decimalSeparator: {
      type: String
    },
    onInput: {
      type: Function
    },
    onChange: {
      type: Function
    },
    onPressEnter: {
      type: Function
    },
    onStep: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    onFocus: {
      type: Function
    }
  };
};
var VcInputNumber = Vue.defineComponent({
  name: "InnerInputNumber",
  inheritAttrs: false,
  props: _extends(_extends({}, inputNumberProps$1()), {
    lazy: Boolean
  }),
  slots: ["upHandler", "downHandler"],
  setup: function setup146(props2, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    var inputRef = Vue.ref();
    var focus = Vue.ref(false);
    var userTypingRef = Vue.ref(false);
    var compositionRef = Vue.ref(false);
    var decimalValue = Vue.ref(getMiniDecimal(props2.value));
    function setUncontrolledDecimalValue(newDecimal) {
      if (props2.value === void 0) {
        decimalValue.value = newDecimal;
      }
    }
    var getPrecision = function getPrecision2(numStr, userTyping) {
      if (userTyping) {
        return void 0;
      }
      if (props2.precision >= 0) {
        return props2.precision;
      }
      return Math.max(getNumberPrecision(numStr), getNumberPrecision(props2.step));
    };
    var mergedParser = function mergedParser2(num) {
      var numStr = String(num);
      if (props2.parser) {
        return props2.parser(numStr);
      }
      var parsedStr = numStr;
      if (props2.decimalSeparator) {
        parsedStr = parsedStr.replace(props2.decimalSeparator, ".");
      }
      return parsedStr.replace(/[^\w.-]+/g, "");
    };
    var inputValue = Vue.ref("");
    var mergedFormatter = function mergedFormatter2(number, userTyping) {
      if (props2.formatter) {
        return props2.formatter(number, {
          userTyping,
          input: String(inputValue.value)
        });
      }
      var str = typeof number === "number" ? num2str(number) : number;
      if (!userTyping) {
        var mergedPrecision = getPrecision(str, userTyping);
        if (validateNumber(str) && (props2.decimalSeparator || mergedPrecision >= 0)) {
          var separatorStr = props2.decimalSeparator || ".";
          str = toFixed(str, separatorStr, mergedPrecision);
        }
      }
      return str;
    };
    var initValue = function() {
      var initValue2 = props2.value;
      if (decimalValue.value.isInvalidate() && ["string", "number"].includes(_typeof$1(initValue2))) {
        return Number.isNaN(initValue2) ? "" : initValue2;
      }
      return mergedFormatter(decimalValue.value.toString(), false);
    }();
    inputValue.value = initValue;
    function setInputValue(newValue, userTyping) {
      inputValue.value = mergedFormatter(newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping);
    }
    var maxDecimal = Vue.computed(function() {
      return getDecimalIfValidate(props2.max);
    });
    var minDecimal = Vue.computed(function() {
      return getDecimalIfValidate(props2.min);
    });
    var upDisabled = Vue.computed(function() {
      if (!maxDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {
        return false;
      }
      return maxDecimal.value.lessEquals(decimalValue.value);
    });
    var downDisabled = Vue.computed(function() {
      if (!minDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {
        return false;
      }
      return decimalValue.value.lessEquals(minDecimal.value);
    });
    var _useCursor = useCursor(inputRef, focus), _useCursor2 = _slicedToArray(_useCursor, 2), recordCursor = _useCursor2[0], restoreCursor = _useCursor2[1];
    var getRangeValue = function getRangeValue2(target) {
      if (maxDecimal.value && !target.lessEquals(maxDecimal.value)) {
        return maxDecimal.value;
      }
      if (minDecimal.value && !minDecimal.value.lessEquals(target)) {
        return minDecimal.value;
      }
      return null;
    };
    var isInRange2 = function isInRange3(target) {
      return !getRangeValue(target);
    };
    var triggerValueUpdate = function triggerValueUpdate2(newValue, userTyping) {
      var _a;
      var updateValue = newValue;
      var isRangeValidate = isInRange2(updateValue) || updateValue.isEmpty();
      if (!updateValue.isEmpty() && !userTyping) {
        updateValue = getRangeValue(updateValue) || updateValue;
        isRangeValidate = true;
      }
      if (!props2.readonly && !props2.disabled && isRangeValidate) {
        var numStr = updateValue.toString();
        var mergedPrecision = getPrecision(numStr, userTyping);
        if (mergedPrecision >= 0) {
          updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision));
        }
        if (!updateValue.equals(decimalValue.value)) {
          setUncontrolledDecimalValue(updateValue);
          (_a = props2.onChange) === null || _a === void 0 ? void 0 : _a.call(props2, updateValue.isEmpty() ? null : getDecimalValue(props2.stringMode, updateValue));
          if (props2.value === void 0) {
            setInputValue(updateValue, userTyping);
          }
        }
        return updateValue;
      }
      return decimalValue.value;
    };
    var onNextPromise = useFrame();
    var collectInputValue = function collectInputValue2(inputStr) {
      var _a;
      recordCursor();
      inputValue.value = inputStr;
      if (!compositionRef.value) {
        var finalValue = mergedParser(inputStr);
        var finalDecimal = getMiniDecimal(finalValue);
        if (!finalDecimal.isNaN()) {
          triggerValueUpdate(finalDecimal, true);
        }
      }
      (_a = props2.onInput) === null || _a === void 0 ? void 0 : _a.call(props2, inputStr);
      onNextPromise(function() {
        var nextInputStr = inputStr;
        if (!props2.parser) {
          nextInputStr = inputStr.replace(//g, ".");
        }
        if (nextInputStr !== inputStr) {
          collectInputValue2(nextInputStr);
        }
      });
    };
    var onCompositionStart2 = function onCompositionStart3() {
      compositionRef.value = true;
    };
    var onCompositionEnd2 = function onCompositionEnd3() {
      compositionRef.value = false;
      collectInputValue(inputRef.value.value);
    };
    var onInternalInput = function onInternalInput2(e2) {
      collectInputValue(e2.target.value);
    };
    var onInternalStep = function onInternalStep2(up) {
      var _a, _b;
      if (up && upDisabled.value || !up && downDisabled.value) {
        return;
      }
      userTypingRef.value = false;
      var stepDecimal = getMiniDecimal(props2.step);
      if (!up) {
        stepDecimal = stepDecimal.negate();
      }
      var target = (decimalValue.value || getMiniDecimal(0)).add(stepDecimal.toString());
      var updatedValue = triggerValueUpdate(target, false);
      (_a = props2.onStep) === null || _a === void 0 ? void 0 : _a.call(props2, getDecimalValue(props2.stringMode, updatedValue), {
        offset: props2.step,
        type: up ? "up" : "down"
      });
      (_b = inputRef.value) === null || _b === void 0 ? void 0 : _b.focus();
    };
    var flushInputValue = function flushInputValue2(userTyping) {
      var parsedValue = getMiniDecimal(mergedParser(inputValue.value));
      var formatValue2 = parsedValue;
      if (!parsedValue.isNaN()) {
        formatValue2 = triggerValueUpdate(parsedValue, userTyping);
      } else {
        formatValue2 = decimalValue.value;
      }
      if (props2.value !== void 0) {
        setInputValue(decimalValue.value, false);
      } else if (!formatValue2.isNaN()) {
        setInputValue(formatValue2, false);
      }
    };
    var onKeyDown = function onKeyDown2(event) {
      var _a;
      var which = event.which;
      userTypingRef.value = true;
      if (which === KeyCode$1.ENTER) {
        if (!compositionRef.value) {
          userTypingRef.value = false;
        }
        flushInputValue(false);
        (_a = props2.onPressEnter) === null || _a === void 0 ? void 0 : _a.call(props2, event);
      }
      if (props2.keyboard === false) {
        return;
      }
      if (!compositionRef.value && [KeyCode$1.UP, KeyCode$1.DOWN].includes(which)) {
        onInternalStep(KeyCode$1.UP === which);
        event.preventDefault();
      }
    };
    var onKeyUp = function onKeyUp2() {
      userTypingRef.value = false;
    };
    var onBlur2 = function onBlur3(e2) {
      flushInputValue(false);
      focus.value = false;
      userTypingRef.value = false;
      emit("blur", e2);
    };
    Vue.watch(function() {
      return props2.precision;
    }, function() {
      if (!decimalValue.value.isInvalidate()) {
        setInputValue(decimalValue.value, false);
      }
    }, {
      flush: "post"
    });
    Vue.watch(function() {
      return props2.value;
    }, function() {
      var newValue = getMiniDecimal(props2.value);
      decimalValue.value = newValue;
      var currentParsedValue = getMiniDecimal(mergedParser(inputValue.value));
      if (!newValue.equals(currentParsedValue) || !userTypingRef.value || props2.formatter) {
        setInputValue(newValue, userTypingRef.value);
      }
    }, {
      flush: "post"
    });
    Vue.watch(inputValue, function() {
      if (props2.formatter) {
        restoreCursor();
      }
    }, {
      flush: "post"
    });
    Vue.watch(function() {
      return props2.disabled;
    }, function(val) {
      if (val) {
        focus.value = false;
      }
    });
    expose({
      focus: function focus2() {
        var _a;
        (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      },
      blur: function blur() {
        var _a;
        (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.blur();
      }
    });
    return function() {
      var _classNames;
      var _a = _extends(_extends({}, attrs), props2), _a$prefixCls = _a.prefixCls, prefixCls = _a$prefixCls === void 0 ? "rc-input-number" : _a$prefixCls, min = _a.min, max = _a.max, _a$step = _a.step, step = _a$step === void 0 ? 1 : _a$step;
      _a.defaultValue;
      _a.value;
      var disabled = _a.disabled, readonly = _a.readonly;
      _a.keyboard;
      var _a$controls = _a.controls, controls = _a$controls === void 0 ? true : _a$controls, autofocus = _a.autofocus;
      _a.stringMode;
      _a.parser;
      _a.formatter;
      _a.precision;
      _a.decimalSeparator;
      _a.onChange;
      _a.onInput;
      _a.onPressEnter;
      _a.onStep;
      var lazy = _a.lazy, className = _a.class, style = _a.style, inputProps3 = __rest$3(_a, ["prefixCls", "min", "max", "step", "defaultValue", "value", "disabled", "readonly", "keyboard", "controls", "autofocus", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep", "lazy", "class", "style"]);
      var upHandler = slots.upHandler, downHandler = slots.downHandler;
      var inputClassName = "".concat(prefixCls, "-input");
      var eventProps = {};
      if (lazy) {
        eventProps.onChange = onInternalInput;
      } else {
        eventProps.onInput = onInternalInput;
      }
      return Vue.createVNode("div", {
        "class": classNames(prefixCls, className, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls, "-focused"), focus.value), _defineProperty$T(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$T(_classNames, "".concat(prefixCls, "-readonly"), readonly), _defineProperty$T(_classNames, "".concat(prefixCls, "-not-a-number"), decimalValue.value.isNaN()), _defineProperty$T(_classNames, "".concat(prefixCls, "-out-of-range"), !decimalValue.value.isInvalidate() && !isInRange2(decimalValue.value)), _classNames)),
        "style": style,
        "onKeydown": onKeyDown,
        "onKeyup": onKeyUp
      }, [controls && Vue.createVNode(StepHandler, {
        "prefixCls": prefixCls,
        "upDisabled": upDisabled.value,
        "downDisabled": downDisabled.value,
        "onStep": onInternalStep
      }, {
        upNode: upHandler,
        downNode: downHandler
      }), Vue.createVNode("div", {
        "class": "".concat(inputClassName, "-wrap")
      }, [Vue.createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "autofocus": autofocus,
        "autocomplete": "off",
        "role": "spinbutton",
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-valuenow": decimalValue.value.isInvalidate() ? null : decimalValue.value.toString(),
        "step": step
      }, inputProps3), {}, {
        "ref": inputRef,
        "class": inputClassName,
        "value": inputValue.value,
        "disabled": disabled,
        "readonly": readonly,
        "onFocus": function onFocus2(e2) {
          focus.value = true;
          emit("focus", e2);
        }
      }, eventProps), {}, {
        "onBlur": onBlur2,
        "onCompositionstart": onCompositionStart2,
        "onCompositionend": onCompositionEnd2
      }), null)])]);
    };
  }
});
function isValidValue(val) {
  return val !== void 0 && val !== null;
}
var __rest$2 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var baseProps = inputNumberProps$1();
var inputNumberProps = function inputNumberProps3() {
  return _extends(_extends({}, baseProps), {
    size: {
      type: String
    },
    bordered: {
      type: Boolean,
      default: true
    },
    placeholder: String,
    name: String,
    id: String,
    type: String,
    addonBefore: PropTypes$1.any,
    addonAfter: PropTypes$1.any,
    prefix: PropTypes$1.any,
    "update:value": baseProps.onChange,
    valueModifiers: Object
  });
};
var InputNumber = Vue.defineComponent({
  name: "AInputNumber",
  inheritAttrs: false,
  props: inputNumberProps(),
  slots: ["addonBefore", "addonAfter", "prefix"],
  setup: function setup147(props2, _ref) {
    var emit = _ref.emit, expose = _ref.expose, attrs = _ref.attrs, slots = _ref.slots;
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("input-number", props2), prefixCls = _useConfigInject.prefixCls, size = _useConfigInject.size, direction = _useConfigInject.direction;
    var mergedValue = Vue.ref(props2.value === void 0 ? props2.defaultValue : props2.value);
    var focused = Vue.ref(false);
    Vue.watch(function() {
      return props2.value;
    }, function() {
      mergedValue.value = props2.value;
    });
    var inputNumberRef = Vue.ref(null);
    var focus = function focus2() {
      var _a;
      (_a = inputNumberRef.value) === null || _a === void 0 ? void 0 : _a.focus();
    };
    var blur = function blur2() {
      var _a;
      (_a = inputNumberRef.value) === null || _a === void 0 ? void 0 : _a.blur();
    };
    expose({
      focus,
      blur
    });
    var handleChange2 = function handleChange3(val) {
      if (props2.value === void 0) {
        mergedValue.value = val;
      }
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    var handleBlur = function handleBlur2(e2) {
      focused.value = false;
      emit("blur", e2);
      formItemContext.onFieldBlur();
    };
    var handleFocus = function handleFocus2(e2) {
      focused.value = true;
      emit("focus", e2);
    };
    Vue.onMounted(function() {
      Vue.nextTick(function() {
      });
    });
    return function() {
      var _classNames;
      var _a, _b, _c;
      var _d = _extends(_extends({}, attrs), props2), className = _d.class, bordered = _d.bordered, readonly = _d.readonly, style = _d.style, _d$addonBefore = _d.addonBefore, addonBefore = _d$addonBefore === void 0 ? (_a = slots.addonBefore) === null || _a === void 0 ? void 0 : _a.call(slots) : _d$addonBefore, _d$addonAfter = _d.addonAfter, addonAfter = _d$addonAfter === void 0 ? (_b = slots.addonAfter) === null || _b === void 0 ? void 0 : _b.call(slots) : _d$addonAfter, _d$prefix = _d.prefix, prefix = _d$prefix === void 0 ? (_c = slots.prefix) === null || _c === void 0 ? void 0 : _c.call(slots) : _d$prefix, _d$valueModifiers = _d.valueModifiers, valueModifiers = _d$valueModifiers === void 0 ? {} : _d$valueModifiers, others = __rest$2(_d, ["class", "bordered", "readonly", "style", "addonBefore", "addonAfter", "prefix", "valueModifiers"]);
      var preCls = prefixCls.value;
      var mergeSize = size.value;
      var inputNumberClass = classNames((_classNames = {}, _defineProperty$T(_classNames, "".concat(preCls, "-lg"), mergeSize === "large"), _defineProperty$T(_classNames, "".concat(preCls, "-sm"), mergeSize === "small"), _defineProperty$T(_classNames, "".concat(preCls, "-rtl"), direction.value === "rtl"), _defineProperty$T(_classNames, "".concat(preCls, "-readonly"), readonly), _defineProperty$T(_classNames, "".concat(preCls, "-borderless"), !bordered), _classNames), className);
      var element = Vue.createVNode(VcInputNumber, _objectSpread2$1(_objectSpread2$1({}, omit(others, ["size", "defaultValue"])), {}, {
        "ref": inputNumberRef,
        "lazy": !!valueModifiers.lazy,
        "value": mergedValue.value,
        "class": inputNumberClass,
        "prefixCls": preCls,
        "readonly": readonly,
        "onChange": handleChange2,
        "onBlur": handleBlur,
        "onFocus": handleFocus
      }), {
        upHandler: function upHandler() {
          return Vue.createVNode(UpOutlined$1, {
            "class": "".concat(preCls, "-handler-up-inner")
          }, null);
        },
        downHandler: function downHandler() {
          return Vue.createVNode(DownOutlined$1, {
            "class": "".concat(preCls, "-handler-down-inner")
          }, null);
        }
      });
      var hasAddon2 = isValidValue(addonBefore) || isValidValue(addonAfter);
      if (isValidValue(prefix)) {
        var _classNames2;
        var affixWrapperCls = classNames("".concat(preCls, "-affix-wrapper"), (_classNames2 = {}, _defineProperty$T(_classNames2, "".concat(preCls, "-affix-wrapper-focused"), focused.value), _defineProperty$T(_classNames2, "".concat(preCls, "-affix-wrapper-disabled"), props2.disabled), _defineProperty$T(_classNames2, "".concat(preCls, "-affix-wrapper-sm"), size.value === "small"), _defineProperty$T(_classNames2, "".concat(preCls, "-affix-wrapper-lg"), size.value === "large"), _defineProperty$T(_classNames2, "".concat(preCls, "-affix-wrapper-rtl"), direction.value === "rtl"), _defineProperty$T(_classNames2, "".concat(preCls, "-affix-wrapper-readonly"), readonly), _defineProperty$T(_classNames2, "".concat(preCls, "-affix-wrapper-borderless"), !bordered), _defineProperty$T(_classNames2, "".concat(className), !hasAddon2 && className), _classNames2));
        element = Vue.createVNode("div", {
          "class": affixWrapperCls,
          "style": style,
          "onMouseup": function onMouseup() {
            return inputNumberRef.value.focus();
          }
        }, [Vue.createVNode("span", {
          "class": "".concat(preCls, "-prefix")
        }, [prefix]), element]);
      }
      if (hasAddon2) {
        var _classNames4;
        var wrapperClassName = "".concat(preCls, "-group");
        var addonClassName = "".concat(wrapperClassName, "-addon");
        var addonBeforeNode = addonBefore ? Vue.createVNode("div", {
          "class": addonClassName
        }, [addonBefore]) : null;
        var addonAfterNode = addonAfter ? Vue.createVNode("div", {
          "class": addonClassName
        }, [addonAfter]) : null;
        var mergedWrapperClassName = classNames("".concat(preCls, "-wrapper"), wrapperClassName, _defineProperty$T({}, "".concat(wrapperClassName, "-rtl"), direction.value === "rtl"));
        var mergedGroupClassName = classNames("".concat(preCls, "-group-wrapper"), (_classNames4 = {}, _defineProperty$T(_classNames4, "".concat(preCls, "-group-wrapper-sm"), mergeSize === "small"), _defineProperty$T(_classNames4, "".concat(preCls, "-group-wrapper-lg"), mergeSize === "large"), _defineProperty$T(_classNames4, "".concat(preCls, "-group-wrapper-rtl"), direction.value === "rtl"), _classNames4), className);
        element = Vue.createVNode("div", {
          "class": mergedGroupClassName,
          "style": style
        }, [Vue.createVNode("div", {
          "class": mergedWrapperClassName
        }, [addonBeforeNode, element, addonAfterNode])]);
      }
      return cloneElement(element, {
        style
      });
    };
  }
});
var _InputNumber = _extends(InputNumber, {
  install: function install5(app) {
    app.component(InputNumber.name, InputNumber);
    return app;
  }
});
var Input = ({
  property: property2,
  slots,
  listeners
}) => {
  let component = Input$1;
  if (property2.isPassword) {
    component = InputPassword;
  }
  if (property2.isNumber) {
    component = _InputNumber;
  }
  if (property2.isTextarea) {
    component = Textarea;
    property2.autosize = property2.autosize || {
      minRows: 4,
      maxRows: 6
    };
  }
  return Vue.createVNode(component, Vue.mergeProps(property2, listeners), slots);
};
var index$3 = "";
var index$2 = "";
var weekday$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    return function(e2, t2) {
      t2.prototype.weekday = function(e3) {
        var t3 = this.$locale().weekStart || 0, i2 = this.$W, n2 = (i2 < t3 ? i2 + 7 : i2) - t3;
        return this.$utils().u(e3) ? n2 : this.subtract(n2, "day").add(e3, "day");
      };
    };
  });
})(weekday$1);
var weekday = weekday$1.exports;
var localeData$1 = { exports: {} };
(function(module2, exports2) {
  !function(n2, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    return function(n2, e2, t2) {
      var r2 = e2.prototype, o2 = function(n3) {
        return n3 && (n3.indexOf ? n3 : n3.s);
      }, u2 = function(n3, e3, t3, r3, u3) {
        var i3 = n3.name ? n3 : n3.$locale(), a3 = o2(i3[e3]), s3 = o2(i3[t3]), f2 = a3 || s3.map(function(n4) {
          return n4.slice(0, r3);
        });
        if (!u3)
          return f2;
        var d2 = i3.weekStart;
        return f2.map(function(n4, e4) {
          return f2[(e4 + (d2 || 0)) % 7];
        });
      }, i2 = function() {
        return t2.Ls[t2.locale()];
      }, a2 = function(n3, e3) {
        return n3.formats[e3] || function(n4) {
          return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n5, e4, t3) {
            return e4 || t3.slice(1);
          });
        }(n3.formats[e3.toUpperCase()]);
      }, s2 = function() {
        var n3 = this;
        return {
          months: function(e3) {
            return e3 ? e3.format("MMMM") : u2(n3, "months");
          },
          monthsShort: function(e3) {
            return e3 ? e3.format("MMM") : u2(n3, "monthsShort", "months", 3);
          },
          firstDayOfWeek: function() {
            return n3.$locale().weekStart || 0;
          },
          weekdays: function(e3) {
            return e3 ? e3.format("dddd") : u2(n3, "weekdays");
          },
          weekdaysMin: function(e3) {
            return e3 ? e3.format("dd") : u2(n3, "weekdaysMin", "weekdays", 2);
          },
          weekdaysShort: function(e3) {
            return e3 ? e3.format("ddd") : u2(n3, "weekdaysShort", "weekdays", 3);
          },
          longDateFormat: function(e3) {
            return a2(n3.$locale(), e3);
          },
          meridiem: this.$locale().meridiem,
          ordinal: this.$locale().ordinal
        };
      };
      r2.localeData = function() {
        return s2.bind(this)();
      }, t2.localeData = function() {
        var n3 = i2();
        return {
          firstDayOfWeek: function() {
            return n3.weekStart || 0;
          },
          weekdays: function() {
            return t2.weekdays();
          },
          weekdaysShort: function() {
            return t2.weekdaysShort();
          },
          weekdaysMin: function() {
            return t2.weekdaysMin();
          },
          months: function() {
            return t2.months();
          },
          monthsShort: function() {
            return t2.monthsShort();
          },
          longDateFormat: function(e3) {
            return a2(n3, e3);
          },
          meridiem: n3.meridiem,
          ordinal: n3.ordinal
        };
      }, t2.months = function() {
        return u2(i2(), "months");
      }, t2.monthsShort = function() {
        return u2(i2(), "monthsShort", "months", 3);
      }, t2.weekdays = function(n3) {
        return u2(i2(), "weekdays", null, null, n3);
      }, t2.weekdaysShort = function(n3) {
        return u2(i2(), "weekdaysShort", "weekdays", 3, n3);
      }, t2.weekdaysMin = function(n3) {
        return u2(i2(), "weekdaysMin", "weekdays", 2, n3);
      };
    };
  });
})(localeData$1);
var localeData = localeData$1.exports;
var weekOfYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    var e2 = "week", t2 = "year";
    return function(i2, n2, r2) {
      var f2 = n2.prototype;
      f2.week = function(i3) {
        if (i3 === void 0 && (i3 = null), i3 !== null)
          return this.add(7 * (i3 - this.week()), "day");
        var n3 = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var f3 = r2(this).startOf(t2).add(1, t2).date(n3), s2 = r2(this).endOf(e2);
          if (f3.isBefore(s2))
            return 1;
        }
        var a2 = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a2, e2, true);
        return o2 < 0 ? r2(this).startOf("week").week() : Math.ceil(o2);
      }, f2.weeks = function(e3) {
        return e3 === void 0 && (e3 = null), this.week(e3);
      };
    };
  });
})(weekOfYear$1);
var weekOfYear = weekOfYear$1.exports;
var weekYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    return function(e2, t2) {
      t2.prototype.weekYear = function() {
        var e3 = this.month(), t3 = this.week(), n2 = this.year();
        return t3 === 1 && e3 === 11 ? n2 + 1 : e3 === 0 && t3 >= 52 ? n2 - 1 : n2;
      };
    };
  });
})(weekYear$1);
var weekYear = weekYear$1.exports;
var advancedFormat$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    return function(e2, t2, r2) {
      var n2 = t2.prototype, s2 = n2.format;
      r2.en.ordinal = function(e3) {
        var t3 = ["th", "st", "nd", "rd"], r3 = e3 % 100;
        return "[" + e3 + (t3[(r3 - 20) % 10] || t3[r3] || t3[0]) + "]";
      }, n2.format = function(e3) {
        var t3 = this, r3 = this.$locale();
        if (!this.isValid())
          return s2.bind(this)(e3);
        var n3 = this.$utils(), a2 = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
          switch (e4) {
            case "Q":
              return Math.ceil((t3.$M + 1) / 3);
            case "Do":
              return r3.ordinal(t3.$D);
            case "gggg":
              return t3.weekYear();
            case "GGGG":
              return t3.isoWeekYear();
            case "wo":
              return r3.ordinal(t3.week(), "W");
            case "w":
            case "ww":
              return n3.s(t3.week(), e4 === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return n3.s(t3.isoWeek(), e4 === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return n3.s(String(t3.$H === 0 ? 24 : t3.$H), e4 === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(t3.$d.getTime() / 1e3);
            case "x":
              return t3.$d.getTime();
            case "z":
              return "[" + t3.offsetName() + "]";
            case "zzz":
              return "[" + t3.offsetName("long") + "]";
            default:
              return e4;
          }
        });
        return s2.bind(this)(a2);
      };
    };
  });
})(advancedFormat$1);
var advancedFormat = advancedFormat$1.exports;
var customParseFormat$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    var e2 = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    }, t2 = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i2 = /\d*[^\s\d-_:/()]+/, o2 = {}, s2 = function(e3) {
      return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
    };
    var a2 = function(e3) {
      return function(t3) {
        this[e3] = +t3;
      };
    }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
      (this.zone || (this.zone = {})).offset = function(e4) {
        if (!e4)
          return 0;
        if (e4 === "Z")
          return 0;
        var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
        return n3 === 0 ? 0 : t3[0] === "+" ? -n3 : n3;
      }(e3);
    }], h2 = function(e3) {
      var t3 = o2[e3];
      return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
    }, u2 = function(e3, t3) {
      var n3, r3 = o2.meridiem;
      if (r3) {
        for (var i3 = 1; i3 <= 24; i3 += 1)
          if (e3.indexOf(r3(i3, 0, t3)) > -1) {
            n3 = i3 > 12;
            break;
          }
      } else
        n3 = e3 === (t3 ? "pm" : "PM");
      return n3;
    }, d2 = {
      A: [i2, function(e3) {
        this.afternoon = u2(e3, false);
      }],
      a: [i2, function(e3) {
        this.afternoon = u2(e3, true);
      }],
      S: [/\d/, function(e3) {
        this.milliseconds = 100 * +e3;
      }],
      SS: [n2, function(e3) {
        this.milliseconds = 10 * +e3;
      }],
      SSS: [/\d{3}/, function(e3) {
        this.milliseconds = +e3;
      }],
      s: [r2, a2("seconds")],
      ss: [r2, a2("seconds")],
      m: [r2, a2("minutes")],
      mm: [r2, a2("minutes")],
      H: [r2, a2("hours")],
      h: [r2, a2("hours")],
      HH: [r2, a2("hours")],
      hh: [r2, a2("hours")],
      D: [r2, a2("day")],
      DD: [n2, a2("day")],
      Do: [i2, function(e3) {
        var t3 = o2.ordinal, n3 = e3.match(/\d+/);
        if (this.day = n3[0], t3)
          for (var r3 = 1; r3 <= 31; r3 += 1)
            t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
      }],
      M: [r2, a2("month")],
      MM: [n2, a2("month")],
      MMM: [i2, function(e3) {
        var t3 = h2("months"), n3 = (h2("monthsShort") || t3.map(function(e4) {
          return e4.slice(0, 3);
        })).indexOf(e3) + 1;
        if (n3 < 1)
          throw new Error();
        this.month = n3 % 12 || n3;
      }],
      MMMM: [i2, function(e3) {
        var t3 = h2("months").indexOf(e3) + 1;
        if (t3 < 1)
          throw new Error();
        this.month = t3 % 12 || t3;
      }],
      Y: [/[+-]?\d+/, a2("year")],
      YY: [n2, function(e3) {
        this.year = s2(e3);
      }],
      YYYY: [/\d{4}/, a2("year")],
      Z: f2,
      ZZ: f2
    };
    function c2(n3) {
      var r3, i3;
      r3 = n3, i3 = o2 && o2.formats;
      for (var s3 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
        var o3 = r4 && r4.toUpperCase();
        return n4 || i3[r4] || e2[r4] || i3[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
          return t4 || n5.slice(1);
        });
      })).match(t2), a3 = s3.length, f3 = 0; f3 < a3; f3 += 1) {
        var h3 = s3[f3], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
        s3[f3] = l2 ? {
          regex: c3,
          parser: l2
        } : h3.replace(/^\[|\]$/g, "");
      }
      return function(e3) {
        for (var t3 = {}, n4 = 0, r4 = 0; n4 < a3; n4 += 1) {
          var i4 = s3[n4];
          if (typeof i4 == "string")
            r4 += i4.length;
          else {
            var o3 = i4.regex, f4 = i4.parser, h4 = e3.slice(r4), u4 = o3.exec(h4)[0];
            f4.call(t3, u4), e3 = e3.replace(u4, "");
          }
        }
        return function(e4) {
          var t4 = e4.afternoon;
          if (t4 !== void 0) {
            var n5 = e4.hours;
            t4 ? n5 < 12 && (e4.hours += 12) : n5 === 12 && (e4.hours = 0), delete e4.afternoon;
          }
        }(t3), t3;
      };
    }
    return function(e3, t3, n3) {
      n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s2 = e3.parseTwoDigitYear);
      var r3 = t3.prototype, i3 = r3.parse;
      r3.parse = function(e4) {
        var t4 = e4.date, r4 = e4.utc, s3 = e4.args;
        this.$u = r4;
        var a3 = s3[1];
        if (typeof a3 == "string") {
          var f3 = s3[2] === true, h3 = s3[3] === true, u3 = f3 || h3, d3 = s3[2];
          h3 && (d3 = s3[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n3.Ls[d3]), this.$d = function(e5, t5, n4) {
            try {
              if (["x", "X"].indexOf(t5) > -1)
                return new Date((t5 === "X" ? 1e3 : 1) * e5);
              var r5 = c2(t5)(e5), i4 = r5.year, o3 = r5.month, s4 = r5.day, a4 = r5.hours, f4 = r5.minutes, h4 = r5.seconds, u4 = r5.milliseconds, d4 = r5.zone, l3 = new Date(), m3 = s4 || (i4 || o3 ? 1 : l3.getDate()), M3 = i4 || l3.getFullYear(), Y2 = 0;
              i4 && !o3 || (Y2 = o3 > 0 ? o3 - 1 : l3.getMonth());
              var p2 = a4 || 0, v2 = f4 || 0, D2 = h4 || 0, g2 = u4 || 0;
              return d4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2 + 60 * d4.offset * 1e3)) : n4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2)) : new Date(M3, Y2, m3, p2, v2, D2, g2);
            } catch (e6) {
              return new Date("");
            }
          }(t4, a3, r4), this.init(), d3 && d3 !== true && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a3) && (this.$d = new Date("")), o2 = {};
        } else if (a3 instanceof Array)
          for (var l2 = a3.length, m2 = 1; m2 <= l2; m2 += 1) {
            s3[1] = a3[m2 - 1];
            var M2 = n3.apply(this, s3);
            if (M2.isValid()) {
              this.$d = M2.$d, this.$L = M2.$L, this.init();
              break;
            }
            m2 === l2 && (this.$d = new Date(""));
          }
        else
          i3.call(this, e4);
      };
    };
  });
})(customParseFormat$1);
var customParseFormat = customParseFormat$1.exports;
dayjs.extend(customParseFormat);
dayjs.extend(advancedFormat);
dayjs.extend(weekday);
dayjs.extend(localeData);
dayjs.extend(weekOfYear);
dayjs.extend(weekYear);
dayjs.extend(function(_o, c2) {
  var proto = c2.prototype;
  var oldFormat = proto.format;
  proto.format = function f2(formatStr) {
    var str = (formatStr || "").replace("Wo", "wo");
    return oldFormat.bind(this)(str);
  };
});
var localeMap = {
  bn_BD: "bn-bd",
  by_BY: "be",
  en_GB: "en-gb",
  en_US: "en",
  fr_BE: "fr",
  fr_CA: "fr-ca",
  hy_AM: "hy-am",
  kmr_IQ: "ku",
  nl_BE: "nl-be",
  pt_BR: "pt-br",
  zh_CN: "zh-cn",
  zh_HK: "zh-hk",
  zh_TW: "zh-tw"
};
var parseLocale = function parseLocale2(locale2) {
  var mapLocale = localeMap[locale2];
  return mapLocale || locale2.split("_")[0];
};
var parseNoMatchNotice = function parseNoMatchNotice2() {
  noteOnce(false, "Not match any format. Please help to fire a issue about this.");
};
var generateConfig = {
  getNow: function getNow() {
    return dayjs();
  },
  getFixedDate: function getFixedDate(string) {
    return dayjs(string, ["YYYY-M-DD", "YYYY-MM-DD"]);
  },
  getEndDate: function getEndDate(date) {
    return date.endOf("month");
  },
  getWeekDay: function getWeekDay(date) {
    var clone2 = date.locale("en");
    return clone2.weekday() + clone2.localeData().firstDayOfWeek();
  },
  getYear: function getYear(date) {
    return date.year();
  },
  getMonth: function getMonth(date) {
    return date.month();
  },
  getDate: function getDate(date) {
    return date.date();
  },
  getHour: function getHour(date) {
    return date.hour();
  },
  getMinute: function getMinute(date) {
    return date.minute();
  },
  getSecond: function getSecond(date) {
    return date.second();
  },
  addYear: function addYear(date, diff) {
    return date.add(diff, "year");
  },
  addMonth: function addMonth(date, diff) {
    return date.add(diff, "month");
  },
  addDate: function addDate(date, diff) {
    return date.add(diff, "day");
  },
  setYear: function setYear(date, year) {
    return date.year(year);
  },
  setMonth: function setMonth(date, month) {
    return date.month(month);
  },
  setDate: function setDate(date, num) {
    return date.date(num);
  },
  setHour: function setHour(date, hour) {
    return date.hour(hour);
  },
  setMinute: function setMinute(date, minute) {
    return date.minute(minute);
  },
  setSecond: function setSecond(date, second) {
    return date.second(second);
  },
  isAfter: function isAfter(date1, date2) {
    return date1.isAfter(date2);
  },
  isValidate: function isValidate(date) {
    return date.isValid();
  },
  locale: {
    getWeekFirstDay: function getWeekFirstDay(locale2) {
      return dayjs().locale(parseLocale(locale2)).localeData().firstDayOfWeek();
    },
    getWeekFirstDate: function getWeekFirstDate(locale2, date) {
      return date.locale(parseLocale(locale2)).weekday(0);
    },
    getWeek: function getWeek(locale2, date) {
      return date.locale(parseLocale(locale2)).week();
    },
    getShortWeekDays: function getShortWeekDays(locale2) {
      return dayjs().locale(parseLocale(locale2)).localeData().weekdaysMin();
    },
    getShortMonths: function getShortMonths(locale2) {
      return dayjs().locale(parseLocale(locale2)).localeData().monthsShort();
    },
    format: function format(locale2, date, _format) {
      return date.locale(parseLocale(locale2)).format(_format);
    },
    parse: function parse(locale2, text, formats) {
      var localeStr = parseLocale(locale2);
      for (var i2 = 0; i2 < formats.length; i2 += 1) {
        var format2 = formats[i2];
        var formatText = text;
        if (format2.includes("wo") || format2.includes("Wo")) {
          var year = formatText.split("-")[0];
          var weekStr = formatText.split("-")[1];
          var firstWeek = dayjs(year, "YYYY").startOf("year").locale(localeStr);
          for (var j2 = 0; j2 <= 52; j2 += 1) {
            var nextWeek = firstWeek.add(j2, "week");
            if (nextWeek.format("Wo") === weekStr) {
              return nextWeek;
            }
          }
          parseNoMatchNotice();
          return null;
        }
        var date = dayjs(formatText, format2, true).locale(localeStr);
        if (date.isValid()) {
          return date;
        }
      }
      if (!text) {
        parseNoMatchNotice();
      }
      return null;
    }
  },
  toDate: function toDate(value, valueFormat) {
    if (Array.isArray(value)) {
      return value.map(function(val) {
        return typeof val === "string" && val ? dayjs(val, valueFormat) : val || null;
      });
    } else {
      return typeof value === "string" && value ? dayjs(value, valueFormat) : value || null;
    }
  },
  toString: function toString2(value, valueFormat) {
    if (Array.isArray(value)) {
      return value.map(function(val) {
        return dayjs.isDayjs(val) ? val.format(valueFormat) : val;
      });
    } else {
      return dayjs.isDayjs(value) ? value.format(valueFormat) : value;
    }
  }
};
var dayjsGenerateConfig = generateConfig;
var PickerButton = function PickerButton2(props2, _ref) {
  var attrs = _ref.attrs, slots = _ref.slots;
  return Vue.createVNode(Button$1, _objectSpread2$1(_objectSpread2$1({
    "size": "small",
    "type": "primary"
  }, props2), attrs), slots);
};
var PickerButton$1 = PickerButton;
var checkableTagProps = function checkableTagProps2() {
  return {
    prefixCls: String,
    checked: {
      type: Boolean,
      default: void 0
    },
    onChange: {
      type: Function
    },
    onClick: {
      type: Function
    },
    "onUpdate:checked": Function
  };
};
var CheckableTag = Vue.defineComponent({
  name: "ACheckableTag",
  props: checkableTagProps(),
  setup: function setup148(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit;
    var _useConfigInject = useConfigInject("tag", props2), prefixCls = _useConfigInject.prefixCls;
    var handleClick = function handleClick2(e2) {
      var checked = props2.checked;
      emit("update:checked", !checked);
      emit("change", !checked);
      emit("click", e2);
    };
    var cls = Vue.computed(function() {
      var _classNames;
      return classNames(prefixCls.value, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls.value, "-checkable"), true), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-checkable-checked"), props2.checked), _classNames));
    });
    return function() {
      var _a;
      return Vue.createVNode("span", {
        "class": cls.value,
        "onClick": handleClick
      }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);
    };
  }
});
var CheckableTag$1 = CheckableTag;
var PresetColorRegex = new RegExp("^(".concat(PresetColorTypes.join("|"), ")(-inverse)?$"));
var PresetStatusColorRegex = new RegExp("^(".concat(PresetStatusColorTypes.join("|"), ")$"));
var tagProps = function tagProps2() {
  return {
    prefixCls: String,
    color: {
      type: String
    },
    closable: {
      type: Boolean,
      default: false
    },
    closeIcon: PropTypes$1.any,
    visible: {
      type: Boolean,
      default: void 0
    },
    onClose: {
      type: Function
    },
    "onUpdate:visible": Function,
    icon: PropTypes$1.any
  };
};
var Tag = Vue.defineComponent({
  name: "ATag",
  props: tagProps(),
  slots: ["closeIcon", "icon"],
  setup: function setup149(props2, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("tag", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var visible = Vue.ref(true);
    Vue.watchEffect(function() {
      if (props2.visible !== void 0) {
        visible.value = props2.visible;
      }
    });
    var handleCloseClick = function handleCloseClick2(e2) {
      e2.stopPropagation();
      emit("update:visible", false);
      emit("close", e2);
      if (e2.defaultPrevented) {
        return;
      }
      if (props2.visible === void 0) {
        visible.value = false;
      }
    };
    var isPresetColor = Vue.computed(function() {
      var color = props2.color;
      if (!color) {
        return false;
      }
      return PresetColorRegex.test(color) || PresetStatusColorRegex.test(color);
    });
    var tagClassName = Vue.computed(function() {
      var _classNames;
      return classNames(prefixCls.value, (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls.value, "-").concat(props2.color), isPresetColor.value), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-has-color"), props2.color && !isPresetColor.value), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-hidden"), !visible.value), _defineProperty$T(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames));
    });
    return function() {
      var _a, _b, _c;
      var _props$icon = props2.icon, icon = _props$icon === void 0 ? (_a = slots.icon) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$icon, color = props2.color, _props$closeIcon = props2.closeIcon, closeIcon = _props$closeIcon === void 0 ? (_b = slots.closeIcon) === null || _b === void 0 ? void 0 : _b.call(slots) : _props$closeIcon, _props$closable = props2.closable, closable = _props$closable === void 0 ? false : _props$closable;
      var renderCloseIcon = function renderCloseIcon2() {
        if (closable) {
          return closeIcon ? Vue.createVNode("div", {
            "class": "".concat(prefixCls.value, "-close-icon"),
            "onClick": handleCloseClick
          }, [closeIcon]) : Vue.createVNode(CloseOutlined$1, {
            "class": "".concat(prefixCls.value, "-close-icon"),
            "onClick": handleCloseClick
          }, null);
        }
        return null;
      };
      var tagStyle = {
        backgroundColor: color && !isPresetColor.value ? color : void 0
      };
      var iconNode = icon || null;
      var children = (_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots);
      var kids = iconNode ? Vue.createVNode(Vue.Fragment, null, [iconNode, Vue.createVNode("span", null, [children])]) : children;
      var isNeedWave = "onClick" in attrs;
      var tagNode = Vue.createVNode("span", {
        "class": tagClassName.value,
        "style": tagStyle
      }, [kids, renderCloseIcon()]);
      return isNeedWave ? Vue.createVNode(Wave, null, {
        default: function _default5() {
          return [tagNode];
        }
      }) : tagNode;
    };
  }
});
Tag.CheckableTag = CheckableTag$1;
Tag.install = function(app) {
  app.component(Tag.name, Tag);
  app.component(CheckableTag$1.name, CheckableTag$1);
  return app;
};
var Tag$1 = Tag;
function PickerTag(props2, _ref) {
  var slots = _ref.slots, attrs = _ref.attrs;
  return Vue.createVNode(Tag$1, _objectSpread2$1(_objectSpread2$1({
    "color": "blue"
  }, props2), attrs), slots);
}
function useMergeProps(props2) {
  var attrs = Vue.useAttrs();
  return _extends(_extends({}, props2), attrs);
}
var PanelContextKey = Symbol("PanelContextProps");
var useProvidePanel = function useProvidePanel2(props2) {
  Vue.provide(PanelContextKey, props2);
};
var useInjectPanel = function useInjectPanel2() {
  return Vue.inject(PanelContextKey, {});
};
var HIDDEN_STYLE = {
  visibility: "hidden"
};
function Header(_props, _ref) {
  var slots = _ref.slots;
  var _a;
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, _props$prevIcon = props2.prevIcon, prevIcon = _props$prevIcon === void 0 ? "\u2039" : _props$prevIcon, _props$nextIcon = props2.nextIcon, nextIcon = _props$nextIcon === void 0 ? "\u203A" : _props$nextIcon, _props$superPrevIcon = props2.superPrevIcon, superPrevIcon = _props$superPrevIcon === void 0 ? "\xAB" : _props$superPrevIcon, _props$superNextIcon = props2.superNextIcon, superNextIcon = _props$superNextIcon === void 0 ? "\xBB" : _props$superNextIcon, onSuperPrev = props2.onSuperPrev, onSuperNext = props2.onSuperNext, onPrev = props2.onPrev, onNext = props2.onNext;
  var _useInjectPanel = useInjectPanel(), hideNextBtn = _useInjectPanel.hideNextBtn, hidePrevBtn = _useInjectPanel.hidePrevBtn;
  return Vue.createVNode("div", {
    "class": prefixCls
  }, [onSuperPrev && Vue.createVNode("button", {
    "type": "button",
    "onClick": onSuperPrev,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-super-prev-btn"),
    "style": hidePrevBtn.value ? HIDDEN_STYLE : {}
  }, [superPrevIcon]), onPrev && Vue.createVNode("button", {
    "type": "button",
    "onClick": onPrev,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-prev-btn"),
    "style": hidePrevBtn.value ? HIDDEN_STYLE : {}
  }, [prevIcon]), Vue.createVNode("div", {
    "class": "".concat(prefixCls, "-view")
  }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]), onNext && Vue.createVNode("button", {
    "type": "button",
    "onClick": onNext,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-next-btn"),
    "style": hideNextBtn.value ? HIDDEN_STYLE : {}
  }, [nextIcon]), onSuperNext && Vue.createVNode("button", {
    "type": "button",
    "onClick": onSuperNext,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-super-next-btn"),
    "style": hideNextBtn.value ? HIDDEN_STYLE : {}
  }, [superNextIcon])]);
}
Header.displayName = "Header";
Header.inheritAttrs = false;
function DecadeHeader(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, generateConfig2 = props2.generateConfig, viewDate = props2.viewDate, onPrevDecades = props2.onPrevDecades, onNextDecades = props2.onNextDecades;
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader) {
    return null;
  }
  var headerPrefixCls = "".concat(prefixCls, "-header");
  var yearNumber = generateConfig2.getYear(viewDate);
  var startYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
  var endYear = startYear + DECADE_DISTANCE_COUNT - 1;
  return Vue.createVNode(Header, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevDecades,
    "onSuperNext": onNextDecades
  }), {
    default: function _default5() {
      return [startYear, Vue.createTextVNode("-"), endYear];
    }
  });
}
DecadeHeader.displayName = "DecadeHeader";
DecadeHeader.inheritAttrs = false;
function setTime(generateConfig2, date, hour, minute, second) {
  var nextTime = generateConfig2.setHour(date, hour);
  nextTime = generateConfig2.setMinute(nextTime, minute);
  nextTime = generateConfig2.setSecond(nextTime, second);
  return nextTime;
}
function setDateTime(generateConfig2, date, defaultDate) {
  if (!defaultDate) {
    return date;
  }
  var newDate = date;
  newDate = generateConfig2.setHour(newDate, generateConfig2.getHour(defaultDate));
  newDate = generateConfig2.setMinute(newDate, generateConfig2.getMinute(defaultDate));
  newDate = generateConfig2.setSecond(newDate, generateConfig2.getSecond(defaultDate));
  return newDate;
}
function getLowerBoundTime(hour, minute, second, hourStep, minuteStep, secondStep) {
  var lowerBoundHour = Math.floor(hour / hourStep) * hourStep;
  if (lowerBoundHour < hour) {
    return [lowerBoundHour, 60 - minuteStep, 60 - secondStep];
  }
  var lowerBoundMinute = Math.floor(minute / minuteStep) * minuteStep;
  if (lowerBoundMinute < minute) {
    return [lowerBoundHour, lowerBoundMinute, 60 - secondStep];
  }
  var lowerBoundSecond = Math.floor(second / secondStep) * secondStep;
  return [lowerBoundHour, lowerBoundMinute, lowerBoundSecond];
}
function getLastDay(generateConfig2, date) {
  var year = generateConfig2.getYear(date);
  var month = generateConfig2.getMonth(date) + 1;
  var endDate = generateConfig2.getEndDate(generateConfig2.getFixedDate("".concat(year, "-").concat(month, "-01")));
  var lastDay = generateConfig2.getDate(endDate);
  var monthShow = month < 10 ? "0".concat(month) : "".concat(month);
  return "".concat(year, "-").concat(monthShow, "-").concat(lastDay);
}
function PanelBody(_props) {
  var _useMergeProps = useMergeProps(_props), prefixCls = _useMergeProps.prefixCls, disabledDate = _useMergeProps.disabledDate, onSelect = _useMergeProps.onSelect, picker = _useMergeProps.picker, rowNum = _useMergeProps.rowNum, colNum = _useMergeProps.colNum, prefixColumn = _useMergeProps.prefixColumn, rowClassName = _useMergeProps.rowClassName, baseDate = _useMergeProps.baseDate, getCellClassName = _useMergeProps.getCellClassName, getCellText = _useMergeProps.getCellText, getCellNode = _useMergeProps.getCellNode, getCellDate = _useMergeProps.getCellDate, generateConfig2 = _useMergeProps.generateConfig, titleCell = _useMergeProps.titleCell, headerCells = _useMergeProps.headerCells;
  var _useInjectPanel = useInjectPanel(), onDateMouseenter = _useInjectPanel.onDateMouseenter, onDateMouseleave = _useInjectPanel.onDateMouseleave, mode = _useInjectPanel.mode;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var rows = [];
  for (var i2 = 0; i2 < rowNum; i2 += 1) {
    var row = [];
    var rowStartDate = void 0;
    var _loop = function _loop2(j3) {
      var _extends2;
      var offset3 = i2 * colNum + j3;
      var currentDate = getCellDate(baseDate, offset3);
      var disabled = getCellDateDisabled({
        cellDate: currentDate,
        mode: mode.value,
        disabledDate,
        generateConfig: generateConfig2
      });
      if (j3 === 0) {
        rowStartDate = currentDate;
        if (prefixColumn) {
          row.push(prefixColumn(rowStartDate));
        }
      }
      var title = titleCell && titleCell(currentDate);
      row.push(Vue.createVNode("td", {
        "key": j3,
        "title": title,
        "class": classNames(cellPrefixCls, _extends((_extends2 = {}, _defineProperty$T(_extends2, "".concat(cellPrefixCls, "-disabled"), disabled), _defineProperty$T(_extends2, "".concat(cellPrefixCls, "-start"), getCellText(currentDate) === 1 || picker === "year" && Number(title) % 10 === 0), _defineProperty$T(_extends2, "".concat(cellPrefixCls, "-end"), title === getLastDay(generateConfig2, currentDate) || picker === "year" && Number(title) % 10 === 9), _extends2), getCellClassName(currentDate))),
        "onClick": function onClick2() {
          if (!disabled) {
            onSelect(currentDate);
          }
        },
        "onMouseenter": function onMouseenter2() {
          if (!disabled && onDateMouseenter) {
            onDateMouseenter(currentDate);
          }
        },
        "onMouseleave": function onMouseleave2() {
          if (!disabled && onDateMouseleave) {
            onDateMouseleave(currentDate);
          }
        }
      }, [getCellNode ? getCellNode(currentDate) : Vue.createVNode("div", {
        "class": "".concat(cellPrefixCls, "-inner")
      }, [getCellText(currentDate)])]));
    };
    for (var j2 = 0; j2 < colNum; j2 += 1) {
      _loop(j2);
    }
    rows.push(Vue.createVNode("tr", {
      "key": i2,
      "class": rowClassName && rowClassName(rowStartDate)
    }, [row]));
  }
  return Vue.createVNode("div", {
    "class": "".concat(prefixCls, "-body")
  }, [Vue.createVNode("table", {
    "class": "".concat(prefixCls, "-content")
  }, [headerCells && Vue.createVNode("thead", null, [Vue.createVNode("tr", null, [headerCells])]), Vue.createVNode("tbody", null, [rows])])]);
}
PanelBody.displayName = "PanelBody";
PanelBody.inheritAttrs = false;
var DECADE_COL_COUNT = 3;
var DECADE_ROW_COUNT = 4;
function DecadeBody(_props) {
  var props2 = useMergeProps(_props);
  var DECADE_UNIT_DIFF_DES = DECADE_UNIT_DIFF - 1;
  var prefixCls = props2.prefixCls, viewDate = props2.viewDate, generateConfig2 = props2.generateConfig;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var yearNumber = generateConfig2.getYear(viewDate);
  var decadeYearNumber = Math.floor(yearNumber / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
  var startDecadeYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
  var endDecadeYear = startDecadeYear + DECADE_DISTANCE_COUNT - 1;
  var baseDecadeYear = generateConfig2.setYear(viewDate, startDecadeYear - Math.ceil((DECADE_COL_COUNT * DECADE_ROW_COUNT * DECADE_UNIT_DIFF - DECADE_DISTANCE_COUNT) / 2));
  var getCellClassName = function getCellClassName2(date) {
    var _ref;
    var startDecadeNumber = generateConfig2.getYear(date);
    var endDecadeNumber = startDecadeNumber + DECADE_UNIT_DIFF_DES;
    return _ref = {}, _defineProperty$T(_ref, "".concat(cellPrefixCls, "-in-view"), startDecadeYear <= startDecadeNumber && endDecadeNumber <= endDecadeYear), _defineProperty$T(_ref, "".concat(cellPrefixCls, "-selected"), startDecadeNumber === decadeYearNumber), _ref;
  };
  return Vue.createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "rowNum": DECADE_ROW_COUNT,
    "colNum": DECADE_COL_COUNT,
    "baseDate": baseDecadeYear,
    "getCellText": function getCellText(date) {
      var startDecadeNumber = generateConfig2.getYear(date);
      return "".concat(startDecadeNumber, "-").concat(startDecadeNumber + DECADE_UNIT_DIFF_DES);
    },
    "getCellClassName": getCellClassName,
    "getCellDate": function getCellDate(date, offset3) {
      return generateConfig2.addYear(date, offset3 * DECADE_UNIT_DIFF);
    }
  }), null);
}
DecadeBody.displayName = "DecadeBody";
DecadeBody.inheritAttrs = false;
var scrollIds = /* @__PURE__ */ new Map();
function waitElementReady(element, callback) {
  var id;
  function tryOrNextFrame() {
    if (isVisible(element)) {
      callback();
    } else {
      id = wrapperRaf(function() {
        tryOrNextFrame();
      });
    }
  }
  tryOrNextFrame();
  return function() {
    wrapperRaf.cancel(id);
  };
}
function scrollTo(element, to, duration) {
  if (scrollIds.get(element)) {
    wrapperRaf.cancel(scrollIds.get(element));
  }
  if (duration <= 0) {
    scrollIds.set(element, wrapperRaf(function() {
      element.scrollTop = to;
    }));
    return;
  }
  var difference = to - element.scrollTop;
  var perTick = difference / duration * 10;
  scrollIds.set(element, wrapperRaf(function() {
    element.scrollTop += perTick;
    if (element.scrollTop !== to) {
      scrollTo(element, to, duration - 10);
    }
  }));
}
function createKeydownHandler(event, _ref) {
  var onLeftRight = _ref.onLeftRight, onCtrlLeftRight = _ref.onCtrlLeftRight, onUpDown = _ref.onUpDown, onPageUpDown = _ref.onPageUpDown, onEnter = _ref.onEnter;
  var which = event.which, ctrlKey = event.ctrlKey, metaKey = event.metaKey;
  switch (which) {
    case KeyCode$1.LEFT:
      if (ctrlKey || metaKey) {
        if (onCtrlLeftRight) {
          onCtrlLeftRight(-1);
          return true;
        }
      } else if (onLeftRight) {
        onLeftRight(-1);
        return true;
      }
      break;
    case KeyCode$1.RIGHT:
      if (ctrlKey || metaKey) {
        if (onCtrlLeftRight) {
          onCtrlLeftRight(1);
          return true;
        }
      } else if (onLeftRight) {
        onLeftRight(1);
        return true;
      }
      break;
    case KeyCode$1.UP:
      if (onUpDown) {
        onUpDown(-1);
        return true;
      }
      break;
    case KeyCode$1.DOWN:
      if (onUpDown) {
        onUpDown(1);
        return true;
      }
      break;
    case KeyCode$1.PAGE_UP:
      if (onPageUpDown) {
        onPageUpDown(-1);
        return true;
      }
      break;
    case KeyCode$1.PAGE_DOWN:
      if (onPageUpDown) {
        onPageUpDown(1);
        return true;
      }
      break;
    case KeyCode$1.ENTER:
      if (onEnter) {
        onEnter();
        return true;
      }
      break;
  }
  return false;
}
function getDefaultFormat(format2, picker, showTime, use12Hours) {
  var mergedFormat = format2;
  if (!mergedFormat) {
    switch (picker) {
      case "time":
        mergedFormat = use12Hours ? "hh:mm:ss a" : "HH:mm:ss";
        break;
      case "week":
        mergedFormat = "gggg-wo";
        break;
      case "month":
        mergedFormat = "YYYY-MM";
        break;
      case "quarter":
        mergedFormat = "YYYY-[Q]Q";
        break;
      case "year":
        mergedFormat = "YYYY";
        break;
      default:
        mergedFormat = showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
    }
  }
  return mergedFormat;
}
function getInputSize(picker, format2, generateConfig2) {
  var defaultSize = picker === "time" ? 8 : 10;
  var length = typeof format2 === "function" ? format2(generateConfig2.getNow()).length : format2.length;
  return Math.max(defaultSize, length) + 2;
}
var globalClickFunc = null;
var clickCallbacks = /* @__PURE__ */ new Set();
function addGlobalMousedownEvent(callback) {
  if (!globalClickFunc && typeof window !== "undefined" && window.addEventListener) {
    globalClickFunc = function globalClickFunc2(e2) {
      _toConsumableArray(clickCallbacks).forEach(function(queueFunc) {
        queueFunc(e2);
      });
    };
    window.addEventListener("mousedown", globalClickFunc);
  }
  clickCallbacks.add(callback);
  return function() {
    clickCallbacks.delete(callback);
    if (clickCallbacks.size === 0) {
      window.removeEventListener("mousedown", globalClickFunc);
      globalClickFunc = null;
    }
  };
}
function getTargetFromEvent(e2) {
  var _a;
  var target = e2.target;
  if (e2.composed && target.shadowRoot) {
    return ((_a = e2.composedPath) === null || _a === void 0 ? void 0 : _a.call(e2)[0]) || target;
  }
  return target;
}
var getYearNextMode = function getYearNextMode2(next2) {
  if (next2 === "month" || next2 === "date") {
    return "year";
  }
  return next2;
};
var getMonthNextMode = function getMonthNextMode2(next2) {
  if (next2 === "date") {
    return "month";
  }
  return next2;
};
var getQuarterNextMode = function getQuarterNextMode2(next2) {
  if (next2 === "month" || next2 === "date") {
    return "quarter";
  }
  return next2;
};
var getWeekNextMode = function getWeekNextMode2(next2) {
  if (next2 === "date") {
    return "week";
  }
  return next2;
};
var PickerModeMap = {
  year: getYearNextMode,
  month: getMonthNextMode,
  quarter: getQuarterNextMode,
  week: getWeekNextMode,
  time: null,
  date: null
};
function elementsContains(elements, target) {
  return elements.some(function(ele) {
    return ele && ele.contains(target);
  });
}
var DECADE_UNIT_DIFF = 10;
var DECADE_DISTANCE_COUNT = DECADE_UNIT_DIFF * 10;
function DecadePanel(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, onViewDateChange = props2.onViewDateChange, generateConfig2 = props2.generateConfig, viewDate = props2.viewDate, operationRef = props2.operationRef, onSelect = props2.onSelect, onPanelChange = props2.onPanelChange;
  var panelPrefixCls = "".concat(prefixCls, "-decade-panel");
  operationRef.value = {
    onKeydown: function onKeydown(event) {
      return createKeydownHandler(event, {
        onLeftRight: function onLeftRight(diff) {
          onSelect(generateConfig2.addYear(viewDate, diff * DECADE_UNIT_DIFF), "key");
        },
        onCtrlLeftRight: function onCtrlLeftRight(diff) {
          onSelect(generateConfig2.addYear(viewDate, diff * DECADE_DISTANCE_COUNT), "key");
        },
        onUpDown: function onUpDown(diff) {
          onSelect(generateConfig2.addYear(viewDate, diff * DECADE_UNIT_DIFF * DECADE_COL_COUNT), "key");
        },
        onEnter: function onEnter() {
          onPanelChange("year", viewDate);
        }
      });
    }
  };
  var onDecadesChange = function onDecadesChange2(diff) {
    var newDate = generateConfig2.addYear(viewDate, diff * DECADE_DISTANCE_COUNT);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  var onInternalSelect = function onInternalSelect2(date) {
    onSelect(date, "mouse");
    onPanelChange("year", date);
  };
  return Vue.createVNode("div", {
    "class": panelPrefixCls
  }, [Vue.createVNode(DecadeHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevDecades": function onPrevDecades() {
      onDecadesChange(-1);
    },
    "onNextDecades": function onNextDecades() {
      onDecadesChange(1);
    }
  }), null), Vue.createVNode(DecadeBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": onInternalSelect
  }), null)]);
}
DecadePanel.displayName = "DecadePanel";
DecadePanel.inheritAttrs = false;
var WEEK_DAY_COUNT = 7;
function isNullEqual(value1, value2) {
  if (!value1 && !value2) {
    return true;
  }
  if (!value1 || !value2) {
    return false;
  }
  return void 0;
}
function isSameDecade(generateConfig2, decade1, decade2) {
  var equal = isNullEqual(decade1, decade2);
  if (typeof equal === "boolean") {
    return equal;
  }
  var num1 = Math.floor(generateConfig2.getYear(decade1) / 10);
  var num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
  return num1 === num2;
}
function isSameYear(generateConfig2, year1, year2) {
  var equal = isNullEqual(year1, year2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getYear(year1) === generateConfig2.getYear(year2);
}
function getQuarter(generateConfig2, date) {
  var quota = Math.floor(generateConfig2.getMonth(date) / 3);
  return quota + 1;
}
function isSameQuarter(generateConfig2, quarter1, quarter2) {
  var equal = isNullEqual(quarter1, quarter2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2);
}
function isSameMonth(generateConfig2, month1, month2) {
  var equal = isNullEqual(month1, month2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2);
}
function isSameDate(generateConfig2, date1, date2) {
  var equal = isNullEqual(date1, date2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getYear(date1) === generateConfig2.getYear(date2) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date2) && generateConfig2.getDate(date1) === generateConfig2.getDate(date2);
}
function isSameTime(generateConfig2, time1, time2) {
  var equal = isNullEqual(time1, time2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2);
}
function isSameWeek(generateConfig2, locale2, date1, date2) {
  var equal = isNullEqual(date1, date2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.locale.getWeek(locale2, date1) === generateConfig2.locale.getWeek(locale2, date2);
}
function isEqual(generateConfig2, value1, value2) {
  return isSameDate(generateConfig2, value1, value2) && isSameTime(generateConfig2, value1, value2);
}
function isInRange(generateConfig2, startDate, endDate, current2) {
  if (!startDate || !endDate || !current2) {
    return false;
  }
  return !isSameDate(generateConfig2, startDate, current2) && !isSameDate(generateConfig2, endDate, current2) && generateConfig2.isAfter(current2, startDate) && generateConfig2.isAfter(endDate, current2);
}
function getWeekStartDate(locale2, generateConfig2, value) {
  var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2);
  var monthStartDate = generateConfig2.setDate(value, 1);
  var startDateWeekDay = generateConfig2.getWeekDay(monthStartDate);
  var alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
  if (generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1) {
    alignStartDate = generateConfig2.addDate(alignStartDate, -7);
  }
  return alignStartDate;
}
function getClosingViewDate(viewDate, picker, generateConfig2) {
  var offset3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  switch (picker) {
    case "year":
      return generateConfig2.addYear(viewDate, offset3 * 10);
    case "quarter":
    case "month":
      return generateConfig2.addYear(viewDate, offset3);
    default:
      return generateConfig2.addMonth(viewDate, offset3);
  }
}
function formatValue(value, _ref) {
  var generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, format2 = _ref.format;
  return typeof format2 === "function" ? format2(value) : generateConfig2.locale.format(locale2.locale, value, format2);
}
function parseValue(value, _ref2) {
  var generateConfig2 = _ref2.generateConfig, locale2 = _ref2.locale, formatList = _ref2.formatList;
  if (!value || typeof formatList[0] === "function") {
    return null;
  }
  return generateConfig2.locale.parse(locale2.locale, value, formatList);
}
function getCellDateDisabled(_ref3) {
  var cellDate = _ref3.cellDate, mode = _ref3.mode, disabledDate = _ref3.disabledDate, generateConfig2 = _ref3.generateConfig;
  if (!disabledDate)
    return false;
  var getDisabledFromRange = function getDisabledFromRange2(currentMode, start, end) {
    var current2 = start;
    while (current2 <= end) {
      var date = void 0;
      switch (currentMode) {
        case "date": {
          date = generateConfig2.setDate(cellDate, current2);
          if (!disabledDate(date)) {
            return false;
          }
          break;
        }
        case "month": {
          date = generateConfig2.setMonth(cellDate, current2);
          if (!getCellDateDisabled({
            cellDate: date,
            mode: "month",
            generateConfig: generateConfig2,
            disabledDate
          })) {
            return false;
          }
          break;
        }
        case "year": {
          date = generateConfig2.setYear(cellDate, current2);
          if (!getCellDateDisabled({
            cellDate: date,
            mode: "year",
            generateConfig: generateConfig2,
            disabledDate
          })) {
            return false;
          }
          break;
        }
      }
      current2 += 1;
    }
    return true;
  };
  switch (mode) {
    case "date":
    case "week": {
      return disabledDate(cellDate);
    }
    case "month": {
      var startDate = 1;
      var endDate = generateConfig2.getDate(generateConfig2.getEndDate(cellDate));
      return getDisabledFromRange("date", startDate, endDate);
    }
    case "quarter": {
      var startMonth = Math.floor(generateConfig2.getMonth(cellDate) / 3) * 3;
      var endMonth = startMonth + 2;
      return getDisabledFromRange("month", startMonth, endMonth);
    }
    case "year": {
      return getDisabledFromRange("month", 0, 11);
    }
    case "decade": {
      var year = generateConfig2.getYear(cellDate);
      var startYear = Math.floor(year / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
      var endYear = startYear + DECADE_UNIT_DIFF - 1;
      return getDisabledFromRange("year", startYear, endYear);
    }
  }
}
function TimeHeader(_props) {
  var props2 = useMergeProps(_props);
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader.value) {
    return null;
  }
  var prefixCls = props2.prefixCls, generateConfig2 = props2.generateConfig, locale2 = props2.locale, value = props2.value, format2 = props2.format;
  var headerPrefixCls = "".concat(prefixCls, "-header");
  return Vue.createVNode(Header, {
    "prefixCls": headerPrefixCls
  }, {
    default: function _default5() {
      return [value ? formatValue(value, {
        locale: locale2,
        format: format2,
        generateConfig: generateConfig2
      }) : "\xA0"];
    }
  });
}
TimeHeader.displayName = "TimeHeader";
TimeHeader.inheritAttrs = false;
var TimeUnitColumn = Vue.defineComponent({
  name: "TimeUnitColumn",
  props: ["prefixCls", "units", "onSelect", "value", "active", "hideDisabledOptions"],
  setup: function setup150(props2) {
    var _useInjectPanel = useInjectPanel(), open2 = _useInjectPanel.open;
    var ulRef = Vue.ref(null);
    var liRefs = Vue.ref(/* @__PURE__ */ new Map());
    var scrollRef = Vue.ref();
    Vue.watch(function() {
      return props2.value;
    }, function() {
      var li = liRefs.value.get(props2.value);
      if (li && open2.value !== false) {
        scrollTo(ulRef.value, li.offsetTop, 120);
      }
    });
    Vue.onBeforeUnmount(function() {
      var _a;
      (_a = scrollRef.value) === null || _a === void 0 ? void 0 : _a.call(scrollRef);
    });
    Vue.watch(open2, function() {
      var _a;
      (_a = scrollRef.value) === null || _a === void 0 ? void 0 : _a.call(scrollRef);
      Vue.nextTick(function() {
        if (open2.value) {
          var li = liRefs.value.get(props2.value);
          if (li) {
            scrollRef.value = waitElementReady(li, function() {
              scrollTo(ulRef.value, li.offsetTop, 0);
            });
          }
        }
      });
    }, {
      immediate: true,
      flush: "post"
    });
    return function() {
      var prefixCls = props2.prefixCls, units = props2.units, onSelect = props2.onSelect, value = props2.value, active = props2.active, hideDisabledOptions = props2.hideDisabledOptions;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      return Vue.createVNode("ul", {
        "class": classNames("".concat(prefixCls, "-column"), _defineProperty$T({}, "".concat(prefixCls, "-column-active"), active)),
        "ref": ulRef,
        "style": {
          position: "relative"
        }
      }, [units.map(function(unit) {
        var _classNames2;
        if (hideDisabledOptions && unit.disabled) {
          return null;
        }
        return Vue.createVNode("li", {
          "key": unit.value,
          "ref": function ref(element) {
            liRefs.value.set(unit.value, element);
          },
          "class": classNames(cellPrefixCls, (_classNames2 = {}, _defineProperty$T(_classNames2, "".concat(cellPrefixCls, "-disabled"), unit.disabled), _defineProperty$T(_classNames2, "".concat(cellPrefixCls, "-selected"), value === unit.value), _classNames2)),
          "onClick": function onClick2() {
            if (unit.disabled) {
              return;
            }
            onSelect(unit.value);
          }
        }, [Vue.createVNode("div", {
          "class": "".concat(cellPrefixCls, "-inner")
        }, [unit.label])]);
      })]);
    };
  }
});
function leftPad(str, length) {
  var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  var current2 = String(str);
  while (current2.length < length) {
    current2 = "".concat(fill).concat(str);
  }
  return current2;
}
var tuple = function tuple3() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args;
};
function toArray$1(val) {
  if (val === null || val === void 0) {
    return [];
  }
  return Array.isArray(val) ? val : [val];
}
function getDataOrAriaProps(props2) {
  var retProps = {};
  Object.keys(props2).forEach(function(key2) {
    if ((key2.substr(0, 5) === "data-" || key2.substr(0, 5) === "aria-" || key2 === "role" || key2 === "name") && key2.substr(0, 7) !== "data-__") {
      retProps[key2] = props2[key2];
    }
  });
  return retProps;
}
function getValue(values, index2) {
  return values ? values[index2] : null;
}
function updateValues(values, value, index2) {
  var newValues = [getValue(values, 0), getValue(values, 1)];
  newValues[index2] = typeof value === "function" ? value(newValues[index2]) : value;
  if (!newValues[0] && !newValues[1]) {
    return null;
  }
  return newValues;
}
function generateUnits(start, end, step, disabledUnits) {
  var units = [];
  for (var i2 = start; i2 <= end; i2 += step) {
    units.push({
      label: leftPad(i2, 2),
      value: i2,
      disabled: (disabledUnits || []).includes(i2)
    });
  }
  return units;
}
var TimeBody = Vue.defineComponent({
  name: "TimeBody",
  inheritAttrs: false,
  props: ["generateConfig", "prefixCls", "operationRef", "activeColumnIndex", "value", "showHour", "showMinute", "showSecond", "use12Hours", "hourStep", "minuteStep", "secondStep", "disabledHours", "disabledMinutes", "disabledSeconds", "disabledTime", "hideDisabledOptions", "onSelect"],
  setup: function setup151(props2) {
    var originHour = Vue.computed(function() {
      return props2.value ? props2.generateConfig.getHour(props2.value) : -1;
    });
    var isPM = Vue.computed(function() {
      if (props2.use12Hours) {
        return originHour.value >= 12;
      } else {
        return false;
      }
    });
    var hour = Vue.computed(function() {
      if (props2.use12Hours) {
        return originHour.value % 12;
      } else {
        return originHour.value;
      }
    });
    var minute = Vue.computed(function() {
      return props2.value ? props2.generateConfig.getMinute(props2.value) : -1;
    });
    var second = Vue.computed(function() {
      return props2.value ? props2.generateConfig.getSecond(props2.value) : -1;
    });
    var now2 = Vue.ref(props2.generateConfig.getNow());
    var mergedDisabledHours = Vue.ref();
    var mergedDisabledMinutes = Vue.ref();
    var mergedDisabledSeconds = Vue.ref();
    Vue.onBeforeUpdate(function() {
      now2.value = props2.generateConfig.getNow();
    });
    Vue.watchEffect(function() {
      if (props2.disabledTime) {
        var disabledConfig = props2.disabledTime(now2);
        var _ref = [disabledConfig.disabledHours, disabledConfig.disabledMinutes, disabledConfig.disabledSeconds];
        mergedDisabledHours.value = _ref[0];
        mergedDisabledMinutes.value = _ref[1];
        mergedDisabledSeconds.value = _ref[2];
      } else {
        var _ref2 = [props2.disabledHours, props2.disabledMinutes, props2.disabledSeconds];
        mergedDisabledHours.value = _ref2[0];
        mergedDisabledMinutes.value = _ref2[1];
        mergedDisabledSeconds.value = _ref2[2];
      }
    });
    var setTime$1 = function setTime$12(isNewPM, newHour, newMinute, newSecond) {
      var newDate = props2.value || props2.generateConfig.getNow();
      var mergedHour = Math.max(0, newHour);
      var mergedMinute = Math.max(0, newMinute);
      var mergedSecond = Math.max(0, newSecond);
      newDate = setTime(props2.generateConfig, newDate, !props2.use12Hours || !isNewPM ? mergedHour : mergedHour + 12, mergedMinute, mergedSecond);
      return newDate;
    };
    var rawHours = Vue.computed(function() {
      var _a;
      return generateUnits(0, 23, (_a = props2.hourStep) !== null && _a !== void 0 ? _a : 1, mergedDisabledHours.value && mergedDisabledHours.value());
    });
    var AMPMDisabled = Vue.computed(function() {
      if (!props2.use12Hours) {
        return [false, false];
      }
      var AMPMDisabled2 = [true, true];
      rawHours.value.forEach(function(_ref3) {
        var disabled = _ref3.disabled, hourValue = _ref3.value;
        if (disabled)
          return;
        if (hourValue >= 12) {
          AMPMDisabled2[1] = false;
        } else {
          AMPMDisabled2[0] = false;
        }
      });
      return AMPMDisabled2;
    });
    var hours = Vue.computed(function() {
      if (!props2.use12Hours)
        return rawHours.value;
      return rawHours.value.filter(isPM.value ? function(hourMeta) {
        return hourMeta.value >= 12;
      } : function(hourMeta) {
        return hourMeta.value < 12;
      }).map(function(hourMeta) {
        var hourValue = hourMeta.value % 12;
        var hourLabel = hourValue === 0 ? "12" : leftPad(hourValue, 2);
        return _extends(_extends({}, hourMeta), {
          label: hourLabel,
          value: hourValue
        });
      });
    });
    var minutes = Vue.computed(function() {
      var _a;
      return generateUnits(0, 59, (_a = props2.minuteStep) !== null && _a !== void 0 ? _a : 1, mergedDisabledMinutes.value && mergedDisabledMinutes.value(originHour.value));
    });
    var seconds = Vue.computed(function() {
      var _a;
      return generateUnits(0, 59, (_a = props2.secondStep) !== null && _a !== void 0 ? _a : 1, mergedDisabledSeconds.value && mergedDisabledSeconds.value(originHour.value, minute));
    });
    return function() {
      var prefixCls = props2.prefixCls, operationRef = props2.operationRef, activeColumnIndex = props2.activeColumnIndex, showHour = props2.showHour, showMinute = props2.showMinute, showSecond = props2.showSecond, use12Hours = props2.use12Hours, hideDisabledOptions = props2.hideDisabledOptions, onSelect = props2.onSelect;
      var columns = [];
      var contentPrefixCls = "".concat(prefixCls, "-content");
      var columnPrefixCls = "".concat(prefixCls, "-time-panel");
      operationRef.value = {
        onUpDown: function onUpDown(diff) {
          var column = columns[activeColumnIndex];
          if (column) {
            var valueIndex = column.units.findIndex(function(unit) {
              return unit.value === column.value;
            });
            var unitLen = column.units.length;
            for (var i2 = 1; i2 < unitLen; i2 += 1) {
              var nextUnit = column.units[(valueIndex + diff * i2 + unitLen) % unitLen];
              if (nextUnit.disabled !== true) {
                column.onSelect(nextUnit.value);
                break;
              }
            }
          }
        }
      };
      function addColumnNode(condition, node, columnValue, units, onColumnSelect) {
        if (condition !== false) {
          columns.push({
            node: cloneElement(node, {
              prefixCls: columnPrefixCls,
              value: columnValue,
              active: activeColumnIndex === columns.length,
              onSelect: onColumnSelect,
              units,
              hideDisabledOptions
            }),
            onSelect: onColumnSelect,
            value: columnValue,
            units
          });
        }
      }
      addColumnNode(showHour, Vue.createVNode(TimeUnitColumn, {
        "key": "hour"
      }, null), hour.value, hours.value, function(num) {
        onSelect(setTime$1(isPM.value, num, minute.value, second.value), "mouse");
      });
      addColumnNode(showMinute, Vue.createVNode(TimeUnitColumn, {
        "key": "minute"
      }, null), minute.value, minutes.value, function(num) {
        onSelect(setTime$1(isPM.value, hour.value, num, second.value), "mouse");
      });
      addColumnNode(showSecond, Vue.createVNode(TimeUnitColumn, {
        "key": "second"
      }, null), second.value, seconds.value, function(num) {
        onSelect(setTime$1(isPM.value, hour.value, minute.value, num), "mouse");
      });
      var PMIndex = -1;
      if (typeof isPM.value === "boolean") {
        PMIndex = isPM.value ? 1 : 0;
      }
      addColumnNode(use12Hours === true, Vue.createVNode(TimeUnitColumn, {
        "key": "12hours"
      }, null), PMIndex, [{
        label: "AM",
        value: 0,
        disabled: AMPMDisabled.value[0]
      }, {
        label: "PM",
        value: 1,
        disabled: AMPMDisabled.value[1]
      }], function(num) {
        onSelect(setTime$1(!!num, hour.value, minute.value, second.value), "mouse");
      });
      return Vue.createVNode("div", {
        "class": contentPrefixCls
      }, [columns.map(function(_ref4) {
        var node = _ref4.node;
        return node;
      })]);
    };
  }
});
var TimeBody$1 = TimeBody;
var countBoolean = function countBoolean2(boolList) {
  return boolList.filter(function(bool) {
    return bool !== false;
  }).length;
};
function TimePanel(_props) {
  var props2 = useMergeProps(_props);
  var generateConfig2 = props2.generateConfig, _props$format = props2.format, format2 = _props$format === void 0 ? "HH:mm:ss" : _props$format, prefixCls = props2.prefixCls, active = props2.active, operationRef = props2.operationRef, showHour = props2.showHour, showMinute = props2.showMinute, showSecond = props2.showSecond, _props$use12Hours = props2.use12Hours, use12Hours = _props$use12Hours === void 0 ? false : _props$use12Hours, onSelect = props2.onSelect, value = props2.value;
  var panelPrefixCls = "".concat(prefixCls, "-time-panel");
  var bodyOperationRef = Vue.ref();
  var activeColumnIndex = Vue.ref(-1);
  var columnsCount = countBoolean([showHour, showMinute, showSecond, use12Hours]);
  operationRef.value = {
    onKeydown: function onKeydown(event) {
      return createKeydownHandler(event, {
        onLeftRight: function onLeftRight(diff) {
          activeColumnIndex.value = (activeColumnIndex.value + diff + columnsCount) % columnsCount;
        },
        onUpDown: function onUpDown(diff) {
          if (activeColumnIndex.value === -1) {
            activeColumnIndex.value = 0;
          } else if (bodyOperationRef.value) {
            bodyOperationRef.value.onUpDown(diff);
          }
        },
        onEnter: function onEnter() {
          onSelect(value || generateConfig2.getNow(), "key");
          activeColumnIndex.value = -1;
        }
      });
    },
    onBlur: function onBlur2() {
      activeColumnIndex.value = -1;
    }
  };
  return Vue.createVNode("div", {
    "class": classNames(panelPrefixCls, _defineProperty$T({}, "".concat(panelPrefixCls, "-active"), active))
  }, [Vue.createVNode(TimeHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "format": format2,
    "prefixCls": prefixCls
  }), null), Vue.createVNode(TimeBody$1, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "activeColumnIndex": activeColumnIndex.value,
    "operationRef": bodyOperationRef
  }), null)]);
}
TimePanel.displayName = "TimePanel";
TimePanel.inheritAttrs = false;
function useCellClassName(_ref) {
  var cellPrefixCls = _ref.cellPrefixCls, generateConfig2 = _ref.generateConfig, rangedValue = _ref.rangedValue, hoverRangedValue = _ref.hoverRangedValue, isInView = _ref.isInView, isSameCell = _ref.isSameCell, offsetCell = _ref.offsetCell, today = _ref.today, value = _ref.value;
  function getClassName(currentDate) {
    var _ref2;
    var prevDate = offsetCell(currentDate, -1);
    var nextDate = offsetCell(currentDate, 1);
    var rangeStart = getValue(rangedValue, 0);
    var rangeEnd = getValue(rangedValue, 1);
    var hoverStart = getValue(hoverRangedValue, 0);
    var hoverEnd = getValue(hoverRangedValue, 1);
    var isRangeHovered = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate);
    function isRangeStart(date) {
      return isSameCell(rangeStart, date);
    }
    function isRangeEnd(date) {
      return isSameCell(rangeEnd, date);
    }
    var isHoverStart = isSameCell(hoverStart, currentDate);
    var isHoverEnd = isSameCell(hoverEnd, currentDate);
    var isHoverEdgeStart = (isRangeHovered || isHoverEnd) && (!isInView(prevDate) || isRangeEnd(prevDate));
    var isHoverEdgeEnd = (isRangeHovered || isHoverStart) && (!isInView(nextDate) || isRangeStart(nextDate));
    return _ref2 = {}, _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-in-view"), isInView(currentDate)), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-in-range"), isInRange(generateConfig2, rangeStart, rangeEnd, currentDate)), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-start"), isRangeStart(currentDate)), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-end"), isRangeEnd(currentDate)), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-start-single"), isRangeStart(currentDate) && !rangeEnd), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-end-single"), isRangeEnd(currentDate) && !rangeStart), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-start-near-hover"), isRangeStart(currentDate) && (isSameCell(prevDate, hoverStart) || isInRange(generateConfig2, hoverStart, hoverEnd, prevDate))), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-end-near-hover"), isRangeEnd(currentDate) && (isSameCell(nextDate, hoverEnd) || isInRange(generateConfig2, hoverStart, hoverEnd, nextDate))), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-hover"), isRangeHovered), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-hover-start"), isHoverStart), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-hover-end"), isHoverEnd), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-start"), isHoverEdgeStart), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-end"), isHoverEdgeEnd), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-start-near-range"), isHoverEdgeStart && isSameCell(prevDate, rangeEnd)), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-end-near-range"), isHoverEdgeEnd && isSameCell(nextDate, rangeStart)), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-today"), isSameCell(today, currentDate)), _defineProperty$T(_ref2, "".concat(cellPrefixCls, "-selected"), isSameCell(value, currentDate)), _ref2;
  }
  return getClassName;
}
var RangeContextKey = Symbol("RangeContextProps");
var useProvideRange = function useProvideRange2(props2) {
  Vue.provide(RangeContextKey, props2);
};
var useInjectRange = function useInjectRange2() {
  return Vue.inject(RangeContextKey, {
    rangedValue: Vue.ref(),
    hoverRangedValue: Vue.ref(),
    inRange: Vue.ref(),
    panelPosition: Vue.ref()
  });
};
var RangeContextProvider = Vue.defineComponent({
  name: "PanelContextProvider",
  inheritAttrs: false,
  props: {
    value: {
      type: Object,
      default: function _default4() {
        return {};
      }
    }
  },
  setup: function setup152(props2, _ref) {
    var slots = _ref.slots;
    var value = {
      rangedValue: Vue.ref(props2.value.rangedValue),
      hoverRangedValue: Vue.ref(props2.value.hoverRangedValue),
      inRange: Vue.ref(props2.value.inRange),
      panelPosition: Vue.ref(props2.value.panelPosition)
    };
    useProvideRange(value);
    Vue.toRef;
    Vue.watch(function() {
      return props2.value;
    }, function() {
      Object.keys(props2.value).forEach(function(key2) {
        if (value[key2]) {
          value[key2].value = props2.value[key2];
        }
      });
    });
    return function() {
      var _a;
      return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
    };
  }
});
function DateBody(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, generateConfig2 = props2.generateConfig, prefixColumn = props2.prefixColumn, locale2 = props2.locale, rowCount = props2.rowCount, viewDate = props2.viewDate, value = props2.value, dateRender = props2.dateRender;
  var _useInjectRange = useInjectRange(), rangedValue = _useInjectRange.rangedValue, hoverRangedValue = _useInjectRange.hoverRangedValue;
  var baseDate = getWeekStartDate(locale2.locale, generateConfig2, viewDate);
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2.locale);
  var today = generateConfig2.getNow();
  var headerCells = [];
  var weekDaysLocale = locale2.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale2.locale) : []);
  if (prefixColumn) {
    headerCells.push(Vue.createVNode("th", {
      "key": "empty",
      "aria-label": "empty cell"
    }, null));
  }
  for (var i2 = 0; i2 < WEEK_DAY_COUNT; i2 += 1) {
    headerCells.push(Vue.createVNode("th", {
      "key": i2
    }, [weekDaysLocale[(i2 + weekFirstDay) % WEEK_DAY_COUNT]]));
  }
  var getCellClassName = useCellClassName({
    cellPrefixCls,
    today,
    value,
    generateConfig: generateConfig2,
    rangedValue: prefixColumn ? null : rangedValue.value,
    hoverRangedValue: prefixColumn ? null : hoverRangedValue.value,
    isSameCell: function isSameCell(current2, target) {
      return isSameDate(generateConfig2, current2, target);
    },
    isInView: function isInView(date) {
      return isSameMonth(generateConfig2, date, viewDate);
    },
    offsetCell: function offsetCell(date, offset3) {
      return generateConfig2.addDate(date, offset3);
    }
  });
  var getCellNode = dateRender ? function(date) {
    return dateRender({
      current: date,
      today
    });
  } : void 0;
  return Vue.createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "rowNum": rowCount,
    "colNum": WEEK_DAY_COUNT,
    "baseDate": baseDate,
    "getCellNode": getCellNode,
    "getCellText": generateConfig2.getDate,
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addDate,
    "titleCell": function titleCell(date) {
      return formatValue(date, {
        locale: locale2,
        format: "YYYY-MM-DD",
        generateConfig: generateConfig2
      });
    },
    "headerCells": headerCells
  }), null);
}
DateBody.displayName = "DateBody";
DateBody.inheritAttrs = false;
DateBody.props = [
  "prefixCls",
  "generateConfig",
  "value?",
  "viewDate",
  "locale",
  "rowCount",
  "onSelect",
  "dateRender?",
  "disabledDate?",
  "prefixColumn?",
  "rowClassName?"
];
function DateHeader(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, generateConfig2 = props2.generateConfig, locale2 = props2.locale, viewDate = props2.viewDate, onNextMonth = props2.onNextMonth, onPrevMonth = props2.onPrevMonth, onNextYear = props2.onNextYear, onPrevYear = props2.onPrevYear, onYearClick = props2.onYearClick, onMonthClick = props2.onMonthClick;
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader.value) {
    return null;
  }
  var headerPrefixCls = "".concat(prefixCls, "-header");
  var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
  var month = generateConfig2.getMonth(viewDate);
  var yearNode = Vue.createVNode("button", {
    "type": "button",
    "key": "year",
    "onClick": onYearClick,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-year-btn")
  }, [formatValue(viewDate, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  })]);
  var monthNode = Vue.createVNode("button", {
    "type": "button",
    "key": "month",
    "onClick": onMonthClick,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-month-btn")
  }, [locale2.monthFormat ? formatValue(viewDate, {
    locale: locale2,
    format: locale2.monthFormat,
    generateConfig: generateConfig2
  }) : monthsLocale[month]]);
  var monthYearNodes = locale2.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
  return Vue.createVNode(Header, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onPrev": onPrevMonth,
    "onNext": onNextMonth,
    "onSuperNext": onNextYear
  }), {
    default: function _default5() {
      return [monthYearNodes];
    }
  });
}
DateHeader.displayName = "DateHeader";
DateHeader.inheritAttrs = false;
var DATE_ROW_COUNT = 6;
function DatePanel(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, _props$panelName = props2.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, keyboardConfig = props2.keyboardConfig, active = props2.active, operationRef = props2.operationRef, generateConfig2 = props2.generateConfig, value = props2.value, viewDate = props2.viewDate, onViewDateChange = props2.onViewDateChange, onPanelChange = props2.onPanelChange, _onSelect = props2.onSelect;
  var panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel");
  operationRef.value = {
    onKeydown: function onKeydown(event) {
      return createKeydownHandler(event, _extends({
        onLeftRight: function onLeftRight(diff) {
          _onSelect(generateConfig2.addDate(value || viewDate, diff), "key");
        },
        onCtrlLeftRight: function onCtrlLeftRight(diff) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
        },
        onUpDown: function onUpDown(diff) {
          _onSelect(generateConfig2.addDate(value || viewDate, diff * WEEK_DAY_COUNT), "key");
        },
        onPageUpDown: function onPageUpDown(diff) {
          _onSelect(generateConfig2.addMonth(value || viewDate, diff), "key");
        }
      }, keyboardConfig));
    }
  };
  var onYearChange = function onYearChange2(diff) {
    var newDate = generateConfig2.addYear(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  var onMonthChange = function onMonthChange2(diff) {
    var newDate = generateConfig2.addMonth(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return Vue.createVNode("div", {
    "class": classNames(panelPrefixCls, _defineProperty$T({}, "".concat(panelPrefixCls, "-active"), active))
  }, [Vue.createVNode(DateHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "value": value,
    "viewDate": viewDate,
    "onPrevYear": function onPrevYear() {
      onYearChange(-1);
    },
    "onNextYear": function onNextYear() {
      onYearChange(1);
    },
    "onPrevMonth": function onPrevMonth() {
      onMonthChange(-1);
    },
    "onNextMonth": function onNextMonth() {
      onMonthChange(1);
    },
    "onMonthClick": function onMonthClick() {
      onPanelChange("month", viewDate);
    },
    "onYearClick": function onYearClick() {
      onPanelChange("year", viewDate);
    }
  }), null), Vue.createVNode(DateBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "onSelect": function onSelect(date) {
      return _onSelect(date, "mouse");
    },
    "prefixCls": prefixCls,
    "value": value,
    "viewDate": viewDate,
    "rowCount": DATE_ROW_COUNT
  }), null)]);
}
DatePanel.displayName = "DatePanel";
DatePanel.inheritAttrs = false;
var ACTIVE_PANEL = tuple("date", "time");
function DatetimePanel(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, operationRef = props2.operationRef, generateConfig2 = props2.generateConfig, value = props2.value, defaultValue = props2.defaultValue, disabledTime = props2.disabledTime, showTime = props2.showTime, onSelect = props2.onSelect;
  var panelPrefixCls = "".concat(prefixCls, "-datetime-panel");
  var activePanel = Vue.ref(null);
  var dateOperationRef = Vue.ref({});
  var timeOperationRef = Vue.ref({});
  var timeProps = _typeof$1(showTime) === "object" ? _extends({}, showTime) : {};
  function getNextActive(offset3) {
    var activeIndex = ACTIVE_PANEL.indexOf(activePanel.value) + offset3;
    var nextActivePanel = ACTIVE_PANEL[activeIndex] || null;
    return nextActivePanel;
  }
  var onBlur2 = function onBlur3(e2) {
    if (timeOperationRef.value.onBlur) {
      timeOperationRef.value.onBlur(e2);
    }
    activePanel.value = null;
  };
  operationRef.value = {
    onKeydown: function onKeydown(event) {
      if (event.which === KeyCode$1.TAB) {
        var nextActivePanel = getNextActive(event.shiftKey ? -1 : 1);
        activePanel.value = nextActivePanel;
        if (nextActivePanel) {
          event.preventDefault();
        }
        return true;
      }
      if (activePanel.value) {
        var _ref = activePanel.value === "date" ? dateOperationRef : timeOperationRef;
        if (_ref.value && _ref.value.onKeydown) {
          _ref.value.onKeydown(event);
        }
        return true;
      }
      if ([KeyCode$1.LEFT, KeyCode$1.RIGHT, KeyCode$1.UP, KeyCode$1.DOWN].includes(event.which)) {
        activePanel.value = "date";
        return true;
      }
      return false;
    },
    onBlur: onBlur2,
    onClose: onBlur2
  };
  var onInternalSelect = function onInternalSelect2(date, source) {
    var selectedDate = date;
    if (source === "date" && !value && timeProps.defaultValue) {
      selectedDate = generateConfig2.setHour(selectedDate, generateConfig2.getHour(timeProps.defaultValue));
      selectedDate = generateConfig2.setMinute(selectedDate, generateConfig2.getMinute(timeProps.defaultValue));
      selectedDate = generateConfig2.setSecond(selectedDate, generateConfig2.getSecond(timeProps.defaultValue));
    } else if (source === "time" && !value && defaultValue) {
      selectedDate = generateConfig2.setYear(selectedDate, generateConfig2.getYear(defaultValue));
      selectedDate = generateConfig2.setMonth(selectedDate, generateConfig2.getMonth(defaultValue));
      selectedDate = generateConfig2.setDate(selectedDate, generateConfig2.getDate(defaultValue));
    }
    if (onSelect) {
      onSelect(selectedDate, "mouse");
    }
  };
  var disabledTimes = disabledTime ? disabledTime(value || null) : {};
  return Vue.createVNode("div", {
    "class": classNames(panelPrefixCls, _defineProperty$T({}, "".concat(panelPrefixCls, "-active"), activePanel.value))
  }, [Vue.createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "operationRef": dateOperationRef,
    "active": activePanel.value === "date",
    "onSelect": function onSelect2(date) {
      onInternalSelect(setDateTime(generateConfig2, date, !value && _typeof$1(showTime) === "object" ? showTime.defaultValue : null), "date");
    }
  }), null), Vue.createVNode(TimePanel, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "format": void 0
  }, timeProps), disabledTimes), {}, {
    "disabledTime": null,
    "defaultValue": void 0,
    "operationRef": timeOperationRef,
    "active": activePanel.value === "time",
    "onSelect": function onSelect2(date) {
      onInternalSelect(date, "time");
    }
  }), null)]);
}
DatetimePanel.displayName = "DatetimePanel";
DatetimePanel.inheritAttrs = false;
function WeekPanel(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, generateConfig2 = props2.generateConfig, locale2 = props2.locale, value = props2.value;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var prefixColumn = function prefixColumn2(date) {
    return Vue.createVNode("td", {
      "key": "week",
      "class": classNames(cellPrefixCls, "".concat(cellPrefixCls, "-week"))
    }, [generateConfig2.locale.getWeek(locale2.locale, date)]);
  };
  var rowPrefixCls = "".concat(prefixCls, "-week-panel-row");
  var rowClassName = function rowClassName2(date) {
    return classNames(rowPrefixCls, _defineProperty$T({}, "".concat(rowPrefixCls, "-selected"), isSameWeek(generateConfig2, locale2.locale, value, date)));
  };
  return Vue.createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "panelName": "week",
    "prefixColumn": prefixColumn,
    "rowClassName": rowClassName,
    "keyboardConfig": {
      onLeftRight: null
    }
  }), null);
}
WeekPanel.displayName = "WeekPanel";
WeekPanel.inheritAttrs = false;
function MonthHeader(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, generateConfig2 = props2.generateConfig, locale2 = props2.locale, viewDate = props2.viewDate, onNextYear = props2.onNextYear, onPrevYear = props2.onPrevYear, onYearClick = props2.onYearClick;
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader.value) {
    return null;
  }
  var headerPrefixCls = "".concat(prefixCls, "-header");
  return Vue.createVNode(Header, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onSuperNext": onNextYear
  }), {
    default: function _default5() {
      return [Vue.createVNode("button", {
        "type": "button",
        "onClick": onYearClick,
        "class": "".concat(prefixCls, "-year-btn")
      }, [formatValue(viewDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      })])];
    }
  });
}
MonthHeader.displayName = "MonthHeader";
MonthHeader.inheritAttrs = false;
var MONTH_COL_COUNT = 3;
var MONTH_ROW_COUNT = 4;
function MonthBody(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, locale2 = props2.locale, value = props2.value, viewDate = props2.viewDate, generateConfig2 = props2.generateConfig, monthCellRender = props2.monthCellRender;
  var _useInjectRange = useInjectRange(), rangedValue = _useInjectRange.rangedValue, hoverRangedValue = _useInjectRange.hoverRangedValue;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var getCellClassName = useCellClassName({
    cellPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: function isSameCell(current2, target) {
      return isSameMonth(generateConfig2, current2, target);
    },
    isInView: function isInView() {
      return true;
    },
    offsetCell: function offsetCell(date, offset3) {
      return generateConfig2.addMonth(date, offset3);
    }
  });
  var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
  var baseMonth = generateConfig2.setMonth(viewDate, 0);
  var getCellNode = monthCellRender ? function(date) {
    return monthCellRender({
      current: date,
      locale: locale2
    });
  } : void 0;
  return Vue.createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "rowNum": MONTH_ROW_COUNT,
    "colNum": MONTH_COL_COUNT,
    "baseDate": baseMonth,
    "getCellNode": getCellNode,
    "getCellText": function getCellText(date) {
      return locale2.monthFormat ? formatValue(date, {
        locale: locale2,
        format: locale2.monthFormat,
        generateConfig: generateConfig2
      }) : monthsLocale[generateConfig2.getMonth(date)];
    },
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addMonth,
    "titleCell": function titleCell(date) {
      return formatValue(date, {
        locale: locale2,
        format: "YYYY-MM",
        generateConfig: generateConfig2
      });
    }
  }), null);
}
MonthBody.displayName = "MonthBody";
MonthBody.inheritAttrs = false;
function MonthPanel(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, operationRef = props2.operationRef, onViewDateChange = props2.onViewDateChange, generateConfig2 = props2.generateConfig, value = props2.value, viewDate = props2.viewDate, onPanelChange = props2.onPanelChange, _onSelect = props2.onSelect;
  var panelPrefixCls = "".concat(prefixCls, "-month-panel");
  operationRef.value = {
    onKeydown: function onKeydown(event) {
      return createKeydownHandler(event, {
        onLeftRight: function onLeftRight(diff) {
          _onSelect(generateConfig2.addMonth(value || viewDate, diff), "key");
        },
        onCtrlLeftRight: function onCtrlLeftRight(diff) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
        },
        onUpDown: function onUpDown(diff) {
          _onSelect(generateConfig2.addMonth(value || viewDate, diff * MONTH_COL_COUNT), "key");
        },
        onEnter: function onEnter() {
          onPanelChange("date", value || viewDate);
        }
      });
    }
  };
  var onYearChange = function onYearChange2(diff) {
    var newDate = generateConfig2.addYear(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return Vue.createVNode("div", {
    "class": panelPrefixCls
  }, [Vue.createVNode(MonthHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevYear": function onPrevYear() {
      onYearChange(-1);
    },
    "onNextYear": function onNextYear() {
      onYearChange(1);
    },
    "onYearClick": function onYearClick() {
      onPanelChange("year", viewDate);
    }
  }), null), Vue.createVNode(MonthBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": function onSelect(date) {
      _onSelect(date, "mouse");
      onPanelChange("date", date);
    }
  }), null)]);
}
MonthPanel.displayName = "MonthPanel";
MonthPanel.inheritAttrs = false;
function QuarterHeader(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, generateConfig2 = props2.generateConfig, locale2 = props2.locale, viewDate = props2.viewDate, onNextYear = props2.onNextYear, onPrevYear = props2.onPrevYear, onYearClick = props2.onYearClick;
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader.value) {
    return null;
  }
  var headerPrefixCls = "".concat(prefixCls, "-header");
  return Vue.createVNode(Header, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onSuperNext": onNextYear
  }), {
    default: function _default5() {
      return [Vue.createVNode("button", {
        "type": "button",
        "onClick": onYearClick,
        "class": "".concat(prefixCls, "-year-btn")
      }, [formatValue(viewDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      })])];
    }
  });
}
QuarterHeader.displayName = "QuarterHeader";
QuarterHeader.inheritAttrs = false;
var QUARTER_COL_COUNT = 4;
var QUARTER_ROW_COUNT = 1;
function QuarterBody(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, locale2 = props2.locale, value = props2.value, viewDate = props2.viewDate, generateConfig2 = props2.generateConfig;
  var _useInjectRange = useInjectRange(), rangedValue = _useInjectRange.rangedValue, hoverRangedValue = _useInjectRange.hoverRangedValue;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var getCellClassName = useCellClassName({
    cellPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: function isSameCell(current2, target) {
      return isSameQuarter(generateConfig2, current2, target);
    },
    isInView: function isInView() {
      return true;
    },
    offsetCell: function offsetCell(date, offset3) {
      return generateConfig2.addMonth(date, offset3 * 3);
    }
  });
  var baseQuarter = generateConfig2.setDate(generateConfig2.setMonth(viewDate, 0), 1);
  return Vue.createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "rowNum": QUARTER_ROW_COUNT,
    "colNum": QUARTER_COL_COUNT,
    "baseDate": baseQuarter,
    "getCellText": function getCellText(date) {
      return formatValue(date, {
        locale: locale2,
        format: locale2.quarterFormat || "[Q]Q",
        generateConfig: generateConfig2
      });
    },
    "getCellClassName": getCellClassName,
    "getCellDate": function getCellDate(date, offset3) {
      return generateConfig2.addMonth(date, offset3 * 3);
    },
    "titleCell": function titleCell(date) {
      return formatValue(date, {
        locale: locale2,
        format: "YYYY-[Q]Q",
        generateConfig: generateConfig2
      });
    }
  }), null);
}
QuarterBody.displayName = "QuarterBody";
QuarterBody.inheritAttrs = false;
function QuarterPanel(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, operationRef = props2.operationRef, onViewDateChange = props2.onViewDateChange, generateConfig2 = props2.generateConfig, value = props2.value, viewDate = props2.viewDate, onPanelChange = props2.onPanelChange, _onSelect = props2.onSelect;
  var panelPrefixCls = "".concat(prefixCls, "-quarter-panel");
  operationRef.value = {
    onKeydown: function onKeydown(event) {
      return createKeydownHandler(event, {
        onLeftRight: function onLeftRight(diff) {
          _onSelect(generateConfig2.addMonth(value || viewDate, diff * 3), "key");
        },
        onCtrlLeftRight: function onCtrlLeftRight(diff) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
        },
        onUpDown: function onUpDown(diff) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
        }
      });
    }
  };
  var onYearChange = function onYearChange2(diff) {
    var newDate = generateConfig2.addYear(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return Vue.createVNode("div", {
    "class": panelPrefixCls
  }, [Vue.createVNode(QuarterHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevYear": function onPrevYear() {
      onYearChange(-1);
    },
    "onNextYear": function onNextYear() {
      onYearChange(1);
    },
    "onYearClick": function onYearClick() {
      onPanelChange("year", viewDate);
    }
  }), null), Vue.createVNode(QuarterBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": function onSelect(date) {
      _onSelect(date, "mouse");
    }
  }), null)]);
}
QuarterPanel.displayName = "QuarterPanel";
QuarterPanel.inheritAttrs = false;
function YearHeader(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, generateConfig2 = props2.generateConfig, viewDate = props2.viewDate, onPrevDecade = props2.onPrevDecade, onNextDecade = props2.onNextDecade, onDecadeClick = props2.onDecadeClick;
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader.value) {
    return null;
  }
  var headerPrefixCls = "".concat(prefixCls, "-header");
  var yearNumber = generateConfig2.getYear(viewDate);
  var startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
  var endYear = startYear + YEAR_DECADE_COUNT - 1;
  return Vue.createVNode(Header, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevDecade,
    "onSuperNext": onNextDecade
  }), {
    default: function _default5() {
      return [Vue.createVNode("button", {
        "type": "button",
        "onClick": onDecadeClick,
        "class": "".concat(prefixCls, "-decade-btn")
      }, [startYear, Vue.createTextVNode("-"), endYear])];
    }
  });
}
YearHeader.displayName = "YearHeader";
YearHeader.inheritAttrs = false;
var YEAR_COL_COUNT = 3;
var YEAR_ROW_COUNT = 4;
function YearBody(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, value = props2.value, viewDate = props2.viewDate, locale2 = props2.locale, generateConfig2 = props2.generateConfig;
  var _useInjectRange = useInjectRange(), rangedValue = _useInjectRange.rangedValue, hoverRangedValue = _useInjectRange.hoverRangedValue;
  var yearPrefixCls = "".concat(prefixCls, "-cell");
  var yearNumber = generateConfig2.getYear(viewDate);
  var startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
  var endYear = startYear + YEAR_DECADE_COUNT - 1;
  var baseYear = generateConfig2.setYear(viewDate, startYear - Math.ceil((YEAR_COL_COUNT * YEAR_ROW_COUNT - YEAR_DECADE_COUNT) / 2));
  var isInView = function isInView2(date) {
    var currentYearNumber = generateConfig2.getYear(date);
    return startYear <= currentYearNumber && currentYearNumber <= endYear;
  };
  var getCellClassName = useCellClassName({
    cellPrefixCls: yearPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: function isSameCell(current2, target) {
      return isSameYear(generateConfig2, current2, target);
    },
    isInView,
    offsetCell: function offsetCell(date, offset3) {
      return generateConfig2.addYear(date, offset3);
    }
  });
  return Vue.createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "rowNum": YEAR_ROW_COUNT,
    "colNum": YEAR_COL_COUNT,
    "baseDate": baseYear,
    "getCellText": generateConfig2.getYear,
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addYear,
    "titleCell": function titleCell(date) {
      return formatValue(date, {
        locale: locale2,
        format: "YYYY",
        generateConfig: generateConfig2
      });
    }
  }), null);
}
YearBody.displayName = "YearBody";
YearBody.inheritAttrs = false;
var YEAR_DECADE_COUNT = 10;
function YearPanel(_props) {
  var props2 = useMergeProps(_props);
  var prefixCls = props2.prefixCls, operationRef = props2.operationRef, onViewDateChange = props2.onViewDateChange, generateConfig2 = props2.generateConfig, value = props2.value, viewDate = props2.viewDate, sourceMode = props2.sourceMode, _onSelect = props2.onSelect, onPanelChange = props2.onPanelChange;
  var panelPrefixCls = "".concat(prefixCls, "-year-panel");
  operationRef.value = {
    onKeydown: function onKeydown(event) {
      return createKeydownHandler(event, {
        onLeftRight: function onLeftRight(diff) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
        },
        onCtrlLeftRight: function onCtrlLeftRight(diff) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff * YEAR_DECADE_COUNT), "key");
        },
        onUpDown: function onUpDown(diff) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff * YEAR_COL_COUNT), "key");
        },
        onEnter: function onEnter() {
          onPanelChange(sourceMode === "date" ? "date" : "month", value || viewDate);
        }
      });
    }
  };
  var onDecadeChange = function onDecadeChange2(diff) {
    var newDate = generateConfig2.addYear(viewDate, diff * 10);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return Vue.createVNode("div", {
    "class": panelPrefixCls
  }, [Vue.createVNode(YearHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevDecade": function onPrevDecade() {
      onDecadeChange(-1);
    },
    "onNextDecade": function onNextDecade() {
      onDecadeChange(1);
    },
    "onDecadeClick": function onDecadeClick() {
      onPanelChange("decade", viewDate);
    }
  }), null), Vue.createVNode(YearBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": function onSelect(date) {
      onPanelChange(sourceMode === "date" ? "date" : "month", date);
      _onSelect(date, "mouse");
    }
  }), null)]);
}
YearPanel.displayName = "YearPanel";
YearPanel.inheritAttrs = false;
function getExtraFooter(prefixCls, mode, renderExtraFooter) {
  if (!renderExtraFooter) {
    return null;
  }
  return Vue.createVNode("div", {
    "class": "".concat(prefixCls, "-footer-extra")
  }, [renderExtraFooter(mode)]);
}
function getRanges(_ref) {
  var prefixCls = _ref.prefixCls, _ref$rangeList = _ref.rangeList, rangeList = _ref$rangeList === void 0 ? [] : _ref$rangeList, _ref$components = _ref.components, components2 = _ref$components === void 0 ? {} : _ref$components, needConfirmButton = _ref.needConfirmButton, onNow = _ref.onNow, onOk = _ref.onOk, okDisabled = _ref.okDisabled, showNow = _ref.showNow, locale2 = _ref.locale;
  var presetNode;
  var okNode;
  if (rangeList.length) {
    var Item3 = components2.rangeItem || "span";
    presetNode = Vue.createVNode(Vue.Fragment, null, [rangeList.map(function(_ref2) {
      var label = _ref2.label, onClick2 = _ref2.onClick, onMouseenter2 = _ref2.onMouseenter, onMouseleave2 = _ref2.onMouseleave;
      return Vue.createVNode("li", {
        "key": label,
        "class": "".concat(prefixCls, "-preset")
      }, [Vue.createVNode(Item3, {
        "onClick": onClick2,
        "onMouseenter": onMouseenter2,
        "onMouseleave": onMouseleave2
      }, {
        default: function _default5() {
          return [label];
        }
      })]);
    })]);
  }
  if (needConfirmButton) {
    var Button2 = components2.button || "button";
    if (onNow && !presetNode && showNow !== false) {
      presetNode = Vue.createVNode("li", {
        "class": "".concat(prefixCls, "-now")
      }, [Vue.createVNode("a", {
        "class": "".concat(prefixCls, "-now-btn"),
        "onClick": onNow
      }, [locale2.now])]);
    }
    okNode = needConfirmButton && Vue.createVNode("li", {
      "class": "".concat(prefixCls, "-ok")
    }, [Vue.createVNode(Button2, {
      "disabled": okDisabled,
      "onClick": onOk
    }, {
      default: function _default5() {
        return [locale2.ok];
      }
    })]);
  }
  if (!presetNode && !okNode) {
    return null;
  }
  return Vue.createVNode("ul", {
    "class": "".concat(prefixCls, "-ranges")
  }, [presetNode, okNode]);
}
function PickerPanel() {
  return Vue.defineComponent({
    name: "PickerPanel",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      locale: Object,
      generateConfig: Object,
      value: Object,
      defaultValue: Object,
      pickerValue: Object,
      defaultPickerValue: Object,
      disabledDate: Function,
      mode: String,
      picker: {
        type: String,
        default: "date"
      },
      tabindex: {
        type: [Number, String],
        default: 0
      },
      showNow: {
        type: Boolean,
        default: void 0
      },
      showTime: [Boolean, Object],
      showToday: Boolean,
      renderExtraFooter: Function,
      dateRender: Function,
      hideHeader: {
        type: Boolean,
        default: void 0
      },
      onSelect: Function,
      onChange: Function,
      onPanelChange: Function,
      onMousedown: Function,
      onPickerValueChange: Function,
      onOk: Function,
      components: Object,
      direction: String,
      hourStep: {
        type: Number,
        default: 1
      },
      minuteStep: {
        type: Number,
        default: 1
      },
      secondStep: {
        type: Number,
        default: 1
      }
    },
    setup: function setup153(props2, _ref) {
      var attrs = _ref.attrs;
      var needConfirmButton = Vue.computed(function() {
        return props2.picker === "date" && !!props2.showTime || props2.picker === "time";
      });
      var isHourStepValid = Vue.computed(function() {
        return 24 % props2.hourStep === 0;
      });
      var isMinuteStepValid = Vue.computed(function() {
        return 60 % props2.minuteStep === 0;
      });
      var isSecondStepValid = Vue.computed(function() {
        return 60 % props2.secondStep === 0;
      });
      var panelContext = useInjectPanel();
      var operationRef = panelContext.operationRef, panelDivRef = panelContext.panelRef, onContextSelect = panelContext.onSelect, hideRanges = panelContext.hideRanges, defaultOpenValue = panelContext.defaultOpenValue;
      var _useInjectRange = useInjectRange(), inRange = _useInjectRange.inRange, panelPosition = _useInjectRange.panelPosition, rangedValue = _useInjectRange.rangedValue, hoverRangedValue = _useInjectRange.hoverRangedValue;
      var panelRef = Vue.ref({});
      var _useMergedState = useMergedState(null, {
        value: Vue.toRef(props2, "value"),
        defaultValue: props2.defaultValue,
        postState: function postState(val) {
          if (!val && (defaultOpenValue === null || defaultOpenValue === void 0 ? void 0 : defaultOpenValue.value) && props2.picker === "time") {
            return defaultOpenValue.value;
          }
          return val;
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
      var _useMergedState3 = useMergedState(null, {
        value: Vue.toRef(props2, "pickerValue"),
        defaultValue: props2.defaultPickerValue || mergedValue.value,
        postState: function postState(date) {
          var generateConfig2 = props2.generateConfig, showTime = props2.showTime, defaultValue = props2.defaultValue;
          var now2 = generateConfig2.getNow();
          if (!date)
            return now2;
          if (!mergedValue.value && props2.showTime) {
            if (_typeof$1(showTime) === "object") {
              return setDateTime(generateConfig2, Array.isArray(date) ? date[0] : date, showTime.defaultValue || now2);
            }
            if (defaultValue) {
              return setDateTime(generateConfig2, Array.isArray(date) ? date[0] : date, defaultValue);
            }
            return setDateTime(generateConfig2, Array.isArray(date) ? date[0] : date, now2);
          }
          return date;
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), viewDate = _useMergedState4[0], setInnerViewDate = _useMergedState4[1];
      var setViewDate = function setViewDate2(date) {
        setInnerViewDate(date);
        if (props2.onPickerValueChange) {
          props2.onPickerValueChange(date);
        }
      };
      var getInternalNextMode = function getInternalNextMode2(nextMode) {
        var getNextMode = PickerModeMap[props2.picker];
        if (getNextMode) {
          return getNextMode(nextMode);
        }
        return nextMode;
      };
      var _useMergedState5 = useMergedState(function() {
        if (props2.picker === "time") {
          return "time";
        }
        return getInternalNextMode("date");
      }, {
        value: Vue.toRef(props2, "mode")
      }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedMode = _useMergedState6[0], setInnerMode = _useMergedState6[1];
      Vue.watch(function() {
        return props2.picker;
      }, function() {
        setInnerMode(props2.picker);
      });
      var sourceMode = Vue.ref(mergedMode.value);
      var setSourceMode = function setSourceMode2(val) {
        sourceMode.value = val;
      };
      var onInternalPanelChange = function onInternalPanelChange2(newMode, viewValue) {
        var onPanelChange = props2.onPanelChange, generateConfig2 = props2.generateConfig;
        var nextMode = getInternalNextMode(newMode || mergedMode.value);
        setSourceMode(mergedMode.value);
        setInnerMode(nextMode);
        if (onPanelChange && (mergedMode.value !== nextMode || isEqual(generateConfig2, viewDate.value, viewDate.value))) {
          onPanelChange(viewValue, nextMode);
        }
      };
      var triggerSelect = function triggerSelect2(date, type2) {
        var forceTriggerSelect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var picker = props2.picker, generateConfig2 = props2.generateConfig, onSelect = props2.onSelect, onChange = props2.onChange, disabledDate = props2.disabledDate;
        if (mergedMode.value === picker || forceTriggerSelect) {
          setInnerValue(date);
          if (onSelect) {
            onSelect(date);
          }
          if (onContextSelect) {
            onContextSelect(date, type2);
          }
          if (onChange && !isEqual(generateConfig2, date, mergedValue.value) && !(disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date))) {
            onChange(date);
          }
        }
      };
      var onInternalKeydown = function onInternalKeydown2(e2) {
        if (panelRef.value && panelRef.value.onKeydown) {
          if ([KeyCode$1.LEFT, KeyCode$1.RIGHT, KeyCode$1.UP, KeyCode$1.DOWN, KeyCode$1.PAGE_UP, KeyCode$1.PAGE_DOWN, KeyCode$1.ENTER].includes(e2.which)) {
            e2.preventDefault();
          }
          return panelRef.value.onKeydown(e2);
        }
        {
          return false;
        }
      };
      var onInternalBlur = function onInternalBlur2(e2) {
        if (panelRef.value && panelRef.value.onBlur) {
          panelRef.value.onBlur(e2);
        }
      };
      var onNow = function onNow2() {
        var generateConfig2 = props2.generateConfig, hourStep = props2.hourStep, minuteStep = props2.minuteStep, secondStep = props2.secondStep;
        var now2 = generateConfig2.getNow();
        var lowerBoundTime = getLowerBoundTime(generateConfig2.getHour(now2), generateConfig2.getMinute(now2), generateConfig2.getSecond(now2), isHourStepValid.value ? hourStep : 1, isMinuteStepValid.value ? minuteStep : 1, isSecondStepValid.value ? secondStep : 1);
        var adjustedNow = setTime(generateConfig2, now2, lowerBoundTime[0], lowerBoundTime[1], lowerBoundTime[2]);
        triggerSelect(adjustedNow, "submit");
      };
      var classString = Vue.computed(function() {
        var _classNames;
        var prefixCls = props2.prefixCls, direction = props2.direction;
        return classNames("".concat(prefixCls, "-panel"), (_classNames = {}, _defineProperty$T(_classNames, "".concat(prefixCls, "-panel-has-range"), rangedValue && rangedValue.value && rangedValue.value[0] && rangedValue.value[1]), _defineProperty$T(_classNames, "".concat(prefixCls, "-panel-has-range-hover"), hoverRangedValue && hoverRangedValue.value && hoverRangedValue.value[0] && hoverRangedValue.value[1]), _defineProperty$T(_classNames, "".concat(prefixCls, "-panel-rtl"), direction === "rtl"), _classNames));
      });
      useProvidePanel(_extends(_extends({}, panelContext), {
        mode: mergedMode,
        hideHeader: Vue.computed(function() {
          var _a;
          return props2.hideHeader !== void 0 ? props2.hideHeader : (_a = panelContext.hideHeader) === null || _a === void 0 ? void 0 : _a.value;
        }),
        hidePrevBtn: Vue.computed(function() {
          return inRange.value && panelPosition.value === "right";
        }),
        hideNextBtn: Vue.computed(function() {
          return inRange.value && panelPosition.value === "left";
        })
      }));
      Vue.watch(function() {
        return props2.value;
      }, function() {
        if (props2.value) {
          setInnerViewDate(props2.value);
        }
      });
      return function() {
        var _props$prefixCls = props2.prefixCls, prefixCls = _props$prefixCls === void 0 ? "ant-picker" : _props$prefixCls, locale2 = props2.locale, generateConfig2 = props2.generateConfig, disabledDate = props2.disabledDate, _props$picker = props2.picker, picker = _props$picker === void 0 ? "date" : _props$picker, _props$tabindex = props2.tabindex, tabindex = _props$tabindex === void 0 ? 0 : _props$tabindex, showNow = props2.showNow, showTime = props2.showTime, showToday = props2.showToday, renderExtraFooter = props2.renderExtraFooter, onMousedown2 = props2.onMousedown, _onOk = props2.onOk, components2 = props2.components;
        if (operationRef && panelPosition.value !== "right") {
          operationRef.value = {
            onKeydown: onInternalKeydown,
            onClose: function onClose() {
              if (panelRef.value && panelRef.value.onClose) {
                panelRef.value.onClose();
              }
            }
          };
        }
        var panelNode;
        var pickerProps = _extends(_extends(_extends({}, attrs), props2), {
          operationRef: panelRef,
          prefixCls,
          viewDate: viewDate.value,
          value: mergedValue.value,
          onViewDateChange: setViewDate,
          sourceMode: sourceMode.value,
          onPanelChange: onInternalPanelChange,
          disabledDate
        });
        delete pickerProps.onChange;
        delete pickerProps.onSelect;
        switch (mergedMode.value) {
          case "decade":
            panelNode = Vue.createVNode(DecadePanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": function onSelect(date, type2) {
                setViewDate(date);
                triggerSelect(date, type2);
              }
            }), null);
            break;
          case "year":
            panelNode = Vue.createVNode(YearPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": function onSelect(date, type2) {
                setViewDate(date);
                triggerSelect(date, type2);
              }
            }), null);
            break;
          case "month":
            panelNode = Vue.createVNode(MonthPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": function onSelect(date, type2) {
                setViewDate(date);
                triggerSelect(date, type2);
              }
            }), null);
            break;
          case "quarter":
            panelNode = Vue.createVNode(QuarterPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": function onSelect(date, type2) {
                setViewDate(date);
                triggerSelect(date, type2);
              }
            }), null);
            break;
          case "week":
            panelNode = Vue.createVNode(WeekPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": function onSelect(date, type2) {
                setViewDate(date);
                triggerSelect(date, type2);
              }
            }), null);
            break;
          case "time":
            delete pickerProps.showTime;
            panelNode = Vue.createVNode(TimePanel, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickerProps), _typeof$1(showTime) === "object" ? showTime : null), {}, {
              "onSelect": function onSelect(date, type2) {
                setViewDate(date);
                triggerSelect(date, type2);
              }
            }), null);
            break;
          default:
            if (showTime) {
              panelNode = Vue.createVNode(DatetimePanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
                "onSelect": function onSelect(date, type2) {
                  setViewDate(date);
                  triggerSelect(date, type2);
                }
              }), null);
            } else {
              panelNode = Vue.createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
                "onSelect": function onSelect(date, type2) {
                  setViewDate(date);
                  triggerSelect(date, type2);
                }
              }), null);
            }
        }
        var extraFooter;
        var rangesNode;
        if (!(hideRanges === null || hideRanges === void 0 ? void 0 : hideRanges.value)) {
          extraFooter = getExtraFooter(prefixCls, mergedMode.value, renderExtraFooter);
          rangesNode = getRanges({
            prefixCls,
            components: components2,
            needConfirmButton: needConfirmButton.value,
            okDisabled: !mergedValue.value || disabledDate && disabledDate(mergedValue.value),
            locale: locale2,
            showNow,
            onNow: needConfirmButton.value && onNow,
            onOk: function onOk() {
              if (mergedValue.value) {
                triggerSelect(mergedValue.value, "submit", true);
                if (_onOk) {
                  _onOk(mergedValue.value);
                }
              }
            }
          });
        }
        var todayNode;
        if (showToday && mergedMode.value === "date" && picker === "date" && !showTime) {
          var now2 = generateConfig2.getNow();
          var todayCls = "".concat(prefixCls, "-today-btn");
          var disabled = disabledDate && disabledDate(now2);
          todayNode = Vue.createVNode("a", {
            "class": classNames(todayCls, disabled && "".concat(todayCls, "-disabled")),
            "aria-disabled": disabled,
            "onClick": function onClick2() {
              if (!disabled) {
                triggerSelect(now2, "mouse", true);
              }
            }
          }, [locale2.today]);
        }
        return Vue.createVNode("div", {
          "tabindex": tabindex,
          "class": classNames(classString.value, attrs.class),
          "style": attrs.style,
          "onKeydown": onInternalKeydown,
          "onBlur": onInternalBlur,
          "onMousedown": onMousedown2,
          "ref": panelDivRef
        }, [panelNode, extraFooter || rangesNode || todayNode ? Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-footer")
        }, [extraFooter, rangesNode, todayNode]) : null]);
      };
    }
  });
}
var InterPickerPanel = PickerPanel();
var PickerPanel$1 = function(props2) {
  return Vue.createVNode(InterPickerPanel, props2);
};
var BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
function PickerTrigger(props2, _ref) {
  var _classNames;
  var slots = _ref.slots;
  var _useMergeProps = useMergeProps(props2), prefixCls = _useMergeProps.prefixCls, popupStyle = _useMergeProps.popupStyle, visible = _useMergeProps.visible, dropdownClassName = _useMergeProps.dropdownClassName, dropdownAlign = _useMergeProps.dropdownAlign, transitionName2 = _useMergeProps.transitionName, getPopupContainer = _useMergeProps.getPopupContainer, range = _useMergeProps.range, popupPlacement = _useMergeProps.popupPlacement, direction = _useMergeProps.direction;
  var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
  var getPopupPlacement = function getPopupPlacement2() {
    if (popupPlacement !== void 0) {
      return popupPlacement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  };
  return Vue.createVNode(Trigger, {
    "showAction": [],
    "hideAction": [],
    "popupPlacement": getPopupPlacement(),
    "builtinPlacements": BUILT_IN_PLACEMENTS,
    "prefixCls": dropdownPrefixCls,
    "popupTransitionName": transitionName2,
    "popupAlign": dropdownAlign,
    "popupVisible": visible,
    "popupClassName": classNames(dropdownClassName, (_classNames = {}, _defineProperty$T(_classNames, "".concat(dropdownPrefixCls, "-range"), range), _defineProperty$T(_classNames, "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl"), _classNames)),
    "popupStyle": popupStyle,
    "getPopupContainer": getPopupContainer
  }, {
    default: slots.default,
    popup: slots.popupElement
  });
}
function usePickerInput(_ref) {
  var open2 = _ref.open, value = _ref.value, isClickOutside = _ref.isClickOutside, triggerOpen = _ref.triggerOpen, forwardKeydown = _ref.forwardKeydown, _onKeydown = _ref.onKeydown, blurToCancel = _ref.blurToCancel, onSubmit = _ref.onSubmit, onCancel = _ref.onCancel, _onFocus = _ref.onFocus, _onBlur = _ref.onBlur;
  var typing = Vue.ref(false);
  var focused = Vue.ref(false);
  var preventBlurRef = Vue.ref(false);
  var valueChangedRef = Vue.ref(false);
  var preventDefaultRef = Vue.ref(false);
  var inputProps3 = Vue.computed(function() {
    return {
      onMousedown: function onMousedown2() {
        typing.value = true;
        triggerOpen(true);
      },
      onKeydown: function onKeydown(e2) {
        var preventDefault = function preventDefault2() {
          preventDefaultRef.value = true;
        };
        _onKeydown(e2, preventDefault);
        if (preventDefaultRef.value)
          return;
        switch (e2.which) {
          case KeyCode$1.ENTER: {
            if (!open2.value) {
              triggerOpen(true);
            } else if (onSubmit() !== false) {
              typing.value = true;
            }
            e2.preventDefault();
            return;
          }
          case KeyCode$1.TAB: {
            if (typing.value && open2.value && !e2.shiftKey) {
              typing.value = false;
              e2.preventDefault();
            } else if (!typing.value && open2.value) {
              if (!forwardKeydown(e2) && e2.shiftKey) {
                typing.value = true;
                e2.preventDefault();
              }
            }
            return;
          }
          case KeyCode$1.ESC: {
            typing.value = true;
            onCancel();
            return;
          }
        }
        if (!open2.value && ![KeyCode$1.SHIFT].includes(e2.which)) {
          triggerOpen(true);
        } else if (!typing.value) {
          forwardKeydown(e2);
        }
      },
      onFocus: function onFocus2(e2) {
        typing.value = true;
        focused.value = true;
        if (_onFocus) {
          _onFocus(e2);
        }
      },
      onBlur: function onBlur2(e2) {
        if (preventBlurRef.value || !isClickOutside(document.activeElement)) {
          preventBlurRef.value = false;
          return;
        }
        if (blurToCancel.value) {
          setTimeout(function() {
            var _document = document, activeElement = _document.activeElement;
            while (activeElement && activeElement.shadowRoot) {
              activeElement = activeElement.shadowRoot.activeElement;
            }
            if (isClickOutside(activeElement)) {
              onCancel();
            }
          }, 0);
        } else if (open2.value) {
          triggerOpen(false);
          if (valueChangedRef.value) {
            onSubmit();
          }
        }
        focused.value = false;
        if (_onBlur) {
          _onBlur(e2);
        }
      }
    };
  });
  Vue.watch(open2, function() {
    valueChangedRef.value = false;
  });
  Vue.watch(value, function() {
    valueChangedRef.value = true;
  });
  var globalMousedownEvent = Vue.ref();
  Vue.watchEffect(function() {
    return globalMousedownEvent.value && globalMousedownEvent.value()(globalMousedownEvent.value = addGlobalMousedownEvent(function(e2) {
      var target = getTargetFromEvent(e2);
      if (open2) {
        var clickedOutside = isClickOutside(target);
        if (!clickedOutside) {
          preventBlurRef.value = true;
          wrapperRaf(function() {
            preventBlurRef.value = false;
          });
        } else if (!focused.value || clickedOutside) {
          triggerOpen(false);
        }
      }
    }));
  });
  Vue.onBeforeUnmount(function() {
    globalMousedownEvent.value && globalMousedownEvent.value();
  });
  return [inputProps3, {
    focused,
    typing
  }];
}
function useTextValueMapping(_ref) {
  var valueTexts = _ref.valueTexts, onTextChange = _ref.onTextChange;
  var text = Vue.ref("");
  function triggerTextChange(value) {
    text.value = value;
    onTextChange(value);
  }
  function resetText() {
    text.value = valueTexts.value[0];
  }
  Vue.watch(function() {
    return _toConsumableArray(valueTexts.value);
  }, function(cur) {
    var pre = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (cur.join("||") !== pre.join("||") && valueTexts.value.every(function(valText) {
      return valText !== text.value;
    })) {
      resetText();
    }
  }, {
    immediate: true
  });
  return [text, triggerTextChange, resetText];
}
function useValueTexts(value, _ref) {
  var formatList = _ref.formatList, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale;
  var texts = useMemo(function() {
    if (!value.value) {
      return [[""], ""];
    }
    var firstValueText2 = "";
    var fullValueTexts2 = [];
    for (var i2 = 0; i2 < formatList.value.length; i2 += 1) {
      var format2 = formatList.value[i2];
      var formatStr = formatValue(value.value, {
        generateConfig: generateConfig2.value,
        locale: locale2.value,
        format: format2
      });
      fullValueTexts2.push(formatStr);
      if (i2 === 0) {
        firstValueText2 = formatStr;
      }
    }
    return [fullValueTexts2, firstValueText2];
  }, [value, formatList], function(next2, prev2) {
    return prev2[0] !== next2[0] || !shallowequal(prev2[1], next2[1]);
  });
  var fullValueTexts = Vue.computed(function() {
    return texts.value[0];
  });
  var firstValueText = Vue.computed(function() {
    return texts.value[1];
  });
  return [fullValueTexts, firstValueText];
}
function useHoverValue(valueText, _ref) {
  var formatList = _ref.formatList, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale;
  var innerValue = Vue.ref(null);
  var rafId;
  function setValue(val) {
    var immediately = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    wrapperRaf.cancel(rafId);
    if (immediately) {
      innerValue.value = val;
      return;
    }
    rafId = wrapperRaf(function() {
      innerValue.value = val;
    });
  }
  var _useValueTexts = useValueTexts(innerValue, {
    formatList,
    generateConfig: generateConfig2,
    locale: locale2
  }), _useValueTexts2 = _slicedToArray(_useValueTexts, 2), firstText = _useValueTexts2[1];
  function onEnter(date) {
    setValue(date);
  }
  function onLeave() {
    var immediately = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    setValue(null, immediately);
  }
  Vue.watch(valueText, function() {
    onLeave(true);
  });
  Vue.onBeforeUnmount(function() {
    wrapperRaf.cancel(rafId);
  });
  return [firstText, onEnter, onLeave];
}
function Picker() {
  return Vue.defineComponent({
    name: "Picker",
    inheritAttrs: false,
    props: ["prefixCls", "id", "tabindex", "dropdownClassName", "dropdownAlign", "popupStyle", "transitionName", "generateConfig", "locale", "inputReadOnly", "allowClear", "autofocus", "showTime", "showNow", "showHour", "showMinute", "showSecond", "picker", "format", "use12Hours", "value", "defaultValue", "open", "defaultOpen", "defaultOpenValue", "suffixIcon", "clearIcon", "disabled", "disabledDate", "placeholder", "getPopupContainer", "panelRender", "inputRender", "onChange", "onOpenChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onContextmenu", "onClick", "onKeydown", "onSelect", "direction", "autocomplete", "showToday", "renderExtraFooter", "dateRender"],
    setup: function setup153(props2, _ref) {
      var attrs = _ref.attrs, expose = _ref.expose;
      var inputRef = Vue.ref(null);
      var picker = Vue.computed(function() {
        var _a;
        return (_a = props2.picker) !== null && _a !== void 0 ? _a : "date";
      });
      var needConfirmButton = Vue.computed(function() {
        return picker.value === "date" && !!props2.showTime || picker.value === "time";
      });
      var formatList = Vue.computed(function() {
        return toArray$1(getDefaultFormat(props2.format, picker.value, props2.showTime, props2.use12Hours));
      });
      var panelDivRef = Vue.ref(null);
      var inputDivRef = Vue.ref(null);
      var containerRef = Vue.ref(null);
      var _useMergedState = useMergedState(null, {
        value: Vue.toRef(props2, "value"),
        defaultValue: props2.defaultValue
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
      var selectedValue = Vue.ref(mergedValue.value);
      var setSelectedValue = function setSelectedValue2(val) {
        selectedValue.value = val;
      };
      var operationRef = Vue.ref(null);
      var _useMergedState3 = useMergedState(false, {
        value: Vue.toRef(props2, "open"),
        defaultValue: props2.defaultOpen,
        postState: function postState(postOpen) {
          return props2.disabled ? false : postOpen;
        },
        onChange: function onChange(newOpen) {
          if (props2.onOpenChange) {
            props2.onOpenChange(newOpen);
          }
          if (!newOpen && operationRef.value && operationRef.value.onClose) {
            operationRef.value.onClose();
          }
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedOpen = _useMergedState4[0], triggerInnerOpen = _useMergedState4[1];
      var _useValueTexts = useValueTexts(selectedValue, {
        formatList,
        generateConfig: Vue.toRef(props2, "generateConfig"),
        locale: Vue.toRef(props2, "locale")
      }), _useValueTexts2 = _slicedToArray(_useValueTexts, 2), valueTexts = _useValueTexts2[0], firstValueText = _useValueTexts2[1];
      var _useTextValueMapping = useTextValueMapping({
        valueTexts,
        onTextChange: function onTextChange(newText) {
          var inputDate = parseValue(newText, {
            locale: props2.locale,
            formatList: formatList.value,
            generateConfig: props2.generateConfig
          });
          if (inputDate && (!props2.disabledDate || !props2.disabledDate(inputDate))) {
            setSelectedValue(inputDate);
          }
        }
      }), _useTextValueMapping2 = _slicedToArray(_useTextValueMapping, 3), text = _useTextValueMapping2[0], triggerTextChange = _useTextValueMapping2[1], resetText = _useTextValueMapping2[2];
      var triggerChange = function triggerChange2(newValue) {
        var onChange = props2.onChange, generateConfig2 = props2.generateConfig, locale2 = props2.locale;
        setSelectedValue(newValue);
        setInnerValue(newValue);
        if (onChange && !isEqual(generateConfig2, mergedValue.value, newValue)) {
          onChange(newValue, newValue ? formatValue(newValue, {
            generateConfig: generateConfig2,
            locale: locale2,
            format: formatList.value[0]
          }) : "");
        }
      };
      var triggerOpen = function triggerOpen2(newOpen) {
        if (props2.disabled && newOpen) {
          return;
        }
        triggerInnerOpen(newOpen);
      };
      var forwardKeydown = function forwardKeydown2(e2) {
        if (mergedOpen.value && operationRef.value && operationRef.value.onKeydown) {
          return operationRef.value.onKeydown(e2);
        }
        {
          return false;
        }
      };
      var onInternalMouseup = function onInternalMouseup2() {
        if (props2.onMouseup) {
          props2.onMouseup.apply(props2, arguments);
        }
        if (inputRef.value) {
          inputRef.value.focus();
          triggerOpen(true);
        }
      };
      var _usePickerInput = usePickerInput({
        blurToCancel: needConfirmButton,
        open: mergedOpen,
        value: text,
        triggerOpen,
        forwardKeydown,
        isClickOutside: function isClickOutside(target) {
          return !elementsContains([panelDivRef.value, inputDivRef.value, containerRef.value], target);
        },
        onSubmit: function onSubmit() {
          if (!selectedValue.value || props2.disabledDate && props2.disabledDate(selectedValue.value)) {
            return false;
          }
          triggerChange(selectedValue.value);
          triggerOpen(false);
          resetText();
          return true;
        },
        onCancel: function onCancel() {
          triggerOpen(false);
          setSelectedValue(mergedValue.value);
          resetText();
        },
        onKeydown: function onKeydown(e2, preventDefault) {
          var _a;
          (_a = props2.onKeydown) === null || _a === void 0 ? void 0 : _a.call(props2, e2, preventDefault);
        },
        onFocus: function onFocus2(e2) {
          var _a;
          (_a = props2.onFocus) === null || _a === void 0 ? void 0 : _a.call(props2, e2);
        },
        onBlur: function onBlur2(e2) {
          var _a;
          (_a = props2.onBlur) === null || _a === void 0 ? void 0 : _a.call(props2, e2);
        }
      }), _usePickerInput2 = _slicedToArray(_usePickerInput, 2), inputProps3 = _usePickerInput2[0], _usePickerInput2$ = _usePickerInput2[1], focused = _usePickerInput2$.focused, typing = _usePickerInput2$.typing;
      Vue.watch([mergedOpen, valueTexts], function() {
        if (!mergedOpen.value) {
          setSelectedValue(mergedValue.value);
          if (!valueTexts.value.length || valueTexts.value[0] === "") {
            triggerTextChange("");
          } else if (firstValueText.value !== text.value) {
            resetText();
          }
        }
      });
      Vue.watch(picker, function() {
        if (!mergedOpen.value) {
          resetText();
        }
      });
      Vue.watch(mergedValue, function() {
        setSelectedValue(mergedValue.value);
      });
      var _useHoverValue = useHoverValue(text, {
        formatList,
        generateConfig: Vue.toRef(props2, "generateConfig"),
        locale: Vue.toRef(props2, "locale")
      }), _useHoverValue2 = _slicedToArray(_useHoverValue, 3), hoverValue = _useHoverValue2[0], onEnter = _useHoverValue2[1], onLeave = _useHoverValue2[2];
      var onContextSelect = function onContextSelect2(date, type2) {
        if (type2 === "submit" || type2 !== "key" && !needConfirmButton.value) {
          triggerChange(date);
          triggerOpen(false);
        }
      };
      useProvidePanel({
        operationRef,
        hideHeader: Vue.computed(function() {
          return picker.value === "time";
        }),
        panelRef: panelDivRef,
        onSelect: onContextSelect,
        open: mergedOpen,
        defaultOpenValue: Vue.toRef(props2, "defaultOpenValue"),
        onDateMouseenter: onEnter,
        onDateMouseleave: onLeave
      });
      expose({
        focus: function focus() {
          if (inputRef.value) {
            inputRef.value.focus();
          }
        },
        blur: function blur() {
          if (inputRef.value) {
            inputRef.value.blur();
          }
        }
      });
      var getPortal = useProviderTrigger();
      return function() {
        var _classNames2;
        var _props$prefixCls = props2.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-picker" : _props$prefixCls, id = props2.id, tabindex = props2.tabindex, dropdownClassName = props2.dropdownClassName, dropdownAlign = props2.dropdownAlign, popupStyle = props2.popupStyle, transitionName2 = props2.transitionName, generateConfig2 = props2.generateConfig, locale2 = props2.locale, inputReadOnly = props2.inputReadOnly, allowClear = props2.allowClear, autofocus = props2.autofocus, _props$picker = props2.picker, picker2 = _props$picker === void 0 ? "date" : _props$picker;
        props2.defaultOpenValue;
        var suffixIcon = props2.suffixIcon, clearIcon = props2.clearIcon, disabled = props2.disabled, placeholder = props2.placeholder, getPopupContainer = props2.getPopupContainer, panelRender = props2.panelRender, onMousedown2 = props2.onMousedown, onMouseenter2 = props2.onMouseenter, onMouseleave2 = props2.onMouseleave, onContextmenu2 = props2.onContextmenu, onClick2 = props2.onClick, _onSelect = props2.onSelect, direction = props2.direction, _props$autocomplete = props2.autocomplete, autocomplete = _props$autocomplete === void 0 ? "off" : _props$autocomplete;
        var panelProps = _extends(_extends(_extends({}, props2), attrs), {
          class: classNames(_defineProperty$T({}, "".concat(prefixCls, "-panel-focused"), !typing.value)),
          style: void 0,
          pickerValue: void 0,
          onPickerValueChange: void 0,
          onChange: null
        });
        var panelNode = Vue.createVNode(PickerPanel$1, _objectSpread2$1(_objectSpread2$1({}, panelProps), {}, {
          "generateConfig": generateConfig2,
          "value": selectedValue.value,
          "locale": locale2,
          "tabindex": -1,
          "onSelect": function onSelect(date) {
            _onSelect === null || _onSelect === void 0 ? void 0 : _onSelect(date);
            setSelectedValue(date);
          },
          "direction": direction,
          "onPanelChange": function onPanelChange(viewDate, mode) {
            var onPanelChange2 = props2.onPanelChange;
            onLeave(true);
            onPanelChange2 === null || onPanelChange2 === void 0 ? void 0 : onPanelChange2(viewDate, mode);
          }
        }), null);
        if (panelRender) {
          panelNode = panelRender(panelNode);
        }
        var panel = Vue.createVNode("div", {
          "class": "".concat(prefixCls, "-panel-container"),
          "onMousedown": function onMousedown3(e2) {
            e2.preventDefault();
          }
        }, [panelNode]);
        var suffixNode;
        if (suffixIcon) {
          suffixNode = Vue.createVNode("span", {
            "class": "".concat(prefixCls, "-suffix")
          }, [suffixIcon]);
        }
        var clearNode;
        if (allowClear && mergedValue.value && !disabled) {
          clearNode = Vue.createVNode("span", {
            "onMousedown": function onMousedown3(e2) {
              e2.preventDefault();
              e2.stopPropagation();
            },
            "onMouseup": function onMouseup(e2) {
              e2.preventDefault();
              e2.stopPropagation();
              triggerChange(null);
              triggerOpen(false);
            },
            "class": "".concat(prefixCls, "-clear"),
            "role": "button"
          }, [clearIcon || Vue.createVNode("span", {
            "class": "".concat(prefixCls, "-clear-btn")
          }, null)]);
        }
        var mergedInputProps = _extends(_extends(_extends(_extends({
          id,
          tabindex,
          disabled,
          readonly: inputReadOnly || typeof formatList.value[0] === "function" || !typing.value,
          value: hoverValue.value || text.value,
          onInput: function onInput(e2) {
            triggerTextChange(e2.target.value);
          },
          autofocus,
          placeholder,
          ref: inputRef,
          title: text.value
        }, inputProps3.value), {
          size: getInputSize(picker2, formatList.value[0], generateConfig2)
        }), getDataOrAriaProps(props2)), {
          autocomplete
        });
        var inputNode = props2.inputRender ? props2.inputRender(mergedInputProps) : Vue.createVNode("input", mergedInputProps, null);
        var popupPlacement = direction === "rtl" ? "bottomRight" : "bottomLeft";
        return Vue.createVNode(PickerTrigger, {
          "visible": mergedOpen.value,
          "popupStyle": popupStyle,
          "prefixCls": prefixCls,
          "dropdownClassName": dropdownClassName,
          "dropdownAlign": dropdownAlign,
          "getPopupContainer": getPopupContainer,
          "transitionName": transitionName2,
          "popupPlacement": popupPlacement,
          "direction": direction
        }, {
          default: function _default5() {
            return [Vue.createVNode("div", {
              "ref": containerRef,
              "class": classNames(prefixCls, attrs.class, (_classNames2 = {}, _defineProperty$T(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$T(_classNames2, "".concat(prefixCls, "-focused"), focused.value), _defineProperty$T(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames2)),
              "style": attrs.style,
              "onMousedown": onMousedown2,
              "onMouseup": onInternalMouseup,
              "onMouseenter": onMouseenter2,
              "onMouseleave": onMouseleave2,
              "onContextmenu": onContextmenu2,
              "onClick": onClick2
            }, [Vue.createVNode("div", {
              "class": classNames("".concat(prefixCls, "-input"), _defineProperty$T({}, "".concat(prefixCls, "-input-placeholder"), !!hoverValue.value)),
              "ref": inputDivRef
            }, [inputNode, suffixNode, clearNode]), getPortal()])];
          },
          popupElement: function popupElement() {
            return panel;
          }
        });
      };
    }
  });
}
var Picker$1 = Picker();
function useRangeDisabled(_ref, openRecordsRef) {
  var picker = _ref.picker, locale2 = _ref.locale, selectedValue = _ref.selectedValue, disabledDate = _ref.disabledDate, disabled = _ref.disabled, generateConfig2 = _ref.generateConfig;
  var startDate = Vue.computed(function() {
    return getValue(selectedValue.value, 0);
  });
  var endDate = Vue.computed(function() {
    return getValue(selectedValue.value, 1);
  });
  function weekFirstDate(date) {
    return generateConfig2.value.locale.getWeekFirstDate(locale2.value.locale, date);
  }
  function monthNumber(date) {
    var year = generateConfig2.value.getYear(date);
    var month = generateConfig2.value.getMonth(date);
    return year * 100 + month;
  }
  function quarterNumber(date) {
    var year = generateConfig2.value.getYear(date);
    var quarter = getQuarter(generateConfig2.value, date);
    return year * 10 + quarter;
  }
  var disabledStartDate = function disabledStartDate2(date) {
    var _a;
    if (disabledDate && ((_a = disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate.value) === null || _a === void 0 ? void 0 : _a.call(disabledDate, date))) {
      return true;
    }
    if (disabled[1] && endDate) {
      return !isSameDate(generateConfig2.value, date, endDate.value) && generateConfig2.value.isAfter(date, endDate.value);
    }
    if (openRecordsRef.value[1] && endDate.value) {
      switch (picker.value) {
        case "quarter":
          return quarterNumber(date) > quarterNumber(endDate.value);
        case "month":
          return monthNumber(date) > monthNumber(endDate.value);
        case "week":
          return weekFirstDate(date) > weekFirstDate(endDate.value);
        default:
          return !isSameDate(generateConfig2.value, date, endDate.value) && generateConfig2.value.isAfter(date, endDate.value);
      }
    }
    return false;
  };
  var disabledEndDate = function disabledEndDate2(date) {
    var _a;
    if ((_a = disabledDate.value) === null || _a === void 0 ? void 0 : _a.call(disabledDate, date)) {
      return true;
    }
    if (disabled[0] && startDate) {
      return !isSameDate(generateConfig2.value, date, endDate.value) && generateConfig2.value.isAfter(startDate.value, date);
    }
    if (openRecordsRef.value[0] && startDate.value) {
      switch (picker.value) {
        case "quarter":
          return quarterNumber(date) < quarterNumber(startDate.value);
        case "month":
          return monthNumber(date) < monthNumber(startDate.value);
        case "week":
          return weekFirstDate(date) < weekFirstDate(startDate.value);
        default:
          return !isSameDate(generateConfig2.value, date, startDate.value) && generateConfig2.value.isAfter(startDate.value, date);
      }
    }
    return false;
  };
  return [disabledStartDate, disabledEndDate];
}
function getStartEndDistance(startDate, endDate, picker, generateConfig2) {
  var startNext = getClosingViewDate(startDate, picker, generateConfig2, 1);
  function getDistance(compareFunc) {
    if (compareFunc(startDate, endDate)) {
      return "same";
    }
    if (compareFunc(startNext, endDate)) {
      return "closing";
    }
    return "far";
  }
  switch (picker) {
    case "year":
      return getDistance(function(start, end) {
        return isSameDecade(generateConfig2, start, end);
      });
    case "quarter":
    case "month":
      return getDistance(function(start, end) {
        return isSameYear(generateConfig2, start, end);
      });
    default:
      return getDistance(function(start, end) {
        return isSameMonth(generateConfig2, start, end);
      });
  }
}
function getRangeViewDate(values, index2, picker, generateConfig2) {
  var startDate = getValue(values, 0);
  var endDate = getValue(values, 1);
  if (index2 === 0) {
    return startDate;
  }
  if (startDate && endDate) {
    var distance = getStartEndDistance(startDate, endDate, picker, generateConfig2);
    switch (distance) {
      case "same":
        return startDate;
      case "closing":
        return startDate;
      default:
        return getClosingViewDate(endDate, picker, generateConfig2, -1);
    }
  }
  return startDate;
}
function useRangeViewDates(_ref) {
  var values = _ref.values, picker = _ref.picker, defaultDates = _ref.defaultDates, generateConfig2 = _ref.generateConfig;
  var defaultViewDates = Vue.ref([getValue(defaultDates, 0), getValue(defaultDates, 1)]);
  var viewDates = Vue.ref(null);
  var startDate = Vue.computed(function() {
    return getValue(values.value, 0);
  });
  var endDate = Vue.computed(function() {
    return getValue(values.value, 1);
  });
  var getViewDate = function getViewDate2(index2) {
    if (defaultViewDates.value[index2]) {
      return defaultViewDates.value[index2];
    }
    return getValue(viewDates.value, index2) || getRangeViewDate(values.value, index2, picker.value, generateConfig2.value) || startDate.value || endDate.value || generateConfig2.value.getNow();
  };
  var startViewDate = Vue.ref(null);
  var endViewDate = Vue.ref(null);
  Vue.watchEffect(function() {
    startViewDate.value = getViewDate(0);
    endViewDate.value = getViewDate(1);
  });
  function setViewDate(viewDate, index2) {
    if (viewDate) {
      var newViewDates = updateValues(viewDates.value, viewDate, index2);
      defaultViewDates.value = updateValues(defaultViewDates.value, null, index2) || [null, null];
      var anotherIndex = (index2 + 1) % 2;
      if (!getValue(values.value, anotherIndex)) {
        newViewDates = updateValues(newViewDates, viewDate, anotherIndex);
      }
      viewDates.value = newViewDates;
    } else if (startDate.value || endDate.value) {
      viewDates.value = null;
    }
  }
  return [startViewDate, endViewDate, setViewDate];
}
function reorderValues(values, generateConfig2) {
  if (values && values[0] && values[1] && generateConfig2.isAfter(values[0], values[1])) {
    return [values[1], values[0]];
  }
  return values;
}
function canValueTrigger(value, index2, disabled, allowEmpty) {
  if (value) {
    return true;
  }
  if (allowEmpty && allowEmpty[index2]) {
    return true;
  }
  if (disabled[(index2 + 1) % 2]) {
    return true;
  }
  return false;
}
function RangerPicker() {
  return Vue.defineComponent({
    name: "RangerPicker",
    inheritAttrs: false,
    props: ["prefixCls", "id", "popupStyle", "dropdownClassName", "transitionName", "dropdownAlign", "getPopupContainer", "generateConfig", "locale", "placeholder", "autofocus", "disabled", "format", "picker", "showTime", "showNow", "showHour", "showMinute", "showSecond", "use12Hours", "separator", "value", "defaultValue", "defaultPickerValue", "open", "defaultOpen", "disabledDate", "disabledTime", "dateRender", "panelRender", "ranges", "allowEmpty", "allowClear", "suffixIcon", "clearIcon", "pickerRef", "inputReadOnly", "mode", "renderExtraFooter", "onChange", "onOpenChange", "onPanelChange", "onCalendarChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onClick", "onOk", "onKeydown", "components", "order", "direction", "activePickerIndex", "autocomplete"],
    setup: function setup153(props2, _ref) {
      var attrs = _ref.attrs, expose = _ref.expose;
      var needConfirmButton = Vue.computed(function() {
        return props2.picker === "date" && !!props2.showTime || props2.picker === "time";
      });
      var getPortal = useProviderTrigger();
      var openRecordsRef = Vue.ref({});
      var containerRef = Vue.ref(null);
      var panelDivRef = Vue.ref(null);
      var startInputDivRef = Vue.ref(null);
      var endInputDivRef = Vue.ref(null);
      var separatorRef = Vue.ref(null);
      var startInputRef = Vue.ref(null);
      var endInputRef = Vue.ref(null);
      var arrowRef = Vue.ref(null);
      var formatList = Vue.computed(function() {
        return toArray$1(getDefaultFormat(props2.format, props2.picker, props2.showTime, props2.use12Hours));
      });
      var _useMergedState = useMergedState(0, {
        value: Vue.toRef(props2, "activePickerIndex")
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedActivePickerIndex = _useMergedState2[0], setMergedActivePickerIndex = _useMergedState2[1];
      var operationRef = Vue.ref(null);
      var mergedDisabled = Vue.computed(function() {
        var disabled = props2.disabled;
        if (Array.isArray(disabled)) {
          return disabled;
        }
        return [disabled || false, disabled || false];
      });
      var _useMergedState3 = useMergedState(null, {
        value: Vue.toRef(props2, "value"),
        defaultValue: props2.defaultValue,
        postState: function postState(values) {
          return props2.picker === "time" && !props2.order ? values : reorderValues(values, props2.generateConfig);
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedValue = _useMergedState4[0], setInnerValue = _useMergedState4[1];
      var _useRangeViewDates = useRangeViewDates({
        values: mergedValue,
        picker: Vue.toRef(props2, "picker"),
        defaultDates: props2.defaultPickerValue,
        generateConfig: Vue.toRef(props2, "generateConfig")
      }), _useRangeViewDates2 = _slicedToArray(_useRangeViewDates, 3), startViewDate = _useRangeViewDates2[0], endViewDate = _useRangeViewDates2[1], setViewDate = _useRangeViewDates2[2];
      var _useMergedState5 = useMergedState(mergedValue.value, {
        postState: function postState(values) {
          var postValues = values;
          if (mergedDisabled.value[0] && mergedDisabled.value[1]) {
            return postValues;
          }
          for (var i2 = 0; i2 < 2; i2 += 1) {
            if (mergedDisabled[i2] && !getValue(postValues, i2) && !getValue(props2.allowEmpty, i2)) {
              postValues = updateValues(postValues, props2.generateConfig.getNow(), i2);
            }
          }
          return postValues;
        }
      }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), selectedValue = _useMergedState6[0], setSelectedValue = _useMergedState6[1];
      var _useMergedState7 = useMergedState([props2.picker, props2.picker], {
        value: Vue.toRef(props2, "mode")
      }), _useMergedState8 = _slicedToArray(_useMergedState7, 2), mergedModes = _useMergedState8[0], setInnerModes = _useMergedState8[1];
      Vue.watch(function() {
        return props2.picker;
      }, function() {
        setInnerModes([props2.picker, props2.picker]);
      });
      var triggerModesChange = function triggerModesChange2(modes, values) {
        var _a;
        setInnerModes(modes);
        (_a = props2.onPanelChange) === null || _a === void 0 ? void 0 : _a.call(props2, values, modes);
      };
      var _useRangeDisabled = useRangeDisabled({
        picker: Vue.toRef(props2, "picker"),
        selectedValue,
        locale: Vue.toRef(props2, "locale"),
        disabled: mergedDisabled,
        disabledDate: Vue.toRef(props2, "disabledDate"),
        generateConfig: Vue.toRef(props2, "generateConfig")
      }, openRecordsRef), _useRangeDisabled2 = _slicedToArray(_useRangeDisabled, 2), disabledStartDate = _useRangeDisabled2[0], disabledEndDate = _useRangeDisabled2[1];
      var _useMergedState9 = useMergedState(false, {
        value: Vue.toRef(props2, "open"),
        defaultValue: props2.defaultOpen,
        postState: function postState(postOpen) {
          return mergedDisabled.value[mergedActivePickerIndex.value] ? false : postOpen;
        },
        onChange: function onChange(newOpen) {
          var _a;
          (_a = props2.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(props2, newOpen);
          if (!newOpen && operationRef.value && operationRef.value.onClose) {
            operationRef.value.onClose();
          }
        }
      }), _useMergedState10 = _slicedToArray(_useMergedState9, 2), mergedOpen = _useMergedState10[0], triggerInnerOpen = _useMergedState10[1];
      var startOpen = Vue.computed(function() {
        return mergedOpen.value && mergedActivePickerIndex.value === 0;
      });
      var endOpen = Vue.computed(function() {
        return mergedOpen.value && mergedActivePickerIndex.value === 1;
      });
      var popupMinWidth = Vue.ref(0);
      Vue.watch(mergedOpen, function() {
        if (!mergedOpen.value && containerRef.value) {
          popupMinWidth.value = containerRef.value.offsetWidth;
        }
      });
      var triggerRef = Vue.ref();
      function _triggerOpen(newOpen, index2) {
        if (newOpen) {
          clearTimeout(triggerRef.value);
          openRecordsRef.value[index2] = true;
          setMergedActivePickerIndex(index2);
          triggerInnerOpen(newOpen);
          if (!mergedOpen.value) {
            setViewDate(null, index2);
          }
        } else if (mergedActivePickerIndex.value === index2) {
          triggerInnerOpen(newOpen);
          var openRecords = openRecordsRef.value;
          triggerRef.value = setTimeout(function() {
            if (openRecords === openRecordsRef.value) {
              openRecordsRef.value = {};
            }
          });
        }
      }
      function triggerOpenAndFocus(index2) {
        _triggerOpen(true, index2);
        setTimeout(function() {
          var inputRef = [startInputRef, endInputRef][index2];
          if (inputRef.value) {
            inputRef.value.focus();
          }
        }, 0);
      }
      function triggerChange(newValue, sourceIndex) {
        var values = newValue;
        var startValue = getValue(values, 0);
        var endValue = getValue(values, 1);
        var generateConfig2 = props2.generateConfig, locale2 = props2.locale, picker = props2.picker, order = props2.order, onCalendarChange = props2.onCalendarChange, allowEmpty = props2.allowEmpty, onChange = props2.onChange, showTime = props2.showTime;
        if (startValue && endValue && generateConfig2.isAfter(startValue, endValue)) {
          if (picker === "week" && !isSameWeek(generateConfig2, locale2.locale, startValue, endValue) || picker === "quarter" && !isSameQuarter(generateConfig2, startValue, endValue) || picker !== "week" && picker !== "quarter" && picker !== "time" && !(showTime ? isEqual(generateConfig2, startValue, endValue) : isSameDate(generateConfig2, startValue, endValue))) {
            if (sourceIndex === 0) {
              values = [startValue, null];
              endValue = null;
            } else {
              startValue = null;
              values = [null, endValue];
            }
            openRecordsRef.value = _defineProperty$T({}, sourceIndex, true);
          } else if (picker !== "time" || order !== false) {
            values = reorderValues(values, generateConfig2);
          }
        }
        setSelectedValue(values);
        var startStr2 = values && values[0] ? formatValue(values[0], {
          generateConfig: generateConfig2,
          locale: locale2,
          format: formatList.value[0]
        }) : "";
        var endStr2 = values && values[1] ? formatValue(values[1], {
          generateConfig: generateConfig2,
          locale: locale2,
          format: formatList.value[0]
        }) : "";
        if (onCalendarChange) {
          var info = {
            range: sourceIndex === 0 ? "start" : "end"
          };
          onCalendarChange(values, [startStr2, endStr2], info);
        }
        var canStartValueTrigger = canValueTrigger(startValue, 0, mergedDisabled.value, allowEmpty);
        var canEndValueTrigger = canValueTrigger(endValue, 1, mergedDisabled.value, allowEmpty);
        var canTrigger = values === null || canStartValueTrigger && canEndValueTrigger;
        if (canTrigger) {
          setInnerValue(values);
          if (onChange && (!isEqual(generateConfig2, getValue(mergedValue.value, 0), startValue) || !isEqual(generateConfig2, getValue(mergedValue.value, 1), endValue))) {
            onChange(values, [startStr2, endStr2]);
          }
        }
        var nextOpenIndex = null;
        if (sourceIndex === 0 && !mergedDisabled.value[1]) {
          nextOpenIndex = 1;
        } else if (sourceIndex === 1 && !mergedDisabled.value[0]) {
          nextOpenIndex = 0;
        }
        if (nextOpenIndex !== null && nextOpenIndex !== mergedActivePickerIndex.value && (!openRecordsRef.value[nextOpenIndex] || !getValue(values, nextOpenIndex)) && getValue(values, sourceIndex)) {
          triggerOpenAndFocus(nextOpenIndex);
        } else {
          _triggerOpen(false, sourceIndex);
        }
      }
      var forwardKeydown = function forwardKeydown2(e2) {
        if (mergedOpen && operationRef.value && operationRef.value.onKeydown) {
          return operationRef.value.onKeydown(e2);
        }
        {
          return false;
        }
      };
      var sharedTextHooksProps = {
        formatList,
        generateConfig: Vue.toRef(props2, "generateConfig"),
        locale: Vue.toRef(props2, "locale")
      };
      var _useValueTexts = useValueTexts(Vue.computed(function() {
        return getValue(selectedValue.value, 0);
      }), sharedTextHooksProps), _useValueTexts2 = _slicedToArray(_useValueTexts, 2), startValueTexts = _useValueTexts2[0], firstStartValueText = _useValueTexts2[1];
      var _useValueTexts3 = useValueTexts(Vue.computed(function() {
        return getValue(selectedValue.value, 1);
      }), sharedTextHooksProps), _useValueTexts4 = _slicedToArray(_useValueTexts3, 2), endValueTexts = _useValueTexts4[0], firstEndValueText = _useValueTexts4[1];
      var _onTextChange = function onTextChange(newText, index2) {
        var inputDate = parseValue(newText, {
          locale: props2.locale,
          formatList: formatList.value,
          generateConfig: props2.generateConfig
        });
        var disabledFunc = index2 === 0 ? disabledStartDate : disabledEndDate;
        if (inputDate && !disabledFunc(inputDate)) {
          setSelectedValue(updateValues(selectedValue.value, inputDate, index2));
          setViewDate(inputDate, index2);
        }
      };
      var _useTextValueMapping = useTextValueMapping({
        valueTexts: startValueTexts,
        onTextChange: function onTextChange(newText) {
          return _onTextChange(newText, 0);
        }
      }), _useTextValueMapping2 = _slicedToArray(_useTextValueMapping, 3), startText = _useTextValueMapping2[0], triggerStartTextChange = _useTextValueMapping2[1], resetStartText = _useTextValueMapping2[2];
      var _useTextValueMapping3 = useTextValueMapping({
        valueTexts: endValueTexts,
        onTextChange: function onTextChange(newText) {
          return _onTextChange(newText, 1);
        }
      }), _useTextValueMapping4 = _slicedToArray(_useTextValueMapping3, 3), endText = _useTextValueMapping4[0], triggerEndTextChange = _useTextValueMapping4[1], resetEndText = _useTextValueMapping4[2];
      var _useState = useState(null), _useState2 = _slicedToArray(_useState, 2), rangeHoverValue = _useState2[0], setRangeHoverValue = _useState2[1];
      var _useState3 = useState(null), _useState4 = _slicedToArray(_useState3, 2), hoverRangedValue = _useState4[0], setHoverRangedValue = _useState4[1];
      var _useHoverValue = useHoverValue(startText, sharedTextHooksProps), _useHoverValue2 = _slicedToArray(_useHoverValue, 3), startHoverValue = _useHoverValue2[0], onStartEnter = _useHoverValue2[1], onStartLeave = _useHoverValue2[2];
      var _useHoverValue3 = useHoverValue(endText, sharedTextHooksProps), _useHoverValue4 = _slicedToArray(_useHoverValue3, 3), endHoverValue = _useHoverValue4[0], onEndEnter = _useHoverValue4[1], onEndLeave = _useHoverValue4[2];
      var onDateMouseenter = function onDateMouseenter2(date) {
        setHoverRangedValue(updateValues(selectedValue.value, date, mergedActivePickerIndex.value));
        if (mergedActivePickerIndex.value === 0) {
          onStartEnter(date);
        } else {
          onEndEnter(date);
        }
      };
      var onDateMouseleave = function onDateMouseleave2() {
        setHoverRangedValue(updateValues(selectedValue.value, null, mergedActivePickerIndex.value));
        if (mergedActivePickerIndex.value === 0) {
          onStartLeave();
        } else {
          onEndLeave();
        }
      };
      var getSharedInputHookProps = function getSharedInputHookProps2(index2, resetText) {
        return {
          forwardKeydown,
          onBlur: function onBlur2(e2) {
            var _a;
            (_a = props2.onBlur) === null || _a === void 0 ? void 0 : _a.call(props2, e2);
          },
          isClickOutside: function isClickOutside(target) {
            return !elementsContains([panelDivRef.value, startInputDivRef.value, endInputDivRef.value, containerRef.value], target);
          },
          onFocus: function onFocus2(e2) {
            var _a;
            setMergedActivePickerIndex(index2);
            (_a = props2.onFocus) === null || _a === void 0 ? void 0 : _a.call(props2, e2);
          },
          triggerOpen: function triggerOpen(newOpen) {
            _triggerOpen(newOpen, index2);
          },
          onSubmit: function onSubmit() {
            if (!selectedValue.value || props2.disabledDate && props2.disabledDate(selectedValue.value[index2])) {
              return false;
            }
            triggerChange(selectedValue.value, index2);
            resetText();
          },
          onCancel: function onCancel() {
            _triggerOpen(false, index2);
            setSelectedValue(mergedValue.value);
            resetText();
          }
        };
      };
      var _usePickerInput = usePickerInput(_extends(_extends({}, getSharedInputHookProps(0, resetStartText)), {
        blurToCancel: needConfirmButton,
        open: startOpen,
        value: startText,
        onKeydown: function onKeydown(e2, preventDefault) {
          var _a;
          (_a = props2.onKeydown) === null || _a === void 0 ? void 0 : _a.call(props2, e2, preventDefault);
        }
      })), _usePickerInput2 = _slicedToArray(_usePickerInput, 2), startInputProps = _usePickerInput2[0], _usePickerInput2$ = _usePickerInput2[1], startFocused = _usePickerInput2$.focused, startTyping = _usePickerInput2$.typing;
      var _usePickerInput3 = usePickerInput(_extends(_extends({}, getSharedInputHookProps(1, resetEndText)), {
        blurToCancel: needConfirmButton,
        open: endOpen,
        value: endText,
        onKeydown: function onKeydown(e2, preventDefault) {
          var _a;
          (_a = props2.onKeydown) === null || _a === void 0 ? void 0 : _a.call(props2, e2, preventDefault);
        }
      })), _usePickerInput4 = _slicedToArray(_usePickerInput3, 2), endInputProps = _usePickerInput4[0], _usePickerInput4$ = _usePickerInput4[1], endFocused = _usePickerInput4$.focused, endTyping = _usePickerInput4$.typing;
      var onPickerClick = function onPickerClick2(e2) {
        var _a;
        (_a = props2.onClick) === null || _a === void 0 ? void 0 : _a.call(props2, e2);
        if (!mergedOpen.value && !startInputRef.value.contains(e2.target) && !endInputRef.value.contains(e2.target)) {
          if (!mergedDisabled.value[0]) {
            triggerOpenAndFocus(0);
          } else if (!mergedDisabled.value[1]) {
            triggerOpenAndFocus(1);
          }
        }
      };
      var onPickerMousedown = function onPickerMousedown2(e2) {
        var _a;
        (_a = props2.onMousedown) === null || _a === void 0 ? void 0 : _a.call(props2, e2);
        if (mergedOpen.value && (startFocused.value || endFocused.value) && !startInputRef.value.contains(e2.target) && !endInputRef.value.contains(e2.target)) {
          e2.preventDefault();
        }
      };
      var startStr = Vue.computed(function() {
        var _a;
        return ((_a = mergedValue.value) === null || _a === void 0 ? void 0 : _a[0]) ? formatValue(mergedValue.value[0], {
          locale: props2.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: props2.generateConfig
        }) : "";
      });
      var endStr = Vue.computed(function() {
        var _a;
        return ((_a = mergedValue.value) === null || _a === void 0 ? void 0 : _a[1]) ? formatValue(mergedValue.value[1], {
          locale: props2.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: props2.generateConfig
        }) : "";
      });
      Vue.watch([mergedOpen, startValueTexts, endValueTexts], function() {
        if (!mergedOpen.value) {
          setSelectedValue(mergedValue.value);
          if (!startValueTexts.value.length || startValueTexts.value[0] === "") {
            triggerStartTextChange("");
          } else if (firstStartValueText.value !== startText.value) {
            resetStartText();
          }
          if (!endValueTexts.value.length || endValueTexts.value[0] === "") {
            triggerEndTextChange("");
          } else if (firstEndValueText.value !== endText.value) {
            resetEndText();
          }
        }
      });
      Vue.watch([startStr, endStr], function() {
        setSelectedValue(mergedValue.value);
      });
      expose({
        focus: function focus() {
          if (startInputRef.value) {
            startInputRef.value.focus();
          }
        },
        blur: function blur() {
          if (startInputRef.value) {
            startInputRef.value.blur();
          }
          if (endInputRef.value) {
            endInputRef.value.blur();
          }
        }
      });
      var rangeList = Vue.computed(function() {
        return Object.keys(props2.ranges || {}).map(function(label) {
          var range = props2.ranges[label];
          var newValues = typeof range === "function" ? range() : range;
          return {
            label,
            onClick: function onClick2() {
              triggerChange(newValues, null);
              _triggerOpen(false, mergedActivePickerIndex.value);
            },
            onMouseenter: function onMouseenter2() {
              setRangeHoverValue(newValues);
            },
            onMouseleave: function onMouseleave2() {
              setRangeHoverValue(null);
            }
          };
        });
      });
      var panelHoverRangedValue = Vue.computed(function() {
        if (mergedOpen.value && hoverRangedValue.value && hoverRangedValue.value[0] && hoverRangedValue.value[1] && props2.generateConfig.isAfter(hoverRangedValue.value[1], hoverRangedValue.value[0])) {
          return hoverRangedValue.value;
        } else {
          return null;
        }
      });
      function renderPanel() {
        var panelPosition = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var panelProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var generateConfig2 = props2.generateConfig, showTime = props2.showTime, dateRender = props2.dateRender, direction = props2.direction, _disabledTime = props2.disabledTime, prefixCls = props2.prefixCls, locale2 = props2.locale;
        var panelShowTime = showTime;
        if (showTime && _typeof$1(showTime) === "object" && showTime.defaultValue) {
          var timeDefaultValues = showTime.defaultValue;
          panelShowTime = _extends(_extends({}, showTime), {
            defaultValue: getValue(timeDefaultValues, mergedActivePickerIndex.value) || void 0
          });
        }
        var panelDateRender = null;
        if (dateRender) {
          panelDateRender = function panelDateRender2(_ref2) {
            var date = _ref2.current, today = _ref2.today;
            return dateRender({
              current: date,
              today,
              info: {
                range: mergedActivePickerIndex.value ? "end" : "start"
              }
            });
          };
        }
        return Vue.createVNode(RangeContextProvider, {
          "value": {
            inRange: true,
            panelPosition,
            rangedValue: rangeHoverValue.value || selectedValue.value,
            hoverRangedValue: panelHoverRangedValue.value
          }
        }, {
          default: function _default5() {
            return [Vue.createVNode(PickerPanel$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props2), panelProps), {}, {
              "dateRender": panelDateRender,
              "showTime": panelShowTime,
              "mode": mergedModes.value[mergedActivePickerIndex.value],
              "generateConfig": generateConfig2,
              "style": void 0,
              "direction": direction,
              "disabledDate": mergedActivePickerIndex.value === 0 ? disabledStartDate : disabledEndDate,
              "disabledTime": function disabledTime(date) {
                if (_disabledTime) {
                  return _disabledTime(date, mergedActivePickerIndex.value === 0 ? "start" : "end");
                }
                return false;
              },
              "class": classNames(_defineProperty$T({}, "".concat(prefixCls, "-panel-focused"), mergedActivePickerIndex.value === 0 ? !startTyping.value : !endTyping.value)),
              "value": getValue(selectedValue.value, mergedActivePickerIndex.value),
              "locale": locale2,
              "tabIndex": -1,
              "onPanelChange": function onPanelChange(date, newMode) {
                if (mergedActivePickerIndex.value === 0) {
                  onStartLeave(true);
                }
                if (mergedActivePickerIndex.value === 1) {
                  onEndLeave(true);
                }
                triggerModesChange(updateValues(mergedModes.value, newMode, mergedActivePickerIndex.value), updateValues(selectedValue.value, date, mergedActivePickerIndex.value));
                var viewDate = date;
                if (panelPosition === "right" && mergedModes.value[mergedActivePickerIndex.value] === newMode) {
                  viewDate = getClosingViewDate(viewDate, newMode, generateConfig2, -1);
                }
                setViewDate(viewDate, mergedActivePickerIndex.value);
              },
              "onOk": null,
              "onSelect": void 0,
              "onChange": void 0,
              "defaultValue": mergedActivePickerIndex.value === 0 ? getValue(selectedValue.value, 1) : getValue(selectedValue.value, 0)
            }), null)];
          }
        });
      }
      var onContextSelect = function onContextSelect2(date, type2) {
        var values = updateValues(selectedValue.value, date, mergedActivePickerIndex.value);
        if (type2 === "submit" || type2 !== "key" && !needConfirmButton.value) {
          triggerChange(values, mergedActivePickerIndex.value);
          if (mergedActivePickerIndex.value === 0) {
            onStartLeave();
          } else {
            onEndLeave();
          }
        } else {
          setSelectedValue(values);
        }
      };
      useProvidePanel({
        operationRef,
        hideHeader: Vue.computed(function() {
          return props2.picker === "time";
        }),
        onDateMouseenter,
        onDateMouseleave,
        hideRanges: Vue.computed(function() {
          return true;
        }),
        onSelect: onContextSelect,
        open: mergedOpen
      });
      return function() {
        var _classNames2, _classNames3, _classNames4;
        var _props$prefixCls = props2.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-picker" : _props$prefixCls, id = props2.id, popupStyle = props2.popupStyle, dropdownClassName = props2.dropdownClassName, transitionName2 = props2.transitionName, dropdownAlign = props2.dropdownAlign, getPopupContainer = props2.getPopupContainer, generateConfig2 = props2.generateConfig, locale2 = props2.locale, placeholder = props2.placeholder, autofocus = props2.autofocus, _props$picker = props2.picker, picker = _props$picker === void 0 ? "date" : _props$picker, showTime = props2.showTime, _props$separator = props2.separator, separator = _props$separator === void 0 ? "~" : _props$separator, disabledDate = props2.disabledDate, panelRender = props2.panelRender, allowClear = props2.allowClear, suffixIcon = props2.suffixIcon, clearIcon = props2.clearIcon, inputReadOnly = props2.inputReadOnly, renderExtraFooter = props2.renderExtraFooter, onMouseenter2 = props2.onMouseenter, onMouseleave2 = props2.onMouseleave, onMouseup = props2.onMouseup, _onOk = props2.onOk, components2 = props2.components, direction = props2.direction, _props$autocomplete = props2.autocomplete, autocomplete = _props$autocomplete === void 0 ? "off" : _props$autocomplete;
        var arrowLeft = 0;
        var panelLeft = 0;
        if (mergedActivePickerIndex.value && startInputDivRef.value && separatorRef.value && panelDivRef.value) {
          arrowLeft = startInputDivRef.value.offsetWidth + separatorRef.value.offsetWidth;
          if (panelDivRef.value.offsetWidth && arrowRef.value.offsetWidth && arrowLeft > panelDivRef.value.offsetWidth - arrowRef.value.offsetWidth - (direction === "rtl" || arrowRef.value.offsetLeft > arrowLeft ? 0 : arrowRef.value.offsetLeft)) {
            panelLeft = arrowLeft;
          }
        }
        var arrowPositionStyle = direction === "rtl" ? {
          right: arrowLeft
        } : {
          left: arrowLeft
        };
        function renderPanels() {
          var panels;
          var extraNode = getExtraFooter(prefixCls, mergedModes.value[mergedActivePickerIndex.value], renderExtraFooter);
          var rangesNode = getRanges({
            prefixCls,
            components: components2,
            needConfirmButton: needConfirmButton.value,
            okDisabled: !getValue(selectedValue.value, mergedActivePickerIndex.value) || disabledDate && disabledDate(selectedValue.value[mergedActivePickerIndex.value]),
            locale: locale2,
            rangeList: rangeList.value,
            onOk: function onOk() {
              if (getValue(selectedValue.value, mergedActivePickerIndex.value)) {
                triggerChange(selectedValue.value, mergedActivePickerIndex.value);
                if (_onOk) {
                  _onOk(selectedValue.value);
                }
              }
            }
          });
          if (picker !== "time" && !showTime) {
            var viewDate = mergedActivePickerIndex.value === 0 ? startViewDate.value : endViewDate.value;
            var nextViewDate = getClosingViewDate(viewDate, picker, generateConfig2);
            var currentMode = mergedModes.value[mergedActivePickerIndex.value];
            var showDoublePanel = currentMode === picker;
            var leftPanel = renderPanel(showDoublePanel ? "left" : false, {
              pickerValue: viewDate,
              onPickerValueChange: function onPickerValueChange(newViewDate) {
                setViewDate(newViewDate, mergedActivePickerIndex.value);
              }
            });
            var rightPanel = renderPanel("right", {
              pickerValue: nextViewDate,
              onPickerValueChange: function onPickerValueChange(newViewDate) {
                setViewDate(getClosingViewDate(newViewDate, picker, generateConfig2, -1), mergedActivePickerIndex.value);
              }
            });
            if (direction === "rtl") {
              panels = Vue.createVNode(Vue.Fragment, null, [rightPanel, showDoublePanel && leftPanel]);
            } else {
              panels = Vue.createVNode(Vue.Fragment, null, [leftPanel, showDoublePanel && rightPanel]);
            }
          } else {
            panels = renderPanel();
          }
          var mergedNodes = Vue.createVNode(Vue.Fragment, null, [Vue.createVNode("div", {
            "class": "".concat(prefixCls, "-panels")
          }, [panels]), (extraNode || rangesNode) && Vue.createVNode("div", {
            "class": "".concat(prefixCls, "-footer")
          }, [extraNode, rangesNode])]);
          if (panelRender) {
            mergedNodes = panelRender(mergedNodes);
          }
          return Vue.createVNode("div", {
            "class": "".concat(prefixCls, "-panel-container"),
            "style": {
              marginLeft: panelLeft
            },
            "ref": panelDivRef,
            "onMousedown": function onMousedown2(e2) {
              e2.preventDefault();
            }
          }, [mergedNodes]);
        }
        var rangePanel = Vue.createVNode("div", {
          "class": classNames("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper")),
          "style": {
            minWidth: "".concat(popupMinWidth.value, "px")
          }
        }, [Vue.createVNode("div", {
          "ref": arrowRef,
          "class": "".concat(prefixCls, "-range-arrow"),
          "style": arrowPositionStyle
        }, null), renderPanels()]);
        var suffixNode;
        if (suffixIcon) {
          suffixNode = Vue.createVNode("span", {
            "class": "".concat(prefixCls, "-suffix")
          }, [suffixIcon]);
        }
        var clearNode;
        if (allowClear && (getValue(mergedValue.value, 0) && !mergedDisabled.value[0] || getValue(mergedValue.value, 1) && !mergedDisabled.value[1])) {
          clearNode = Vue.createVNode("span", {
            "onMousedown": function onMousedown2(e2) {
              e2.preventDefault();
              e2.stopPropagation();
            },
            "onMouseup": function onMouseup2(e2) {
              e2.preventDefault();
              e2.stopPropagation();
              var values = mergedValue.value;
              if (!mergedDisabled.value[0]) {
                values = updateValues(values, null, 0);
              }
              if (!mergedDisabled.value[1]) {
                values = updateValues(values, null, 1);
              }
              triggerChange(values, null);
              _triggerOpen(false, mergedActivePickerIndex.value);
            },
            "class": "".concat(prefixCls, "-clear")
          }, [clearIcon || Vue.createVNode("span", {
            "class": "".concat(prefixCls, "-clear-btn")
          }, null)]);
        }
        var inputSharedProps = {
          size: getInputSize(picker, formatList.value[0], generateConfig2)
        };
        var activeBarLeft = 0;
        var activeBarWidth = 0;
        if (startInputDivRef.value && endInputDivRef.value && separatorRef.value) {
          if (mergedActivePickerIndex.value === 0) {
            activeBarWidth = startInputDivRef.value.offsetWidth;
          } else {
            activeBarLeft = arrowLeft;
            activeBarWidth = endInputDivRef.value.offsetWidth;
          }
        }
        var activeBarPositionStyle = direction === "rtl" ? {
          right: "".concat(activeBarLeft, "px")
        } : {
          left: "".concat(activeBarLeft, "px")
        };
        return Vue.createVNode(PickerTrigger, {
          "visible": mergedOpen.value,
          "popupStyle": popupStyle,
          "prefixCls": prefixCls,
          "dropdownClassName": dropdownClassName,
          "dropdownAlign": dropdownAlign,
          "getPopupContainer": getPopupContainer,
          "transitionName": transitionName2,
          "range": true,
          "direction": direction
        }, {
          default: function _default5() {
            return [Vue.createVNode("div", _objectSpread2$1({
              "ref": containerRef,
              "class": classNames(prefixCls, "".concat(prefixCls, "-range"), attrs.class, (_classNames2 = {}, _defineProperty$T(_classNames2, "".concat(prefixCls, "-disabled"), mergedDisabled.value[0] && mergedDisabled.value[1]), _defineProperty$T(_classNames2, "".concat(prefixCls, "-focused"), mergedActivePickerIndex.value === 0 ? startFocused.value : endFocused.value), _defineProperty$T(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames2)),
              "style": attrs.style,
              "onClick": onPickerClick,
              "onMouseenter": onMouseenter2,
              "onMouseleave": onMouseleave2,
              "onMousedown": onPickerMousedown,
              "onMouseup": onMouseup
            }, getDataOrAriaProps(props2)), [Vue.createVNode("div", {
              "class": classNames("".concat(prefixCls, "-input"), (_classNames3 = {}, _defineProperty$T(_classNames3, "".concat(prefixCls, "-input-active"), mergedActivePickerIndex.value === 0), _defineProperty$T(_classNames3, "".concat(prefixCls, "-input-placeholder"), !!startHoverValue.value), _classNames3)),
              "ref": startInputDivRef
            }, [Vue.createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
              "id": id,
              "disabled": mergedDisabled.value[0],
              "readonly": inputReadOnly || typeof formatList.value[0] === "function" || !startTyping.value,
              "value": startHoverValue.value || startText.value,
              "onInput": function onInput(e2) {
                triggerStartTextChange(e2.target.value);
              },
              "autofocus": autofocus,
              "placeholder": getValue(placeholder, 0) || "",
              "ref": startInputRef
            }, startInputProps.value), inputSharedProps), {}, {
              "autocomplete": autocomplete
            }), null)]), Vue.createVNode("div", {
              "class": "".concat(prefixCls, "-range-separator"),
              "ref": separatorRef
            }, [separator]), Vue.createVNode("div", {
              "class": classNames("".concat(prefixCls, "-input"), (_classNames4 = {}, _defineProperty$T(_classNames4, "".concat(prefixCls, "-input-active"), mergedActivePickerIndex.value === 1), _defineProperty$T(_classNames4, "".concat(prefixCls, "-input-placeholder"), !!endHoverValue.value), _classNames4)),
              "ref": endInputDivRef
            }, [Vue.createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
              "disabled": mergedDisabled.value[1],
              "readonly": inputReadOnly || typeof formatList.value[0] === "function" || !endTyping.value,
              "value": endHoverValue.value || endText.value,
              "onInput": function onInput(e2) {
                triggerEndTextChange(e2.target.value);
              },
              "placeholder": getValue(placeholder, 1) || "",
              "ref": endInputRef
            }, endInputProps.value), inputSharedProps), {}, {
              "autocomplete": autocomplete
            }), null)]), Vue.createVNode("div", {
              "class": "".concat(prefixCls, "-active-bar"),
              "style": _extends(_extends({}, activeBarPositionStyle), {
                width: "".concat(activeBarWidth, "px"),
                position: "absolute"
              })
            }, null), suffixNode, clearNode, getPortal()])];
          },
          popupElement: function popupElement() {
            return rangePanel;
          }
        });
      };
    }
  });
}
var InterRangerPicker = RangerPicker();
var VCRangePicker = InterRangerPicker;
function getPlaceholder(picker, locale2, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale2.lang.yearPlaceholder) {
    return locale2.lang.yearPlaceholder;
  }
  if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
    return locale2.lang.quarterPlaceholder;
  }
  if (picker === "month" && locale2.lang.monthPlaceholder) {
    return locale2.lang.monthPlaceholder;
  }
  if (picker === "week" && locale2.lang.weekPlaceholder) {
    return locale2.lang.weekPlaceholder;
  }
  if (picker === "time" && locale2.timePickerLocale.placeholder) {
    return locale2.timePickerLocale.placeholder;
  }
  return locale2.lang.placeholder;
}
function getRangePlaceholder(picker, locale2, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale2.lang.yearPlaceholder) {
    return locale2.lang.rangeYearPlaceholder;
  }
  if (picker === "month" && locale2.lang.monthPlaceholder) {
    return locale2.lang.rangeMonthPlaceholder;
  }
  if (picker === "week" && locale2.lang.weekPlaceholder) {
    return locale2.lang.rangeWeekPlaceholder;
  }
  if (picker === "time" && locale2.timePickerLocale.placeholder) {
    return locale2.timePickerLocale.rangePlaceholder;
  }
  return locale2.lang.rangePlaceholder;
}
function commonProps() {
  return {
    id: String,
    dropdownClassName: String,
    dropdownAlign: {
      type: Object
    },
    popupStyle: {
      type: Object
    },
    transitionName: String,
    placeholder: String,
    allowClear: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    tabindex: Number,
    open: {
      type: Boolean,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      default: void 0
    },
    inputReadOnly: {
      type: Boolean,
      default: void 0
    },
    getPopupContainer: {
      type: Function
    },
    panelRender: {
      type: Function
    },
    onChange: {
      type: Function
    },
    "onUpdate:value": {
      type: Function
    },
    onOk: {
      type: Function
    },
    onOpenChange: {
      type: Function
    },
    "onUpdate:open": {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    onMousedown: {
      type: Function
    },
    onMouseup: {
      type: Function
    },
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onContextmenu: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    role: String,
    name: String,
    autocomplete: String,
    direction: {
      type: String
    },
    showToday: {
      type: Boolean,
      default: void 0
    },
    showTime: {
      type: [Boolean, Object],
      default: void 0
    },
    locale: {
      type: Object
    },
    size: {
      type: String
    },
    bordered: {
      type: Boolean,
      default: void 0
    },
    dateRender: {
      type: Function
    },
    disabledDate: {
      type: Function
    },
    mode: {
      type: String
    },
    picker: {
      type: String
    },
    valueFormat: String
  };
}
function datePickerProps() {
  return {
    defaultPickerValue: {
      type: [String, Object]
    },
    defaultValue: {
      type: [String, Object]
    },
    value: {
      type: [String, Object]
    },
    disabledTime: {
      type: Function
    },
    format: {
      type: [String, Function, Array]
    },
    renderExtraFooter: {
      type: Function
    },
    showNow: {
      type: Boolean,
      default: void 0
    },
    monthCellRender: {
      type: Function
    },
    monthCellContentRender: {
      type: Function
    }
  };
}
function rangePickerProps() {
  return {
    allowEmpty: {
      type: Array
    },
    dateRender: {
      type: Function
    },
    defaultPickerValue: {
      type: Array
    },
    defaultValue: {
      type: Array
    },
    value: {
      type: Array
    },
    disabledTime: {
      type: Function
    },
    disabled: {
      type: [Boolean, Array]
    },
    format: String,
    renderExtraFooter: {
      type: Function
    },
    separator: {
      type: String
    },
    ranges: {
      type: Object
    },
    placeholder: Array,
    mode: {
      type: Array
    },
    onChange: {
      type: Function
    },
    "onUpdate:value": {
      type: Function
    },
    onCalendarChange: {
      type: Function
    },
    onPanelChange: {
      type: Function
    },
    onOk: {
      type: Function
    }
  };
}
var __rest$1 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function generateSinglePicker(generateConfig2, extraProps) {
  function getPicker(picker, displayName) {
    var comProps = _extends(_extends(_extends({}, commonProps()), datePickerProps()), extraProps);
    return Vue.defineComponent({
      name: displayName,
      inheritAttrs: false,
      props: comProps,
      slots: [
        "suffixIcon",
        "prevIcon",
        "nextIcon",
        "superPrevIcon",
        "superNextIcon",
        "dateRender",
        "renderExtraFooter",
        "monthCellRender"
      ],
      setup: function setup153(_props, _ref) {
        var slots = _ref.slots, expose = _ref.expose, attrs = _ref.attrs, emit = _ref.emit;
        var props2 = _props;
        var formItemContext = useInjectFormItemContext();
        devWarning(!(props2.monthCellContentRender || slots.monthCellContentRender), "DatePicker", '`monthCellContentRender` is deprecated. Please use `monthCellRender"` instead.');
        devWarning(!attrs.getCalendarContainer, "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.');
        var _useConfigInject = useConfigInject("picker", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer, size = _useConfigInject.size, rootPrefixCls = _useConfigInject.rootPrefixCls;
        var pickerRef = Vue.ref();
        Vue.onMounted(function() {
          Vue.nextTick(function() {
          });
        });
        expose({
          focus: function focus() {
            var _a;
            (_a = pickerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          },
          blur: function blur() {
            var _a;
            (_a = pickerRef.value) === null || _a === void 0 ? void 0 : _a.blur();
          }
        });
        var maybeToString = function maybeToString2(date) {
          return props2.valueFormat ? generateConfig2.toString(date, props2.valueFormat) : date;
        };
        var onChange = function onChange2(date, dateString) {
          var value2 = maybeToString(date);
          emit("update:value", value2);
          emit("change", value2, dateString);
          formItemContext.onFieldChange();
        };
        var onOpenChange = function onOpenChange2(open2) {
          emit("update:open", open2);
          emit("openChange", open2);
        };
        var onFocus2 = function onFocus3(e2) {
          emit("focus", e2);
        };
        var onBlur2 = function onBlur3(e2) {
          emit("blur", e2);
          formItemContext.onFieldBlur();
        };
        var onPanelChange = function onPanelChange2(date, mode) {
          var value2 = maybeToString(date);
          emit("panelChange", value2, mode);
        };
        var onOk = function onOk2(date) {
          var value2 = maybeToString(date);
          emit("ok", value2);
        };
        var _useLocaleReceiver = useLocaleReceiver("DatePicker", enUS), _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 1), contextLocale = _useLocaleReceiver2[0];
        var value = Vue.computed(function() {
          if (props2.value) {
            return props2.valueFormat ? generateConfig2.toDate(props2.value, props2.valueFormat) : props2.value;
          }
          return props2.value === "" ? void 0 : props2.value;
        });
        var defaultValue = Vue.computed(function() {
          if (props2.defaultValue) {
            return props2.valueFormat ? generateConfig2.toDate(props2.defaultValue, props2.valueFormat) : props2.defaultValue;
          }
          return props2.defaultValue === "" ? void 0 : props2.defaultValue;
        });
        var defaultPickerValue = Vue.computed(function() {
          if (props2.defaultPickerValue) {
            return props2.valueFormat ? generateConfig2.toDate(props2.defaultPickerValue, props2.valueFormat) : props2.defaultPickerValue;
          }
          return props2.defaultPickerValue === "" ? void 0 : props2.defaultPickerValue;
        });
        return function() {
          var _classNames;
          var _a, _b, _c, _d, _e, _f;
          var locale2 = _extends(_extends({}, contextLocale.value), props2.locale);
          var p2 = _extends(_extends({}, props2), attrs);
          var _p$bordered = p2.bordered, bordered = _p$bordered === void 0 ? true : _p$bordered, placeholder = p2.placeholder, _p$suffixIcon = p2.suffixIcon, suffixIcon = _p$suffixIcon === void 0 ? (_a = slots.suffixIcon) === null || _a === void 0 ? void 0 : _a.call(slots) : _p$suffixIcon, _p$showToday = p2.showToday, showToday = _p$showToday === void 0 ? true : _p$showToday, transitionName2 = p2.transitionName, _p$allowClear = p2.allowClear, allowClear = _p$allowClear === void 0 ? true : _p$allowClear, _p$dateRender = p2.dateRender, dateRender = _p$dateRender === void 0 ? slots.dateRender : _p$dateRender, _p$renderExtraFooter = p2.renderExtraFooter, renderExtraFooter = _p$renderExtraFooter === void 0 ? slots.renderExtraFooter : _p$renderExtraFooter, _p$monthCellRender = p2.monthCellRender, monthCellRender = _p$monthCellRender === void 0 ? slots.monthCellRender || props2.monthCellContentRender || slots.monthCellContentRender : _p$monthCellRender, _p$clearIcon = p2.clearIcon, clearIcon = _p$clearIcon === void 0 ? (_b = slots.clearIcon) === null || _b === void 0 ? void 0 : _b.call(slots) : _p$clearIcon, _p$id = p2.id, id = _p$id === void 0 ? formItemContext.id.value : _p$id, restProps = __rest$1(p2, ["bordered", "placeholder", "suffixIcon", "showToday", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "monthCellRender", "clearIcon", "id"]);
          var showTime = p2.showTime === "" ? true : p2.showTime;
          var format2 = p2.format;
          var additionalOverrideProps = {};
          if (picker) {
            additionalOverrideProps.picker = picker;
          }
          var mergedPicker = picker || p2.picker || "date";
          additionalOverrideProps = _extends(_extends(_extends({}, additionalOverrideProps), showTime ? getTimeProps(_extends({
            format: format2,
            picker: mergedPicker
          }, _typeof$1(showTime) === "object" ? showTime : {})) : {}), mergedPicker === "time" ? getTimeProps(_extends(_extends({
            format: format2
          }, restProps), {
            picker: mergedPicker
          })) : {});
          var pre = prefixCls.value;
          return Vue.createVNode(Picker$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "monthCellRender": monthCellRender,
            "dateRender": dateRender,
            "renderExtraFooter": renderExtraFooter,
            "ref": pickerRef,
            "placeholder": getPlaceholder(mergedPicker, locale2, placeholder),
            "suffixIcon": suffixIcon || (mergedPicker === "time" ? Vue.createVNode(ClockCircleOutlined$1, null, null) : Vue.createVNode(CalendarOutlined$1, null, null)),
            "clearIcon": clearIcon || Vue.createVNode(CloseCircleFilled$1, null, null),
            "allowClear": allowClear,
            "transitionName": transitionName2 || "".concat(rootPrefixCls.value, "-slide-up")
          }, restProps), additionalOverrideProps), {}, {
            "id": id,
            "picker": mergedPicker,
            "value": value.value,
            "defaultValue": defaultValue.value,
            "defaultPickerValue": defaultPickerValue.value,
            "showToday": showToday,
            "locale": locale2.lang,
            "class": classNames((_classNames = {}, _defineProperty$T(_classNames, "".concat(pre, "-").concat(size.value), size.value), _defineProperty$T(_classNames, "".concat(pre, "-borderless"), !bordered), _classNames), attrs.class),
            "prefixCls": pre,
            "getPopupContainer": attrs.getCalendarContainer || getPopupContainer.value,
            "generateConfig": generateConfig2,
            "prevIcon": ((_c = slots.prevIcon) === null || _c === void 0 ? void 0 : _c.call(slots)) || Vue.createVNode("span", {
              "class": "".concat(pre, "-prev-icon")
            }, null),
            "nextIcon": ((_d = slots.nextIcon) === null || _d === void 0 ? void 0 : _d.call(slots)) || Vue.createVNode("span", {
              "class": "".concat(pre, "-next-icon")
            }, null),
            "superPrevIcon": ((_e = slots.superPrevIcon) === null || _e === void 0 ? void 0 : _e.call(slots)) || Vue.createVNode("span", {
              "class": "".concat(pre, "-super-prev-icon")
            }, null),
            "superNextIcon": ((_f = slots.superNextIcon) === null || _f === void 0 ? void 0 : _f.call(slots)) || Vue.createVNode("span", {
              "class": "".concat(pre, "-super-next-icon")
            }, null),
            "components": Components,
            "direction": direction.value,
            "onChange": onChange,
            "onOpenChange": onOpenChange,
            "onFocus": onFocus2,
            "onBlur": onBlur2,
            "onPanelChange": onPanelChange,
            "onOk": onOk
          }), null);
        };
      }
    });
  }
  var DatePicker2 = getPicker(void 0, "ADatePicker");
  var WeekPicker2 = getPicker("week", "AWeekPicker");
  var MonthPicker2 = getPicker("month", "AMonthPicker");
  var YearPicker2 = getPicker("year", "AYearPicker");
  var TimePicker2 = getPicker("time", "TimePicker");
  var QuarterPicker2 = getPicker("quarter", "AQuarterPicker");
  return {
    DatePicker: DatePicker2,
    WeekPicker: WeekPicker2,
    MonthPicker: MonthPicker2,
    YearPicker: YearPicker2,
    TimePicker: TimePicker2,
    QuarterPicker: QuarterPicker2
  };
}
var __rest = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function generateRangePicker(generateConfig2, extraProps) {
  var RangePicker2 = Vue.defineComponent({
    name: "ARangePicker",
    inheritAttrs: false,
    props: _extends(_extends(_extends({}, commonProps()), rangePickerProps()), extraProps),
    slots: [
      "suffixIcon",
      "prevIcon",
      "nextIcon",
      "superPrevIcon",
      "superNextIcon",
      "dateRender",
      "renderExtraFooter"
    ],
    setup: function setup153(_props, _ref) {
      var expose = _ref.expose, slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
      var props2 = _props;
      var formItemContext = useInjectFormItemContext();
      devWarning(!attrs.getCalendarContainer, "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.');
      var _useConfigInject = useConfigInject("picker", props2), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer, size = _useConfigInject.size, rootPrefixCls = _useConfigInject.rootPrefixCls;
      var pickerRef = Vue.ref();
      Vue.onMounted(function() {
        Vue.nextTick(function() {
        });
      });
      expose({
        focus: function focus() {
          var _a;
          (_a = pickerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        },
        blur: function blur() {
          var _a;
          (_a = pickerRef.value) === null || _a === void 0 ? void 0 : _a.blur();
        }
      });
      var maybeToStrings = function maybeToStrings2(dates) {
        return props2.valueFormat ? generateConfig2.toString(dates, props2.valueFormat) : dates;
      };
      var onChange = function onChange2(dates, dateStrings) {
        var values = maybeToStrings(dates);
        emit("update:value", values);
        emit("change", values, dateStrings);
        formItemContext.onFieldChange();
      };
      var onOpenChange = function onOpenChange2(open2) {
        emit("update:open", open2);
        emit("openChange", open2);
      };
      var onFocus2 = function onFocus3(e2) {
        emit("focus", e2);
      };
      var onBlur2 = function onBlur3(e2) {
        emit("blur", e2);
        formItemContext.onFieldBlur();
      };
      var onPanelChange = function onPanelChange2(dates, modes) {
        var values = maybeToStrings(dates);
        emit("panelChange", values, modes);
      };
      var onOk = function onOk2(dates) {
        var value2 = maybeToStrings(dates);
        emit("ok", value2);
      };
      var onCalendarChange = function onCalendarChange2(dates, dateStrings, info) {
        var values = maybeToStrings(dates);
        emit("calendarChange", values, dateStrings, info);
      };
      var _useLocaleReceiver = useLocaleReceiver("DatePicker", enUS), _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 1), contextLocale = _useLocaleReceiver2[0];
      var value = Vue.computed(function() {
        if (props2.value) {
          return props2.valueFormat ? generateConfig2.toDate(props2.value, props2.valueFormat) : props2.value;
        }
        return props2.value;
      });
      var defaultValue = Vue.computed(function() {
        if (props2.defaultValue) {
          return props2.valueFormat ? generateConfig2.toDate(props2.defaultValue, props2.valueFormat) : props2.defaultValue;
        }
        return props2.defaultValue;
      });
      var defaultPickerValue = Vue.computed(function() {
        if (props2.defaultPickerValue) {
          return props2.valueFormat ? generateConfig2.toDate(props2.defaultPickerValue, props2.valueFormat) : props2.defaultPickerValue;
        }
        return props2.defaultPickerValue;
      });
      return function() {
        var _classNames;
        var _a, _b, _c, _d, _e, _f, _g;
        var locale2 = _extends(_extends({}, contextLocale.value), props2.locale);
        var p2 = _extends(_extends({}, props2), attrs);
        p2.prefixCls;
        var _p$bordered = p2.bordered, bordered = _p$bordered === void 0 ? true : _p$bordered, placeholder = p2.placeholder, _p$suffixIcon = p2.suffixIcon, suffixIcon = _p$suffixIcon === void 0 ? (_a = slots.suffixIcon) === null || _a === void 0 ? void 0 : _a.call(slots) : _p$suffixIcon, _p$picker = p2.picker, picker = _p$picker === void 0 ? "date" : _p$picker, transitionName2 = p2.transitionName, _p$allowClear = p2.allowClear, allowClear = _p$allowClear === void 0 ? true : _p$allowClear, _p$dateRender = p2.dateRender, dateRender = _p$dateRender === void 0 ? slots.dateRender : _p$dateRender, _p$renderExtraFooter = p2.renderExtraFooter, renderExtraFooter = _p$renderExtraFooter === void 0 ? slots.renderExtraFooter : _p$renderExtraFooter, _p$separator = p2.separator, separator = _p$separator === void 0 ? (_b = slots.separator) === null || _b === void 0 ? void 0 : _b.call(slots) : _p$separator, _p$clearIcon = p2.clearIcon, clearIcon = _p$clearIcon === void 0 ? (_c = slots.clearIcon) === null || _c === void 0 ? void 0 : _c.call(slots) : _p$clearIcon, _p$id = p2.id, id = _p$id === void 0 ? formItemContext.id.value : _p$id, restProps = __rest(p2, ["prefixCls", "bordered", "placeholder", "suffixIcon", "picker", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "separator", "clearIcon", "id"]);
        delete restProps["onUpdate:value"];
        delete restProps["onUpdate:open"];
        var format2 = p2.format, showTime = p2.showTime;
        var additionalOverrideProps = {};
        additionalOverrideProps = _extends(_extends(_extends({}, additionalOverrideProps), showTime ? getTimeProps(_extends({
          format: format2,
          picker
        }, showTime)) : {}), picker === "time" ? getTimeProps(_extends(_extends({
          format: format2
        }, omit(restProps, ["disabledTime"])), {
          picker
        })) : {});
        var pre = prefixCls.value;
        return Vue.createVNode(VCRangePicker, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "dateRender": dateRender,
          "renderExtraFooter": renderExtraFooter,
          "separator": separator || Vue.createVNode("span", {
            "aria-label": "to",
            "class": "".concat(pre, "-separator")
          }, [Vue.createVNode(SwapRightOutlined$1, null, null)]),
          "ref": pickerRef,
          "placeholder": getRangePlaceholder(picker, locale2, placeholder),
          "suffixIcon": suffixIcon || (picker === "time" ? Vue.createVNode(ClockCircleOutlined$1, null, null) : Vue.createVNode(CalendarOutlined$1, null, null)),
          "clearIcon": clearIcon || Vue.createVNode(CloseCircleFilled$1, null, null),
          "allowClear": allowClear,
          "transitionName": transitionName2 || "".concat(rootPrefixCls.value, "-slide-up")
        }, restProps), additionalOverrideProps), {}, {
          "id": id,
          "value": value.value,
          "defaultValue": defaultValue.value,
          "defaultPickerValue": defaultPickerValue.value,
          "picker": picker,
          "class": classNames((_classNames = {}, _defineProperty$T(_classNames, "".concat(pre, "-").concat(size.value), size.value), _defineProperty$T(_classNames, "".concat(pre, "-borderless"), !bordered), _classNames), attrs.class),
          "locale": locale2.lang,
          "prefixCls": pre,
          "getPopupContainer": attrs.getCalendarContainer || getPopupContainer.value,
          "generateConfig": generateConfig2,
          "prevIcon": ((_d = slots.prevIcon) === null || _d === void 0 ? void 0 : _d.call(slots)) || Vue.createVNode("span", {
            "class": "".concat(pre, "-prev-icon")
          }, null),
          "nextIcon": ((_e = slots.nextIcon) === null || _e === void 0 ? void 0 : _e.call(slots)) || Vue.createVNode("span", {
            "class": "".concat(pre, "-next-icon")
          }, null),
          "superPrevIcon": ((_f = slots.superPrevIcon) === null || _f === void 0 ? void 0 : _f.call(slots)) || Vue.createVNode("span", {
            "class": "".concat(pre, "-super-prev-icon")
          }, null),
          "superNextIcon": ((_g = slots.superNextIcon) === null || _g === void 0 ? void 0 : _g.call(slots)) || Vue.createVNode("span", {
            "class": "".concat(pre, "-super-next-icon")
          }, null),
          "components": Components,
          "direction": direction.value,
          "onChange": onChange,
          "onOpenChange": onOpenChange,
          "onFocus": onFocus2,
          "onBlur": onBlur2,
          "onPanelChange": onPanelChange,
          "onOk": onOk,
          "onCalendarChange": onCalendarChange
        }), null);
      };
    }
  });
  return RangePicker2;
}
var Components = {
  button: PickerButton$1,
  rangeItem: PickerTag
};
function toArray(list) {
  if (!list) {
    return [];
  }
  return Array.isArray(list) ? list : [list];
}
function getTimeProps(props2) {
  var format2 = props2.format, picker = props2.picker, showHour = props2.showHour, showMinute = props2.showMinute, showSecond = props2.showSecond, use12Hours = props2.use12Hours;
  var firstFormat = toArray(format2)[0];
  var showTimeObj = _extends({}, props2);
  if (firstFormat && typeof firstFormat === "string") {
    if (!firstFormat.includes("s") && showSecond === void 0) {
      showTimeObj.showSecond = false;
    }
    if (!firstFormat.includes("m") && showMinute === void 0) {
      showTimeObj.showMinute = false;
    }
    if (!firstFormat.includes("H") && !firstFormat.includes("h") && showHour === void 0) {
      showTimeObj.showHour = false;
    }
    if ((firstFormat.includes("a") || firstFormat.includes("A")) && use12Hours === void 0) {
      showTimeObj.use12Hours = true;
    }
  }
  if (picker === "time") {
    return showTimeObj;
  }
  if (typeof firstFormat === "function") {
    delete showTimeObj.format;
  }
  return {
    showTime: showTimeObj
  };
}
function generatePicker(generateConfig2, extraProps) {
  var _generateSinglePicker = generateSinglePicker(generateConfig2, extraProps), DatePicker2 = _generateSinglePicker.DatePicker, WeekPicker2 = _generateSinglePicker.WeekPicker, MonthPicker2 = _generateSinglePicker.MonthPicker, YearPicker2 = _generateSinglePicker.YearPicker, TimePicker2 = _generateSinglePicker.TimePicker, QuarterPicker2 = _generateSinglePicker.QuarterPicker;
  var RangePicker2 = generateRangePicker(generateConfig2, extraProps);
  return {
    DatePicker: DatePicker2,
    WeekPicker: WeekPicker2,
    MonthPicker: MonthPicker2,
    YearPicker: YearPicker2,
    TimePicker: TimePicker2,
    QuarterPicker: QuarterPicker2,
    RangePicker: RangePicker2
  };
}
var _generatePicker = generatePicker(dayjsGenerateConfig), DatePicker$2 = _generatePicker.DatePicker, WeekPicker = _generatePicker.WeekPicker, MonthPicker = _generatePicker.MonthPicker, YearPicker = _generatePicker.YearPicker, TimePicker$1 = _generatePicker.TimePicker, QuarterPicker = _generatePicker.QuarterPicker, RangePicker$1 = _generatePicker.RangePicker;
var DatePicker$3 = _extends(DatePicker$2, {
  WeekPicker,
  MonthPicker,
  YearPicker,
  RangePicker: RangePicker$1,
  TimePicker: TimePicker$1,
  QuarterPicker,
  install: function install6(app) {
    app.component(DatePicker$2.name, DatePicker$2);
    app.component(RangePicker$1.name, RangePicker$1);
    app.component(MonthPicker.name, MonthPicker);
    app.component(WeekPicker.name, WeekPicker);
    app.component(QuarterPicker.name, QuarterPicker);
    return app;
  }
});
var locale$2 = {
  locale: "zh_CN",
  today: "\u4ECA\u5929",
  now: "\u6B64\u523B",
  backToToday: "\u8FD4\u56DE\u4ECA\u5929",
  ok: "\u786E\u5B9A",
  timeSelect: "\u9009\u62E9\u65F6\u95F4",
  dateSelect: "\u9009\u62E9\u65E5\u671F",
  weekSelect: "\u9009\u62E9\u5468",
  clear: "\u6E05\u9664",
  month: "\u6708",
  year: "\u5E74",
  previousMonth: "\u4E0A\u4E2A\u6708 (\u7FFB\u9875\u4E0A\u952E)",
  nextMonth: "\u4E0B\u4E2A\u6708 (\u7FFB\u9875\u4E0B\u952E)",
  monthSelect: "\u9009\u62E9\u6708\u4EFD",
  yearSelect: "\u9009\u62E9\u5E74\u4EFD",
  decadeSelect: "\u9009\u62E9\u5E74\u4EE3",
  yearFormat: "YYYY\u5E74",
  dayFormat: "D\u65E5",
  dateFormat: "YYYY\u5E74M\u6708D\u65E5",
  dateTimeFormat: "YYYY\u5E74M\u6708D\u65E5 HH\u65F6mm\u5206ss\u79D2",
  previousYear: "\u4E0A\u4E00\u5E74 (Control\u952E\u52A0\u5DE6\u65B9\u5411\u952E)",
  nextYear: "\u4E0B\u4E00\u5E74 (Control\u952E\u52A0\u53F3\u65B9\u5411\u952E)",
  previousDecade: "\u4E0A\u4E00\u5E74\u4EE3",
  nextDecade: "\u4E0B\u4E00\u5E74\u4EE3",
  previousCentury: "\u4E0A\u4E00\u4E16\u7EAA",
  nextCentury: "\u4E0B\u4E00\u4E16\u7EAA"
};
var CalendarLocale = locale$2;
var locale$1 = {
  placeholder: "\u8BF7\u9009\u62E9\u65F6\u95F4",
  rangePlaceholder: ["\u5F00\u59CB\u65F6\u95F4", "\u7ED3\u675F\u65F6\u95F4"]
};
var TimePicker = locale$1;
var locale = {
  lang: _extends({
    placeholder: "\u8BF7\u9009\u62E9\u65E5\u671F",
    yearPlaceholder: "\u8BF7\u9009\u62E9\u5E74\u4EFD",
    quarterPlaceholder: "\u8BF7\u9009\u62E9\u5B63\u5EA6",
    monthPlaceholder: "\u8BF7\u9009\u62E9\u6708\u4EFD",
    weekPlaceholder: "\u8BF7\u9009\u62E9\u5468",
    rangePlaceholder: ["\u5F00\u59CB\u65E5\u671F", "\u7ED3\u675F\u65E5\u671F"],
    rangeYearPlaceholder: ["\u5F00\u59CB\u5E74\u4EFD", "\u7ED3\u675F\u5E74\u4EFD"],
    rangeMonthPlaceholder: ["\u5F00\u59CB\u6708\u4EFD", "\u7ED3\u675F\u6708\u4EFD"],
    rangeQuarterPlaceholder: ["\u5F00\u59CB\u5B63\u5EA6", "\u7ED3\u675F\u5B63\u5EA6"],
    rangeWeekPlaceholder: ["\u5F00\u59CB\u5468", "\u7ED3\u675F\u5468"]
  }, CalendarLocale),
  timePickerLocale: _extends({}, TimePicker)
};
locale.lang.ok = "\u786E\u5B9A";
var DatePicker$1 = locale;
var typeTemplate = "${label}\u4E0D\u662F\u4E00\u4E2A\u6709\u6548\u7684${type}";
var localeValues = {
  locale: "zh-cn",
  Pagination: Pagination$1,
  DatePicker: DatePicker$1,
  TimePicker,
  Calendar: DatePicker$1,
  global: {
    placeholder: "\u8BF7\u9009\u62E9"
  },
  Table: {
    filterTitle: "\u7B5B\u9009",
    filterConfirm: "\u786E\u5B9A",
    filterReset: "\u91CD\u7F6E",
    filterEmptyText: "\u65E0\u7B5B\u9009\u9879",
    filterCheckall: "\u5168\u9009",
    filterSearchPlaceholder: "\u5728\u7B5B\u9009\u9879\u4E2D\u641C\u7D22",
    selectAll: "\u5168\u9009\u5F53\u9875",
    selectInvert: "\u53CD\u9009\u5F53\u9875",
    selectNone: "\u6E05\u7A7A\u6240\u6709",
    selectionAll: "\u5168\u9009\u6240\u6709",
    sortTitle: "\u6392\u5E8F",
    expand: "\u5C55\u5F00\u884C",
    collapse: "\u5173\u95ED\u884C",
    triggerDesc: "\u70B9\u51FB\u964D\u5E8F",
    triggerAsc: "\u70B9\u51FB\u5347\u5E8F",
    cancelSort: "\u53D6\u6D88\u6392\u5E8F"
  },
  Modal: {
    okText: "\u786E\u5B9A",
    cancelText: "\u53D6\u6D88",
    justOkText: "\u77E5\u9053\u4E86"
  },
  Popconfirm: {
    cancelText: "\u53D6\u6D88",
    okText: "\u786E\u5B9A"
  },
  Transfer: {
    searchPlaceholder: "\u8BF7\u8F93\u5165\u641C\u7D22\u5185\u5BB9",
    itemUnit: "\u9879",
    itemsUnit: "\u9879",
    remove: "\u5220\u9664",
    selectCurrent: "\u5168\u9009\u5F53\u9875",
    removeCurrent: "\u5220\u9664\u5F53\u9875",
    selectAll: "\u5168\u9009\u6240\u6709",
    removeAll: "\u5220\u9664\u5168\u90E8",
    selectInvert: "\u53CD\u9009\u5F53\u9875"
  },
  Upload: {
    uploading: "\u6587\u4EF6\u4E0A\u4F20\u4E2D",
    removeFile: "\u5220\u9664\u6587\u4EF6",
    uploadError: "\u4E0A\u4F20\u9519\u8BEF",
    previewFile: "\u9884\u89C8\u6587\u4EF6",
    downloadFile: "\u4E0B\u8F7D\u6587\u4EF6"
  },
  Empty: {
    description: "\u6682\u65E0\u6570\u636E"
  },
  Icon: {
    icon: "\u56FE\u6807"
  },
  Text: {
    edit: "\u7F16\u8F91",
    copy: "\u590D\u5236",
    copied: "\u590D\u5236\u6210\u529F",
    expand: "\u5C55\u5F00"
  },
  PageHeader: {
    back: "\u8FD4\u56DE"
  },
  Form: {
    optional: "\uFF08\u53EF\u9009\uFF09",
    defaultValidateMessages: {
      default: "\u5B57\u6BB5\u9A8C\u8BC1\u9519\u8BEF${label}",
      required: "\u8BF7\u8F93\u5165${label}",
      enum: "${label}\u5FC5\u987B\u662F\u5176\u4E2D\u4E00\u4E2A[${enum}]",
      whitespace: "${label}\u4E0D\u80FD\u4E3A\u7A7A\u5B57\u7B26",
      date: {
        format: "${label}\u65E5\u671F\u683C\u5F0F\u65E0\u6548",
        parse: "${label}\u4E0D\u80FD\u8F6C\u6362\u4E3A\u65E5\u671F",
        invalid: "${label}\u662F\u4E00\u4E2A\u65E0\u6548\u65E5\u671F"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label}\u987B\u4E3A${len}\u4E2A\u5B57\u7B26",
        min: "${label}\u6700\u5C11${min}\u4E2A\u5B57\u7B26",
        max: "${label}\u6700\u591A${max}\u4E2A\u5B57\u7B26",
        range: "${label}\u987B\u5728${min}-${max}\u5B57\u7B26\u4E4B\u95F4"
      },
      number: {
        len: "${label}\u5FC5\u987B\u7B49\u4E8E${len}",
        min: "${label}\u6700\u5C0F\u503C\u4E3A${min}",
        max: "${label}\u6700\u5927\u503C\u4E3A${max}",
        range: "${label}\u987B\u5728${min}-${max}\u4E4B\u95F4"
      },
      array: {
        len: "\u987B\u4E3A${len}\u4E2A${label}",
        min: "\u6700\u5C11${min}\u4E2A${label}",
        max: "\u6700\u591A${max}\u4E2A${label}",
        range: "${label}\u6570\u91CF\u987B\u5728${min}-${max}\u4E4B\u95F4"
      },
      pattern: {
        mismatch: "${label}\u4E0E\u6A21\u5F0F\u4E0D\u5339\u914D${pattern}"
      }
    }
  },
  Image: {
    preview: "\u9884\u89C8"
  }
};
var zhCn$1 = localeValues;
var zhCn = { exports: {} };
(function(module2, exports2) {
  !function(e2, _2) {
    module2.exports = _2(dayjs_min.exports);
  }(commonjsGlobal, function(e2) {
    function _2(e3) {
      return e3 && typeof e3 == "object" && "default" in e3 ? e3 : {
        default: e3
      };
    }
    var t2 = _2(e2), d2 = {
      name: "zh-cn",
      weekdays: "\u661F\u671F\u65E5_\u661F\u671F\u4E00_\u661F\u671F\u4E8C_\u661F\u671F\u4E09_\u661F\u671F\u56DB_\u661F\u671F\u4E94_\u661F\u671F\u516D".split("_"),
      weekdaysShort: "\u5468\u65E5_\u5468\u4E00_\u5468\u4E8C_\u5468\u4E09_\u5468\u56DB_\u5468\u4E94_\u5468\u516D".split("_"),
      weekdaysMin: "\u65E5_\u4E00_\u4E8C_\u4E09_\u56DB_\u4E94_\u516D".split("_"),
      months: "\u4E00\u6708_\u4E8C\u6708_\u4E09\u6708_\u56DB\u6708_\u4E94\u6708_\u516D\u6708_\u4E03\u6708_\u516B\u6708_\u4E5D\u6708_\u5341\u6708_\u5341\u4E00\u6708_\u5341\u4E8C\u6708".split("_"),
      monthsShort: "1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),
      ordinal: function(e3, _3) {
        return _3 === "W" ? e3 + "\u5468" : e3 + "\u65E5";
      },
      weekStart: 1,
      yearStart: 4,
      formats: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY/MM/DD",
        LL: "YYYY\u5E74M\u6708D\u65E5",
        LLL: "YYYY\u5E74M\u6708D\u65E5Ah\u70B9mm\u5206",
        LLLL: "YYYY\u5E74M\u6708D\u65E5ddddAh\u70B9mm\u5206",
        l: "YYYY/M/D",
        ll: "YYYY\u5E74M\u6708D\u65E5",
        lll: "YYYY\u5E74M\u6708D\u65E5 HH:mm",
        llll: "YYYY\u5E74M\u6708D\u65E5dddd HH:mm"
      },
      relativeTime: {
        future: "%s\u5185",
        past: "%s\u524D",
        s: "\u51E0\u79D2",
        m: "1 \u5206\u949F",
        mm: "%d \u5206\u949F",
        h: "1 \u5C0F\u65F6",
        hh: "%d \u5C0F\u65F6",
        d: "1 \u5929",
        dd: "%d \u5929",
        M: "1 \u4E2A\u6708",
        MM: "%d \u4E2A\u6708",
        y: "1 \u5E74",
        yy: "%d \u5E74"
      },
      meridiem: function(e3, _3) {
        var t3 = 100 * e3 + _3;
        return t3 < 600 ? "\u51CC\u6668" : t3 < 900 ? "\u65E9\u4E0A" : t3 < 1100 ? "\u4E0A\u5348" : t3 < 1300 ? "\u4E2D\u5348" : t3 < 1800 ? "\u4E0B\u5348" : "\u665A\u4E0A";
      }
    };
    return t2.default.locale(d2, null, true), d2;
  });
})(zhCn);
var enAu = { exports: {} };
(function(module2, exports2) {
  !function(e2, a2) {
    module2.exports = a2(dayjs_min.exports);
  }(commonjsGlobal, function(e2) {
    function a2(e3) {
      return e3 && typeof e3 == "object" && "default" in e3 ? e3 : {
        default: e3
      };
    }
    var t2 = a2(e2), _2 = {
      name: "en-au",
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
      weekStart: 1,
      weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
      monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
      weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
      ordinal: function(e3) {
        return e3;
      },
      formats: {
        LT: "h:mm A",
        LTS: "h:mm:ss A",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY h:mm A",
        LLLL: "dddd, D MMMM YYYY h:mm A"
      },
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      }
    };
    return t2.default.locale(_2, null, true), _2;
  });
})(enAu);
const lStorage = new Proxy(localStorage, {
  set(_localStorage, prop, value) {
    if (_global__.isPlainObject(value)) {
      _localStorage[prop] = JSON.stringify(value);
    } else {
      _localStorage[prop] = value;
    }
    return true;
  },
  get(_localStorage, prop) {
    const objString = _localStorage[prop];
    try {
      return JSON.parse(objString);
    } catch (error) {
      if (objString === "undefined") {
        return false;
      }
      return objString || false;
    }
  }
});
lStorage.appConfigs = lStorage.appConfigs || {
  pagination: {
    page: "page",
    size: "size",
    total: "total"
  }
};
const State_UI = Vue.reactive({
  language: lStorage["language"] || "zh-CN",
  onLanguageChange: false,
  LANGUAGE: {
    enUs: defaultLocale,
    zhCn: zhCn$1
  },
  i18nMessage: {},
  $t(prop, payload = {}, i18nMessage = false) {
    const result = {
      label: prop,
      prop
    };
    _.templateSettings.interpolate = /{([\s\S]+?)}/g;
    if (State_UI.i18nMessage) {
      const temp = i18nMessage ? i18nMessage[prop] : State_UI.i18nMessage[prop];
      if (temp) {
        result.label = _.template(temp)(payload);
        if (!result.label) {
          result.label = prop;
          console.error(`i18n:${prop} "NOT_FOUND"`);
        }
      }
    }
    return result;
  }
});
Vue.watch(() => State_UI.language, (language) => {
  lStorage["language"] = language;
  dayjs.locale(language === "zh-CN" ? "zh-cn" : "en");
  if (State_UI.onLanguageChange) {
    State_UI.onLanguageChange(language, State_UI);
  }
}, {
  immediate: true
});
const Cpt_UI_locale = Vue.computed(() => {
  const currentLanguage = _.camelCase(State_UI.language);
  const locale2 = State_UI.LANGUAGE[currentLanguage];
  return locale2;
});
var DatePicker = ({
  property: property2,
  slots,
  listeners
}) => {
  let value = "";
  if (property2.value) {
    value = dayjs(property2.value);
    _global__.doNothing(value, property2.value);
    if (value === "Invalid Date") {
      _global__.doNothing("property.value", property2.value);
      value = "";
    }
  }
  return Vue.createVNode(DatePicker$3, Vue.mergeProps(property2, listeners, {
    "value": value,
    "locale": Cpt_UI_locale.value.DatePicker
  }), slots);
};
var RangePicker = ({
  property: property2,
  slots,
  listeners
}) => {
  console.log("property", property2.value);
  return Vue.createVNode(RangePicker$1, Vue.mergeProps(property2, listeners, {
    "locale": Cpt_UI_locale.value.DatePicker
  }), slots);
};
const EVENT_TYPE = {
  validateForm: "validateForm",
  update: "update",
  change: "change",
  input: "input",
  blur: "blur",
  focus: "focus"
};
const TIPS_TYPE = {
  success: "success",
  error: "error"
};
async function validateForm(configsForm) {
  let results = await Promise.all(_global__.map(configsForm, (configs, prop) => new Promise((resolve) => {
    if (_global__.isInput(configs.vIf)) {
      const isFalse = !configs.vIf;
      if (isFalse) {
        return resolve();
      }
      const isResFalse = _global__.isFunction(configs.vIf) && !configs.vIf();
      if (isResFalse) {
        return resolve();
      }
    }
    if (configs.validate) {
      configs.validate.formCallBack = (result) => {
        delete configs.validate.formCallBack;
        resolve(result);
      };
      configs.validate(EVENT_TYPE.validateForm);
    } else {
      resolve();
    }
  })));
  results = results.filter((res) => res && res[0] && res[1]);
  return results;
}
const AllWasWell = (res) => {
  return _global__.isArray(res) && res.length === 0;
};
const checkXItem = async (xItemConfigs, handlerResult) => {
  xItemConfigs.checking = true;
  try {
    const {
      rules,
      prop
    } = xItemConfigs;
    const result = await (async () => {
      let dontCheck = 0;
      for (let i2 = 0; i2 < rules.length; i2++) {
        const rule = rules[i2];
        const trigger2 = rule.trigger || [];
        let isFail = await (async () => {
          let trigBy;
          const isNeedVerify = (() => {
            if (xItemConfigs.validate.triggerEventsObj[EVENT_TYPE.validateForm]) {
              trigBy = "validateForm";
              return true;
            }
            const isInTrigger = (eventName) => xItemConfigs.validate.triggerEventsObj[eventName];
            if (_global__.some(trigger2, isInTrigger)) {
              trigBy = `triggerEvent ${trigger2.toString()}`;
              return true;
            }
            if (trigger2.includes(EVENT_TYPE.update)) {
              const updateTrigger = [EVENT_TYPE.change, EVENT_TYPE.input, EVENT_TYPE.blur];
              if (_global__.some(updateTrigger, isInTrigger)) {
                trigBy = "update";
                return true;
              }
            }
            return false;
          })();
          trigBy && _global__.doNothing(`%cValidate trigger off by [${trigBy}]`, "color:yellow;background:green;");
          if (isNeedVerify) {
            const validateResult = await rule.validator(xItemConfigs.value, {
              configs: xItemConfigs,
              rule
            });
            if (validateResult) {
              return validateResult;
            }
          } else {
            dontCheck++;
          }
          return false;
        })();
        if (isFail) {
          return [prop, rule.msg, xItemConfigs.FormItemId];
        }
      }
      if (dontCheck === rules.length) {
        return [false, false];
      } else {
        return [prop, false];
      }
    })();
    handlerResult(result);
    if (_global__.isFunction(xItemConfigs.validate.formCallBack)) {
      xItemConfigs.validate.formCallBack(result);
    }
  } catch (error) {
    console.error(error);
  } finally {
    xItemConfigs.validate.triggerEventsObj = {};
  }
};
var Checkbox = ({
  property: property2
}) => {
  const _property = _.merge({}, property2, {
    checked: property2.value,
    onClick() {
      _property["onUpdate:value"](!_property.value, EVENT_TYPE.update);
    }
  });
  return Vue.h(Checkbox$1, _property);
};
var Select = ({
  property: property2,
  listeners
}) => {
  const _property = _global__.omit(property2, ["options"]);
  const renderOptions = () => {
    return _global__.map(property2.options, (option) => {
      return Vue.createVNode(SelectOption, {
        "value": option.value
      }, {
        default: () => [option.label]
      });
    });
  };
  return Vue.createVNode(_Select, Vue.mergeProps(listeners, _property), {
    default: renderOptions
  });
};
var RadioGroup = ({
  property: property2,
  slots,
  listeners
}) => {
  return Vue.createVNode(RadioGroup$1, Vue.mergeProps(property2, listeners), slots);
};
var CheckboxGroup = ({
  property: property2,
  slots,
  listeners
}) => {
  return Vue.createVNode(CheckboxGroup$1, Vue.mergeProps(property2, listeners), slots);
};
var Switch = ({
  property: property2,
  slots,
  listeners
}) => {
  const _property = _global__.merge({}, property2, {
    checked: property2.value,
    onClick() {
      listeners["onUpdate:value"](!_property.value);
    }
  });
  return Vue.createVNode("span", null, [Vue.h(_Switch, _global__.omit(_property, ["value"]))]);
};
const itemRenders = {
  Input,
  Checkbox,
  Select,
  Switch,
  DatePicker,
  RangePicker,
  RadioGroup,
  CheckboxGroup
};
const MutatingProps = (item, prop, val = null) => {
  item = item || {};
  const propArray = prop.split(".");
  let key2 = "";
  let nextItem = item;
  const setVal = () => {
    while (key2 = propArray.shift()) {
      if (propArray.length === 0) {
        nextItem[key2] = val;
        return;
      } else {
        const _nextItem = nextItem[key2];
        if (!_nextItem) {
          nextItem[key2] = {};
        }
        nextItem = nextItem[key2];
      }
    }
  };
  const getVal = () => {
    while (key2 = propArray.shift()) {
      const _nextItem = nextItem[key2];
      if (!_nextItem) {
        return nextItem[key2];
      } else {
        if (propArray.length === 0) {
          return _nextItem;
        } else {
          nextItem = nextItem[key2];
        }
      }
    }
    return nextItem;
  };
  if (val || _global__.isString(val) || _global__.isBoolean(val) || _global__.isNumber(val) && !_global__.isNaN(val)) {
    setVal();
  } else {
    return getVal(key2, propArray, nextItem);
  }
  return item;
};
const domClass = {
  tipsError: "ant-form-item-explain ant-form-item-explain-error"
};
var _sfc_main$k = Vue.defineComponent({
  name: "xItem",
  props: {
    modelValue: {
      type: [Object, String, Number, Boolean]
    },
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props2) {
    let Cpt_isShowXItem = true;
    let Cpt_isDisabled = false;
    if (_global__.isFunction(props2.configs.vIf)) {
      Cpt_isShowXItem = Vue.computed(props2.configs.vIf);
    } else if (_global__.isBoolean(props2.configs.vIf)) {
      Cpt_isShowXItem = props2.configs.vIf;
    }
    if (_global__.isFunction(props2.configs.disabled)) {
      Cpt_isDisabled = Vue.computed(props2.configs.disabled);
    } else if (_global__.isBoolean(props2.configs.disabled)) {
      Cpt_isDisabled = props2.configs.disabled;
    }
    return {
      Cpt_isShowXItem,
      Cpt_isDisabled
    };
  },
  emits: ["update:modelValue"],
  data() {
    return {
      isRequired: false
    };
  },
  computed: {
    isChecking() {
      return Boolean(this.configs.checking);
    },
    FormItemId() {
      return `xItem_${this._.uid}`;
    },
    itemTips() {
      var _a, _b;
      const _itemTips = {
        type: "",
        msg: ""
      };
      if ((_b = (_a = this.configs) == null ? void 0 : _a.itemTips) == null ? void 0 : _b.type) {
        return {
          type: this.configs.itemTips.type,
          msg: _global__.isFunction(this.configs.itemTips.msg) ? this.configs.itemTips.msg() : this.configs.itemTips.msg
        };
      } else {
        this.configs.itemTips = _itemTips;
        return _itemTips;
      }
    },
    itemWrapperClass() {
      return [
        this.configs.itemWrapperClass,
        "ant-form-item ant-form-item-with-help x-item flex",
        this.itemTips.type === TIPS_TYPE.error ? "ant-form-item-has-error" : ""
      ].join(" ");
    },
    componentSettings() {
      const configs = this.configs;
      configs.value = this.modelValue;
      const property2 = {};
      const listeners = {};
      let slots = {};
      const pickAttrs2 = (properties) => {
        _global__.each(properties, (value, prop) => {
          if (prop === "slots") {
            slots = value;
            return;
          }
          if (["placeholder"].includes(prop) && _global__.isFunction(value)) {
            property2[prop] = value(this);
            return;
          }
          if (["itemTips", "rules"].includes(prop)) {
            return;
          }
          if (_global__.isListener(prop)) {
            if (listeners[prop]) {
              listeners[prop].queue.push(value);
              return;
            } else {
              listeners[prop] = function(...args) {
                listeners[prop].queue.forEach((listener) => listener(...args));
              };
              listeners[prop].queue = [value];
              return;
            }
          }
          property2[prop] = value;
          return;
        });
      };
      const handleConfigsValidate = (eventType) => {
        configs.validate && configs.validate(eventType);
      };
      pickAttrs2({
        "onUpdate:value": (val, ...args) => {
          this.$emit("update:modelValue", val);
          if (_global__.isFunction(configs.onAfterValueChang)) {
            configs.onAfterValueChange(configs);
          }
          handleConfigsValidate(EVENT_TYPE.update);
        },
        onChange: () => {
          handleConfigsValidate(EVENT_TYPE.change);
        },
        onInput: () => {
          handleConfigsValidate(EVENT_TYPE.input);
        },
        onBlur: () => {
          handleConfigsValidate(EVENT_TYPE.blur);
        },
        onFocus: () => {
          handleConfigsValidate(EVENT_TYPE.focus);
        }
      });
      pickAttrs2(this.configs);
      pickAttrs2(this.$attrs);
      if (this.Cpt_isDisabled) {
        property2.disabled = true;
      } else {
        delete property2.disabled;
      }
      return {
        property: property2,
        slots,
        listeners
      };
    },
    tipsVNode() {
      if (this.isChecking) {
        return Vue.createVNode("div", null, [Vue.createVNode("div", {
          "data-type": "checking"
        }, [Vue.createTextVNode("checking...")])]);
      }
      if (this.configs.tipsVNodeRender) {
        return this.configs.tipsVNodeRender({
          xItem: this,
          configs: this.configs,
          itemTips: this.itemTips
        });
      }
      if (this.itemTips.msg) {
        if (this.itemTips.type === TIPS_TYPE.error) {
          return Vue.createVNode("div", {
            "class": domClass.tipsError
          }, [Vue.createVNode("div", {
            "data-type": "error"
          }, [this.itemTips.msg])]);
        }
      }
      return null;
    },
    labelVNode() {
      const classString = this.isRequired ? "ant-form-item-required" : "";
      if (this.configs.labelVNodeRender) {
        return this.configs.labelVNodeRender(this.configs, classString);
      }
      let label = (() => {
        const _label = this.configs.label;
        if (_global__.isFunction(_label)) {
          return _label();
        }
        if (_global__.isString(_label)) {
          return _label;
        }
        return false;
      })();
      if (label === false) {
        return null;
      }
      return Vue.createVNode("div", {
        "class": "ant-form-item-label"
      }, [Vue.createVNode("label", {
        "for": this.configs.prop,
        "class": classString
      }, [label])]);
    }
  },
  watch: {
    "configs.rules": {
      immediate: true,
      deep: true,
      handler(rules) {
        this.setValidateInfo(rules);
      }
    }
  },
  created() {
    MutatingProps(this, "configs.FormItemId", this.FormItemId);
  },
  methods: {
    setTips(type2 = "", msg = "") {
      MutatingProps(this, "configs.itemTips", {
        type: type2,
        msg
      });
    },
    setValidateInfo(rules) {
      let isRequired = false;
      if (_global__.isArrayFill(rules)) {
        isRequired = _global__.some(rules, {
          name: "required"
        });
        const handleAfterCheck = ([prop, msg]) => {
          MutatingProps(this, "configs.checking", false);
          if (prop) {
            if (msg) {
              this.setTips(TIPS_TYPE.error, msg);
              if (_global__.isFunction(this.configs.onValidateFail)) {
                this.configs.onValidateFail(this.configs);
              }
            } else {
              this.setTips();
            }
          }
        };
        const debounceCheckXItem = _global__.debounce(checkXItem, 300);
        MutatingProps(this, "configs.validate", (eventType) => {
          const prop = `configs.validate.triggerEventsObj.${eventType}`;
          MutatingProps(this, prop, true);
          debounceCheckXItem(this.configs, handleAfterCheck);
        });
        MutatingProps(this, "configs.validate.triggerEventsObj", {});
      } else {
        if (_global__.isFunction(this.configs.validate)) {
          delete this.configs.validate;
        }
      }
      this.isRequired = isRequired;
    }
  },
  render(h2) {
    if (!this.Cpt_isShowXItem) {
      return null;
    }
    const CurrentXItem = (() => {
      return itemRenders[this.configs.itemType] || itemRenders.Input;
    })();
    return Vue.createVNode("div", {
      "id": this.FormItemId,
      "class": this.itemWrapperClass
    }, [this.labelVNode, Vue.createVNode("div", {
      "class": "ant-form-item-control"
    }, [Vue.createVNode(CurrentXItem, this.componentSettings, null), this.tipsVNode])]);
  }
});
var _sfc_main$j = Vue.defineComponent({
  name: "xForm",
  props: {
    labelStyle: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  emits: [],
  data() {
    return {};
  },
  computed: {
    xFormId() {
      return `xForm_${this._.uid}`;
    },
    labelStyleText() {
      return _global__.map(_global__.merge({
        width: "120px",
        "text-align": "left"
      }, this.labelStyle), (value, prop) => `${prop}: ${value}`).join(";");
    },
    styleContent() {
      return `#${this.xFormId} { width:100%; padding:0 16px; }
 #${this.xFormId} div.ant-form-item-label { ${this.labelStyleText} }`;
    }
  },
  mounted() {
    const $form = $(`#${this.xFormId}`);
    const $style = $("<style/>", {
      id: `style_${this.xFormId}`
    }).append(this.styleContent);
    $form.prepend($style);
  },
  watch: {
    styleContent() {
      this.updateStyle(this.styleContent);
    }
  },
  methods: {
    updateStyle(styleContent) {
      const $style = $(`#style_${this.xFormId}`);
      $style.html(styleContent);
    }
  }
});
var _export_sfc = (sfc, props2) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props2) {
    target[key2] = val;
  }
  return target;
};
const _hoisted_1$a = ["id"];
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return Vue.openBlock(), Vue.createElementBlock("form", {
    id: _ctx.xFormId
  }, [Vue.renderSlot(_ctx.$slots, "default")], 8, _hoisted_1$a);
}
var xForm = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$8]]);
const BTN_PRESET_MAP = {
  query: () => ({
    icon: Vue.createVNode(SearchOutlined$1, null, null),
    text: State_UI.$t("\u67E5\u8BE2").label
  }),
  refresh: () => ({
    icon: Vue.createVNode(SyncOutlined$1, null, null),
    text: State_UI.$t("\u5237\u65B0").label
  }),
  save: () => ({
    icon: Vue.createVNode(SaveOutlined$1, null, null),
    text: State_UI.$t("\u4FDD\u5B58").label
  }),
  upload: () => ({
    icon: Vue.createVNode(UploadOutlined$1, null, null),
    text: State_UI.$t("\u4E0A\u4F20").label
  }),
  delete: () => ({
    icon: Vue.createVNode(DeleteOutlined$1, null, null),
    text: State_UI.$t("\u5220\u9664").label
  })
};
var xButton = Vue.defineComponent({
  name: "xButton",
  components: {
    Button: Button$1
  },
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    return {
      loading: true
    };
  },
  computed: {
    type() {
      if (this.configs.preset === "query") {
        return "primary";
      }
      return this.configs.type;
    },
    title() {
      if (_global__.isString(this.disabled) && this.disabled.length > 0) {
        return this.disabled;
      }
      if (_global__.isString(this.configs.title) && this.configs.title.length > 0) {
        return this.configs.title;
      }
      return false;
    },
    disabled() {
      if (_global__.isBoolean(this.configs.disabled)) {
        return this.configs.disabled;
      }
      if (_global__.isFunction(this.configs.disabled)) {
        return this.configs.disabled(this);
      }
      return false;
    },
    text() {
      var _a;
      if (_global__.isFunction((_a = this.$slots) == null ? void 0 : _a.default)) {
        return this.$slots.default(this);
      }
      const presetFn = BTN_PRESET_MAP[this.configs.preset];
      if (presetFn) {
        const preset = presetFn();
        return Vue.createVNode("span", {
          "class": "btn-preset"
        }, [preset.icon, preset.text]);
      }
      if (_global__.isFunction(this.configs.text)) {
        return this.configs.text(this) || "";
      }
      return this.configs.text || "";
    }
  },
  watch: {
    configs: {
      immediate: true,
      handler(configs) {
        this.loading = !!configs.loading;
      }
    }
  },
  created() {
  },
  methods: {
    async onClick() {
      if (_global__.isFunction(this.configs.onClick)) {
        this.loading = true;
        try {
          await this.configs.onClick(this);
        } catch (e2) {
          console.error(e2);
        } finally {
          this.loading = false;
        }
      }
    }
  },
  render(h2) {
    const configs = _global__.omit(this.configs, ["text", "onClick", "disabled"]);
    if (this.title) {
      configs.title = this.title;
    }
    return Vue.createVNode(Button$1, Vue.mergeProps({
      "class": "flex middle",
      "onClick": this.onClick,
      "loading": this.loading,
      "disabled": !!this.disabled,
      "type": this.type
    }, configs), {
      default: () => [this.text]
    });
  }
});
var _sfc_main$i = Vue.defineComponent({
  name: "XButtonCountDown",
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    const vm = this;
    return {
      state: {
        captchaCount: 0
      },
      btnConfigs: {
        disabled: false,
        size: "large",
        style: {
          minWidth: "112px"
        },
        text: vm.configs.text.normal,
        async onClick() {
          if (_global__.isFunction(vm.configs.onClick)) {
            await vm.configs.onClick({
              countDown: vm.countDown
            });
          }
        }
      }
    };
  },
  watch: {
    "state.captchaCount"(captchaCount) {
      this.handleCaptchaCountChange(captchaCount);
    }
  },
  methods: {
    countDown() {
      this.state.captchaCount++;
      if (this.state.captchaCount <= this.configs.countMax) {
        setTimeout(this.countDown, 1e3);
      } else {
        this.state.captchaCount = 0;
      }
    },
    handleCaptchaCountChange(captchaCount) {
      if (captchaCount === 0) {
        this.btnConfigs.text = this.configs.text.normal;
        this.btnConfigs.disabled = false;
        return;
      }
      const setCounDownText = () => {
        return this.btnConfigs.text = `${this.configs.countMax - captchaCount} s`;
      };
      if (captchaCount === 1) {
        setCounDownText();
        this.btnConfigs.disabled = true;
        return;
      }
      if (captchaCount && captchaCount <= this.configs.countMax) {
        setCounDownText();
        return;
      }
    }
  }
});
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xButton = Vue.resolveComponent("xButton");
  return Vue.openBlock(), Vue.createBlock(_component_xButton, {
    configs: _ctx.btnConfigs
  }, null, 8, ["configs"]);
}
var xButtonCountDown = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$7]]);
var _sfc_main$h = Vue.defineComponent({
  name: "xGap",
  props: ["t", "l", "r", "b", "a", "f"],
  computed: {
    gapClass: {
      get() {
        let basic = "x-gap";
        if (this.f) {
          basic += ` flex${this.f}`;
        }
        return basic;
      }
    },
    gapStyle: {
      get() {
        const POSITION_MAP = {
          t: "top",
          r: "right",
          b: "bottom",
          l: "left"
        };
        const gapStyle = {};
        if (this.a) {
          gapStyle.margin = `${this.a}px`;
        } else {
          _global__.map(POSITION_MAP, (prop, key2) => {
            const value = this[key2];
            if (value) {
              gapStyle[`margin-${prop}`] = `${value}px`;
            }
          });
        }
        return gapStyle;
      }
    }
  },
  render(h2) {
    return Vue.createVNode("div", {
      "style": this.gapStyle,
      "class": this.gapClass
    }, null);
  }
});
const line = {};
const CONFIGS_MAP = {
  line
};
var _sfc_main$g = Vue.defineComponent({
  name: "xCharts",
  props: {
    payload: {
      type: Object,
      default: ""
    },
    configs: {
      type: [String, Object],
      required: true
    },
    dataset: {
      type: [Array, Object],
      default() {
        return [];
      }
    }
  },
  data() {
    const id = _global__.genId("xChart");
    return {
      id
    };
  },
  computed: {
    helper() {
      if (_global__.isPlainObject(this.configs)) {
        return this.configs;
      }
      return CONFIGS_MAP[this.configs];
    }
  },
  mounted() {
    this.init();
  },
  methods: {
    init() {
      this.updateOptions();
      this.observe();
    },
    updateOptions() {
      if (this.myChart) {
        this.myChart.dispose();
      }
      const options = this.helper.initOptions(this.$props);
      this.options = this.helper.updateOptions(options, this.dataset);
      const dom = document.querySelector(`#${this.id}`);
      this.myChart = this.$echarts.init(dom);
      this.myChart.showLoading();
      this.myChart.setOption(this.options);
      this.myChart.hideLoading();
    },
    observe() {
      this.resizeObserver = new ResizeObserver(() => {
        var _a;
        if (this.myChart) {
          ((_a = this.myChart) == null ? void 0 : _a.resize) && this.myChart.resize();
        }
      });
      this.resizeObserver.observe(this.$el);
    }
  }
});
const _hoisted_1$9 = ["id"];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return Vue.openBlock(), Vue.createElementBlock("div", {
    id: _ctx.id,
    class: "x-charts flex flex1 center middle"
  }, null, 8, _hoisted_1$9);
}
var xCharts = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$6]]);
var _sfc_main$f = Vue.defineComponent({
  name: "xView",
  props: {
    isShow: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {};
  },
  computed: {
    id() {
      return `xView_${this._.uid}`;
    }
  }
});
const _hoisted_1$8 = ["id"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("div", {
    id: _ctx.id
  }, [Vue.renderSlot(_ctx.$slots, "default")], 8, _hoisted_1$8)), [[Vue.vShow, !!_ctx.isShow]]);
}
var xView = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$5]]);
function _isSlot(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !Vue.isVNode(s2);
}
const static_word = {
  operation: "operation"
};
function defDataGridOption(options) {
  options.pagination = options.pagination || defPagination();
  options.isLoading = Boolean(options.isLoading);
  if (options.queryTableList) {
    options._queryTableList_origin = options.queryTableList;
    options.queryTableList = async function(...args) {
      this.isLoading = true;
      await this._queryTableList_origin.apply(this, args);
      this.isLoading = false;
    };
  }
  options.onPaginationChange = options.onPaginationChange || async function(pagination) {
    await this.queryTableList({
      pagination
    });
  };
  return options;
}
function defPagination(num_page = 1, num_size = 10, num_total = 0) {
  const {
    page,
    size,
    total: total2
  } = lStorage.appConfigs.pagination;
  return {
    [page]: num_page || 1,
    [size]: num_size || 10,
    [total2]: num_total || 0
  };
}
function setPagination(StateTable, pagination) {
  const PAGINATION_MAP = lStorage.appConfigs.pagination;
  _global__.each(pagination, (value, prop) => {
    StateTable.pagination[PAGINATION_MAP[prop]] = value;
  });
}
function defCol(options) {
  return {
    [options.prop]: __spreadProps(__spreadValues({}, options), {
      key: options.prop,
      title: options.label,
      dataIndex: options.prop
    })
  };
}
function defColActions(options) {
  return {
    [static_word.operation]: _global__.merge({
      title: State_UI.$t("\u64CD\u4F5C").label,
      key: static_word.operation,
      prop: static_word.operation,
      fixed: "right",
      minWidth: 100
    }, options)
  };
}
function defColActionsBtnlist(options) {
  const {
    fold = 3,
    btns = []
  } = options;
  const [always, more] = (() => {
    if (btns.length > fold) {
      return [btns.slice(0, fold - 1), btns.slice(fold - 1)];
    } else {
      return [btns, []];
    }
  })();
  return Vue.createVNode("div", {
    "class": "flex middle"
  }, [Vue.createVNode(Vue.resolveComponent("xGap"), {
    "l": "4"
  }, null), _global__.map(always, (btn) => {
    const configs = _global__.merge({
      type: "link",
      size: "small"
    }, btn);
    return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode(Vue.resolveComponent("xButton"), {
      "configs": configs
    }, null), Vue.createVNode(Vue.resolveComponent("xGap"), {
      "l": "4"
    }, null)]);
  }), (() => {
    if (more.length === 0) {
      return null;
    }
    return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode(Vue.resolveComponent("aDropdown"), null, {
      default: () => {
        return Vue.createVNode(Vue.resolveComponent("aButton"), {
          "type": "link"
        }, {
          default: () => [State_UI.$t("\u66F4\u591A").label]
        });
      },
      overlay: () => {
        let _slot;
        return Vue.createVNode(Vue.Fragment, null, [Vue.createVNode(Vue.resolveComponent("aMenu"), null, _isSlot(_slot = _global__.map(more, (btn) => {
          const configs = _global__.merge({
            type: "link",
            size: "small"
          }, btn);
          return Vue.createVNode(Vue.resolveComponent("aMenuItem"), {
            "key": btn.text
          }, {
            default: () => [Vue.createVNode(Vue.resolveComponent("xButton"), {
              "configs": configs
            }, null)]
          });
        })) ? _slot : {
          default: () => [_slot]
        })]);
      }
    }), Vue.createVNode(Vue.resolveComponent("xGap"), {
      "l": "4"
    }, null)]);
  })()]);
}
function filterColIsShow(isShow, prop) {
  if (_global__.isBoolean(isShow)) {
    return isShow;
  } else {
    return true;
  }
}
const PAGE_SIZE_OPTIONS = ["10", "20", "30"];
var _sfc_main$e = Vue.defineComponent({
  name: "xPagination",
  components: {
    Pagination: _Pagination
  },
  props: {
    onPaginationChange: {
      type: Function,
      default: false
    },
    pagination: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    const {
      page,
      size,
      total: total2
    } = lStorage.appConfigs.pagination;
    return {
      pageSizeOptions: PAGE_SIZE_OPTIONS,
      page,
      size,
      total: total2
    };
  },
  methods: {
    onShowSizeChange: _global__.debounce(function(page, size) {
      setPagination(this, {
        page,
        size
      });
      if (this.onPaginationChange) {
        this.onPaginationChange(this.pagination);
      }
    }, 30)
  }
});
lStorage.appConfigs.pagination;
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Pagination = Vue.resolveComponent("Pagination");
  return Vue.openBlock(), Vue.createBlock(_component_Pagination, {
    current: _ctx.pagination[_ctx.page],
    "onUpdate:current": _cache[0] || (_cache[0] = ($event) => _ctx.pagination[_ctx.page] = $event),
    "page-size-options": _ctx.pageSizeOptions,
    total: _ctx.pagination[_ctx.total],
    "page-size": _ctx.pagination[_ctx.size],
    "show-size-changer": "",
    "show-total": (total2) => _ctx.$t("\u603B\u6761\u6570", {
      total: total2
    }).label,
    onShowSizeChange: _ctx.onShowSizeChange,
    onChange: _ctx.onShowSizeChange
  }, {
    buildOptionText: Vue.withCtx((props2) => [Vue.createElementVNode("span", null, Vue.toDisplayString(_ctx.$t("\u6761\u9875", {
      size: props2.value
    }).label), 1)]),
    _: 1
  }, 8, ["current", "page-size-options", "total", "page-size", "show-total", "onShowSizeChange", "onChange"]);
}
var xPagination = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$4]]);
var _sfc_main$d = Vue.defineComponent({
  name: "xDataGrid",
  components: {
    xPagination
  },
  setup() {
    return {
      Cpt_UI_locale
    };
  },
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    return {
      State: {
        id: _global__.genId("xDataGrid")
      }
    };
  },
  computed: {
    Cpt_Columns() {
      if (this.configs.isGroupingColumns) {
        return this.configs.columns;
      }
      let columns = null;
      columns = _global__.map(this.Cpt_ColumnsOrder, (prop) => _global__.find(this.configs.columns, {
        prop
      }));
      columns = _global__.filter(columns, (i2) => filterColIsShow(i2 == null ? void 0 : i2.isShow, i2 == null ? void 0 : i2.prop));
      return columns;
    },
    Cpt_ColumnsOrder() {
      const order = (() => {
        if (this.configs.columns_order) {
          return this.configs.columns_order;
        } else {
          return _global__.map(this.configs.columns, (i2) => i2.prop);
        }
      })();
      return _global__.filter(order, (i2) => !!i2);
    },
    Cpt_AntTableProperty() {
      if (this.configs.antTableProperty) {
        return this.configs.antTableProperty;
      } else {
        return {};
      }
    },
    Cpt_VNodeTable() {
      if (this.configs.renderTable) {
        return this.configs.renderTable({
          vm: this
        });
      } else {
        const slots = {
          emptyText: () => Vue.createVNode("div", {
            "class": "ant-empty ant-empty-normal"
          }, [Vue.createVNode("div", {
            "class": "ant-empty-image"
          }, [Vue.createVNode("svg", {
            "class": "ant-empty-img-simple",
            "width": "64",
            "height": "41",
            "viewBox": "0 0 64 41"
          }, [Vue.createVNode("g", {
            "transform": "translate(0 1)",
            "fill": "none",
            "fill-rule": "evenodd"
          }, [Vue.createVNode("ellipse", {
            "class": "ant-empty-img-simple-ellipse",
            "fill": "#F5F5F5",
            "cx": "32",
            "cy": "33",
            "rx": "32",
            "ry": "7"
          }, null), Vue.createVNode("g", {
            "class": "ant-empty-img-simple-g",
            "fill-rule": "nonzero",
            "stroke": "#D9D9D9"
          }, [Vue.createVNode("path", {
            "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
          }, null), Vue.createVNode("path", {
            "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
            "fill": "#FAFAFA",
            "class": "ant-empty-img-simple-path"
          }, null)])])])]), Vue.createVNode("p", {
            "class": "ant-empty-description"
          }, [this.Cpt_UI_locale.Empty.description])]),
          bodyCell: (args) => {
            const {
              column
            } = args;
            if (column && column.renderCell) {
              const vNode = column.renderCell(args);
              if (_global__.isNull(vNode) || _global__.isUndefined(vNode)) {
                return "";
              }
              return vNode;
            }
          }
        };
        return Vue.createVNode(_Table, Vue.mergeProps({
          "loading": this.configs.isLoading,
          "dataSource": this.configs.dataSource,
          "columns": this.Cpt_Columns,
          "scroll": {
            x: 1500
          },
          "pagination": false,
          "locale": this.Cpt_UI_locale.Table
        }, this.Cpt_AntTableProperty), slots);
      }
    },
    Cpt_VNodePagination() {
      if (this.configs.isHidePagination) {
        return null;
      }
      return Vue.createVNode(xPagination, {
        "class": "table-pagination",
        "pagination": this.configs.pagination,
        "onPaginationChange": this.handlePaginationChange
      }, null);
    }
  },
  mounted() {
    if (this.configs.onMounted) {
      this.configs.onMounted({
        id: this.State.id
      });
    }
  },
  methods: {
    async handlePaginationChange(pagination) {
      this.configs.isLoading = true;
      await this.configs.onPaginationChange(pagination);
      this.configs.isLoading = false;
    }
  },
  render() {
    return Vue.createVNode("div", {
      "id": this.State.id
    }, [this.Cpt_VNodeTable, this.Cpt_VNodePagination]);
  }
});
var xDataGrid_vue_vue_type_style_index_0_lang = "";
var _sfc_main$c = Vue.defineComponent({
  name: "xColFilter",
  components: {
    SettingOutlined: SettingOutlined$1
  },
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  methods: {
    handleChecked(col) {
      const target = _global__.find(this.configs.columns, {
        key: col.key
      });
      target.isShow = _global__.isBoolean(target.isShow) ? !target.isShow : false;
    }
  },
  computed: {
    Cpt_ColumnsOrder() {
      const order = (() => {
        if (this.configs.columns_order) {
          return this.configs.columns_order;
        } else {
          return _global__.map(this.configs.columns, (i2) => i2.prop);
        }
      })();
      return _global__.filter(order, (i2) => !!i2);
    },
    Cpt_Columns() {
      return _global__.map(this.Cpt_ColumnsOrder, (prop) => _global__.find(this.configs.columns, {
        prop
      }));
    },
    checkedList() {
      return _global__.filter(this.Cpt_ColumnsOrder, (prop) => {
        const {
          isShow
        } = this.configs.columns[prop];
        return filterColIsShow(isShow);
      });
    }
  }
});
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_aCheckbox = Vue.resolveComponent("aCheckbox");
  const _component_SettingOutlined = Vue.resolveComponent("SettingOutlined");
  const _component_aButton = Vue.resolveComponent("aButton");
  const _component_aPopover = Vue.resolveComponent("aPopover");
  return Vue.openBlock(), Vue.createBlock(_component_aPopover, {
    placement: "leftTop",
    trigger: "click"
  }, {
    content: Vue.withCtx(() => [(Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(_ctx.Cpt_Columns, (col) => {
      return Vue.openBlock(), Vue.createElementBlock("p", {
        key: col.key
      }, [Vue.createVNode(_component_aCheckbox, {
        checked: _ctx.checkedList.includes(col.key),
        onChange: ($event) => _ctx.handleChecked(col)
      }, {
        default: Vue.withCtx(() => [Vue.createTextVNode(Vue.toDisplayString(col.title), 1)]),
        _: 2
      }, 1032, ["checked", "onChange"])]);
    }), 128))]),
    default: Vue.withCtx(() => [Vue.createVNode(_component_aButton, null, {
      icon: Vue.withCtx(() => [Vue.createVNode(_component_SettingOutlined)]),
      _: 1
    })]),
    _: 1
  });
}
var xColFilter = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$3]]);
var _sfc_main$b = Vue.defineComponent({
  name: "xDataGridToolbar",
  components: {
    xColFilter
  },
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  computed: {
    Cpt_btn_query() {
      return {
        preset: "query",
        onClick: async () => {
          if (this.configs.queryTableList) {
            setPagination(this.configs, {
              page: 1
            });
            await this.configs.queryTableList({
              pagination: {
                page: 1
              }
            });
          }
        }
      };
    },
    Cpt_btn_refresh() {
      return {
        preset: "refresh",
        onClick: async () => {
          if (this.configs.queryTableList) {
            await this.configs.queryTableList();
          }
        }
      };
    },
    Cpt_isShowQuery() {
      if (!this.configs.queryTableList) {
        return false;
      }
      return !this.configs.isHideQuery;
    },
    Cpt_isShowRefresh() {
      if (!this.configs.queryTableList) {
        return false;
      }
      return !this.configs.isHideRefresh;
    },
    Cpt_isShowFilter() {
      if (this.configs.isGroupingColumns) {
        return false;
      }
      if (this.configs.isHideFilter) {
        return false;
      }
      return true;
    },
    Cpt_isSetConfigs() {
      return this.configs && this.configs.pagination;
    }
  }
});
const _hoisted_1$7 = {
  class: "table-options"
};
const _hoisted_2$4 = {
  class: "table-option-left flex flex1"
};
const _hoisted_3$4 = {
  key: 0,
  class: "table-filter flex"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xButton = Vue.resolveComponent("xButton");
  const _component_xGap = Vue.resolveComponent("xGap");
  const _component_xColFilter = Vue.resolveComponent("xColFilter");
  return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$7, [Vue.createElementVNode("div", _hoisted_2$4, [Vue.renderSlot(_ctx.$slots, "default")]), _ctx.Cpt_isSetConfigs ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_3$4, [_ctx.Cpt_isShowQuery ? (Vue.openBlock(), Vue.createBlock(_component_xButton, {
    key: 0,
    configs: _ctx.Cpt_btn_query
  }, null, 8, ["configs"])) : Vue.createCommentVNode("", true), Vue.createVNode(_component_xGap, {
    l: "4"
  }), _ctx.Cpt_isShowRefresh ? (Vue.openBlock(), Vue.createBlock(_component_xButton, {
    key: 1,
    configs: _ctx.Cpt_btn_refresh
  }, null, 8, ["configs"])) : Vue.createCommentVNode("", true), Vue.createVNode(_component_xGap, {
    l: "4"
  }), _ctx.Cpt_isShowFilter ? (Vue.openBlock(), Vue.createBlock(_component_xColFilter, {
    key: 2,
    configs: _ctx.configs
  }, null, 8, ["configs"])) : Vue.createCommentVNode("", true)])) : Vue.createCommentVNode("", true)]);
}
var xDataGridToolbar = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$2]]);
var _sfc_main$a = Vue.defineComponent({
  name: "xCellLabel",
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    return {
      loading: false,
      title: ""
    };
  },
  computed: {
    id() {
      return `xLabel_${this._.uid}`;
    }
  },
  watch: {
    configs: {
      immediate: true,
      handler(configs) {
        this.loading = !!configs.loading;
      }
    }
  },
  methods: {
    updateTitle(title) {
      if (this.title !== title) {
        this.title = title;
      }
    }
  },
  updated() {
    const $dom = $(`#${this.id}`);
    const domWidth = $dom.width();
    const $span = $(`#${this.id} > span`);
    const spanWidth = $span.width();
    if (domWidth < spanWidth) {
      const text = $dom.text();
      this.updateTitle(text);
    } else {
      this.updateTitle("");
    }
  }
});
const _hoisted_1$6 = ["title", "id"];
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return Vue.openBlock(), Vue.createElementBlock("div", {
    class: "ellipsis",
    title: _ctx.title,
    id: _ctx.id
  }, [Vue.createElementVNode("span", null, [Vue.renderSlot(_ctx.$slots, "default")])], 8, _hoisted_1$6);
}
var xCellLabel = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$1]]);
const installUIDialogComponent = (UI2, {
  appPlugins: appPlugins2,
  dependState
}) => {
  UI2.dialog.component = async (options) => new Promise((resolve, reject) => {
    const {
      component,
      title,
      area
    } = options;
    const id = `xDialog_${Date.now()}`;
    let $container = $("<div/>", {
      id
    });
    $container.appendTo($("body"));
    const __elId = `#${id}`;
    if (options.yes) {
      options._yes = options.yes;
      delete options.yes;
    }
    let app = null;
    let handleEcsPress = {
      layerIndex: "",
      handler(event) {
        const code = event.keyCode;
        event.preventDefault();
        if (code === KEY.esc) {
          layer.close(handleEcsPress.layerIndex);
        }
      },
      on(layerIndex) {
        handleEcsPress.layerIndex = layerIndex;
        $(document).on(`keyup.${__elId}`, handleEcsPress.handler);
      },
      off() {
        $(document).off(`keyup.${__elId}`, handleEcsPress.handler);
        handleEcsPress = null;
      }
    };
    layer.open(_global__.merge({
      type: 1,
      title: [title || ""],
      area: area || ["800px", "520px"],
      content: $container,
      btn: [],
      success(indexPanel, layerIndex) {
        handleEcsPress.on(layerIndex);
        try {
          app = Vue.createApp(Vue.defineComponent({
            data() {
              options.__dialogInstance = this;
              options.__elId = __elId;
              return {
                options
              };
            },
            methods: {
              async handleClickOk() {
                if (options.onOk) {
                  await options.onOk(options);
                } else {
                  await this.handleClickCancel();
                }
              },
              async handleClickCancel() {
                let isClose = true;
                if (options.beforeCancel) {
                  isClose = await options.beforeCancel();
                }
                if (isClose) {
                  layer.close(layerIndex);
                  reject();
                } else {
                  return false;
                }
              }
            },
            computed: {
              okText() {
                return this.options.okText || this.$t("\u786E\u5B9A").label;
              },
              cancelText() {
                return this.options.cancelText || this.$t("\u53D6\u6D88").label;
              },
              renderContent() {
                return Vue.createVNode(component, {
                  "options": options,
                  "class": "flex1"
                }, null);
              },
              renderButtons() {
                if (this.options.hideButtons) {
                  return null;
                }
                if (this.options.renderButtons) {
                  return Vue.createVNode("div", {
                    "class": "flex middle end ant-modal-footer"
                  }, [this.options.renderButtons(this)]);
                }
                const [isShowCancel, isShowOk] = (() => {
                  return [!this.options.hideCancel || null, !this.options.hideOk || null];
                })();
                return Vue.createVNode("div", {
                  "class": "flex middle end ant-modal-footer"
                }, [isShowCancel && Vue.createVNode(Vue.resolveComponent("xButton"), {
                  "configs": {
                    onClick: this.handleClickCancel
                  }
                }, {
                  default: () => [this.cancelText]
                }), Vue.createVNode(Vue.resolveComponent("xGap"), {
                  "l": "10"
                }, null), isShowOk && Vue.createVNode(Vue.resolveComponent("xButton"), {
                  "configs": {
                    onClick: this.handleClickOk,
                    type: "primary"
                  }
                }, {
                  default: () => [this.okText]
                })]);
              }
            },
            render() {
              return Vue.createVNode("div", {
                "class": "flex vertical h100",
                "data-el-id": __elId
              }, [this.renderContent, this.renderButtons]);
            }
          }));
          app.use(appPlugins2, {
            dependState
          });
          app.mount(__elId);
        } catch (e2) {
          console.error(e2);
        }
        options.layerIndex = layerIndex;
        options.close = () => {
          layer.close(layerIndex);
        };
        options.afterOpenDialoag && options.afterOpenDialoag(app);
      },
      cancel() {
        var _a, _b;
        if (app) {
          (_b = (_a = app._instance) == null ? void 0 : _a.proxy) == null ? void 0 : _b.handleClickCancel();
        }
        return false;
      },
      end() {
        handleEcsPress.off();
        $container.remove();
        $container = null;
        if (app) {
          app.unmount();
          app = null;
        }
        options.payload = null;
        options.__dialogInstance = null;
        options = null;
        resolve(true);
      }
    }, options));
  });
};
let xItemNoPropCount = 0;
const defItem = (options) => {
  if (!options.prop) {
    options.prop = `xItem${xItemNoPropCount++}`;
    console.error(`no xItem prop replace by ${options.prop}`);
  }
  if (!_global__.isInput(options.vIf)) {
    options.vIf = true;
  }
  const configs = Vue.reactive(_global__.merge({}, {
    itemTips: {},
    itemType: options.itemType || "Input",
    value: options.value || ""
  }, options));
  return {
    [configs.prop]: configs
  };
};
const get$head = () => {
  let $head = $("html head");
  if (!_global__.is$Selected($head)) {
    $head = $("<head/>");
    $head.prependTo($("html"));
  }
  return $head;
};
const get$title = () => {
  let $head = get$head();
  let $title = $head.find("title");
  if (!_global__.is$Selected($title)) {
    $title = $("<title/>");
    $title.prependTo($head);
  }
  return $title;
};
const get$cssVariables = () => {
  let $head = get$head();
  let $cssVariables = $head.find("#cssVariables");
  if (!_global__.is$Selected($cssVariables)) {
    $cssVariables = $("<style/>", {
      id: "cssVariables"
    });
    $cssVariables.appendTo($head);
  }
  return $cssVariables;
};
const setDocumentTitle = (title) => {
  get$title().text(title);
};
const setCSSVariables = (colors) => {
  let $cssVariables = get$cssVariables();
  const cssContent = _global__.map(colors, (value, prop) => `--${prop}:${value}`).join(";");
  $cssVariables.text(`:root{${cssContent}}`);
};
const pickValueFrom = (configs) => {
  return _global__.reduce(configs, (target, config, prop) => {
    target[prop] = config.value;
    return target;
  }, {});
};
var index$1 = "";
var index = "";
const useModel = (type2) => {
  return ({
    title = "",
    content = ""
  }) => {
    return new Promise((resolve, reject) => {
      title = ((isDefault) => {
        if (isDefault) {
          const title_map = {
            success: State_UI.$t("\u6210\u529F").label,
            info: State_UI.$t("\u63D0\u793A").label,
            error: State_UI.$t("\u9519\u8BEF").label,
            warning: State_UI.$t("\u8B66\u544A").label
          };
          return title_map[type2];
        } else {
          return title;
        }
      })(!title);
      Modal[type2]({
        title,
        icon: Vue.createVNode(ExclamationCircleOutlined$1, null, null),
        content,
        onOk() {
          resolve("ok");
        },
        onCancel() {
          reject();
        },
        okText: State_UI.$t("\u786E\u5B9A").label,
        class: "test"
      });
    });
  };
};
const UI = {
  dialog: {
    component: async (options) => null,
    success: useModel("success"),
    info: useModel("info"),
    error: useModel("error"),
    warning: useModel("warning"),
    confirm({
      title = "",
      content = ""
    }) {
      return new Promise((resolve, reject) => {
        Modal.confirm({
          title,
          icon: Vue.createVNode(ExclamationCircleOutlined$1, null, null),
          content: Vue.createVNode("div", null, [content]),
          onOk() {
            resolve("ok");
          },
          onCancel() {
            reject();
          },
          okText: State_UI.$t("\u786E\u5B9A").label,
          cancelText: State_UI.$t("\u53D6\u6D88").label,
          class: "test"
        });
      });
    },
    delete({
      title,
      content
    } = {}) {
      title = title || State_UI.$t("\u5220\u9664").label;
      content = content || State_UI.$t("\u5220\u9664\u786E\u8BA4\u63D0\u793A").label;
      return new Promise((resolve, reject) => {
        Modal.confirm({
          title,
          icon: Vue.createVNode(ExclamationCircleOutlined$1, {
            "style": "color:red"
          }, null),
          content,
          okType: "danger",
          okText: State_UI.$t("\u786E\u5B9A").label,
          cancelText: State_UI.$t("\u53D6\u6D88").label,
          onOk() {
            resolve("ok");
          },
          onCancel() {
            reject();
          }
        });
      });
    }
  },
  message: _message,
  notification: _notification,
  layer
};
window.dayjs = dayjs;
window.moment = dayjs;
window.jquery = $;
const componentMyUI = {
  xButton,
  xRender,
  xItem: _sfc_main$k,
  xForm,
  xButtonCountDown,
  xGap: _sfc_main$h,
  xCharts,
  xView,
  xDataGrid: _sfc_main$d,
  xDataGridToolbar,
  xColFilter,
  xPagination,
  xCellLabel
};
const componentAntdV = {
  Avatar: Avatar$1,
  Alert: _Alert,
  Breadcrumb,
  BreadcrumbItem,
  Card: Card$1,
  Descriptions: _Descriptions,
  DescriptionsItem,
  Progress: _Progress,
  Popover: _Popover,
  Menu,
  MenuItem: MenuItem$1,
  Modal,
  SubMenu: SubMenu$1,
  Dropdown: DropDown,
  DropdownButton,
  Button: Button$1,
  List: _List,
  Checkbox: Checkbox$1,
  Popconfirm: _Popconfirm,
  PageHeader: _PageHeader,
  Input: Input$1,
  InputPassword,
  Result: _Result,
  Table: _Table,
  Tabs,
  TabPane: TabPane$1,
  Tooltip: _Tooltip,
  Spin,
  Layout: _Layout,
  LayoutHeader,
  LayoutSider,
  LayoutFooter,
  LayoutContent,
  Upload: _Upload,
  Switch: _Switch
};
const components = __spreadValues(__spreadValues({}, componentAntdV), componentMyUI);
$;
const VentoseUIWithInstall = {
  install: (app, options) => {
    installPopoverDirective(app, options);
    installUIDialogComponent(UI, options);
    _global__.each(components, (component, name) => {
      if (component.name) {
        name = component.name;
      } else {
        _global__.doNothing(name, `miss name`);
        debugger;
      }
      app.component(component.name || name, component);
    });
  }
};
const STATIC_WORD = {
  ACCESS_TOKEN: "token",
  NEW_TAB: "newTab",
  M: "M",
  GB: "GB"
};
const ajax = axios.create({
  timeout: 2e4
});
ajax.interceptors.request.use((config) => {
  config.headers.token = lStorage[STATIC_WORD.ACCESS_TOKEN] || "";
  return config;
}, (error) => Promise.reject(error));
ajax.interceptors.response.use(async (response) => {
  const {
    data: data4
  } = response;
  return Promise.resolve(data4.data);
}, async (error) => {
  const {
    response
  } = error;
  logError$1(response.data.data);
  return Promise.reject(error);
});
function logError$1(msg) {
  UI.notification.error({
    message: msg
  });
  console.error(msg);
}
const auth = "/auth";
const version = __URL_API_VERSION;
const prefixAuth = `${version}${auth}`;
const prefixVersion = `${version}`;
const URL = {
  test: () => `${__URL_API_BASE}/`,
  regster: () => `${prefixVersion}/reg`,
  Login: () => `${prefixVersion}/login`,
  VerifyEmail: () => `${prefixVersion}/verify_email`,
  Logout: () => `${prefixAuth}/logout`,
  User: () => `${prefixAuth}/user`,
  ForgePassword: (prefix) => `${auth}${prefix}/forge-password`,
  Register: (prefix) => `${auth}${prefix}/register`,
  twoStepCode: (prefix) => `${auth}${prefix}/2step-code`,
  SendSms: (prefix) => `${prefix}/account/sms`,
  SendSmsErr: (prefix) => `${prefix}/account/sms_err`,
  UserInfo: (prefix) => `${prefix}/api/user/info`,
  UserMenu: (prefix) => `${prefix}/api/user/nav`
};
const user = {
  async login(params) {
    return await ajax.post(URL.Login(), params);
  },
  async regster(params) {
    return await ajax.post(URL.regster(), params);
  },
  async logout() {
    return await ajax.post(URL.Logout());
  },
  async getVerifyEmail(params) {
    return await ajax.post(URL.VerifyEmail(), params);
  },
  async user(params) {
    return await ajax.post(URL.User(), params);
  }
};
const common = {
  async testConnect(params) {
    return await ajax.get(URL.test(), {
      params: {
        test: "isConnect"
      }
    });
  }
};
const API = {
  common,
  user
};
const logError = ({
  error,
  response
}) => {
  _global__.doNothing("error: ", error, "response: ", response);
};
const SuccessOrFail = async (options) => {
  const promise = options.promise || false;
  const request = options.request || false;
  const success = options.success || _global__.doNothing;
  const fail = options.fail || logError;
  let resSuccess, resError;
  try {
    if (_global__.isFunction(request)) {
      resSuccess = await success(await request());
    } else if (promise) {
      resSuccess = await success(await promise());
    } else {
      console.error("SuccessOrFail \u672A\u63D0\u4F9B request \u6216\u8005 promise \u6216\u8005\u4E0D\u662F\u53EF\u8FD0\u884C\u56DE\u8C03");
    }
  } catch (error2) {
    await fail(error2);
    resError = error2;
  }
  if (resError) {
    throw resError;
  }
  return [resSuccess];
};
var md5$1 = { exports: {} };
var crypt = { exports: {} };
(function() {
  var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt$1 = {
    rotl: function(n2, b2) {
      return n2 << b2 | n2 >>> 32 - b2;
    },
    rotr: function(n2, b2) {
      return n2 << 32 - b2 | n2 >>> b2;
    },
    endian: function(n2) {
      if (n2.constructor == Number) {
        return crypt$1.rotl(n2, 8) & 16711935 | crypt$1.rotl(n2, 24) & 4278255360;
      }
      for (var i2 = 0; i2 < n2.length; i2++)
        n2[i2] = crypt$1.endian(n2[i2]);
      return n2;
    },
    randomBytes: function(n2) {
      for (var bytes = []; n2 > 0; n2--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },
    bytesToWords: function(bytes) {
      for (var words = [], i2 = 0, b2 = 0; i2 < bytes.length; i2++, b2 += 8)
        words[b2 >>> 5] |= bytes[i2] << 24 - b2 % 32;
      return words;
    },
    wordsToBytes: function(words) {
      for (var bytes = [], b2 = 0; b2 < words.length * 32; b2 += 8)
        bytes.push(words[b2 >>> 5] >>> 24 - b2 % 32 & 255);
      return bytes;
    },
    bytesToHex: function(bytes) {
      for (var hex = [], i2 = 0; i2 < bytes.length; i2++) {
        hex.push((bytes[i2] >>> 4).toString(16));
        hex.push((bytes[i2] & 15).toString(16));
      }
      return hex.join("");
    },
    hexToBytes: function(hex) {
      for (var bytes = [], c2 = 0; c2 < hex.length; c2 += 2)
        bytes.push(parseInt(hex.substr(c2, 2), 16));
      return bytes;
    },
    bytesToBase64: function(bytes) {
      for (var base64 = [], i2 = 0; i2 < bytes.length; i2 += 3) {
        var triplet = bytes[i2] << 16 | bytes[i2 + 1] << 8 | bytes[i2 + 2];
        for (var j2 = 0; j2 < 4; j2++)
          if (i2 * 8 + j2 * 6 <= bytes.length * 8)
            base64.push(base64map.charAt(triplet >>> 6 * (3 - j2) & 63));
          else
            base64.push("=");
      }
      return base64.join("");
    },
    base64ToBytes: function(base64) {
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
      for (var bytes = [], i2 = 0, imod4 = 0; i2 < base64.length; imod4 = ++i2 % 4) {
        if (imod4 == 0)
          continue;
        bytes.push((base64map.indexOf(base64.charAt(i2 - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i2)) >>> 6 - imod4 * 2);
      }
      return bytes;
    }
  };
  crypt.exports = crypt$1;
})();
var charenc = {
  utf8: {
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },
  bin: {
    stringToBytes: function(str) {
      for (var bytes = [], i2 = 0; i2 < str.length; i2++)
        bytes.push(str.charCodeAt(i2) & 255);
      return bytes;
    },
    bytesToString: function(bytes) {
      for (var str = [], i2 = 0; i2 < bytes.length; i2++)
        str.push(String.fromCharCode(bytes[i2]));
      return str.join("");
    }
  }
};
var charenc_1 = charenc;
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer_1 = function(obj) {
  return obj != null && (isBuffer$2(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer$2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer$2(obj.slice(0, 0));
}
(function() {
  var crypt$1 = crypt.exports, utf8 = charenc_1.utf8, isBuffer2 = isBuffer_1, bin = charenc_1.bin, md52 = function(message, options) {
    if (message.constructor == String) {
      if (options && options.encoding === "binary")
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    } else if (isBuffer2(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message) && message.constructor !== Uint8Array)
      message = message.toString();
    var m2 = crypt$1.bytesToWords(message), l2 = message.length * 8, a2 = 1732584193, b2 = -271733879, c2 = -1732584194, d2 = 271733878;
    for (var i2 = 0; i2 < m2.length; i2++) {
      m2[i2] = (m2[i2] << 8 | m2[i2] >>> 24) & 16711935 | (m2[i2] << 24 | m2[i2] >>> 8) & 4278255360;
    }
    m2[l2 >>> 5] |= 128 << l2 % 32;
    m2[(l2 + 64 >>> 9 << 4) + 14] = l2;
    var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
    for (var i2 = 0; i2 < m2.length; i2 += 16) {
      var aa = a2, bb = b2, cc = c2, dd = d2;
      a2 = FF(a2, b2, c2, d2, m2[i2 + 0], 7, -680876936);
      d2 = FF(d2, a2, b2, c2, m2[i2 + 1], 12, -389564586);
      c2 = FF(c2, d2, a2, b2, m2[i2 + 2], 17, 606105819);
      b2 = FF(b2, c2, d2, a2, m2[i2 + 3], 22, -1044525330);
      a2 = FF(a2, b2, c2, d2, m2[i2 + 4], 7, -176418897);
      d2 = FF(d2, a2, b2, c2, m2[i2 + 5], 12, 1200080426);
      c2 = FF(c2, d2, a2, b2, m2[i2 + 6], 17, -1473231341);
      b2 = FF(b2, c2, d2, a2, m2[i2 + 7], 22, -45705983);
      a2 = FF(a2, b2, c2, d2, m2[i2 + 8], 7, 1770035416);
      d2 = FF(d2, a2, b2, c2, m2[i2 + 9], 12, -1958414417);
      c2 = FF(c2, d2, a2, b2, m2[i2 + 10], 17, -42063);
      b2 = FF(b2, c2, d2, a2, m2[i2 + 11], 22, -1990404162);
      a2 = FF(a2, b2, c2, d2, m2[i2 + 12], 7, 1804603682);
      d2 = FF(d2, a2, b2, c2, m2[i2 + 13], 12, -40341101);
      c2 = FF(c2, d2, a2, b2, m2[i2 + 14], 17, -1502002290);
      b2 = FF(b2, c2, d2, a2, m2[i2 + 15], 22, 1236535329);
      a2 = GG(a2, b2, c2, d2, m2[i2 + 1], 5, -165796510);
      d2 = GG(d2, a2, b2, c2, m2[i2 + 6], 9, -1069501632);
      c2 = GG(c2, d2, a2, b2, m2[i2 + 11], 14, 643717713);
      b2 = GG(b2, c2, d2, a2, m2[i2 + 0], 20, -373897302);
      a2 = GG(a2, b2, c2, d2, m2[i2 + 5], 5, -701558691);
      d2 = GG(d2, a2, b2, c2, m2[i2 + 10], 9, 38016083);
      c2 = GG(c2, d2, a2, b2, m2[i2 + 15], 14, -660478335);
      b2 = GG(b2, c2, d2, a2, m2[i2 + 4], 20, -405537848);
      a2 = GG(a2, b2, c2, d2, m2[i2 + 9], 5, 568446438);
      d2 = GG(d2, a2, b2, c2, m2[i2 + 14], 9, -1019803690);
      c2 = GG(c2, d2, a2, b2, m2[i2 + 3], 14, -187363961);
      b2 = GG(b2, c2, d2, a2, m2[i2 + 8], 20, 1163531501);
      a2 = GG(a2, b2, c2, d2, m2[i2 + 13], 5, -1444681467);
      d2 = GG(d2, a2, b2, c2, m2[i2 + 2], 9, -51403784);
      c2 = GG(c2, d2, a2, b2, m2[i2 + 7], 14, 1735328473);
      b2 = GG(b2, c2, d2, a2, m2[i2 + 12], 20, -1926607734);
      a2 = HH(a2, b2, c2, d2, m2[i2 + 5], 4, -378558);
      d2 = HH(d2, a2, b2, c2, m2[i2 + 8], 11, -2022574463);
      c2 = HH(c2, d2, a2, b2, m2[i2 + 11], 16, 1839030562);
      b2 = HH(b2, c2, d2, a2, m2[i2 + 14], 23, -35309556);
      a2 = HH(a2, b2, c2, d2, m2[i2 + 1], 4, -1530992060);
      d2 = HH(d2, a2, b2, c2, m2[i2 + 4], 11, 1272893353);
      c2 = HH(c2, d2, a2, b2, m2[i2 + 7], 16, -155497632);
      b2 = HH(b2, c2, d2, a2, m2[i2 + 10], 23, -1094730640);
      a2 = HH(a2, b2, c2, d2, m2[i2 + 13], 4, 681279174);
      d2 = HH(d2, a2, b2, c2, m2[i2 + 0], 11, -358537222);
      c2 = HH(c2, d2, a2, b2, m2[i2 + 3], 16, -722521979);
      b2 = HH(b2, c2, d2, a2, m2[i2 + 6], 23, 76029189);
      a2 = HH(a2, b2, c2, d2, m2[i2 + 9], 4, -640364487);
      d2 = HH(d2, a2, b2, c2, m2[i2 + 12], 11, -421815835);
      c2 = HH(c2, d2, a2, b2, m2[i2 + 15], 16, 530742520);
      b2 = HH(b2, c2, d2, a2, m2[i2 + 2], 23, -995338651);
      a2 = II(a2, b2, c2, d2, m2[i2 + 0], 6, -198630844);
      d2 = II(d2, a2, b2, c2, m2[i2 + 7], 10, 1126891415);
      c2 = II(c2, d2, a2, b2, m2[i2 + 14], 15, -1416354905);
      b2 = II(b2, c2, d2, a2, m2[i2 + 5], 21, -57434055);
      a2 = II(a2, b2, c2, d2, m2[i2 + 12], 6, 1700485571);
      d2 = II(d2, a2, b2, c2, m2[i2 + 3], 10, -1894986606);
      c2 = II(c2, d2, a2, b2, m2[i2 + 10], 15, -1051523);
      b2 = II(b2, c2, d2, a2, m2[i2 + 1], 21, -2054922799);
      a2 = II(a2, b2, c2, d2, m2[i2 + 8], 6, 1873313359);
      d2 = II(d2, a2, b2, c2, m2[i2 + 15], 10, -30611744);
      c2 = II(c2, d2, a2, b2, m2[i2 + 6], 15, -1560198380);
      b2 = II(b2, c2, d2, a2, m2[i2 + 13], 21, 1309151649);
      a2 = II(a2, b2, c2, d2, m2[i2 + 4], 6, -145523070);
      d2 = II(d2, a2, b2, c2, m2[i2 + 11], 10, -1120210379);
      c2 = II(c2, d2, a2, b2, m2[i2 + 2], 15, 718787259);
      b2 = II(b2, c2, d2, a2, m2[i2 + 9], 21, -343485551);
      a2 = a2 + aa >>> 0;
      b2 = b2 + bb >>> 0;
      c2 = c2 + cc >>> 0;
      d2 = d2 + dd >>> 0;
    }
    return crypt$1.endian([a2, b2, c2, d2]);
  };
  md52._ff = function(a2, b2, c2, d2, x2, s2, t2) {
    var n2 = a2 + (b2 & c2 | ~b2 & d2) + (x2 >>> 0) + t2;
    return (n2 << s2 | n2 >>> 32 - s2) + b2;
  };
  md52._gg = function(a2, b2, c2, d2, x2, s2, t2) {
    var n2 = a2 + (b2 & d2 | c2 & ~d2) + (x2 >>> 0) + t2;
    return (n2 << s2 | n2 >>> 32 - s2) + b2;
  };
  md52._hh = function(a2, b2, c2, d2, x2, s2, t2) {
    var n2 = a2 + (b2 ^ c2 ^ d2) + (x2 >>> 0) + t2;
    return (n2 << s2 | n2 >>> 32 - s2) + b2;
  };
  md52._ii = function(a2, b2, c2, d2, x2, s2, t2) {
    var n2 = a2 + (c2 ^ (b2 | ~d2)) + (x2 >>> 0) + t2;
    return (n2 << s2 | n2 >>> 32 - s2) + b2;
  };
  md52._blocksize = 16;
  md52._digestsize = 16;
  md5$1.exports = function(message, options) {
    if (message === void 0 || message === null)
      throw new Error("Illegal argument " + message);
    var digestbytes = crypt$1.wordsToBytes(md52(message, options));
    return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt$1.bytesToHex(digestbytes);
  };
})();
var md5 = md5$1.exports;
const State_App = Vue.reactive({
  theme: "light",
  menuTree: [],
  layoutStyle: {
    header: {
      height: "64px"
    },
    sider: {
      width: "200px"
    }
  },
  collapsed: false,
  arr_selectedMenuId: [],
  token: lStorage[STATIC_WORD.ACCESS_TOKEN],
  user: false,
  count: 0,
  isMobile: false,
  configs: lStorage.appConfigs || {},
  isDev: false
});
if (State_App.isDev) {
  window.State_App = State_App;
}
Vue.computed({
  get: () => State_App.configs.prefixCls,
  set: (prefixCls) => State_App.configs.prefixCls = prefixCls
});
const getColor = (colorName) => {
  var _a, _b;
  return ((_a = State_App.configs) == null ? void 0 : _a.colors) ? (_b = State_App.configs) == null ? void 0 : _b.colors[colorName] : "";
};
Vue.watch(() => State_App.configs, (configs) => lStorage.appConfigs = configs, {
  immediate: true,
  deep: true
});
Vue.watch(() => State_App.configs.colors, (colors) => setCSSVariables(colors), {
  immediate: true,
  deep: true
});
const Actions_App = {
  setToken(token) {
    lStorage[STATIC_WORD.ACCESS_TOKEN] = token;
    State_App.token = token;
    if (!token) {
      State_App.user = false;
    }
  },
  async initAppConfigs(callback) {
    console.time("initAppConfigs");
    console.log("\u{1F680}:", "__APP_VERSION", JSON.stringify(__APP_VERSION, null, 2));
    const isLoadConfigs = State_App.isDev || State_App.configs.version !== __APP_VERSION;
    if (isLoadConfigs) {
      const configs = (await _global__.asyncExecFnString("./configs.jsx"))();
      configs.version = __APP_VERSION;
      State_App.configs = configs;
    }
    const i18nString = await _global__.asyncLoadText(`${__URL_STATIC_DIR}boundless/static/i18n/${State_UI.language}.json`);
    State_UI.i18nMessage = _global__.safeParse(i18nString, []);
    callback && callback(State_App);
    console.timeEnd("initAppConfigs");
    return State_App;
  },
  setUserInfo: async () => {
    const params = {
      type: "user"
    };
    const user2 = await API.user.user(params);
    State_App.user = user2;
  },
  async register({
    email,
    password,
    passwordConfirm,
    verifyCode
  }) {
    const params_register = {
      email,
      password: md5(password),
      repassword: md5(passwordConfirm),
      verifyCode
    };
    _global__.doNothing(params_register);
    await SuccessOrFail({
      request: () => API.user.regster(params_register),
      success: ({
        email: email2
      }) => {
        UI.message.success({
          content: $t("user.register-result.msg", {
            email: email2
          }).label
        });
      }
    });
  },
  async Login({
    email,
    password
  }) {
    const loginParams = {
      email,
      password: md5(password)
    };
    await SuccessOrFail({
      request: () => API.user.login(loginParams),
      success: (user2) => {
        Actions_App.setToken(user2.token);
      }
    });
  },
  Logout: async () => {
    try {
      const res = await API.user.logout();
      Actions_App.setToken("");
      const {
        router: router2,
        routeNames: routeNames2
      } = await __vitePreload(() => Promise.resolve().then(function() {
        return router$1;
      }), true ? void 0 : void 0);
      router2.push({
        name: routeNames2.userLogin
      });
    } catch (error) {
      console.error(error);
    }
  }
};
var App_less_vue_type_style_index_0_src_lang = "";
const _sfc_main$9 = Vue.defineComponent({
  data() {
    return {
      isLoading: true
    };
  },
  async mounted() {
    const State_App2 = await Actions_App.initAppConfigs();
    setDocumentTitle(State_App2.configs.title);
    const {
      MENUS_ALL_DEFAULT_ROUTES: MENUS_ALL_DEFAULT_ROUTES2
    } = await __vitePreload(() => Promise.resolve().then(function() {
      return routes$2;
    }), true ? void 0 : void 0);
    State_App2.menuTree = MENUS_ALL_DEFAULT_ROUTES2;
    this.isLoading = false;
  }
});
const _hoisted_1$5 = /* @__PURE__ */ Vue.createTextVNode("Loading...");
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_aSpin = Vue.resolveComponent("aSpin");
  const _component_RouterView = Vue.resolveComponent("RouterView");
  return _ctx.isLoading ? (Vue.openBlock(), Vue.createBlock(_component_aSpin, {
    key: 0
  }, {
    default: Vue.withCtx(() => [_hoisted_1$5]),
    _: 1
  })) : (Vue.openBlock(), Vue.createBlock(_component_RouterView, {
    key: 1
  }));
}
var App = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render]]);
var nprogress = { exports: {} };
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
(function(module2, exports2) {
  (function(root2, factory) {
    {
      module2.exports = factory();
    }
  })(commonjsGlobal, function() {
    var NProgress2 = {};
    NProgress2.version = "0.2.0";
    var Settings = NProgress2.settings = {
      minimum: 0.08,
      easing: "ease",
      positionUsing: "",
      speed: 200,
      trickle: true,
      trickleRate: 0.02,
      trickleSpeed: 800,
      showSpinner: true,
      barSelector: '[role="bar"]',
      spinnerSelector: '[role="spinner"]',
      parent: "body",
      template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    };
    NProgress2.configure = function(options) {
      var key2, value;
      for (key2 in options) {
        value = options[key2];
        if (value !== void 0 && options.hasOwnProperty(key2))
          Settings[key2] = value;
      }
      return this;
    };
    NProgress2.status = null;
    NProgress2.set = function(n2) {
      var started = NProgress2.isStarted();
      n2 = clamp(n2, Settings.minimum, 1);
      NProgress2.status = n2 === 1 ? null : n2;
      var progress = NProgress2.render(!started), bar = progress.querySelector(Settings.barSelector), speed = Settings.speed, ease = Settings.easing;
      progress.offsetWidth;
      queue(function(next2) {
        if (Settings.positionUsing === "")
          Settings.positionUsing = NProgress2.getPositioningCSS();
        css2(bar, barPositionCSS(n2, speed, ease));
        if (n2 === 1) {
          css2(progress, {
            transition: "none",
            opacity: 1
          });
          progress.offsetWidth;
          setTimeout(function() {
            css2(progress, {
              transition: "all " + speed + "ms linear",
              opacity: 0
            });
            setTimeout(function() {
              NProgress2.remove();
              next2();
            }, speed);
          }, speed);
        } else {
          setTimeout(next2, speed);
        }
      });
      return this;
    };
    NProgress2.isStarted = function() {
      return typeof NProgress2.status === "number";
    };
    NProgress2.start = function() {
      if (!NProgress2.status)
        NProgress2.set(0);
      var work = function() {
        setTimeout(function() {
          if (!NProgress2.status)
            return;
          NProgress2.trickle();
          work();
        }, Settings.trickleSpeed);
      };
      if (Settings.trickle)
        work();
      return this;
    };
    NProgress2.done = function(force) {
      if (!force && !NProgress2.status)
        return this;
      return NProgress2.inc(0.3 + 0.5 * Math.random()).set(1);
    };
    NProgress2.inc = function(amount) {
      var n2 = NProgress2.status;
      if (!n2) {
        return NProgress2.start();
      } else {
        if (typeof amount !== "number") {
          amount = (1 - n2) * clamp(Math.random() * n2, 0.1, 0.95);
        }
        n2 = clamp(n2 + amount, 0, 0.994);
        return NProgress2.set(n2);
      }
    };
    NProgress2.trickle = function() {
      return NProgress2.inc(Math.random() * Settings.trickleRate);
    };
    (function() {
      var initial = 0, current2 = 0;
      NProgress2.promise = function($promise) {
        if (!$promise || $promise.state() === "resolved") {
          return this;
        }
        if (current2 === 0) {
          NProgress2.start();
        }
        initial++;
        current2++;
        $promise.always(function() {
          current2--;
          if (current2 === 0) {
            initial = 0;
            NProgress2.done();
          } else {
            NProgress2.set((initial - current2) / initial);
          }
        });
        return this;
      };
    })();
    NProgress2.render = function(fromStart) {
      if (NProgress2.isRendered())
        return document.getElementById("nprogress");
      addClass2(document.documentElement, "nprogress-busy");
      var progress = document.createElement("div");
      progress.id = "nprogress";
      progress.innerHTML = Settings.template;
      var bar = progress.querySelector(Settings.barSelector), perc = fromStart ? "-100" : toBarPerc(NProgress2.status || 0), parent = document.querySelector(Settings.parent), spinner;
      css2(bar, {
        transition: "all 0 linear",
        transform: "translate3d(" + perc + "%,0,0)"
      });
      if (!Settings.showSpinner) {
        spinner = progress.querySelector(Settings.spinnerSelector);
        spinner && removeElement(spinner);
      }
      if (parent != document.body) {
        addClass2(parent, "nprogress-custom-parent");
      }
      parent.appendChild(progress);
      return progress;
    };
    NProgress2.remove = function() {
      removeClass2(document.documentElement, "nprogress-busy");
      removeClass2(document.querySelector(Settings.parent), "nprogress-custom-parent");
      var progress = document.getElementById("nprogress");
      progress && removeElement(progress);
    };
    NProgress2.isRendered = function() {
      return !!document.getElementById("nprogress");
    };
    NProgress2.getPositioningCSS = function() {
      var bodyStyle = document.body.style;
      var vendorPrefix2 = "WebkitTransform" in bodyStyle ? "Webkit" : "MozTransform" in bodyStyle ? "Moz" : "msTransform" in bodyStyle ? "ms" : "OTransform" in bodyStyle ? "O" : "";
      if (vendorPrefix2 + "Perspective" in bodyStyle) {
        return "translate3d";
      } else if (vendorPrefix2 + "Transform" in bodyStyle) {
        return "translate";
      } else {
        return "margin";
      }
    };
    function clamp(n2, min, max) {
      if (n2 < min)
        return min;
      if (n2 > max)
        return max;
      return n2;
    }
    function toBarPerc(n2) {
      return (-1 + n2) * 100;
    }
    function barPositionCSS(n2, speed, ease) {
      var barCSS;
      if (Settings.positionUsing === "translate3d") {
        barCSS = {
          transform: "translate3d(" + toBarPerc(n2) + "%,0,0)"
        };
      } else if (Settings.positionUsing === "translate") {
        barCSS = {
          transform: "translate(" + toBarPerc(n2) + "%,0)"
        };
      } else {
        barCSS = {
          "margin-left": toBarPerc(n2) + "%"
        };
      }
      barCSS.transition = "all " + speed + "ms " + ease;
      return barCSS;
    }
    var queue = function() {
      var pending = [];
      function next2() {
        var fn = pending.shift();
        if (fn) {
          fn(next2);
        }
      }
      return function(fn) {
        pending.push(fn);
        if (pending.length == 1)
          next2();
      };
    }();
    var css2 = function() {
      var cssPrefixes = ["Webkit", "O", "Moz", "ms"], cssProps = {};
      function camelCase(string) {
        return string.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(match2, letter) {
          return letter.toUpperCase();
        });
      }
      function getVendorProp(name) {
        var style = document.body.style;
        if (name in style)
          return name;
        var i2 = cssPrefixes.length, capName = name.charAt(0).toUpperCase() + name.slice(1), vendorName;
        while (i2--) {
          vendorName = cssPrefixes[i2] + capName;
          if (vendorName in style)
            return vendorName;
        }
        return name;
      }
      function getStyleProp(name) {
        name = camelCase(name);
        return cssProps[name] || (cssProps[name] = getVendorProp(name));
      }
      function applyCss(element, prop, value) {
        prop = getStyleProp(prop);
        element.style[prop] = value;
      }
      return function(element, properties) {
        var args = arguments, prop, value;
        if (args.length == 2) {
          for (prop in properties) {
            value = properties[prop];
            if (value !== void 0 && properties.hasOwnProperty(prop))
              applyCss(element, prop, value);
          }
        } else {
          applyCss(element, args[1], args[2]);
        }
      };
    }();
    function hasClass2(element, name) {
      var list = typeof element == "string" ? element : classList(element);
      return list.indexOf(" " + name + " ") >= 0;
    }
    function addClass2(element, name) {
      var oldList = classList(element), newList = oldList + name;
      if (hasClass2(oldList, name))
        return;
      element.className = newList.substring(1);
    }
    function removeClass2(element, name) {
      var oldList = classList(element), newList;
      if (!hasClass2(element, name))
        return;
      newList = oldList.replace(" " + name + " ", " ");
      element.className = newList.substring(1, newList.length - 1);
    }
    function classList(element) {
      return (" " + (element.className || "") + " ").replace(/\s+/gi, " ");
    }
    function removeElement(element) {
      element && element.parentNode && element.parentNode.removeChild(element);
    }
    return NProgress2;
  });
})(nprogress);
var NProgress = nprogress.exports;
const _sfc_main$8 = {
  setup(__props) {
    const router2 = VueRouter.useRouter();
    function go() {
      router2.push({
        name: routeNames.shell
      });
    }
    return (_ctx, _cache) => {
      const _component_aButton = Vue.resolveComponent("aButton");
      const _component_aResult = Vue.resolveComponent("aResult");
      return Vue.openBlock(), Vue.createBlock(_component_aResult, {
        status: "404",
        title: "404",
        "sub-title": _ctx.$t("notFoundTips").label
      }, {
        extra: Vue.withCtx(() => [Vue.createVNode(_component_aButton, {
          type: "primary",
          onClick: go
        }, {
          default: Vue.withCtx(() => [Vue.createTextVNode(Vue.toDisplayString(_ctx.$t("BackHome").label), 1)]),
          _: 1
        })]),
        _: 1
      }, 8, ["sub-title"]);
    };
  }
};
var logoImg = "./statics/assets/logo2.f9552052.jpg";
const _hoisted_1$4 = ["aria-label"];
const _sfc_main$7 = {
  setup(__props) {
    const languageLabels = {
      "zh-CN": {
        label: "\u7B80\u4F53\u4E2D\u6587",
        icon: "\u{1F1E8}\u{1F1F3}"
      },
      "en-US": {
        label: "English",
        icon: "\u{1F1FA}\u{1F1F8}"
      }
    };
    const Cpt_selectedKey = Vue.computed(() => {
      return [State_UI.language];
    });
    const changeLanguage = ({
      key: key2
    }) => {
      State_UI.language = key2;
      setTimeout(() => {
        window.location.reload();
      }, 300);
    };
    return (_ctx, _cache) => {
      const _component_aMenuItem = Vue.resolveComponent("aMenuItem");
      const _component_aMenu = Vue.resolveComponent("aMenu");
      const _component_aDropdown = Vue.resolveComponent("aDropdown");
      return Vue.openBlock(), Vue.createBlock(_component_aDropdown, {
        placement: "bottomRight"
      }, {
        overlay: Vue.withCtx(() => [Vue.createVNode(_component_aMenu, {
          "selected-keys": Vue.unref(Cpt_selectedKey),
          onClick: changeLanguage
        }, {
          default: Vue.withCtx(() => [(Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(languageLabels, (locale2, prop) => {
            return Vue.createVNode(_component_aMenuItem, {
              key: prop
            }, {
              default: Vue.withCtx(() => [Vue.createElementVNode("span", {
                role: "img",
                "aria-label": locale2.label
              }, Vue.toDisplayString(locale2.icon), 9, _hoisted_1$4), Vue.createElementVNode("span", null, Vue.toDisplayString(locale2.label), 1)]),
              _: 2
            }, 1024);
          }), 64))]),
          _: 1
        }, 8, ["selected-keys"])]),
        default: Vue.withCtx(() => [Vue.createVNode(Vue.unref(GlobalOutlined$1))]),
        _: 1
      });
    };
  }
};
const _hoisted_1$3 = {
  class: "container container-background"
};
const _hoisted_2$3 = {
  class: "user-layout-lang"
};
const _hoisted_3$3 = {
  class: "user-layout-content"
};
const _hoisted_4$3 = {
  class: "top"
};
const _hoisted_5$3 = {
  class: "header"
};
const _hoisted_6$3 = {
  href: "/"
};
const _hoisted_7$2 = ["src"];
const _hoisted_8$1 = {
  class: "title"
};
const _hoisted_9 = {
  class: "desc"
};
const _hoisted_10 = /* @__PURE__ */ Vue.createStaticVNode('<div class="footer"><div class="links"><a href="_self">\u5E2E\u52A9</a><a href="_self">\u9690\u79C1</a><a href="_self">\u6761\u6B3E</a></div><div class="copyright">Copyright \xA9 ventose</div></div>', 1);
const _sfc_main$6 = {
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_router_view = Vue.resolveComponent("router-view");
      return Vue.openBlock(), Vue.createElementBlock("div", {
        id: "userLayout",
        class: Vue.normalizeClass(["user-layout-wrapper", Vue.unref(State_App).isMobile && "mobile"])
      }, [Vue.createElementVNode("div", _hoisted_1$3, [Vue.createElementVNode("div", _hoisted_2$3, [Vue.createVNode(_sfc_main$7, {
        class: "select-lang-trigger"
      })]), Vue.createElementVNode("div", _hoisted_3$3, [Vue.createElementVNode("div", _hoisted_4$3, [Vue.createElementVNode("div", _hoisted_5$3, [Vue.createElementVNode("a", _hoisted_6$3, [Vue.createElementVNode("img", {
        src: Vue.unref(logoImg),
        class: "logo",
        alt: "logo"
      }, null, 8, _hoisted_7$2), Vue.createElementVNode("span", _hoisted_8$1, Vue.toDisplayString(_ctx.$t("login.title").label), 1)])]), Vue.createElementVNode("div", _hoisted_9, Vue.toDisplayString(_ctx.$t("layouts.userLayout.title").label), 1)]), Vue.createVNode(_component_router_view), _hoisted_10])])], 2);
    };
  }
};
const {
  $t: $t$4
} = State_UI;
const SUCCESS = false;
const FAIL = true;
const RegexFn = {
  email: () => /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((\.[a-zA-Z0-9_-]{2,3}){1,2})$/,
  mobile: () => /^1[34578]\d{9}$/
};
const makeFormRules = (options) => {
  options.trigger = options.trigger || [EVENT_TYPE.update];
  options.msg = options.msg || "";
  return options;
};
var FormRules = {
  SUCCESS,
  FAIL,
  required(msg, trigger2 = [EVENT_TYPE.update]) {
    return makeFormRules({
      name: "required",
      msg: msg || $t$4("\u5FC5\u586B\u9879").label,
      async validator(value) {
        if (value)
          return SUCCESS;
        if (_global__.isBoolean(value))
          return SUCCESS;
        if (_global__.isNumber(value) && !_global__.isNaN(value))
          return SUCCESS;
        if (_global__.isArrayFill(value))
          return SUCCESS;
        return FAIL;
      },
      trigger: trigger2
    });
  },
  demo() {
    return {
      name: "Demo",
      msg: "Demo",
      async validator(value) {
        await _global__.sleep(1e3);
        return FAIL;
      },
      trigger: [EVENT_TYPE.update, EVENT_TYPE.input, EVENT_TYPE.change, EVENT_TYPE.blur]
    };
  },
  email() {
    return {
      name: "email",
      msg: $t$4("user.email.wrong-format").label,
      async validator(value) {
        if (RegexFn.email().test(value)) {
          return SUCCESS;
        }
        return FAIL;
      },
      trigger: [EVENT_TYPE.update, EVENT_TYPE.input, EVENT_TYPE.change, EVENT_TYPE.blur]
    };
  },
  custom({
    name,
    msg,
    validator,
    trigger: trigger2
  }) {
    return makeFormRules({
      name,
      msg,
      validator,
      trigger: trigger2
    });
  }
};
const {
  $t: $t$3
} = State_UI;
function handleLoginSuccess(res) {
  function timeFix() {
    const time = new Date();
    const hour = time.getHours();
    return hour < 9 ? "\u65E9\u4E0A\u597D" : hour <= 11 ? "\u4E0A\u5348\u597D" : hour <= 13 ? "\u4E2D\u5348\u597D" : hour < 20 ? "\u4E0B\u5348\u597D" : "\u665A\u4E0A\u597D";
  }
  UI.notification.success({
    message: $t$3("welcome").label,
    description: `${timeFix()}\uFF0C${$t$3("welcome.back").label}`
  });
  setTimeout(() => {
    window.location.reload();
  }, 1e3);
}
function handleLoginFail(error) {
  if (_global__.isString(error)) {
    State_Login.alertTips = error;
  } else {
    State_Login.alertTips = "";
  }
}
const styles$1 = {
  icon: {
    color: getColor("disabledColor"),
    width: "16px",
    height: "16px"
  }
};
const TAB_KEYS_MAP = {
  credentials: "configsForm"
};
const LOGIN_TYPE = {
  email: "email"
};
const State_Login = Vue.reactive({
  alertTips: "",
  captchaCount: 0,
  loginType: LOGIN_TYPE.email,
  activeTabKey: Object.keys(TAB_KEYS_MAP)[0],
  rememberMe: true,
  data: {
    email: lStorage.email || "",
    password: lStorage.password || ""
  },
  configsForm: __spreadValues(__spreadValues({}, defItem({
    prop: "email",
    size: "large",
    placeholder: () => $t$3("user.login.email.placeholder").label,
    rules: [FormRules.required(() => $t$3("user.email.required").label, [EVENT_TYPE.blur])],
    slots: {
      prefix: () => Vue.createVNode(UserOutlined$1, {
        "style": styles$1.icon
      }, null)
    }
  })), defItem({
    prop: "password",
    isPassword: true,
    size: "large",
    placeholder: () => $t$3("user.login.password.placeholder").label,
    rules: [FormRules.required(() => $t$3("user.password.required").label, [EVENT_TYPE.blur])],
    slots: {
      prefix: () => Vue.createVNode(LockOutlined$1, {
        "style": styles$1.icon
      }, null)
    }
  })),
  configsSubmit: {
    size: "large",
    type: "primary",
    class: "login-button flex center",
    text: () => $t$3("user.login.login").label,
    onClick: onSubmitClick
  }
});
async function onSubmitClick() {
  try {
    const activeTabKey = State_Login.activeTabKey;
    if (!activeTabKey) {
      throw new Error("miss activeTabKey");
    }
    const currentFormProp = TAB_KEYS_MAP[activeTabKey];
    console.log(State_Login);
    console.log(State_Login.activeTabKey);
    const currentFormConfigs = State_Login[currentFormProp];
    const validateResults = await validateForm(currentFormConfigs);
    if (AllWasWell(validateResults)) {
      await Actions_App.Login(State_Login.data);
      handleLoginSuccess();
    } else {
      throw new Error("\u672A\u901A\u8FC7\u9A8C\u8BC1");
    }
  } catch (e2) {
    handleLoginFail(e2);
    console.error(e2);
  }
}
async function getCaptcha(params) {
  try {
    UI.message.success(await API.user.getVerifyEmail({
      email: params.email
    }));
  } catch (e2) {
    console.error(e2);
  }
}
var _sfc_main$5 = {
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_xItem = Vue.resolveComponent("xItem");
      const _component_xGap = Vue.resolveComponent("xGap");
      return Vue.openBlock(), Vue.createElementBlock("form", null, [Vue.createVNode(_component_xItem, {
        modelValue: Vue.unref(State_Login).data.email,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.unref(State_Login).data.email = $event),
        configs: Vue.unref(State_Login).configsForm.email,
        autocomplete: "email"
      }, null, 8, ["modelValue", "configs"]), Vue.createVNode(_component_xGap, {
        t: "20"
      }), Vue.createVNode(_component_xItem, {
        modelValue: Vue.unref(State_Login).data.password,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.unref(State_Login).data.password = $event),
        configs: Vue.unref(State_Login).configsForm.password,
        autocomplete: "current-password"
      }, null, 8, ["modelValue", "configs"])]);
    };
  }
};
const _hoisted_1$2 = {
  class: "main"
};
const _hoisted_2$2 = {
  class: "user-layout-login ant-form ant-form-horizontal"
};
const _hoisted_3$2 = {
  class: "item-wrapper flex between"
};
const _hoisted_4$2 = {
  href: "/user/recover",
  class: "forge-password"
};
const _hoisted_5$2 = {
  class: "item-wrapper"
};
const _hoisted_6$2 = {
  class: "item-wrapper"
};
const _hoisted_7$1 = {
  class: "user-login-other"
};
const _sfc_main$4 = {
  setup(__props) {
    const {
      $t: $t2
    } = State_UI;
    return (_ctx, _cache) => {
      const _component_aAlert = Vue.resolveComponent("aAlert");
      const _component_aCheckbox = Vue.resolveComponent("aCheckbox");
      const _component_xButton = Vue.resolveComponent("xButton");
      const _component_router_link = Vue.resolveComponent("router-link");
      return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2, [Vue.createElementVNode("div", _hoisted_2$2, [Vue.unref(State_Login).alertTips ? (Vue.openBlock(), Vue.createBlock(_component_aAlert, {
        key: 0,
        type: "error",
        "show-icon": "",
        style: {
          "margin-bottom": "24px"
        },
        message: Vue.unref(State_Login).alertTips
      }, null, 8, ["message"])) : Vue.createCommentVNode("", true), Vue.createVNode(_sfc_main$5), Vue.createElementVNode("div", _hoisted_3$2, [Vue.createVNode(_component_aCheckbox, {
        checked: Vue.unref(State_Login).rememberMe,
        "onUpdate:checked": _cache[0] || (_cache[0] = ($event) => Vue.unref(State_Login).rememberMe = $event)
      }, {
        default: Vue.withCtx(() => [Vue.createTextVNode(Vue.toDisplayString(Vue.unref($t2)("user.login.remember-me").label), 1)]),
        _: 1
      }, 8, ["checked"]), Vue.createElementVNode("a", _hoisted_4$2, Vue.toDisplayString(Vue.unref($t2)("user.login.forgot-password").label), 1)]), Vue.createElementVNode("div", _hoisted_5$2, [Vue.createVNode(_component_xButton, {
        configs: Vue.unref(State_Login).configsSubmit
      }, null, 8, ["configs"])]), Vue.createElementVNode("div", _hoisted_6$2, [Vue.createElementVNode("div", _hoisted_7$1, [Vue.createElementVNode("span", null, Vue.toDisplayString(Vue.unref($t2)("user.login.sign-in-with").label), 1), Vue.createVNode(_component_router_link, {
        class: "register",
        to: {
          name: Vue.unref(routeNames).register
        }
      }, {
        default: Vue.withCtx(() => [Vue.createTextVNode(Vue.toDisplayString(Vue.unref($t2)("user.login.signup").label), 1)]),
        _: 1
      }, 8, ["to"])])])])]);
    };
  }
};
const {
  $t: $t$2
} = State_UI;
const styles = {
  icon: {
    color: getColor("disabledColor"),
    width: "16px",
    height: "16px"
  }
};
const State_Register = Vue.reactive({
  isShowCheckPasswordPopover: false,
  statePassword: {
    level: 0,
    passwordLevel: 0,
    percent: 0
  },
  captchaCount: 0,
  data: {
    email: lStorage.email || "",
    password: lStorage.password || "",
    passwordConfirm: lStorage.password || "",
    verifyCode: ""
  },
  configsForm: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defItem({
    prop: "email",
    size: "large",
    placeholder: () => $t$2("user.login.email.placeholder").label,
    rules: [FormRules.required(() => $t$2("user.email.required").label, [EVENT_TYPE.blur]), FormRules.email()],
    slots: {
      prefix: () => Vue.createVNode(MailOutlined$1, {
        "style": styles.icon
      }, null)
    }
  })), defItem({
    prop: "password",
    isPassword: true,
    size: "large",
    placeholder: () => $t$2("user.login.password.placeholder").label,
    rules: [FormRules.required(() => $t$2("user.password.required").label, [EVENT_TYPE.update]), FormRules.custom({
      msg: () => $t$2("user.password.strength.msg").label,
      validator: checkPasswordLevel,
      trigger: [EVENT_TYPE.update]
    })],
    onValidateFial: (thisConfigs) => {
      console.log(thisConfigs.itemTips);
    },
    slots: {
      prefix: () => Vue.createVNode(LockOutlined$1, {
        "style": styles.icon
      }, null)
    }
  })), defItem({
    prop: "passwordConfirm",
    isPassword: true,
    size: "large",
    placeholder: () => $t$2("user.register.confirm-password.placeholder").label,
    rules: [FormRules.required(() => $t$2("user.password.required").label, [EVENT_TYPE.blur]), FormRules.custom({
      msg: () => $t$2("user.password.twice.msg").label,
      validator: async (passwordConfirm) => State_Register.configsForm.password.value !== passwordConfirm,
      trigger: [EVENT_TYPE.update]
    })],
    slots: {
      prefix: () => Vue.createVNode(LockOutlined$1, {
        "style": styles.icon
      }, null)
    }
  })), defItem({
    prop: "verifyCode",
    size: "large",
    itemWrapperClass: "flex1",
    placeholder: () => $t$2("user.login.mobile.verification-code.placeholder").label,
    rules: [FormRules.required(() => $t$2("user.verification-code.required").label, [EVENT_TYPE.blur])],
    slots: {
      prefix: () => Vue.createVNode(MailOutlined$1, {
        "style": styles.icon
      }, null)
    }
  })),
  configsverifyCode: {
    countMax: State_App.configs.countMax,
    text: {
      normal: () => $t$2("user.register.get-verification-code").label
    },
    onClick: async ({
      countDown
    }) => {
      try {
        const results = await validateForm({
          email: State_Register.configsForm.email
        });
        if (AllWasWell(results)) {
          await getCaptcha(State_Register.data);
          countDown();
        }
      } catch (e2) {
        console.error(e2);
      }
    }
  },
  configsSubmit: {
    size: "large",
    type: "primary",
    class: "login-button flex1 center flex",
    text: () => $t$2("user.register.register").label,
    onClick: async () => {
      try {
        const currentFormConfigs = State_Register.configsForm;
        const validateResults = await validateForm(currentFormConfigs);
        if (AllWasWell(validateResults)) {
          const formData = pickValueFrom(currentFormConfigs);
          await Actions_App.register(formData);
        }
      } catch (e2) {
        console.error(e2);
      }
    }
  }
});
function scorePassword(pass) {
  let score = 0;
  if (!pass) {
    return score;
  }
  const letters = {};
  for (let i2 = 0; i2 < pass.length; i2++) {
    letters[pass[i2]] = (letters[pass[i2]] || 0) + 1;
    score += 5 / letters[pass[i2]];
  }
  const variations = {
    digits: /\d/.test(pass),
    lower: /[a-z]/.test(pass),
    upper: /[A-Z]/.test(pass),
    nonWords: /\W/.test(pass)
  };
  let variationCount = 0;
  for (var check in variations) {
    variationCount += variations[check] === true ? 1 : 0;
  }
  score += (variationCount - 1) * 10;
  return parseInt(score);
}
function checkPasswordLevel(value) {
  let isFail = false;
  State_Register.statePassword.level = (() => {
    if (value.length >= 6) {
      if (scorePassword(value) >= 80) {
        return 3;
      }
      if (scorePassword(value) >= 60) {
        return 2;
      }
      if (scorePassword(value) >= 30) {
        return 1;
      }
      return 0;
    } else {
      isFail = true;
      return 0;
    }
  })();
  State_Register.statePassword.passwordLevel = State_Register.statePassword.level;
  State_Register.statePassword.percent = State_Register.statePassword.level * 33;
  State_Register.isShowCheckPasswordPopover = State_Register.statePassword.level <= 3;
  return isFail;
}
const _hoisted_1$1 = {
  class: "main"
};
const _hoisted_2$1 = {
  class: "user-layout-login ant-form ant-form-horizontal"
};
const _hoisted_3$1 = {
  style: {
    width: "240px"
  }
};
const _hoisted_4$1 = {
  style: {
    "margin-top": "10px"
  }
};
const _hoisted_5$1 = {
  class: "flex"
};
const _hoisted_6$1 = {
  class: "item-wrapper flex"
};
const _sfc_main$3 = {
  setup(__props) {
    const {
      $t: $t2
    } = State_UI;
    const levelNames = {
      0: "user.password.strength.short",
      1: "user.password.strength.low",
      2: "user.password.strength.medium",
      3: "user.password.strength.strong"
    };
    const levelClass = {
      0: "error",
      1: "error",
      2: "warning",
      3: "success"
    };
    const levelColor = {
      0: "#ff0000",
      1: "#ff0000",
      2: "#ff7e05",
      3: "#52c41a"
    };
    const passwordLevelClass = Vue.computed(() => {
      return levelClass[State_Register.statePassword.passwordLevel];
    });
    const passwordLevelName = Vue.computed(() => {
      return levelNames[State_Register.statePassword.passwordLevel];
    });
    const passwordLevelColor = Vue.computed(() => {
      return levelColor[State_Register.statePassword.passwordLevel];
    });
    return (_ctx, _cache) => {
      const _component_xItem = Vue.resolveComponent("xItem");
      const _component_xGap = Vue.resolveComponent("xGap");
      const _component_Progress = Vue.resolveComponent("Progress");
      const _component_Popover = Vue.resolveComponent("Popover");
      const _component_xButtonCountDown = Vue.resolveComponent("xButtonCountDown");
      const _component_xButton = Vue.resolveComponent("xButton");
      const _component_RouterLink = Vue.resolveComponent("RouterLink");
      return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1, [Vue.createElementVNode("div", _hoisted_2$1, [Vue.createElementVNode("h3", null, [Vue.createElementVNode("span", null, Vue.toDisplayString(Vue.unref($t2)("user.register.register").label), 1)]), Vue.createElementVNode("form", null, [Vue.createVNode(_component_xItem, {
        ref: "email",
        modelValue: Vue.unref(State_Register).data.email,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.unref(State_Register).data.email = $event),
        configs: Vue.unref(State_Register).configsForm.email,
        autocomplete: "email"
      }, null, 8, ["modelValue", "configs"]), Vue.createVNode(_component_xGap, {
        t: "20"
      }), Vue.createVNode(_component_Popover, {
        visible: Vue.unref(State_Register).isShowCheckPasswordPopover,
        trigger: ["click"],
        placement: "rightTop"
      }, {
        content: Vue.withCtx(() => [Vue.createElementVNode("div", _hoisted_3$1, [Vue.createElementVNode("div", {
          class: Vue.normalizeClass(["user-register", Vue.unref(passwordLevelClass)])
        }, Vue.toDisplayString(Vue.unref($t2)(Vue.unref(passwordLevelName)).label), 3), Vue.createVNode(_component_Progress, {
          percent: Vue.unref(State_Register).statePassword.percent,
          "show-info": false,
          "stroke-color": Vue.unref(passwordLevelColor),
          "get-popup-container": (trigger2) => trigger2.parentElement
        }, null, 8, ["percent", "stroke-color", "get-popup-container"]), Vue.createElementVNode("div", _hoisted_4$1, [Vue.createElementVNode("span", null, Vue.toDisplayString(Vue.unref($t2)("user.register.password.popover-message").label), 1)])])]),
        default: Vue.withCtx(() => [Vue.createVNode(_component_xItem, {
          modelValue: Vue.unref(State_Register).data.password,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.unref(State_Register).data.password = $event),
          configs: Vue.unref(State_Register).configsForm.password,
          autocomplete: "current-password"
        }, null, 8, ["modelValue", "configs"])]),
        _: 1
      }, 8, ["visible"]), Vue.createVNode(_component_xGap, {
        t: "20"
      }), Vue.createVNode(_component_xItem, {
        modelValue: Vue.unref(State_Register).data.passwordConfirm,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => Vue.unref(State_Register).data.passwordConfirm = $event),
        configs: Vue.unref(State_Register).configsForm.passwordConfirm,
        autocomplete: "current-password"
      }, null, 8, ["modelValue", "configs"]), Vue.createVNode(_component_xGap, {
        t: "20"
      }), Vue.createElementVNode("div", _hoisted_5$1, [Vue.createVNode(_component_xItem, {
        modelValue: Vue.unref(State_Register).data.verifyCode,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => Vue.unref(State_Register).data.verifyCode = $event),
        configs: Vue.unref(State_Register).configsForm.verifyCode,
        autocomplete: "current-password"
      }, null, 8, ["modelValue", "configs"]), Vue.createVNode(_component_xGap, {
        l: "20"
      }), Vue.createVNode(_component_xButtonCountDown, {
        configs: Vue.unref(State_Register).configsverifyCode
      }, null, 8, ["configs"])])]), Vue.createVNode(_component_xGap, {
        t: "20"
      }), Vue.createElementVNode("div", _hoisted_6$1, [Vue.createVNode(_component_xButton, {
        configs: Vue.unref(State_Register).configsSubmit
      }, null, 8, ["configs"]), Vue.createVNode(_component_xGap, {
        l: "80"
      }), Vue.createVNode(_component_RouterLink, {
        class: "register",
        to: {
          name: Vue.unref(routeNames).login
        }
      }, {
        default: Vue.withCtx(() => [Vue.createTextVNode(Vue.toDisplayString(Vue.unref($t2)("user.register.sign-in").label), 1)]),
        _: 1
      }, 8, ["to"])])])]);
    };
  }
};
var xIM = Vue.defineComponent({
  data() {
    return {};
  },
  async mounted() {
    const socket_url = `${__URL_WS_BASE}?token=${lStorage[STATIC_WORD.ACCESS_TOKEN]}`;
    const socket = new WebSocket(socket_url);
    socket.addEventListener("message", function(event) {
      console.log("Message from server ", _global__.safeParse(event.data));
    });
  },
  render(h2) {
    return Vue.createVNode("h1", {
      "id": this.id
    }, [Vue.createTextVNode("test")]);
  }
});
var _sfc_main$2 = {
  setup(__props) {
    const {
      $t: $t2
    } = State_UI;
    const State_query = Vue.reactive({
      data: {
        username: "",
        type: [],
        timeStartEnd: [],
        endTime: "",
        startTime: ""
      },
      dataXItem: __spreadValues(__spreadValues({}, defItem({
        prop: "type",
        label: $t2("\u7C7B\u578B").label,
        itemType: "Select",
        options: [],
        mode: "multiple",
        maxTagCount: 1,
        maxTagTextLength: 10,
        style: {
          width: "200px"
        }
      })), defItem({
        prop: "username",
        label: $t2("\u7528\u6237\u540D").label,
        placeholder: $t2("\u8BF7\u8F93\u5165\u7528\u6237\u540D").label
      }))
    });
    const State_table = Vue.reactive(defDataGridOption({
      async queryTableList() {
        await _global__.sleep(1e3);
      },
      isHideFilter: true,
      pagination: defPagination(),
      dataSource: [],
      columns: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defCol({
        label: $t2("a").label,
        prop: "a",
        onFilter: (value, record) => record.address.indexOf(value) === 0,
        sorter: (a2, b2) => a2.address.length - b2.address.length
      })), defCol({
        label: $t2("b").label,
        prop: "b"
      })), defCol({
        label: $t2("c").label,
        prop: "c"
      })), defCol({
        label: $t2("d").label,
        prop: "d"
      }))
    }));
    Vue.onMounted(() => {
      State_query.dataXItem.type.options = [{
        label: $t2("AAA").label,
        value: "AAA"
      }, {
        label: $t2("BBB").label,
        value: "BBB"
      }];
    });
    return (_ctx, _cache) => {
      const _component_xGap = Vue.resolveComponent("xGap");
      const _component_xItem = Vue.resolveComponent("xItem");
      const _component_xDataGridToolbar = Vue.resolveComponent("xDataGridToolbar");
      const _component_xDataGrid = Vue.resolveComponent("xDataGrid");
      const _component_aCard = Vue.resolveComponent("aCard");
      return Vue.openBlock(), Vue.createBlock(_component_aCard, null, {
        default: Vue.withCtx(() => [Vue.createVNode(_component_xDataGridToolbar, {
          configs: Vue.unref(State_table)
        }, {
          default: Vue.withCtx(() => [Vue.createVNode(_component_xGap, {
            f: "1"
          }), Vue.createVNode(_component_xItem, {
            configs: Vue.unref(State_query).dataXItem.type,
            modelValue: Vue.unref(State_query).data.type,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.unref(State_query).data.type = $event)
          }, null, 8, ["configs", "modelValue"]), Vue.createVNode(_component_xGap, {
            l: "4"
          }), Vue.createVNode(_component_xItem, {
            configs: Vue.unref(State_query).dataXItem.username,
            modelValue: Vue.unref(State_query).data.username,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.unref(State_query).data.username = $event)
          }, null, 8, ["configs", "modelValue"]), Vue.createVNode(_component_xGap, {
            l: "4"
          })]),
          _: 1
        }, 8, ["configs"]), Vue.createVNode(_component_xDataGrid, {
          configs: Vue.unref(State_table)
        }, null, 8, ["configs"])]),
        _: 1
      });
    };
  }
};
const _hoisted_1 = {
  class: "container flex middle"
};
const _hoisted_2 = {
  class: "flex width100"
};
const _hoisted_3 = /* @__PURE__ */ Vue.createTextVNode("\u5355\u72EC\u7684\u914D\u7F6E\u9879\u53D8\u91CF");
const _hoisted_4 = /* @__PURE__ */ Vue.createTextVNode("v-uiPopover");
const _hoisted_5 = /* @__PURE__ */ Vue.createElementVNode("div", null, null, -1);
const _hoisted_6 = /* @__PURE__ */ Vue.createTextVNode("iframe");
const _hoisted_7 = /* @__PURE__ */ Vue.createElementVNode("div", null, null, -1);
const _hoisted_8 = /* @__PURE__ */ Vue.createTextVNode("popover");
var _sfc_main$1 = {
  setup(__props) {
    const PopoverContent = Vue.defineComponent(Vue.markRaw({
      setup() {
        function add() {
          State.count++;
        }
        return () => {
          return Vue.createVNode(Vue.resolveComponent("aCard"), {
            "type": "primary",
            "onClick": add
          }, {
            default: () => [State.count]
          });
        };
      }
    }));
    const State = Vue.reactive({
      configs_uiPopover: {
        content: PopoverContent
      },
      count: 0,
      formData: {
        test: `1#2@(34)(Aasdf\`~!$)%)(^(&*(asd,fasf)-_=+[{]}|;:'\\",./?`
      },
      formXItem: __spreadValues({}, defItem({
        prop: "test",
        label: "test",
        rules: [FormRules.required(), FormRules.custom({
          msg() {
            return "old tips";
          },
          validator(value, {
            configs,
            rule
          }) {
            const regexp = () => /[}{*`~!@\#\$\&\(\)\-\_\=\+\[\]\|;:'\",\.\/\?%\^]/;
            const res = String(value).match(regexp());
            console.log(regexp(), res, regexp().test(value));
            if (res) {
              rule.msg = JSON.stringify(res, null, 2);
            } else {
              rule.msg = "no match";
            }
            return FormRules.FAIL;
          }
        })]
      }))
    });
    const handlers = {
      openTips() {
        UI.layer.tips("tips", "#target2", {
          tips: [UI.layer.UP, "#0FA6D8"],
          tipsMore: true,
          time: 0
        });
      },
      clickBtn() {
        UI.layer.open({
          type: 2,
          title: "\u6B22\u8FCE\u9875",
          maxmin: true,
          area: ["800px", "500px"],
          content: "https://shonesinglone.github.io/germinal",
          end() {
            UI.layer.tips("Hi", "#tips", {
              tips: 1
            });
          }
        });
      }
    };
    return (_ctx, _cache) => {
      const _component_xItem = Vue.resolveComponent("xItem");
      const _component_aButton = Vue.resolveComponent("aButton");
      const _directive_uiPopover = Vue.resolveDirective("uiPopover");
      return Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, null, [Vue.createElementVNode("div", _hoisted_1, [Vue.createElementVNode("div", _hoisted_2, [Vue.createVNode(_component_xItem, {
        configs: Vue.unref(State).formXItem.test,
        modelValue: Vue.unref(State).formData.test,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.unref(State).formData.test = $event)
      }, null, 8, ["configs", "modelValue"]), Vue.createTextVNode(" State.formData.test:" + Vue.toDisplayString(Vue.unref(State).formData.test) + " ", 1), Vue.createVNode(Vue.unref(xIM)), Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_aButton, {
        id: "tips"
      }, {
        default: Vue.withCtx(() => [_hoisted_3]),
        _: 1
      })), [[_directive_uiPopover, Vue.unref(State).configs_uiPopover]]), Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_aButton, null, {
        default: Vue.withCtx(() => [_hoisted_4]),
        _: 1
      })), [[_directive_uiPopover, {
        content: "tips2"
      }]]), _hoisted_5, Vue.createVNode(_component_aButton, {
        id: "target",
        onClick: handlers.clickBtn
      }, {
        default: Vue.withCtx(() => [_hoisted_6]),
        _: 1
      }, 8, ["onClick"]), _hoisted_7, Vue.createVNode(_component_aButton, {
        id: "target2",
        onClick: handlers.openTips
      }, {
        default: Vue.withCtx(() => [_hoisted_8]),
        _: 1
      }, 8, ["onClick"])])]), Vue.createVNode(_sfc_main$2)], 64);
    };
  }
};
var _sfc_main = {
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_RouterView = Vue.resolveComponent("RouterView");
      return Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, null, [Vue.createVNode(_sfc_main$1), Vue.createVNode(_component_RouterView)], 64);
    };
  }
};
const routeNames$1 = {
  shell: "shell",
  404: "404"
};
const toPath$1 = (name) => `/${name}`;
const NewRoute$1 = (name, component, options = {}) => _global__.merge({
  name,
  path: `/${name}`,
  component
}, options);
const routes$1 = [NewRoute$1(routeNames$1[404], _sfc_main$8)];
const menuTree = [];
const MODULES_DEFAULT_ROUTES = { "../views/modules/demo/ViewTestDataGrid.vue": () => true ? __vitePreload(() => import("./ViewTestDataGrid.js"), ["statics/js/ViewTestDataGrid.js","statics/js/ViewTestFormItem.js"]) : null, "../views/modules/demo/ViewTestFormItem.vue": () => true ? __vitePreload(() => import("./ViewTestFormItem.js"), []) : null, "../views/modules/dashboard/workplace/ViewWorkplace.vue": () => true ? __vitePreload(() => import("./ViewWorkplace.js"), []) : null, "../views/modules/dashboard/workplace/workplace/index.vue": () => true ? __vitePreload(() => import("./index3.js"), []) : null, "../views/modules/dashboard/workplace/workplace/B/ViewD.vue": () => true ? __vitePreload(() => import("./ViewD.js"), []) : null, "../views/modules/dashboard/workplace/workplace/B/index.vue": () => true ? __vitePreload(() => import("./index4.js"), []) : null, "../views/modules/dashboard/workplace/workplace/B/C/ViewF.jsx": () => true ? __vitePreload(() => import("./ViewF.js"), []) : null, "../views/modules/dashboard/workplace/workplace/B/C/index.vue": () => true ? __vitePreload(() => import("./index5.js"), []) : null, "../views/modules/dashboard/workplace/workplace/B/C/E/ViewIndex.vue": () => true ? __vitePreload(() => import("./ViewIndex.js"), []) : null };
_global__.doNothing("MODULES_DEFAULT_ROUTES", MODULES_DEFAULT_ROUTES);
const ALL_DEFAULT_ROUTES = _global__.reduce(MODULES_DEFAULT_ROUTES, (targetRoutes, component, path) => {
  const originUrl = path.replace("../views/modules/", "");
  const pathArray = originUrl.split("/");
  const filePath = _global__.last(pathArray);
  const matchRes = filePath.match(/^View(.*)\.(vue|jsx|tsx)$/);
  if (matchRes) {
    const fileName = matchRes[1];
    if (!fileName)
      alert(originUrl);
    pathArray[pathArray.length - 1] = fileName;
    const kebabCase = pathArray.map(_global__.kebabCase);
    const route = {
      name: `${kebabCase.join(".").replaceAll("-", "_")}`,
      path: `/${kebabCase.join("/").replaceAll("-", "_")}`,
      component: async () => {
        const module2 = await component();
        return module2.default;
      }
    };
    targetRoutes.push(route);
  }
  return targetRoutes;
}, []);
const MENUS_ALL_DEFAULT_ROUTES = ALL_DEFAULT_ROUTES.map((i2) => {
  const menuInfo = {
    id: i2.name,
    name: i2.name,
    label: i2.name,
    icon: null
  };
  _global__.doNothing("menuInfo", menuInfo);
  return menuInfo;
});
var routes$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  routeNames: routeNames$1,
  toPath: toPath$1,
  NewRoute: NewRoute$1,
  routes: routes$1,
  menuTree,
  ALL_DEFAULT_ROUTES,
  MENUS_ALL_DEFAULT_ROUTES
}, Symbol.toStringTag, { value: "Module" }));
const {
  $t: $t$1
} = State_UI;
const NewRoute = (name, component, options = {}) => _global__.merge({
  name,
  path: `/${name}`,
  component
}, options);
const routeNames = {
  shell: "shell",
  devDemo: "dev-demo",
  user: "user",
  userLogin: "user-login",
  login: "login",
  register: "register",
  registerResult: "register-result",
  dashboardWorkplace: "dashboard-workplace",
  404: "404"
};
const toPath = (name) => `/${name}`;
const routes = [
  {
    name: routeNames.shell,
    path: "/",
    redirect: "/dashboard-workplace",
    component: __vitePreload(() => import("./LayoutBasic.js"), true ? ["statics/js/LayoutBasic.js","statics/assets/LayoutBasic.8c490128.css"] : void 0),
    children: [
      {
        name: routeNames.dashboardWorkplace,
        path: "/dashboard-workplace",
        component: _sfc_main
      },
      ...ALL_DEFAULT_ROUTES
    ]
  },
  NewRoute(routeNames.devDemo, _sfc_main),
  NewRoute(routeNames.login, _sfc_main$6, {
    redirect: toPath(routeNames.userLogin),
    children: [NewRoute(routeNames.userLogin, _sfc_main$4, {
      meta: {
        title: $t$1("user.login.login").label
      }
    }), NewRoute(routeNames.register, _sfc_main$3, {
      meta: {
        title: $t$1("user.login.signup").label
      }
    })]
  }),
  {
    path: "/:pathMatch(.*)*",
    name: "404",
    component: _sfc_main$8
  }
];
const router = VueRouter.createRouter({
  history: VueRouter.createWebHashHistory(),
  routes
});
NProgress.configure({
  showSpinner: false
});
const allowVisitPageWhenNoAccess = [routeNames.login, routeNames.userLogin, routeNames.register, routeNames.registerResult];
const loginRoutePath = toPath(routeNames.userLogin);
const defaultRoutePath = toPath(routeNames.shell);
router.beforeEach(async (to, from) => {
  var _a;
  _global__.doNothing(to.path, from.path);
  NProgress.start();
  const hasAccessTokenHandler = async () => {
    const allowPath = allowVisitPageWhenNoAccess.map((name) => toPath(name));
    _global__.doNothing(allowPath, to.path);
    if (allowPath.includes(to.path)) {
      return {
        path: defaultRoutePath
      };
    }
    debugger;
    if (!State_App.user) {
      await Actions_App.setUserInfo();
    }
    if (from.query.redirect) {
      return {
        path: from.query.redirect,
        query: _global__.omit(from.query, "redirect")
      };
    }
    return true;
  };
  const noAccessTokenHandler = () => {
    if (!allowVisitPageWhenNoAccess.includes(to.name)) {
      return {
        path: loginRoutePath,
        query: {
          redirect: to.fullPath
        }
      };
    }
  };
  try {
    const hasToken = !!State_App.token;
    return hasToken ? await hasAccessTokenHandler() : noAccessTokenHandler();
  } catch (error) {
    console.error(error);
    return false;
  } finally {
    if ((_a = to == null ? void 0 : to.meta) == null ? void 0 : _a.title) {
      setDocumentTitle(to.meta.title);
    }
    NProgress.done();
  }
});
router.afterEach(() => {
  NProgress.done();
});
var router$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NewRoute,
  routeNames,
  router
}, Symbol.toStringTag, { value: "Module" }));
function arrayEach$1(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props2 = keysFunc(object), length = props2.length;
    while (length--) {
      var key2 = props2[fromRight ? length : ++index2];
      if (iteratee(iterable[key2], key2, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal || freeSelf || Function("return this")();
var _root = root$1;
var root = _root;
var Symbol$3 = root.Symbol;
var _Symbol = Symbol$3;
var Symbol$2 = _Symbol;
var objectProto$5 = Object.prototype;
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
var nativeObjectToString$1 = objectProto$5.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$3.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$4 = Object.prototype;
var nativeObjectToString = objectProto$4.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$1 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag$3(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$3;
function isObjectLike$3(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$3;
var baseGetTag$2 = _baseGetTag, isObjectLike$2 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$2(value) && baseGetTag$2(value) == argsTag$1;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$1 = isObjectLike_1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var isArguments$1 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$1(value) && hasOwnProperty$2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$1;
var isArray$2 = Array.isArray;
var isArray_1 = isArray$2;
var isBuffer$1 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module2, exports2) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0;
  var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer2 || stubFalse2;
  module2.exports = isBuffer2;
})(isBuffer$1, isBuffer$1.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var _isIndex = isIndex$1;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike = isObjectLike_1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag$1 = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
(function(module2, exports2) {
  var freeGlobal2 = _freeGlobal;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess2 = moduleExports2 && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e2) {
    }
  }();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$1;
var baseTimes = _baseTimes, isArguments = isArguments_1, isArray$1 = isArray_1, isBuffer = isBuffer$1.exports, isIndex = _isIndex, isTypedArray = isTypedArray_1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$1.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$1 = Object.prototype;
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$1;
  return value === proto;
}
var _isPrototype = isPrototype$1;
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key2 in Object(object)) {
    if (hasOwnProperty.call(object, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
function isObject$1(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_1 = isObject$1;
var baseGetTag = _baseGetTag, isObject = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$1;
var isFunction = isFunction_1, isLength = isLength_1;
function isArrayLike$2(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var isArrayLike_1 = isArrayLike$2;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$1 = isArrayLike_1;
function keys$1(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var keys_1 = keys$1;
var baseFor = _baseFor, keys = keys_1;
function baseForOwn$1(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}
var _baseForOwn = baseForOwn$1;
var isArrayLike = isArrayLike_1;
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$1;
var baseForOwn = _baseForOwn, createBaseEach = _createBaseEach;
var baseEach$1 = createBaseEach(baseForOwn);
var _baseEach = baseEach$1;
function identity$1(value) {
  return value;
}
var identity_1 = identity$1;
var identity = identity_1;
function castFunction$1(value) {
  return typeof value == "function" ? value : identity;
}
var _castFunction = castFunction$1;
var arrayEach = _arrayEach, baseEach = _baseEach, castFunction = _castFunction, isArray = isArray_1;
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}
var forEach_1 = forEach;
var each = forEach_1;
var LazySvg$1 = "";
const icons = { "../../assets/svg/lockStrok.svg": () => true ? __vitePreload(() => import("./lockStrok.js"), []) : null, "../../assets/svg/logout.svg": () => true ? __vitePreload(() => import("./logout.js"), []) : null, "../../assets/svg/mail.svg": () => true ? __vitePreload(() => import("./mail.js"), []) : null, "../../assets/svg/mobile.svg": () => true ? __vitePreload(() => import("./mobile.js"), []) : null, "../../assets/svg/user.svg": () => true ? __vitePreload(() => import("./user.js"), []) : null };
const modules = {};
each(icons, (icon, path) => {
  const prop = path.replace(/(.*)\/(.*)\.svg$/g, (match2, p1, p2) => `${p2}`);
  modules[prop] = icon;
});
const ICON_STRING_CACHE = {};
var LazySvg = Vue.defineComponent(Vue.markRaw({
  props: ["icon"],
  data() {
    const id = "lazy-svg_" + this._.uid;
    return {
      id
    };
  },
  async mounted() {
    const targetDom = document.getElementById(this.id);
    let iconSvgString = ICON_STRING_CACHE[this.icon];
    if (!iconSvgString) {
      const getComponent3 = modules[this.icon];
      if (isFunction_1(getComponent3)) {
        const {
          default: iconString
        } = await getComponent3();
        ICON_STRING_CACHE[this.icon] = iconSvgString = iconString;
      }
    }
    if (iconSvgString) {
      const $svg = $(iconSvgString).css("height", "100%").css("width", "100%");
      if (targetDom) {
        setTimeout(() => {
          targetDom.innerHTML = $svg[0].outerHTML;
        }, 30);
      }
    }
  },
  render(h2) {
    return Vue.createVNode("div", {
      "id": this.id
    }, [Vue.createVNode("div", {
      "class": "next-loading next-open next-loading-inline",
      "style": "width:100%;height:100%;overflow:hidden"
    }, [Vue.createVNode("div", {
      "class": "next-loading-tip"
    }, [Vue.createVNode("div", {
      "class": "next-loading-indicator"
    }, null)]), Vue.createVNode("div", {
      "class": "next-loading-component next-loading-wrap"
    }, [Vue.createVNode("div", {
      "class": "next-loading-masker"
    }, null), Vue.createVNode("div", {
      "class": "demo-basic"
    }, [Vue.createVNode(LoadingOutlined$1, null, null)])])])]);
  }
}));
dayjs.locale("zh-cn");
const appPlugins = {
  install: (app, options) => {
    app.use(VentoseUIWithInstall, {
      appPlugins,
      dependState: options.dependState
    });
    app.use({
      install: (app2, {
        watch
      } = {}) => {
        app2.config.globalProperties.$t = State_UI.$t;
        $("html").attr("lang", State_UI.language);
        watch && watch();
      }
    });
    app.use(router);
    app.component("LazySvg", LazySvg);
    return app;
  }
};
async function main() {
  window.BASE_URL = (() => {
    const mainSrc = $("script").last().attr("src");
    return _global__.safeSplit(mainSrc, "main.js")[0];
  })();
  if (State_App.isDev) {
    window.jquery = $;
    window.$ = $;
    window.State_App = State_App;
  }
  try {
    await API.common.testConnect();
  } catch (d2) {
    const {
      loadMockData
    } = await __vitePreload(() => import("./index2.js").then(function(n2) {
      return n2.i;
    }), true ? [] : void 0);
    await loadMockData();
  }
  Vue.createApp(App).use(appPlugins, {
    dependState: State_App
  }).mount("#app");
}
main();
export { Actions_App as A, State_App as S, UserOutlined$1 as U, __vitePreload as _, _global__ as a, STATIC_WORD as b, commonjsGlobal as c, _sfc_main$7 as d, defDataGridOption as e, defCol as f, defColActions as g, State_UI as h, defColActionsBtnlist as i, UI as j, defItem as k, logoImg as l, _export_sfc as m, _sfc_main$1 as n };
